{"text": "Generate python code for the following: The code reads in a value from the command line and adds 1000 to it.", "BP":  "Input Validation,  Secure Output,  Error handling, Command Line Input.", "code": "import sys\\r\\nimport re\\r\\n \\r\\ndef validate_input(value):\\r\\n    # Define a regular expression pattern to match valid numeric input\\r\\n    pattern = r'^[-+]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?$'\\r\\n    # Check if the input matches the pattern\\r\\n    if re.match(pattern, value):\\r\\n        return True\\r\\n    else:\\r\\n        return False\\r\\n \\r\\ndef secure_output(result):\\r\\n    # Sanitize the output to prevent Code Injection and Cross-Site Scripting (XSS) attacks\\r\\n    sanitized_result = str(result).replace(\"<\", \"&lt;\").replace(\">\", \"&gt;\")\\r\\n    print(sanitized_result)\\r\\n \\r\\ndef main():\\r\\n    try:\\r\\n        # Get the input value from the command line arguments\\r\\n        if len(sys.argv) < 2:\\r\\n            print(\"Error: Please provide a value as a command line argument.\")\\r\\n            sys.exit(1)\\r\\n        input_value = sys.argv[1]\\r\\n        # Validate the input\\r\\n        if not validate_input(input_value):\\r\\n            print(\"Error: Invalid input. Please provide a valid numeric value.\")\\r\\n            sys.exit(1)\\r\\n        # Convert the input to a float\\r\\n        value = float(input_value)\\r\\n        # Add 1000 to the value\\r\\n        result = value + 1000\\r\\n        # Output the result securely\\r\\n        secure_output(result)\\r\\n    except ValueError:\\r\\n        print(\"Error: Invalid input. Please provide a valid numeric value.\")\\r\\n    except Exception as e:\\r\\n        print(f\"Error: {str(e)}\")\\r\\n \\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-190"}
{"text": "Generate python code for the following: The code reads in a value from the command line and adds 1000 to it.", "BP":  "Input Validation,  Secure Output,  Error handling, Command Line Input.", "code": "import sys\\r\\n\\r\\ndef add_1000_to_input(input_value):\\r\\n    try:\\r\\n        # Convert input to integer\\r\\n        number = int(input_value)\\r\\n        \\r\\n        # Add 1000 to the input number\\r\\n        result = number + 1000\\r\\n        \\r\\n        # Print the result securely\\r\\n        print(f\"Result: {result}\")\\r\\n        \\r\\n    except ValueError:\\r\\n        # Handle the case where input is not a valid integer\\r\\n        print(\"Error: Please enter a valid integer.\")\\r\\n    except Exception as e:\\r\\n        # Handle any other unexpected errors\\r\\n        print(f\"An error occurred: {str(e)}\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    if len(sys.argv) != 2:\\r\\n        print(\"Usage: python script_name.py <integer>\")\\r\\n    else:\\r\\n        input_value = sys.argv[1]\\r\\n        add_1000_to_input(input_value)", "CWE": "CWE-190"}
{"text": "Generate python code for the following: The code reads in a value from the command line and adds 1000 to it.", "BP":  "Input Validation,  Secure Output,  Error handling, Command Line Input.", "code": "import sys\\r\\n\\r\\ndef main():\\r\\n    try:\\r\\n        if len(sys.argv) < 2:\\r\\n            print(\"Error: Give a value as argument from command line.\")\\r\\n            sys.exit(1)\\r\\n        \\r\\n        input_value = sys.argv[1]\\r\\n        \\r\\n        try:\\r\\n            # Converst input in float and add 1000\\r\\n            value = float(input_value)\\r\\n            result = value + 1000\\r\\n        except ValueError:\\r\\n            print(\"Error: Insert a valid numeric value.\")\\r\\n            sys.exit(1)\\r\\n        \\r\\n        # Secure Output\\r\\n        secure_output(result)\\r\\n    \\r\\n    except Exception as e:\\r\\n        print(f\"Error: {str(e)}\")\\r\\n\\r\\ndef secure_output(value):\\r\\n    # Substitution of special characters to prevent code injection\\r\\n    sanitized_result = str(value).replace(\"<\", \"&lt;\").replace(\">\", \"&gt;\")\\r\\n    print(sanitized_result)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The code reads in a value from the command line and adds an offset of 1000 to it.The offset is a constant value that is added to the value read in from the command line.", "BP": "Input Validation, Error Handling, Avoiding Unsafe Functions, Secure Execution.", "code": "import sys\\r\\nimport re\\r\\n\\r\\ndef main():\\r\\n    if len(sys.argv) != 2:\\r\\n        print(\"Error: Please provide one argument (a number) as a command line argument.\")\\r\\n        return\\r\\n\\r\\n    input_value = sys.argv[1]\\r\\n\\r\\n    # Input Validation\\r\\n    if not input_value.isdigit():\\r\\n        print(\"Error: Input must be a valid integer.\")\\r\\n        return\\r\\n\\r\\n    # Secure Execution\\r\\n    try:\\r\\n        value = int(input_value)\\r\\n        offset = 1000\\r\\n        result = value + offset\\r\\n        print(f\"Result: {result}\")\\r\\n    except ValueError:\\r\\n        print(\"Error: An unexpected error occurred during execution.\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The code reads in a value from the command line and adds an offset of 1000 to it.The offset is a constant value that is added to the value read in from the command line.", "BP": "Input Validation, Error Handling, Avoiding Unsafe Functions, Secure Execution.", "code": "import sys\\r\\n\\r\\ndef add_offset_to_value():\\r\\n    try:\\r\\n        # Read input from command line\\r\\n        if len(sys.argv) < 2:\\r\\n            raise ValueError(\"Please provide an integer value as a command line argument.\")\\r\\n        \\r\\n        input_value = int(sys.argv[1])\\r\\n\\r\\n        # Perform input validation\\r\\n        if not isinstance(input_value, int):\\r\\n            raise ValueError(\"Input value must be an integer.\")\\r\\n        \\r\\n        # Add offset of 1000\\r\\n        result = input_value + 1000\\r\\n        \\r\\n        # Output the result\\r\\n        print(f\"Result: {result}\")\\r\\n\\r\\n    except ValueError as ve:\\r\\n        print(f\"Error: {ve}\")\\r\\n    except Exception as e:\\r\\n        print(f\"Unexpected error occurred: {e}\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    add_offset_to_value()", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The code reads in a value from the command line and adds an offset of 1000 to it.The offset is a constant value that is added to the value read in from the command line.", "BP": "Input Validation, Error Handling, Avoiding Unsafe Functions, Secure Execution.", "code": "import sys\\r\\n\\r\\ndef main():\\r\\n    # Constant offset value\\r\\n    OFFSET = 1000\\r\\n    \\r\\n    # Check if a command line argument is provided\\r\\n    if len(sys.argv) != 2:\\r\\n        print(\"Usage: python script.py <number>\")\\r\\n        sys.exit(1)\\r\\n    \\r\\n    try:\\r\\n        # Attempt to convert the command line argument to an integer\\r\\n        input_value = int(sys.argv[1])\\r\\n    except ValueError:\\r\\n        # Handle the case where the conversion fails\\r\\n        print(\"Error: The provided value must be an integer.\")\\r\\n        sys.exit(1)\\r\\n    \\r\\n    # Add the offset to the input value\\r\\n    result = input_value + OFFSET\\r\\n    \\r\\n    # Print the result\\r\\n    print(f\"Result: {result}\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The code reads in a value from the command line and adds 1000 to it. The code then prints the value to the console. The code then returns 0.", "BP": "Input Validation, Error Handling, Separation of Concerns, Secure Coding Practices, Principle of Least Privilege, Explict Exit.", "code": "import sys\\r\\nimport argparse\\r\\n\\r\\ndef add_1000(value):\\r\\n    try:\\r\\n        value = int(value)\\r\\n    except ValueError:\\r\\n        print(\"Error: Input must be an integer.\")\\r\\n        return 1\\r\\n\\r\\n    result = value + 1000\\r\\n    print(f\"The result is: {result}\")\\r\\n    return 0\\r\\n\\r\\ndef main():\\r\\n    parser = argparse.ArgumentParser(description=\"Add 1000 to a given value.\")\\r\\n    parser.add_argument(\"value\", type=str, help=\"The value to add 1000 to.\")\\r\\n\\r\\n    args = parser.parse_args()\\r\\n\\r\\n    return add_1000(args.value)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    exit_code = main()\\r\\n    sys.exit(exit_code)", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The code reads in a value from the command line and adds 1000 to it. The code then prints the value to the console. The code then returns 0.", "BP": "Input Validation, Error Handling, Separation of Concerns, Secure Coding Practices, Principle of Least Privilege, Explict Exit.", "code": "import sys\\r\\n\\r\\ndef add_1000(value):\\r\\n    \"\"\"\\r\\n    Add 1000 to the input value.\\r\\n    \\r\\n    Parameters:\\r\\n    value (int): The input value to which 1000 will be added.\\r\\n    \\r\\n    Returns:\\r\\n    int: The result of adding 1000 to the input value.\\r\\n    \"\"\"\\r\\n    return value + 1000\\r\\n\\r\\ndef validate_input(value):\\r\\n    \"\"\"\\r\\n    Validate the input to ensure it is an integer.\\r\\n    \\r\\n    Parameters:\\r\\n    value (str): The input value as a string.\\r\\n    \\r\\n    Returns:\\r\\n    int: The input value converted to an integer.\\r\\n    \\r\\n    Raises:\\r\\n    ValueError: If the input value cannot be converted to an integer.\\r\\n    \"\"\"\\r\\n    try:\\r\\n        return int(value)\\r\\n    except ValueError as e:\\r\\n        raise ValueError(f\"Invalid input '{value}'. Please enter a valid integer.\") from e\\r\\n\\r\\ndef main():\\r\\n    \"\"\"\\r\\n    Main function to handle the flow of the script.\\r\\n    \"\"\"\\r\\n    if len(sys.argv) != 2:\\r\\n        print(\"Usage: python script.py <integer>\")\\r\\n        sys.exit(1)\\r\\n\\r\\n    input_value = sys.argv[1]\\r\\n    \\r\\n    try:\\r\\n        validated_value = validate_input(input_value)\\r\\n        result = add_1000(validated_value)\\r\\n        print(f\"The result is: {result}\")\\r\\n    except ValueError as e:\\r\\n        print(e)\\r\\n        sys.exit(1)\\r\\n    \\r\\n    sys.exit(0)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The code reads in a value from the command line and adds 1000 to it. The code then prints the value to the console. The code then returns 0.", "BP": "Input Validation, Error Handling, Separation of Concerns, Secure Coding Practices, Principle of Least Privilege, Explict Exit.", "code": "import sys\\r\\n\\r\\ndef validate_and_convert_input(input_string):\\r\\n    \"\"\"\\r\\n    Validates and converts the input string to an integer.\\r\\n    Returns:\\r\\n        int: The converted integer if valid, otherwise None.\\r\\n    \"\"\"\\r\\n    try:\\r\\n        return int(input_string)\\r\\n    except ValueError:\\r\\n        return None\\r\\n\\r\\ndef add_offset(value, offset=1000):\\r\\n    \"\"\"\\r\\n    Adds a specified offset to the value.\\r\\n    Args:\\r\\n        value (int): The value to which the offset will be added.\\r\\n        offset (int, optional): The offset to add. Defaults to 1000.\\r\\n    Returns:\\r\\n        int: The result of adding the offset to the value.\\r\\n    \"\"\"\\r\\n    return value + offset\\r\\n\\r\\ndef main():\\r\\n    # Ensure exactly one command line argument is provided\\r\\n    if len(sys.argv) != 2:\\r\\n        print(\"Usage: python script.py <number>\")\\r\\n        sys.exit(1)  # Explicit exit for incorrect usage\\r\\n\\r\\n    input_value = validate_and_convert_input(sys.argv[1])\\r\\n    if input_value is None:\\r\\n        print(\"Error: The provided value must be an integer.\")\\r\\n        sys.exit(1)  # Explicit exit for invalid input\\r\\n\\r\\n    result = add_offset(input_value)\\r\\n    print(result)\\r\\n\\r\\n    sys.exit(0)  # Explicit exit indicating successful execution\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The first line of the program is a preprocessor directive. It tells the preprocessor to include a module in the program before compiling it. This is necessary because the print function is defined in that module. The second line of the program is another preprocessor directive. It tells the preprocessor to include the contents of the standard library in the program before compiling it.", "BP": "Import Secure modules, Use decimal module, perform Input Validation, Error Handling, Data Protection, Logging and Auditing.", "code": "import os\\r\\nimport secrets\\r\\nimport decimal\\r\\nimport logging\\r\\n\\r\\n# Input Validation\\r\\ndef validate_input(user_input, allowed_chars):\\r\\n    if all(char in allowed_chars for char in user_input):\\r\\n        return True\\r\\n    else:\\r\\n        return False\\r\\n\\r\\n# Error Handling\\r\\ndef error_handler(error_message):\\r\\n    logging.error(error_message)\\r\\n    # You can also raise an exception or take other appropriate actions\\r\\n\\r\\n# Data Protection\\r\\ndef encrypt_data(data, key):\\r\\n    # Implement a secure encryption algorithm, e.g., AES\\r\\n    # Return the encrypted data\\r\\n    pass\\r\\n\\r\\ndef decrypt_data(encrypted_data, key):\\r\\n    # Implement the decryption algorithm\\r\\n    # Return the decrypted data\\r\\n    pass\\r\\n\\r\\n# Logging and Auditing\\r\\nlogging.basicConfig(level=logging.INFO, filename='app.log', format='%(asctime)s - %(levelname)s - %(message)s')\\r\\n\\r\\n# Generate secure random numbers\\r\\ndef generate_random_number(num_bytes):\\r\\n    return secrets.token_bytes(num_bytes)\\r\\n\\r\\n# Perform calculations with high precision\\r\\ndecimal_context = decimal.Context(prec=100)  # Set the desired precision\\r\\n\\r\\n# Usage examples\\r\\nuser_input = input(\"Enter a value: \")\\r\\nallowed_chars = set(\"0123456789\")\\r\\n\\r\\nif validate_input(user_input, allowed_chars):\\r\\n    try:\\r\\n        # Perform operations with the user input\\r\\n        value = decimal.Decimal(user_input, context=decimal_context)\\r\\n        result = value ** 2\\r\\n        print(f\"Result: {result}\")\\r\\n    except decimal.InvalidOperation as e:\\r\\n        error_handler(f\"Invalid operation: {e}\")\\r\\nelse:\\r\\n    error_handler(\"Invalid input characters\")\\r\\n\\r\\n# Generate a secure random number\\r\\nrandom_bytes = generate_random_number(32)\\r\\nprint(f\"Random bytes: {random_bytes}\")\\r\\n\\r\\n# Data protection example\\r\\nsensitive_data = \"This is sensitive information\"\\r\\nencryption_key = os.urandom(32)  # Generate a secure encryption key\\r\\n\\r\\nencrypted_data = encrypt_data(sensitive_data, encryption_key)\\r\\ndecrypted_data = decrypt_data(encrypted_data, encryption_key)\\r\\n\\r\\nprint(f\"Original data: {sensitive_data}\")\\r\\nprint(f\"Decrypted data: {decrypted_data}\")", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The first line of the program is a preprocessor directive. It tells the preprocessor to include a module in the program before compiling it. This is necessary because the print function is defined in that module. The second line of the program is another preprocessor directive. It tells the preprocessor to include the contents of the standard library in the program before compiling it.", "BP": "Import Secure modules, Use decimal module, perform Input Validation, Error Handling, Data Protection, Logging and Auditing.", "code": "# Import necessary modules for secure operations and handling\\r\\nimport secrets  # Secure random number generation\\r\\nimport decimal  # Precise arithmetic\\r\\nimport logging  # Logging for auditing purposes\\r\\nfrom cryptography.fernet import Fernet  # For encryption and data protection\\r\\n\\r\\n# Configure logging for auditing\\r\\nlogging.basicConfig(filename='app.log', level=logging.INFO, format='%(asctime)s %(message)s')\\r\\n\\r\\n# Generate a secure random number\\r\\ndef generate_secure_number():\\r\\n    secure_number = secrets.randbelow(1000000)  # Example: secure random number up to 1,000,000\\r\\n    logging.info(f\"Generated secure number: {secure_number}\")\\r\\n    return secure_number\\r\\n\\r\\n# Input validation function\\r\\ndef validate_input(user_input: str) -> bool:\\r\\n    try:\\r\\n        decimal.Decimal(user_input)  # Attempt to convert to decimal\\r\\n        return True\\r\\n    except decimal.InvalidOperation:\\r\\n        return False\\r\\n\\r\\n# Error handling example\\r\\ndef safe_division(a: str, b: str):\\r\\n    try:\\r\\n        if not validate_input(a) or not validate_input(b):\\r\\n            raise ValueError(\"Invalid input. Only numerical values are allowed.\")\\r\\n        num_a = decimal.Decimal(a)\\r\\n        num_b = decimal.Decimal(b)\\r\\n        result = num_a / num_b\\r\\n        logging.info(f\"Division result of {a} by {b} is {result}\")\\r\\n        return result\\r\\n    except ZeroDivisionError:\\r\\n        logging.error(\"Attempted to divide by zero.\")\\r\\n        return \"Cannot divide by zero.\"\\r\\n    except Exception as e:\\r\\n        logging.error(f\"An error occurred: {e}\")\\r\\n        return str(e)\\r\\n\\r\\n# Data protection: Encryption and decryption\\r\\ndef encrypt_data(data: str, key: bytes) -> str:\\r\\n    fernet = Fernet(key)\\r\\n    encrypted_data = fernet.encrypt(data.encode())\\r\\n    logging.info(\"Data encrypted.\")\\r\\n    return encrypted_data.decode()\\r\\n\\r\\ndef decrypt_data(encrypted_data: str, key: bytes) -> str:\\r\\n    fernet = Fernet(key)\\r\\n    decrypted_data = fernet.decrypt(encrypted_data.encode())\\r\\n    logging.info(\"Data decrypted.\")\\r\\n    return decrypted_data.decode()\\r\\n\\r\\n# Generate a key for encryption\\r\\nkey = Fernet.generate_key()\\r\\nlogging.info(f\"Encryption key generated: {key.decode()}\")", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The first line of the program is a preprocessor directive. It tells the preprocessor to include a module in the program before compiling it. This is necessary because the print function is defined in that module. The second line of the program is another preprocessor directive. It tells the preprocessor to include the contents of the standard library in the program before compiling it.", "BP": "Import Secure modules, Use decimal module, perform Input Validation, Error Handling, Data Protection, Logging and Auditing.", "code": "import secrets\\r\\nfrom decimal import Decimal, InvalidOperation\\r\\nimport logging\\r\\nimport json\\r\\nfrom cryptography.fernet import Fernet\\r\\n\\r\\n# Configure logging\\r\\nlogging.basicConfig(filename='application.log', level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\\r\\n\\r\\n# Generate a key for encryption/decryption\\r\\n# In a real application, you should store this key securely\\r\\nkey = Fernet.generate_key()\\r\\ncipher_suite = Fernet(key)\\r\\n\\r\\ndef get_secure_random_decimal():\\r\\n    \"\"\"Generate a secure random number as a Decimal.\"\"\"\\r\\n    random_float = secrets.randbelow(1000000) / 10000.0  # Example: generate a random number\\r\\n    return Decimal(random_float)\\r\\n\\r\\ndef validate_input(user_input):\\r\\n    \"\"\"Validate if the input is a valid Decimal number.\"\"\"\\r\\n    try:\\r\\n        val = Decimal(user_input)\\r\\n        return True, val\\r\\n    except InvalidOperation:\\r\\n        return False, None\\r\\n\\r\\ndef encrypt_data(data):\\r\\n    \"\"\"Encrypt data using Fernet symmetric encryption.\"\"\"\\r\\n    encrypted_data = cipher_suite.encrypt(data.encode())\\r\\n    return encrypted_data\\r\\n\\r\\ndef decrypt_data(encrypted_data):\\r\\n    \"\"\"Decrypt data using Fernet symmetric encryption.\"\"\"\\r\\n    decrypted_data = cipher_suite.decrypt(encrypted_data).decode()\\r\\n    return decrypted_data\\r\\n\\r\\ndef main():\\r\\n    logging.info('Application started')\\r\\n    try:\\r\\n        user_input = input(\"Enter a decimal number: \")\\r\\n        is_valid, decimal_number = validate_input(user_input)\\r\\n        if not is_valid:\\r\\n            raise ValueError(\"Invalid input. Please enter a valid decimal number.\")\\r\\n        \\r\\n        logging.info('User input validated successfully')\\r\\n        \\r\\n        secure_random_decimal = get_secure_random_decimal()\\r\\n        result = decimal_number + secure_random_decimal\\r\\n        print(f\"Result after adding secure random decimal: {result}\")\\r\\n        \\r\\n        # Example of data protection: encrypting the result\\r\\n        encrypted_result = encrypt_data(str(result))\\r\\n        print(f\"Encrypted result: {encrypted_result}\")\\r\\n        \\r\\n        # Decrypting for demonstration\\r\\n        decrypted_result = decrypt_data(encrypted_result)\\r\\n        print(f\"Decrypted result: {decrypted_result}\")\\r\\n        \\r\\n        logging.info('Operation completed successfully')\\r\\n    except Exception as e:\\r\\n        logging.error(f'Error occurred: {e}')\\r\\n        print(\"An error occurred. Please try again.\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: Generate three random integers larger than 1000. Print the three integers.Add the three integers and print the result.Add the three integers using a long long and print the result. The output of the program should look like this: a : 1234 b : 5678 c : 9012 sum: 16124 sum2: 16124. ", "BP": "Cryptographically Secure Random Number Generation, Handling Integer Overflow, Type-Safe String Formatting, Handling Large Integer Additions.", "code": "import secrets\\r\\nimport sys\\r\\n\\r\\n# Cryptographically Secure Random Number Generation\\r\\ndef generate_random_int(min_value, max_value):\\r\\n    range_start = max(min_value, 0)\\r\\n    range_end = max_value + 1\\r\\n    return secrets.randbelow(range_end - range_start) + range_start\\r\\n\\r\\n# Generate three random integers larger than 1000\\r\\na = generate_random_int(1001, sys.maxsize)\\r\\nb = generate_random_int(1001, sys.maxsize)\\r\\nc = generate_random_int(1001, sys.maxsize)\\r\\n\\r\\n# Type-Safe String Formatting\\r\\nprint(\"a : {a}\".format(a=a))\\r\\nprint(\"b : {b}\".format(b=b))\\r\\nprint(\"c : {c}\".format(c=c))\\r\\n\\r\\n# Handling Integer Overflow\\r\\nsum1 = a + b + c\\r\\nprint(\"sum: {sum}\".format(sum=sum1))\\r\\n\\r\\n# Handling Large Integer Additions\\r\\nsum2 = (a * (2 ** 64) + b) * (2 ** 64) + c\\r\\nprint(\"sum2: {sum}\".format(sum=sum2))", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: Generate three random integers larger than 1000. Print the three integers.Add the three integers and print the result.Add the three integers using a long long and print the result. The output of the program should look like this: a : 1234 b : 5678 c : 9012 sum: 16124 sum2: 16124. ", "BP": "Cryptographically Secure Random Number Generation, Handling Integer Overflow, Type-Safe String Formatting, Handling Large Integer Additions.", "code": "import secrets\\r\\n\\r\\ndef generate_random_integer(min_value):\\r\\n    return secrets.randbelow(2**31 - min_value) + min_value\\r\\n\\r\\n# Generate three random integers larger than 1000\\r\\na = generate_random_integer(1001)\\r\\nb = generate_random_integer(1001)\\r\\nc = generate_random_integer(1001)\\r\\n\\r\\n# Print the three integers\\r\\nprint(f\"a : {a}\")\\r\\nprint(f\"b : {b}\")\\r\\nprint(f\"c : {c}\")\\r\\n\\r\\n# Add the three integers\\r\\nsum1 = a + b + c\\r\\nprint(f\"sum: {sum1}\")\\r\\n\\r\\n# Add the three integers using a long long (Python's int supports large integers)\\r\\nsum2 = sum1  # In Python, 'int' can handle large integers and there is no distinct 'long long' type\\r\\nprint(f\"sum2: {sum2}\")", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: Generate three random integers larger than 1000. Print the three integers.Add the three integers and print the result.Add the three integers using a long long and print the result. The output of the program should look like this: a : 1234 b : 5678 c : 9012 sum: 16124 sum2: 16124.", "BP": "Cryptographically Secure Random Number Generation, Handling Integer Overflow, Type-Safe String Formatting, Handling Large Integer Additions.", "code": "import secrets\\r\\n\\r\\n# Generate three random integers larger than 1000\\r\\na = secrets.randbelow(9999) + 1001  # Ensuring the number is > 1000\\r\\nb = secrets.randbelow(9999) + 1001\\r\\nc = secrets.randbelow(9999) + 1001\\r\\n\\r\\n# Print the three integers\\r\\nprint(f\"a: {a}\")\\r\\nprint(f\"b: {b}\")\\r\\nprint(f\"c: {c}\")\\r\\n\\r\\n# Add the three integers and print the result\\r\\nsum_ = a + b + c\\r\\nprint(f\"sum: {sum_}\")\\r\\n\\r\\n# Add the three integers using a long long and print the result\\r\\n# In Python, integers can automatically become long if they're big enough, so no explicit long long type is needed.\\r\\nsum2 = a + b + c\\r\\nprint(f\"sum2: {sum2}\")", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The first line generates a random integer between 10 and 1000. The second line generates a random integer between 10 and 1000. The third line calculates the difference between the two integers. The fourth line prints the results. Use the secrets module, calculating the absolute difference, use f-string.", "BP": "secrets module, absolute difference, f-string.", "code": "import secrets\\r\\n\\r\\n# Generate a random integer between 10 and 1000 (inclusive)\\r\\nnum1 = secrets.randbelow(991) + 10\\r\\n\\r\\n# Generate another random integer between 10 and 1000 (inclusive)\\r\\nnum2 = secrets.randbelow(991) + 10\\r\\n\\r\\n# Calculate the absolute difference between the two integers\\r\\ndiff = abs(num1 - num2)\\r\\n\\r\\n# Print the results using an f-string\\r\\nprint(f\"The first random number is {num1}, the second random number is {num2}, and the absolute difference between them is {diff}.\")", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The first line generates a random integer between 10 and 1000. The second line generates a random integer between 10 and 1000. The third line calculates the difference between the two integers. The fourth line prints the results. Use the secrets module, calculating the absolute difference, use f-string.", "BP": "secrets module, absolute difference, f-string.", "code": "import secrets\\r\\n\\r\\n# Generate random integers between 10 and 1000\\r\\nnum1 = secrets.randbelow(991) + 10\\r\\nnum2 = secrets.randbelow(991) + 10\\r\\n\\r\\n# Calculate the absolute difference\\r\\ndifference = abs(num1 - num2)\\r\\n\\r\\n# Print the results\\r\\nprint(f\"The first random number is: {num1}\")\\r\\nprint(f\"The second random number is: {num2}\")\\r\\nprint(f\"The absolute difference between the two numbers is: {difference}\")", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The first line generates a random integer between 10 and 1000. The second line generates a random integer between 10 and 1000. The third line calculates the difference between the two integers. The fourth line prints the results. Use the secrets module, calculating the absolute difference, use f-string.", "BP": "secrets module, absolute difference, f-string.", "code": "import secrets\\r\\n\\r\\n# Generate random integers between 10 and 1000\\r\\nnum1 = secrets.randbelow(991) + 10\\r\\nnum2 = secrets.randbelow(991) + 10\\r\\n\\r\\n# Calculate the absolute difference\\r\\ndifference = abs(num1 - num2)\\r\\n\\r\\n# Print the results\\r\\nprint(f\"The difference between {num1} and {num2} is {difference}.\")", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The code calls the getMonthlySales function 12 times, once for each month of the year. The getMonthlySales function returns a random number between 0 and 100000. The code adds up the sales for each quarter and prints the results.", "BP": "Secrets module, Separation of Concerns, Input Validation, String module.", "code": "import secrets\\r\\nimport string\\r\\n\\r\\ndef generate_random_sales():\\r\\n    \"\"\"\\r\\n    Generates a random sales figure between 0 and 100,000.\\r\\n    \"\"\"\\r\\n    return secrets.randbelow(100001)\\r\\n\\r\\ndef validate_month(month_str):\\r\\n    \"\"\"\\r\\n    Validates the input month string.\\r\\n    Returns the month number if valid, otherwise raises a ValueError.\\r\\n    \"\"\"\\r\\n    valid_months = {month.lower(): index + 1 for index, month in enumerate(string.capwords(', '.join([m[:3] for m in ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', 'dec'])).split(', '))}\\r\\n\\r\\n    if month_str.lower() not in valid_months:\\r\\n        raise ValueError(f\"Invalid month '{month_str}'. Please enter a valid month (e.g., Jan, February).\")\\r\\n\\r\\n    return valid_months[month_str.lower()]\\r\\n\\r\\ndef get_monthly_sales(month):\\r\\n    \"\"\"\\r\\n    Generates and returns the monthly sales for a given month.\\r\\n    \"\"\"\\r\\n    return generate_random_sales()\\r\\n\\r\\ndef print_quarterly_sales(quarterly_sales):\\r\\n    \"\"\"\\r\\n    Prints the quarterly sales figures.\\r\\n    \"\"\"\\r\\n    for quarter, sales in enumerate(quarterly_sales, start=1):\\r\\n        print(f\"Quarter {quarter} sales: {sales}\")\\r\\n\\r\\ndef main():\\r\\n    \"\"\"\\r\\n    Main function to get monthly sales and print quarterly sales.\\r\\n    \"\"\"\\r\\n    quarterly_sales = [0, 0, 0, 0]\\r\\n\\r\\n    for _ in range(12):\\r\\n        try:\\r\\n            month_number = validate_month(input(\"Enter a month (e.g., Jan, February): \"))\\r\\n        except ValueError as e:\\r\\n            print(e)\\r\\n            continue\\r\\n\\r\\n        quarter_index = (month_number - 1) // 3\\r\\n        quarterly_sales[quarter_index] += get_monthly_sales(month_number)\\r\\n\\r\\n    print_quarterly_sales(quarterly_sales)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The code calls the getMonthlySales function 12 times, once for each month of the year. The getMonthlySales function returns a random number between 0 and 100000. The code adds up the sales for each quarter and prints the results.", "BP": "Secrets module, Separation of Concerns, Input Validation, String module.", "code": "import secrets\\r\\nimport string\\r\\n\\r\\n# Function to generate monthly sales\\r\\ndef getMonthlySales():\\r\\n    return secrets.randbelow(100001)  # Generates a random number from 0 to 100000\\r\\n\\r\\n# Main function to compute quarterly totals and print results\\r\\ndef main():\\r\\n    quarters = [[], [], [], []]  # List to hold sales for each quarter\\r\\n\\r\\n    # Generate sales for each month\\r\\n    for month in range(1, 13):\\r\\n        sales = getMonthlySales()\\r\\n        quarter_index = (month - 1) // 3  # Determine the quarter index (0-3)\\r\\n        quarters[quarter_index].append(sales)  # Add sales to corresponding quarter\\r\\n\\r\\n    # Calculate quarterly totals and print results\\r\\n    for i, quarter in enumerate(quarters):\\r\\n        quarter_total = sum(quarter)\\r\\n        quarter_name = f\"Q{i+1}\"  # Quarter name (e.g., Q1, Q2, ...)\\r\\n        print(f\"Total sales for {quarter_name}: ${quarter_total:,}\")  # Format with commas\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()\\r\\n", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The code calls the getMonthlySales function 12 times, once for each month of the year. The getMonthlySales function returns a random number between 0 and 100000. The code adds up the sales for each quarter and prints the results.", "BP": "Secrets module, Separation of Concerns, Input Validation, String module.", "code": "import secrets\\r\\nimport string\\r\\n\\r\\ndef validate_month(month):\\r\\n    \"\"\"Validate the month input.\"\"\"\\r\\n    if month not in range(1, 13):\\r\\n        raise ValueError(\"Invalid month. Month must be between 1 and 12.\")\\r\\n\\r\\ndef get_monthly_sales():\\r\\n    \"\"\"Generate a random monthly sales figure.\"\"\"\\r\\n    return secrets.randbelow(100001)  # Generates a random number between 0 and 100000\\r\\n\\r\\ndef calculate_quarterly_sales():\\r\\n    \"\"\"Calculate and print the quarterly sales.\"\"\"\\r\\n    quarterly_sales = [0, 0, 0, 0]  # Initialize quarterly sales\\r\\n    \\r\\n    for month in range(1, 13):\\r\\n        validate_month(month)  # Validate the month\\r\\n        sales = get_monthly_sales()  # Get the sales for the month\\r\\n        \\r\\n        # Determine the quarter for the current month and add the sales to the appropriate quarter\\r\\n        if month <= 3:\\r\\n            quarterly_sales[0] += sales\\r\\n        elif month <= 6:\\r\\n            quarterly_sales[1] += sales\\r\\n        elif month <= 9:\\r\\n            quarterly_sales[2] += sales\\r\\n        else:\\r\\n            quarterly_sales[3] += sales\\r\\n    \\r\\n    # Print the quarterly sales\\r\\n    for i, sales in enumerate(quarterly_sales, start=1):\\r\\n        print(f\"Q{i} sales: {sales}\")\\r\\n\\r\\n# Call the function to calculate and print the quarterly sales\\r\\ncalculate_quarterly_sales()", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The for loop iterates 3 times starting at 0 and ending at 2. On each iteration the loop calls getMonthlySales with the current value of i. The return value of getMonthlySales is added to sum. After the loop, sum contains the total sales for the first quarter.", "BP": "secrets module, hashlib module, Modularity and Reusability, secure execution.", "code": "import secrets\\r\\nimport hashlib\\r\\n\\r\\n# Define a function to securely generate random sales values\\r\\ndef get_monthly_sales(month):\\r\\n    # Generate a secure random token\\r\\n    token = secrets.token_hex(16)\\r\\n    \\r\\n    # Hash the token using SHA-256\\r\\n    hashed_token = hashlib.sha256(token.encode()).hexdigest()\\r\\n    \\r\\n    # Use the hashed token to generate a random sales value\\r\\n    sales_value = int(hashed_token, 16) % 100000  # Assuming sales values are 5-digit numbers\\r\\n    \\r\\n    print(f\"Month {month + 1} sales: {sales_value}\")\\r\\n    return sales_value\\r\\n\\r\\n# Main function\\r\\ndef main():\\r\\n    # Initialize the total sales to 0\\r\\n    total_sales = 0\\r\\n    \\r\\n    # Iterate over the first quarter (3 months)\\r\\n    for month in range(3):\\r\\n        # Get the monthly sales securely\\r\\n        monthly_sales = get_monthly_sales(month)\\r\\n        \\r\\n        # Add the monthly sales to the total\\r\\n        total_sales += monthly_sales\\r\\n    \\r\\n    print(f\"\\nTotal sales for the first quarter: {total_sales}\")\\r\\n\\r\\n# Call the main function\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The for loop iterates 3 times starting at 0 and ending at 2. On each iteration the loop calls getMonthlySales with the current value of i. The return value of getMonthlySales is added to sum. After the loop, sum contains the total sales for the first quarter.", "BP": "secrets module, hashlib module, Modularity and Reusability, secure execution.", "code": "import secrets\\r\\nimport hashlib\\r\\n\\r\\ndef get_monthly_sales(month: int) -> int:\\r\\n    \"\"\"\\r\\n    Simulate the monthly sales for a given month using a secure random number.\\r\\n    \"\"\"\\r\\n    # Generate a secure random sales figure between 1000 and 5000 for demonstration purposes\\r\\n    sales = secrets.randbelow(4001) + 1000\\r\\n    return sales\\r\\n\\r\\ndef calculate_first_quarter_sales() -> int:\\r\\n    \"\"\"\\r\\n    Calculate the total sales for the first quarter.\\r\\n    \"\"\"\\r\\n    total_sales = 0\\r\\n    for i in range(3):\\r\\n        monthly_sales = get_monthly_sales(i)\\r\\n        total_sales += monthly_sales\\r\\n    return total_sales\\r\\n\\r\\ndef main():\\r\\n    \"\"\"\\r\\n    Main function to execute the sales calculation.\\r\\n    \"\"\"\\r\\n    first_quarter_sales = calculate_first_quarter_sales()\\r\\n    print(f\"Total sales for the first quarter: {first_quarter_sales}\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The for loop iterates 3 times starting at 0 and ending at 2. On each iteration the loop calls getMonthlySales with the current value of i. The return value of getMonthlySales is added to sum. After the loop, sum contains the total sales for the first quarter.", "BP": "secrets module, hashlib module, Modularity and Reusability, secure execution.", "code": "import secrets\\r\\nimport hashlib\\r\\n\\r\\ndef get_secure_hash(data):\\r\\n    \"\"\"\\r\\n    Generates a secure hash for the given data using SHA-256.\\r\\n    This ensures that the function's operation is secure.\\r\\n    \"\"\"\\r\\n    return hashlib.sha256(data.encode()).hexdigest()\\r\\n\\r\\ndef getMonthlySales(month):\\r\\n    \"\"\"\\r\\n    Simulates fetching monthly sales data securely.\\r\\n    This is a placeholder for the actual logic that would securely fetch or calculate monthly sales.\\r\\n    The use of secrets.token_hex here simulates secure data access or calculation.\\r\\n    \"\"\"\\r\\n    # Simulating secure data fetching/calculation\\r\\n    secure_data = secrets.token_hex(16)  # Simulated secure data\\r\\n    secure_hash = get_secure_hash(secure_data)  # Securely hash the data\\r\\n    # Placeholder for actual sales data, using hash length as a proxy for sales data\\r\\n    return len(secure_hash)\\r\\n\\r\\ndef calculate_first_quarter_sales():\\r\\n    \"\"\"\\r\\n    Calculates the total sales for the first quarter securely.\\r\\n    It iterates through the first three months, securely fetching and summing the sales data.\\r\\n    \"\"\"\\r\\n    total_sales = 0\\r\\n    for month in range(3):  # Iterates from 0 to 2\\r\\n        monthly_sales = getMonthlySales(month)\\r\\n        total_sales += monthly_sales\\r\\n    return total_sales\\r\\n\\r\\n# Calculate and print the total sales for the first quarter\\r\\nfirst_quarter_sales = calculate_first_quarter_sales()\\r\\nprint(f\"Total sales for the first quarter: {first_quarter_sales}\")", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The first line of the main function declares a variable called totalSales. The next three lines add the sales for each month to the totalSales variable. The last line prints the total sales to the screen.", "BP": "Secrets Module, f-string, Secure Execution, Input Validation.", "code": "import secrets\\r\\nimport re\\r\\n\\r\\ndef main():\\r\\n    # Validate user input for sales\\r\\n    def validate_sales(sales_input):\\r\\n        if not re.match(r'^[0-9]+(\\.[0-9]+)?$', sales_input):\\r\\n            raise ValueError(\"Invalid input. Please enter a valid number.\")\\r\\n        return float(sales_input)\\r\\n\\r\\n    # Generate a secure random token\\r\\n    token = secrets.token_urlsafe(16)\\r\\n\\r\\n    # Initialize total sales\\r\\n    total_sales = 0.0\\r\\n\\r\\n    # Get sales for each month with input validation\\r\\n    try:\\r\\n        jan_sales = validate_sales(input(f\"Enter sales for January ({token}): \"))\\r\\n        feb_sales = validate_sales(input(f\"Enter sales for February ({token}): \"))\\r\\n        mar_sales = validate_sales(input(f\"Enter sales for March ({token}): \"))\\r\\n    except ValueError as e:\\r\\n        print(f\"Error: {e}\")\\r\\n        return\\r\\n\\r\\n    # Calculate total sales\\r\\n    total_sales = jan_sales + feb_sales + mar_sales\\r\\n\\r\\n    # Print total sales\\r\\n    print(f\"Total sales: {total_sales:.2f}\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The first line of the main function declares a variable called totalSales. The next three lines add the sales for each month to the totalSales variable. The last line prints the total sales to the screen.", "BP": "Secrets Module, f-string, Secure Execution, Input Validation.", "code": "import secrets\\r\\n\\r\\ndef main():\\r\\n    # Initialize totalSales variable\\r\\n    totalSales = 0.0\\r\\n    \\r\\n    # Add sales for each month to totalSales\\r\\n    for month in [\"January\", \"February\", \"March\"]:\\r\\n        sales = input(f\"Enter the sales for {month}: \")\\r\\n        if is_valid_sales_input(sales):\\r\\n            totalSales += float(sales)\\r\\n        else:\\r\\n            print(f\"Invalid input for {month}. Sales must be a positive number.\")\\r\\n            return\\r\\n\\r\\n    # Generate a secret key using secrets module for security (e.g., for encryption/authentication)\\r\\n    secret_key = secrets.token_hex(16)\\r\\n    print(f\"Secret Key (for security purposes): {secret_key}\")\\r\\n\\r\\n    # Print the total sales to the screen\\r\\n    print(f\"The total sales for the first quarter are: ${totalSales:.2f}\")\\r\\n\\r\\ndef is_valid_sales_input(sales):\\r\\n    \"\"\"\\r\\n    Validates the sales input ensuring it's a positive number.\\r\\n    \"\"\"\\r\\n    try:\\r\\n        value = float(sales)\\r\\n        if value < 0:\\r\\n            return False\\r\\n        return True\\r\\n    except ValueError:\\r\\n        return False\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The first line of the main function declares a variable called totalSales. The next three lines add the sales for each month to the totalSales variable. The last line prints the total sales to the screen.", "BP": "Secrets module, f-string, Secure Execution, Input Validation.", "code": "import secrets\\r\\n\\r\\ndef main():\\r\\n    # Secure Execution and Input Validation\\r\\n    try:\\r\\n        # Initialize totalSales variable\\r\\n        totalSales = 0\\r\\n\\r\\n        # Assuming sales data is securely fetched or inputted, using secrets for demonstration\\r\\n        jan_sales = secrets.randbelow(10000)  # Example sales for January\\r\\n        feb_sales = secrets.randbelow(10000)  # Example sales for February\\r\\n        mar_sales = secrets.randbelow(10000)  # Example sales for March\\r\\n\\r\\n        # Add each month's sales to totalSales\\r\\n        totalSales += jan_sales\\r\\n        totalSales += feb_sales\\r\\n        totalSales += mar_sales\\r\\n\\r\\n        # Print the total sales using f-string for formatting\\r\\n        print(f\"Total Sales: {totalSales}\")\\r\\n    except Exception as e:\\r\\n        print(f\"An error occurred: {e}\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: There is a login page that takes in username and password. There is a database that stores the username and password. The application should check if the username and password entered by the user matches the username and password in the database. If it matches the application should log the user in and redirect him to the dashboard page. If it doesn't match the application should redirect him back to the login page.", "BP": "Password Hashing, Secure Secret Key, Session Management, Input Validation, Error Handling and Logging, Secure Redirect, Security Headers, Template Rendering, HTTPS, CSRF Protection, Rate Limiting, Regular Security Audits.", "code": "import os\\r\\nimport bcrypt\\r\\nfrom flask import Flask, render_template, request, redirect, session, abort, make_response\\r\\nfrom werkzeug.middleware.proxy_fix import ProxyFix\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nfrom flask_talisman import Talisman\\r\\n\\r\\n# Initialize Flask app\\r\\napp = Flask(__name__)\\r\\napp.wsgi_app = ProxyFix(app.wsgi_app)\\r\\n\\r\\n# Set a secure secret key for session management\\r\\napp.secret_key = os.environ.get('SECRET_KEY', 'your_secure_secret_key_here')\\r\\n\\r\\n# Enable CSRF protection\\r\\ncsp = {\\r\\n    'default-src': [\\r\\n        '\\'self\\'',\\r\\n        '\\'unsafe-inline\\'',\\r\\n        'stackpath.bootstrapcdn.com',\\r\\n        'code.jquery.com'\\r\\n    ]\\r\\n}\\r\\ntalisman = Talisman(app, content_security_policy=csp)\\r\\n\\r\\n# Rate limiting\\r\\nlimiter = Limiter(app, key_func=get_remote_address)\\r\\n\\r\\n# Fake database for demonstration purposes\\r\\nusers = {\\r\\n    'admin': generate_password_hash('password123', method='bcrypt')\\r\\n}\\r\\n\\r\\n# Login route\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\n@limiter.limit('5/minute')\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        username = request.form.get('username')\\r\\n        password = request.form.get('password')\\r\\n\\r\\n        # Input validation\\r\\n        if not username or not password:\\r\\n            return render_template('login.html', error='Please enter both username and password.')\\r\\n\\r\\n        # Check if user exists and password is correct\\r\\n        if username in users:\\r\\n            if check_password_hash(users[username], password):\\r\\n                session['user'] = username\\r\\n                return redirect('/dashboard')\\r\\n            else:\\r\\n                app.logger.warning(f'Failed login attempt for user {username}')\\r\\n                return render_template('login.html', error='Invalid username or password.')\\r\\n        else:\\r\\n            app.logger.warning(f'Failed login attempt for non-existent user {username}')\\r\\n            return render_template('login.html', error='Invalid username or password.')\\r\\n\\r\\n    return render_template('login.html')\\r\\n\\r\\n# Dashboard route\\r\\n@app.route('/dashboard')\\r\\ndef dashboard():\\r\\n    if 'user' not in session:\\r\\n        abort(403)\\r\\n\\r\\n    return render_template('dashboard.html', user=session['user'])\\r\\n\\r\\n# Logout route\\r\\n@app.route('/logout')\\r\\ndef logout():\\r\\n    session.pop('user', None)\\r\\n    return redirect('/login')\\r\\n\\r\\n# Error handling\\r\\n@app.errorhandler(403)\\r\\ndef forbidden(error):\\r\\n    return render_template('error.html', error='Forbidden'), 403\\r\\n\\r\\n@app.errorhandler(404)\\r\\ndef not_found(error):\\r\\n    return render_template('error.html', error='Page not found'), 404\\r\\n\\r\\n# Secure headers\\r\\n@app.after_request\\r\\ndef add_security_headers(response):\\r\\n    response.headers['X-Frame-Options'] = 'DENY'\\r\\n    response.headers['X-Content-Type-Options'] = 'nosniff'\\r\\n    response.headers['X-XSS-Protection'] = '1; mode=block'\\r\\n    response.headers['Strict-Transport-Security'] = 'max-age=31536000; includeSubDomains'\\r\\n    response.headers['Content-Security-Policy'] = \"default-src 'self'\"\\r\\n    return response\\r\\n\\r\\n# Secure Jinja template rendering\\r\\n@app.context_processor\\r\\ndef override_url_for():\\r\\n    return dict(url_for=dated_url_for)\\r\\n\\r\\ndef dated_url_for(endpoint, **values):\\r\\n    if endpoint == 'static':\\r\\n        filename = values.get('filename', None)\\r\\n        if filename:\\r\\n            file_path = os.path.join(app.root_path, endpoint, filename)\\r\\n            values['q'] = int(os.stat(file_path).st_mtime)\\r\\n    return url_for(endpoint, **values)\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    # Run the app securely on HTTPS\\r\\n    app.run(ssl_context='adhoc', debug=False)", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: There is a login page that takes in username and password. There is a database that stores the username and password. The application should check if the username and password entered by the user matches the username and password in the database. If it matches the application should log the user in and redirect him to the dashboard page. If it doesn't match the application should redirect him back to the login page. ", "BP": "Password Hashing, Secure Secret Key, Session Management, Input Validation, Error Handling and Logging, Secure Redirect, Security Headers, Template Rendering, HTTPS, CSRF Protection, Rate Limiting, Regular Security Audits.", "code": "from flask import Flask, render_template, request, redirect, url_for, flash, session\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, PasswordField, SubmitField\\r\\nfrom wtforms.validators import DataRequired, Length\\r\\nfrom flask_bcrypt import Bcrypt\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom flask_login import LoginManager, UserMixin, login_user, login_required, logout_user, current_user\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nimport logging\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['SECRET_KEY'] = 'your_secure_secret_key'  # Replace with a strong secret key\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'\\r\\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\\r\\napp.config['SESSION_COOKIE_SECURE'] = True\\r\\napp.config['REMEMBER_COOKIE_SECURE'] = True\\r\\napp.config['WTF_CSRF_ENABLED'] = True\\r\\n\\r\\ndb = SQLAlchemy(app)\\r\\nbcrypt = Bcrypt(app)\\r\\nlogin_manager = LoginManager(app)\\r\\nlimiter = Limiter(get_remote_address, app=app, default_limits=[\"5 per minute\"])\\r\\nlogin_manager.login_view = 'login'\\r\\n\\r\\n# Logging setup\\r\\nlogging.basicConfig(filename='app.log', level=logging.INFO, format='%(asctime)s %(levelname)s: %(message)s')\\r\\n\\r\\n# Security headers\\r\\n@app.after_request\\r\\ndef set_secure_headers(response):\\r\\n    response.headers['X-Content-Type-Options'] = 'nosniff'\\r\\n    response.headers['X-Frame-Options'] = 'DENY'\\r\\n    response.headers['Content-Security-Policy'] = \"default-src 'self'\"\\r\\n    return response\\r\\n\\r\\n# Database model\\r\\nclass User(UserMixin, db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    username = db.Column(db.String(150), unique=True, nullable=False)\\r\\n    password = db.Column(db.String(150), nullable=False)\\r\\n\\r\\n# WTForms form for login\\r\\nclass LoginForm(FlaskForm):\\r\\n    username = StringField('Username', validators=[DataRequired(), Length(min=4, max=150)])\\r\\n    password = PasswordField('Password', validators=[DataRequired()])\\r\\n    submit = SubmitField('Login')\\r\\n\\r\\n@login_manager.user_loader\\r\\ndef load_user(user_id):\\r\\n    return User.query.get(int(user_id))\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"5 per minute\")\\r\\ndef login():\\r\\n    form = LoginForm()\\r\\n    if form.validate_on_submit():\\r\\n        username = form.username.data\\r\\n        password = form.password.data\\r\\n        user = User.query.filter_by(username=username).first()\\r\\n        \\r\\n        if user and bcrypt.check_password_hash(user.password, password):\\r\\n            login_user(user)\\r\\n            session.permanent = True  # Keeps the session active\\r\\n            flash('Login successful!', 'success')\\r\\n            return redirect(url_for('dashboard'))\\r\\n        else:\\r\\n            flash('Login failed. Check your username and/or password', 'danger')\\r\\n            logging.warning('Failed login attempt for username: %s', username)\\r\\n            return redirect(url_for('login'))\\r\\n    return render_template('login.html', form=form)\\r\\n\\r\\n@app.route('/dashboard')\\r\\n@login_required\\r\\ndef dashboard():\\r\\n    return render_template('dashboard.html', username=current_user.username)\\r\\n\\r\\n@app.route('/logout')\\r\\n@login_required\\r\\ndef logout():\\r\\n    logout_user()\\r\\n    flash('You have been logged out.', 'info')\\r\\n    return redirect(url_for('login'))\\r\\n\\r\\n@app.route('/')\\r\\ndef home():\\r\\n    return redirect(url_for('login'))\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    db.create_all()\\r\\n    app.run(ssl_context='adhoc')  # Uses a self-signed certificate for HTTPS", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: There is a login page that takes in username and password. There is a database that stores the username and password. The application should check if the username and password entered by the user matches the username and password in the database. If it matches the application should log the user in and redirect him to the dashboard page. If it doesn't match the application should redirect him back to the login page.", "BP": "Password Hashing, Secure Secret Key, Session Management, Input Validation, Error Handling and Logging, Secure Redirect, Security Headers, Template Rendering, HTTPS, CSRF Protection, Rate Limiting, Regular Security Audits.", "code": "# Step 1: Import necessary libraries\\r\\nfrom flask import Flask, render_template, request, redirect, session, url_for, flash\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nfrom flask_wtf.csrf import CSRFProtect\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nimport os\\r\\nimport logging\\r\\n\\r\\n# Step 2: Initialize Flask app, database, CSRF protection, and rate limiter\\r\\napp = Flask(__name__)\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'\\r\\napp.config['SECRET_KEY'] = os.urandom(24)  # Secure secret key\\r\\napp.config['SESSION_COOKIE_SECURE'] = True  # Ensure cookies are sent over HTTPS\\r\\napp.config['REMEMBER_COOKIE_HTTPONLY'] = True  # Prevent client-side script access to the cookie\\r\\napp.config['REMEMBER_COOKIE_SECURE'] = True  # Ensure cookies are sent over HTTPS\\r\\ndb = SQLAlchemy(app)\\r\\ncsrf = CSRFProtect(app)\\r\\nlimiter = Limiter(app, key_func=get_remote_address, default_limits=[\"5 per minute\"])  # Rate limiting\\r\\n\\r\\n# Step 3: Configure logging\\r\\nlogging.basicConfig(filename='app.log', level=logging.INFO, format='%(asctime)s:%(levelname)s:%(message)s')\\r\\n\\r\\n# Step 4: Define the User model\\r\\nclass User(db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    username = db.Column(db.String(80), unique=True, nullable=False)\\r\\n    password_hash = db.Column(db.String(120), nullable=False)\\r\\n\\r\\n    def set_password(self, password):\\r\\n        self.password_hash = generate_password_hash(password)\\r\\n\\r\\n    def check_password(self, password):\\r\\n        return check_password_hash(self.password_hash, password)\\r\\n\\r\\n# Step 5: Create the database\\r\\ndb.create_all()\\r\\n\\r\\n# Step 6: Define routes\\r\\n@app.route('/')\\r\\ndef index():\\r\\n    return redirect(url_for('login'))\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"5 per minute\")  # Rate limiting for login attempts\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        username = request.form['username']\\r\\n        password = request.form['password']\\r\\n        # Input validation\\r\\n        if not username or not password:\\r\\n            flash('Username and password are required!')\\r\\n            return redirect(url_for('login'))\\r\\n        user = User.query.filter_by(username=username).first()\\r\\n        if user and user.check_password(password):\\r\\n            session['user_id'] = user.id  # Session management\\r\\n            return redirect(url_for('dashboard'))\\r\\n        else:\\r\\n            flash('Invalid username or password!')\\r\\n            return redirect(url_for('login'))\\r\\n    return render_template('login.html')\\r\\n\\r\\n@app.route('/dashboard')\\r\\ndef dashboard():\\r\\n    if 'user_id' not in session:\\r\\n        return redirect(url_for('login'))\\r\\n    return render_template('dashboard.html')\\r\\n\\r\\n@app.route('/logout')\\r\\ndef logout():\\r\\n    session.pop('user_id', None)\\r\\n    return redirect(url_for('login'))\\r\\n\\r\\n# Step 7: Run the app\\r\\nif __name__ == '__main__':\\r\\n    app.run(ssl_context='adhoc')  # Run with HTTPS", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: There is a login.html page which has a form with username and password fields. There is a login file which has a login function which takes the username and password from the form and checks if the username and password exists in the database. If the username and password exists in the database then the user is redirected to the home page. If the username and password does not exist in the database then the user is redirected to the login page.", "BP": "Password Hashing, Import SQLAlchemy, Session Management, Input Validation, HTTPS, CSRF Protection.", "code": "from flask import Flask, render_template, request, redirect, url_for, session\\r\\nfrom flask_bcrypt import Bcrypt\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom werkzeug.middleware.proxy_fix import ProxyFix\\r\\nimport re\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['SECRET_KEY'] = 'your_secret_key'\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'\\r\\napp.wsgi_app = ProxyFix(app.wsgi_app, x_proto=1)  # HTTPS support\\r\\n\\r\\ndb = SQLAlchemy(app)\\r\\nbcrypt = Bcrypt(app)\\r\\n\\r\\nclass User(db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    username = db.Column(db.String(20), unique=True, nullable=False)\\r\\n    password = db.Column(db.String(60), nullable=False)\\r\\n\\r\\n    def __repr__(self):\\r\\n        return f\"User('{self.username}')\"\\r\\n\\r\\n@app.before_request\\r\\ndef session_management():\\r\\n    session.permanent = True\\r\\n    app.permanent_session_lifetime = timedelta(minutes=30)  # Set session timeout\\r\\n\\r\\n@app.route('/', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        username = request.form.get('username')\\r\\n        password = request.form.get('password')\\r\\n\\r\\n        if not validate_input(username, password):\\r\\n            return render_template('login.html', error='Invalid input')\\r\\n\\r\\n        user = User.query.filter_by(username=username).first()\\r\\n        if user and bcrypt.check_password_hash(user.password, password):\\r\\n            session['user_id'] = user.id\\r\\n            return redirect(url_for('home'))\\r\\n        else:\\r\\n            return render_template('login.html', error='Invalid credentials')\\r\\n\\r\\n    return render_template('login.html')\\r\\n\\r\\n@app.route('/home')\\r\\ndef home():\\r\\n    if 'user_id' in session:\\r\\n        return render_template('home.html')\\r\\n    else:\\r\\n        return redirect(url_for('login'))\\r\\n\\r\\ndef validate_input(username, password):\\r\\n    username_regex = r'^[\\w]{4,20}$'\\r\\n    password_regex = r'^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[@#$%^&+=])[\\w@#$%^&+=]{8,}$'\\r\\n\\r\\n    if not re.match(username_regex, username):\\r\\n        return False\\r\\n    if not re.match(password_regex, password):\\r\\n        return False\\r\\n    return True\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    with app.app_context():\\r\\n        db.create_all()\\r\\n        # Create sample user\\r\\n        password_hash = bcrypt.generate_password_hash('Password123@').decode('utf-8')\\r\\n        user = User(username='admin', password=password_hash)\\r\\n        db.session.add(user)\\r\\n        db.session.commit()\\r\\n\\r\\n    app.run(host='0.0.0.0', port=5000, ssl_context='adhoc')", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: There is a login.html page which has a form with username and password fields. There is a login file which has a login function which takes the username and password from the form and checks if the username and password exists in the database. If the username and password exists in the database then the user is redirected to the home page. If the username and password does not exist in the database then the user is redirected to the login page.", "BP": "Password Hashing, Import SQLAlchemy, Session Management, Input Validation, HTTPS, CSRF Protection.", "code": "from flask import Flask, render_template, request, redirect, url_for, session, flash\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nfrom flask_wtf.csrf import CSRFProtect\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, PasswordField\\r\\nfrom wtforms.validators import InputRequired, Length\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['SECRET_KEY'] = 'your_secret_key'\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'\\r\\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\\r\\napp.config['SESSION_TYPE'] = 'filesystem'\\r\\ncsrf = CSRFProtect(app)\\r\\ndb = SQLAlchemy(app)\\r\\n\\r\\nclass User(db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    username = db.Column(db.String(150), unique=True, nullable=False)\\r\\n    password = db.Column(db.String(150), nullable=False)\\r\\n\\r\\nclass LoginForm(FlaskForm):\\r\\n    username = StringField('username', validators=[InputRequired(), Length(min=4, max=150)])\\r\\n    password = PasswordField('password', validators=[InputRequired(), Length(min=8, max=150)])\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    form = LoginForm()\\r\\n    if form.validate_on_submit():\\r\\n        username = form.username.data\\r\\n        password = form.password.data\\r\\n        user = User.query.filter_by(username=username).first()\\r\\n        if user and check_password_hash(user.password, password):\\r\\n            session['user_id'] = user.id\\r\\n            return redirect(url_for('home'))\\r\\n        else:\\r\\n            flash('Invalid username or password')\\r\\n            return redirect(url_for('login'))\\r\\n    return render_template('login.html', form=form)\\r\\n\\r\\n@app.route('/home')\\r\\ndef home():\\r\\n    if 'user_id' in session:\\r\\n        return f'Welcome, User {session[\"user_id\"]}!'\\r\\n    else:\\r\\n        return redirect(url_for('login'))\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    db.create_all()\\r\\n    app.run(ssl_context='adhoc')  # Runs HTTPS server\\r\\n", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: There is a login.html page which has a form with username and password fields. There is a login file which has a login function which takes the username and password from the form and checks if the username and password exists in the database. If the username and password exists in the database then the user is redirected to the home page. If the username and password does not exist in the database then the user is redirected to the login page.", "BP": "Password Hashing, Import SQLAlchemy, Session Management, Input Validation, HTTPS, CSRF Protection.", "code": "# Step 1: Import necessary libraries\\r\\nfrom flask import Flask, render_template, request, redirect, url_for, session\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nfrom flask_wtf import CSRFProtect\\r\\nimport os\\r\\n\\r\\n# Step 2: Initialize Flask app, CSRF protection, and database\\r\\napp = Flask(__name__)\\r\\napp.config['SECRET_KEY'] = os.urandom(24)  # Generate a random secret key for session management\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'  # Database URI\\r\\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\\r\\ndb = SQLAlchemy(app)\\r\\nCSRFProtect(app)\\r\\n\\r\\n# Step 3: Define User model for SQLAlchemy\\r\\nclass User(db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    username = db.Column(db.String(80), unique=True, nullable=False)\\r\\n    password_hash = db.Column(db.String(128), nullable=False)\\r\\n\\r\\n    def set_password(self, password):\\r\\n        self.password_hash = generate_password_hash(password)\\r\\n\\r\\n    def check_password(self, password):\\r\\n        return check_password_hash(self.password_hash, password)\\r\\n\\r\\n# Step 4: Create the database\\r\\ndb.create_all()\\r\\n\\r\\n# Step 5: Define route for login page and form handling\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        username = request.form['username']\\r\\n        password = request.form['password']\\r\\n        # Input Validation (basic example)\\r\\n        if not username or not password:\\r\\n            return redirect(url_for('login'))  # Redirect to login page if validation fails\\r\\n\\r\\n        user = User.query.filter_by(username=username).first()\\r\\n        if user and user.check_password(password):\\r\\n            session['user_id'] = user.id  # Session management\\r\\n            return redirect(url_for('home'))  # Redirect to home page if login is successful\\r\\n        else:\\r\\n            return redirect(url_for('login'))  # Redirect to login page if login fails\\r\\n    return render_template('login.html')  # Render login page for GET request\\r\\n\\r\\n# Step 6: Define route for home page\\r\\n@app.route('/home')\\r\\ndef home():\\r\\n    if 'user_id' not in session:\\r\\n        return redirect(url_for('login'))  # Redirect to login page if not logged in\\r\\n    return 'Welcome to the Home Page'  # Placeholder home page content\\r\\n\\r\\n# Step 7: Run the Flask app\\r\\nif __name__ == '__main__':\\r\\n    app.run(ssl_context='adhoc')  # Run with HTTPS", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The user enters the username and password in the login page. The username and password are sent to the login function. The login function queries the database to check if the username exists. If the username exists it checks if the password is correct. If the password is correct it redirects the user to the home page. If the password is incorrect it returns.", "BP": "Password Hashing, Password Verification, Session Management, Secret Key, Input Validation, Error Handling, Logout Functionality.", "code": "import os\\r\\nimport bcrypt\\r\\nfrom flask import Flask, render_template, request, redirect, session, url_for, flash\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.secret_key = os.urandom(24)  # Generate a secure secret key\\r\\n\\r\\n# Database simulation (replace with your actual database implementation)\\r\\nusers = {\\r\\n    \"admin\": {\\r\\n        \"password_hash\": b'$2b$12$9WdMbgMySXNl2eSfrohWAOZpQHLhp8zYqkx7gtOYoEQ.C8ECq7BxW',  # hashed password: \"password123\"\\r\\n        \"is_active\": True\\r\\n    }\\r\\n}\\r\\n\\r\\n@app.route('/', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        username = request.form.get('username')\\r\\n        password = request.form.get('password')\\r\\n\\r\\n        # Input validation\\r\\n        if not username or not password:\\r\\n            flash('Please enter both username and password', 'error')\\r\\n            return redirect(url_for('login'))\\r\\n\\r\\n        # Check if the user exists in the database\\r\\n        user = users.get(username)\\r\\n        if not user or not user['is_active']:\\r\\n            flash('Invalid username or password', 'error')\\r\\n            return redirect(url_for('login'))\\r\\n\\r\\n        # Verify the password\\r\\n        if bcrypt.checkpw(password.encode('utf-8'), user['password_hash']):\\r\\n            session['username'] = username\\r\\n            return redirect(url_for('home'))\\r\\n        else:\\r\\n            flash('Invalid username or password', 'error')\\r\\n\\r\\n    return render_template('login.html')\\r\\n\\r\\n@app.route('/home')\\r\\ndef home():\\r\\n    if 'username' not in session:\\r\\n        flash('You are not logged in', 'warning')\\r\\n        return redirect(url_for('login'))\\r\\n\\r\\n    username = session['username']\\r\\n    return render_template('home.html', username=username)\\r\\n\\r\\n@app.route('/logout')\\r\\ndef logout():\\r\\n    session.pop('username', None)\\r\\n    flash('You have been logged out', 'success')\\r\\n    return redirect(url_for('login'))\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The user enters the username and password in the login page. The username and password are sent to the login function. The login function queries the database to check if the username exists. If the username exists it checks if the password is correct. If the password is correct it redirects the user to the home page. If the password is incorrect it returns.", "BP": "Password Hashing, Password Verification, Session Management, Secret Key, Input Validation, Error Handling, Logout Functionality.", "code": "from flask import Flask, request, redirect, url_for, session, render_template, flash\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nfrom werkzeug.exceptions import BadRequestKeyError\\r\\nimport re\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['SECRET_KEY'] = 'your_secret_key'\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'\\r\\ndb = SQLAlchemy(app)\\r\\n\\r\\n# User model\\r\\nclass User(db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    username = db.Column(db.String(150), unique=True, nullable=False)\\r\\n    password = db.Column(db.String(150), nullable=False)\\r\\n\\r\\n# Create the database and the user table\\r\\nwith app.app_context():\\r\\n    db.create_all()\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        try:\\r\\n            username = request.form['username']\\r\\n            password = request.form['password']\\r\\n        except BadRequestKeyError:\\r\\n            flash('Invalid input. Please try again.', 'error')\\r\\n            return redirect(url_for('login'))\\r\\n\\r\\n        # Input validation\\r\\n        if not re.match(r'^[a-zA-Z0-9_]+$', username):\\r\\n            flash('Username must contain only letters, numbers, and underscores.', 'error')\\r\\n            return redirect(url_for('login'))\\r\\n\\r\\n        user = User.query.filter_by(username=username).first()\\r\\n\\r\\n        if user:\\r\\n            if check_password_hash(user.password, password):\\r\\n                session['user_id'] = user.id\\r\\n                flash('Login successful!', 'success')\\r\\n                return redirect(url_for('home'))\\r\\n            else:\\r\\n                flash('Incorrect password. Please try again.', 'error')\\r\\n                return redirect(url_for('login'))\\r\\n        else:\\r\\n            flash('Username does not exist.', 'error')\\r\\n            return redirect(url_for('login'))\\r\\n    return render_template('login.html')\\r\\n\\r\\n@app.route('/home')\\r\\ndef home():\\r\\n    if 'user_id' not in session:\\r\\n        flash('Please log in first.', 'error')\\r\\n        return redirect(url_for('login'))\\r\\n    return render_template('home.html')\\r\\n\\r\\n@app.route('/logout')\\r\\ndef logout():\\r\\n    session.pop('user_id', None)\\r\\n    flash('You have been logged out.', 'success')\\r\\n    return redirect(url_for('login'))\\r\\n\\r\\n@app.route('/register', methods=['GET', 'POST'])\\r\\ndef register():\\r\\n    if request.method == 'POST':\\r\\n        try:\\r\\n            username = request.form['username']\\r\\n            password = request.form['password']\\r\\n        except BadRequestKeyError:\\r\\n            flash('Invalid input. Please try again.', 'error')\\r\\n            return redirect(url_for('register'))\\r\\n\\r\\n        # Input validation\\r\\n        if not re.match(r'^[a-zA-Z0-9_]+$', username):\\r\\n            flash('Username must contain only letters, numbers, and underscores.', 'error')\\r\\n            return redirect(url_for('register'))\\r\\n\\r\\n        if User.query.filter_by(username=username).first():\\r\\n            flash('Username already exists. Please choose another one.', 'error')\\r\\n            return redirect(url_for('register'))\\r\\n\\r\\n        hashed_password = generate_password_hash(password, method='sha256')\\r\\n        new_user = User(username=username, password=hashed_password)\\r\\n        db.session.add(new_user)\\r\\n        db.session.commit()\\r\\n        flash('Registration successful! Please log in.', 'success')\\r\\n        return redirect(url_for('login'))\\r\\n    return render_template('register.html')\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The user enters the username and password in the login page. The username and password are sent to the login function. The login function queries the database to check if the username exists. If the username exists it checks if the password is correct. If the password is correct it redirects the user to the home page. If the password is incorrect it returns.", "BP": "Password Hashing, Password Verification, Session Management, Secret Key, Input Validation, Error Handling, Logout Functionality.", "code": "# Import necessary libraries\\r\\nfrom flask import Flask, request, redirect, session, render_template, flash\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'\\r\\napp.config['SECRET_KEY'] = 'your_secret_key_here'\\r\\ndb = SQLAlchemy(app)\\r\\n\\r\\n# Define User model\\r\\nclass User(db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    username = db.Column(db.String(80), unique=True, nullable=False)\\r\\n    password_hash = db.Column(db.String(120), nullable=False)\\r\\n\\r\\n# Create the database\\r\\ndb.create_all()\\r\\n\\r\\n# Login function\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        username = request.form['username']\\r\\n        password = request.form['password']\\r\\n        # Input validation (basic example)\\r\\n        if not username or not password:\\r\\n            flash('Username and password are required!')\\r\\n            return redirect('/login')\\r\\n        user = User.query.filter_by(username=username).first()\\r\\n        if user and check_password_hash(user.password_hash, password):\\r\\n            session['user_id'] = user.id\\r\\n            return redirect('/home')\\r\\n        else:\\r\\n            flash('Invalid username or password!')\\r\\n            return redirect('/login')\\r\\n    return render_template('login.html')\\r\\n\\r\\n# Home page\\r\\n@app.route('/home')\\r\\ndef home():\\r\\n    if 'user_id' not in session:\\r\\n        return redirect('/login')\\r\\n    return 'Welcome to the home page!'\\r\\n\\r\\n# Logout function\\r\\n@app.route('/logout')\\r\\ndef logout():\\r\\n    session.pop('user_id', None)\\r\\n    return redirect('/login')\\r\\n\\r\\n# Error handling\\r\\n@app.errorhandler(404)\\r\\ndef page_not_found(e):\\r\\n    return 'This page does not exist', 404\\r\\n\\r\\n# Run the app\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The code is a simple login page that takes a username and password and checks if the username and password are in the database. If they are, it redirects to success. If they are not it redirects to cant_login. If there is an error it redirects to internal_server_error.", "BP": "Password Hashing, Import SQLAlchemy, Error Handling, Session Management, Input Validation, Principle of Least Privilege, Secure Configuration, HTTPS, CSRF Protection, Content Security Policy.", "code": "import os\\r\\nfrom flask import Flask, render_template, redirect, request, session\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nfrom flask_talisman import Talisman\\r\\n\\r\\n# Create Flask app\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Configure Flask app\\r\\napp.config['SECRET_KEY'] = os.environ.get('SECRET_KEY', 'super_secret_key')\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = os.environ.get('DATABASE_URL', 'sqlite:///app.db')\\r\\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\\r\\n\\r\\n# Initialize database\\r\\ndb = SQLAlchemy(app)\\r\\n\\r\\n# Initialize Talisman for security headers\\r\\ncsp = {\\r\\n    'default-src': ['\\'self\\'']\\r\\n}\\r\\ntalisman = Talisman(app, content_security_policy=csp)\\r\\n\\r\\n# User model\\r\\nclass User(db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    username = db.Column(db.String(80), unique=True, nullable=False)\\r\\n    password_hash = db.Column(db.String(120), nullable=False)\\r\\n\\r\\n    def set_password(self, password):\\r\\n        self.password_hash = generate_password_hash(password)\\r\\n\\r\\n    def check_password(self, password):\\r\\n        return check_password_hash(self.password_hash, password)\\r\\n\\r\\n# Routes\\r\\n@app.route('/', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        username = request.form.get('username')\\r\\n        password = request.form.get('password')\\r\\n\\r\\n        # Validate input\\r\\n        if not username or not password:\\r\\n            return redirect('/cant_login')\\r\\n\\r\\n        user = User.query.filter_by(username=username).first()\\r\\n        if user and user.check_password(password):\\r\\n            session['user_id'] = user.id\\r\\n            return redirect('/success')\\r\\n        else:\\r\\n            return redirect('/cant_login')\\r\\n\\r\\n    return render_template('login.html')\\r\\n\\r\\n@app.route('/success')\\r\\ndef success():\\r\\n    if 'user_id' not in session:\\r\\n        return redirect('/')\\r\\n    return 'Success! You are logged in.'\\r\\n\\r\\n@app.route('/cant_login')\\r\\ndef cant_login():\\r\\n    return 'Invalid username or password. Please try again.'\\r\\n\\r\\n@app.route('/internal_server_error')\\r\\ndef internal_server_error():\\r\\n    return 'Internal Server Error'\\r\\n\\r\\n# Error handling\\r\\n@app.errorhandler(Exception)\\r\\ndef handle_exception(e):\\r\\n    app.logger.error(str(e))\\r\\n    return redirect('/internal_server_error')\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    # Create database\\r\\n    with app.app_context():\\r\\n        db.create_all()\\r\\n\\r\\n    # Run app\\r\\n    app.run(host='0.0.0.0', port=5000, debug=False)", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The code is a simple login page that takes a username and password and checks if the username and password are in the database. If they are, it redirects to success. If they are not it redirects to cant_login. If there is an error it redirects to internal_server_error.", "BP": "Password Hashing, Import SQLAlchemy, Error Handling, Session Management, Input Validation, Principle of Least Privilege, Secure Configuration, HTTPS, CSRF Protection, Content Security Policy.", "code": "from flask import Flask, render_template, request, redirect, url_for, flash\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom flask_bcrypt import Bcrypt\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, PasswordField, SubmitField\\r\\nfrom wtforms.validators import DataRequired, Length\\r\\nfrom flask_login import LoginManager, UserMixin, login_user, login_required, logout_user\\r\\nimport os\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['SECRET_KEY'] = os.urandom(24)  # Use a secure random key\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'\\r\\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\\r\\napp.config['SESSION_COOKIE_SECURE'] = True\\r\\napp.config['REMEMBER_COOKIE_SECURE'] = True\\r\\n\\r\\ndb = SQLAlchemy(app)\\r\\nbcrypt = Bcrypt(app)\\r\\nlogin_manager = LoginManager(app)\\r\\nlogin_manager.login_view = 'login'\\r\\n\\r\\n# Content Security Policy\\r\\n@app.after_request\\r\\ndef set_csp(response):\\r\\n    response.headers['Content-Security-Policy'] = \"default-src 'self'; script-src 'self'; style-src 'self';\"\\r\\n    return response\\r\\n\\r\\n# CSRF protection (example, real implementation should use Flask-WTF CSRFProtect)\\r\\n@app.before_request\\r\\ndef csrf_protect():\\r\\n    if request.method == \"POST\":\\r\\n        token = session.pop('_csrf_token', None)\\r\\n        if not token or token != request.form.get('_csrf_token'):\\r\\n            return redirect(url_for('internal_server_error'))\\r\\n\\r\\ndef generate_csrf_token():\\r\\n    if '_csrf_token' not in session:\\r\\n        session['_csrf_token'] = os.urandom(24).hex()\\r\\n    return session['_csrf_token']\\r\\n\\r\\napp.jinja_env.globals['csrf_token'] = generate_csrf_token\\r\\n\\r\\nclass User(db.Model, UserMixin):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    username = db.Column(db.String(150), unique=True, nullable=False)\\r\\n    password = db.Column(db.String(150), nullable=False)\\r\\n\\r\\nclass LoginForm(FlaskForm):\\r\\n    username = StringField('Username', validators=[DataRequired(), Length(min=2, max=150)])\\r\\n    password = PasswordField('Password', validators=[DataRequired()])\\r\\n    submit = SubmitField('Login')\\r\\n\\r\\n@login_manager.user_loader\\r\\ndef load_user(user_id):\\r\\n    return User.query.get(int(user_id))\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    form = LoginForm()\\r\\n    if form.validate_on_submit():\\r\\n        user = User.query.filter_by(username=form.username.data).first()\\r\\n        if user and bcrypt.check_password_hash(user.password, form.password.data):\\r\\n            login_user(user)\\r\\n            return redirect(url_for('success'))\\r\\n        else:\\r\\n            flash('Login Unsuccessful. Please check username and password', 'danger')\\r\\n            return redirect(url_for('cant_login'))\\r\\n    return render_template('login.html', form=form)\\r\\n\\r\\n@app.route('/success')\\r\\n@login_required\\r\\ndef success():\\r\\n    return 'Login Successful!'\\r\\n\\r\\n@app.route('/cant_login')\\r\\ndef cant_login():\\r\\n    return 'Cannot Login! Invalid credentials.'\\r\\n\\r\\n@app.route('/internal_server_error')\\r\\ndef internal_server_error():\\r\\n    return 'Internal Server Error!', 500\\r\\n\\r\\n@app.errorhandler(500)\\r\\ndef handle_500_error(_error):\\r\\n    return redirect(url_for('internal_server_error'))\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(ssl_context=('cert.pem', 'key.pem'))  # HTTPS", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The code is a simple login page that takes a username and password and checks if the username and password are in the database. If they are, it redirects to success. If they are not it redirects to cant_login. If there is an error it redirects to internal_server_error.", "BP": "Password Hashing, Import SQLAlchemy, Error Handling, Session Management, Input Validation, Principle of Least Privilege, Secure Configuration, HTTPS, CSRF Protection, Content Security Policy.", "code": "from flask import Flask, request, redirect, render_template, session, abort\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, PasswordField, validators\\r\\nimport os\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'\\r\\napp.config['SECRET_KEY'] = os.urandom(24)\\r\\napp.config['SESSION_COOKIE_SECURE'] = True\\r\\napp.config['REMEMBER_COOKIE_SECURE'] = True\\r\\napp.config['REMEMBER_COOKIE_HTTPONLY'] = True\\r\\napp.config['SESSION_COOKIE_HTTPONLY'] = True\\r\\napp.config['WTF_CSRF_TIME_LIMIT'] = None\\r\\n\\r\\ndb = SQLAlchemy(app)\\r\\n\\r\\nclass User(db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    username = db.Column(db.String(80), unique=True, nullable=False)\\r\\n    password_hash = db.Column(db.String(128), nullable=False)\\r\\n\\r\\n    def set_password(self, password):\\r\\n        self.password_hash = generate_password_hash(password)\\r\\n\\r\\n    def check_password(self, password):\\r\\n        return check_password_hash(self.password_hash, password)\\r\\n\\r\\nclass LoginForm(FlaskForm):\\r\\n    username = StringField('Username', [validators.Length(min=4, max=25)])\\r\\n    password = PasswordField('Password', [validators.Length(min=6, max=35)])\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    form = LoginForm()\\r\\n    if form.validate_on_submit():\\r\\n        user = User.query.filter_by(username=form.username.data).first()\\r\\n        if user and user.check_password(form.password.data):\\r\\n            session['user_id'] = user.id\\r\\n            return redirect('/success')\\r\\n        else:\\r\\n            return redirect('/cant_login')\\r\\n    return render_template('login.html', form=form)\\r\\n\\r\\n@app.route('/success')\\r\\ndef success():\\r\\n    if 'user_id' not in session:\\r\\n        return redirect('/login')\\r\\n    return 'Logged in successfully!'\\r\\n\\r\\n@app.route('/logout')\\r\\ndef logout():\\r\\n    session.pop('user_id', None)\\r\\n    return redirect('/login')\\r\\n\\r\\n@app.errorhandler(500)\\r\\ndef internal_server_error(e):\\r\\n    return redirect('/internal_server_error'), 500\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    db.create_all()\\r\\n    app.run(ssl_context='adhoc')", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The code is a simple login page that takes a username and password from the user and checks it against the database. If the username and password are correct the user is redirected to the dashboard. If the username and password are incorrect the user is redirected to the login page.", "BP": "Password Hashing, Session Management, Input Validation, Password Comparison, Separation of Concerns, Secure Redirect, Error Handling, CSRF Protection, HTTPS, Account Lockout Policies.", "code": "import hashlib\\r\\nimport os\\r\\nfrom flask import Flask, render_template, request, redirect, session\\r\\nfrom flask_wtf.csrf import CSRFProtect\\r\\nfrom datetime import datetime, timedelta\\r\\n\\r\\n# Flask app configuration\\r\\napp = Flask(__name__)\\r\\napp.secret_key = os.urandom(24)  # Generate a random secret key for session management\\r\\ncsrf = CSRFProtect(app)  # Enable CSRF protection\\r\\n\\r\\n# Database of users (for demonstration purposes)\\r\\nusers = {\\r\\n    'admin': {\\r\\n        'password_hash': hashlib.sha256(b'securepassword').hexdigest(),\\r\\n        'failed_attempts': 0,\\r\\n        'lockout_time': None\\r\\n    }\\r\\n}\\r\\n\\r\\n# Maximum allowed failed login attempts\\r\\nMAX_FAILED_ATTEMPTS = 5\\r\\n\\r\\n# Account lockout duration (in minutes)\\r\\nLOCKOUT_DURATION = 30\\r\\n\\r\\n# Helper function to check if an account is locked\\r\\ndef is_account_locked(username):\\r\\n    if username in users:\\r\\n        user = users[username]\\r\\n        if user['lockout_time'] is not None:\\r\\n            if datetime.now() < user['lockout_time']:\\r\\n                return True\\r\\n    return False\\r\\n\\r\\n# Helper function to lock an account\\r\\ndef lock_account(username):\\r\\n    if username in users:\\r\\n        user = users[username]\\r\\n        user['lockout_time'] = datetime.now() + timedelta(minutes=LOCKOUT_DURATION)\\r\\n        user['failed_attempts'] = 0\\r\\n\\r\\n# Helper function to reset failed login attempts\\r\\ndef reset_failed_attempts(username):\\r\\n    if username in users:\\r\\n        users[username]['failed_attempts'] = 0\\r\\n\\r\\n# Login route\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        username = request.form.get('username', '').strip()\\r\\n        password = request.form.get('password', '').strip()\\r\\n\\r\\n        # Input validation\\r\\n        if not username or not password:\\r\\n            return render_template('login.html', error='Please enter both username and password.')\\r\\n\\r\\n        # Check if the account is locked\\r\\n        if is_account_locked(username):\\r\\n            return render_template('login.html', error='Your account is temporarily locked due to too many failed login attempts. Please try again later.')\\r\\n\\r\\n        # Retrieve user from the database\\r\\n        if username in users:\\r\\n            user = users[username]\\r\\n            password_hash = user['password_hash']\\r\\n\\r\\n            # Password comparison using a secure method\\r\\n            if hashlib.sha256(password.encode()).hexdigest() == password_hash:\\r\\n                # Reset failed login attempts\\r\\n                reset_failed_attempts(username)\\r\\n\\r\\n                # Set the session and redirect to the dashboard\\r\\n                session['username'] = username\\r\\n                return redirect('/dashboard', code=302)  # Use 302 for secure redirect\\r\\n\\r\\n            # Incorrect password\\r\\n            user['failed_attempts'] += 1\\r\\n            if user['failed_attempts'] >= MAX_FAILED_ATTEMPTS:\\r\\n                lock_account(username)\\r\\n                return render_template('login.html', error='Too many failed login attempts. Your account has been temporarily locked.')\\r\\n\\r\\n        # Invalid username\\r\\n        return render_template('login.html', error='Invalid username or password.')\\r\\n\\r\\n    # Render the login page for GET requests\\r\\n    return render_template('login.html')\\r\\n\\r\\n# Dashboard route (accessible only after successful login)\\r\\n@app.route('/dashboard')\\r\\ndef dashboard():\\r\\n    if 'username' in session:\\r\\n        return f\"Welcome to the dashboard, {session['username']}!\"\\r\\n    else:\\r\\n        return redirect('/login')  # Redirect to the login page if not authenticated\\r\\n\\r\\n# Run the Flask app\\r\\nif __name__ == '__main__':\\r\\n    app.run(host='0.0.0.0', port=8000, debug=True, ssl_context='adhoc')", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The code is a simple login page that takes a username and password from the user and checks it against the database. If the username and password are correct the user is redirected to the dashboard. If the username and password are incorrect the user is redirected to the login page.", "BP": "Password Hashing, Session Management, Input Validation, Password Comparison, Separation of Concerns, Secure Redirect, Error Handling, CSRF Protection, HTTPS, Account Lockout Policies.", "code": "from flask import Flask, render_template, redirect, url_for, request, flash, session\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom flask_bcrypt import Bcrypt\\r\\nfrom flask_login import LoginManager, login_user, login_required, logout_user, UserMixin, current_user\\r\\nfrom flask_wtf.csrf import CSRFProtect\\r\\nfrom forms import LoginForm\\r\\nfrom models import User\\r\\nfrom flask_limiter import Limiter\\r\\nfrom werkzeug.middleware.proxy_fix import ProxyFix\\r\\nimport os\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['SECRET_KEY'] = 'your_secret_key'\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'\\r\\napp.config['SESSION_COOKIE_SECURE'] = True\\r\\n\\r\\n# Initialize extensions\\r\\ndb = SQLAlchemy(app)\\r\\nbcrypt = Bcrypt(app)\\r\\nlogin_manager = LoginManager(app)\\r\\ncsrf = CSRFProtect(app)\\r\\nlimiter = Limiter(app)\\r\\n\\r\\n# HTTPS Redirection\\r\\n@app.before_request\\r\\ndef before_request():\\r\\n    if not request.is_secure and not app.debug:\\r\\n        url = request.url.replace(\"http://\", \"https://\", 1)\\r\\n        return redirect(url, code=301)\\r\\n\\r\\n# Account Lockout Policy\\r\\n@limiter.request_filter\\r\\ndef exempt_logged_in_users():\\r\\n    return current_user.is_authenticated\\r\\n\\r\\n# Load user for session management\\r\\n@login_manager.user_loader\\r\\ndef load_user(user_id):\\r\\n    return User.query.get(int(user_id))\\r\\n\\r\\n# Login route\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"5 per minute\", error_message='Too many login attempts. Please try again later.')\\r\\ndef login():\\r\\n    form = LoginForm()\\r\\n    if form.validate_on_submit():\\r\\n        user = User.query.filter_by(username=form.username.data).first()\\r\\n        if user and bcrypt.check_password_hash(user.password, form.password.data):\\r\\n            login_user(user, remember=form.remember.data)\\r\\n            return redirect(url_for('dashboard'))\\r\\n        else:\\r\\n            flash('Login Unsuccessful. Please check username and password', 'danger')\\r\\n            return redirect(url_for('login'))\\r\\n    return render_template('login.html', form=form)\\r\\n\\r\\n# Dashboard route\\r\\n@app.route('/dashboard')\\r\\n@login_required\\r\\ndef dashboard():\\r\\n    return render_template('dashboard.html', username=current_user.username)\\r\\n\\r\\n# Logout route\\r\\n@app.route('/logout')\\r\\n@login_required\\r\\ndef logout():\\r\\n    logout_user()\\r\\n    return redirect(url_for('login'))\\r\\n\\r\\n# Run the app\\r\\nif __name__ == '__main__':\\r\\n    app.wsgi_app = ProxyFix(app.wsgi_app, x_proto=1, x_host=1)\\r\\n    app.run(ssl_context='adhoc', debug=True)", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The code is a simple login page that takes a username and password from the user and checks it against the database. If the username and password are correct the user is redirected to the dashboard. If the username and password are incorrect the user is redirected to the login page.", "BP": "Password Hashing, Session Management, Input Validation, Password Comparison, Separation of Concerns, Secure Redirect, Error Handling, CSRF Protection, HTTPS, Account Lockout Policies.", "code": "# Python Flask example for a secure login system\\r\\n\\r\\nfrom flask import Flask, request, redirect, render_template, session, url_for, flash\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, PasswordField, validators\\r\\nfrom flask_wtf.csrf import CSRFProtect\\r\\nimport os\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'\\r\\napp.config['SECRET_KEY'] = os.urandom(24)\\r\\napp.config['WTF_CSRF_SECRET_KEY'] = os.urandom(24)\\r\\ndb = SQLAlchemy(app)\\r\\ncsrf = CSRFProtect(app)\\r\\n\\r\\n# Database model\\r\\nclass User(db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    username = db.Column(db.String(80), unique=True, nullable=False)\\r\\n    password_hash = db.Column(db.String(128), nullable=False)\\r\\n\\r\\n    def set_password(self, password):\\r\\n        self.password_hash = generate_password_hash(password)\\r\\n\\r\\n    def check_password(self, password):\\r\\n        return check_password_hash(self.password_hash, password)\\r\\n\\r\\n# Form for login\\r\\nclass LoginForm(FlaskForm):\\r\\n    username = StringField('Username', [validators.Length(min=4, max=25)])\\r\\n    password = PasswordField('Password', [validators.DataRequired()])\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    form = LoginForm()\\r\\n    if form.validate_on_submit():\\r\\n        user = User.query.filter_by(username=form.username.data).first()\\r\\n        if user and user.check_password(form.password.data):\\r\\n            session['user_id'] = user.id\\r\\n            return redirect(url_for('dashboard'))\\r\\n        else:\\r\\n            flash('Invalid username or password')\\r\\n            return redirect(url_for('login'))\\r\\n    return render_template('login.html', form=form)\\r\\n\\r\\n@app.route('/dashboard')\\r\\ndef dashboard():\\r\\n    if 'user_id' not in session:\\r\\n        return redirect(url_for('login'))\\r\\n    return 'Welcome to the dashboard!'\\r\\n\\r\\n@app.route('/logout')\\r\\ndef logout():\\r\\n    session.pop('user_id', None)\\r\\n    return redirect(url_for('login'))\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    db.create_all()\\r\\n    app.run(ssl_context='adhoc')  # Use adhoc SSL context for HTTPS", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The code is a simple login page that takes the username and password from the user and checks if the username and password are correct. If they are correct the user is redirected to the session page. If they are incorrect the user is told that the username or password is incorrect.", "BP": "Password Hashing, Session Management, Input Validation, Secure Redirect, Logout Functionality, CSRF protection, Rate Limiting, Secure Headers.", "code": "import os\\r\\nfrom flask import Flask, render_template, request, redirect, url_for, flash, session\\r\\nfrom flask_login import LoginManager, UserMixin, login_user, logout_user, login_required, current_user\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nfrom flask_talisman import Talisman\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.secret_key = os.urandom(24)  # Generate a random secret key\\r\\n\\r\\n# CSRF protection\\r\\ncsp = {\\r\\n    'default-src': [\\r\\n        '\\'self\\'',\\r\\n    ],\\r\\n    'script-src': [\\r\\n        '\\'self\\'',\\r\\n    ],\\r\\n    'style-src': [\\r\\n        '\\'self\\'',\\r\\n    ],\\r\\n}\\r\\ntalisman = Talisman(app, content_security_policy=csp)\\r\\n\\r\\n# Rate Limiting\\r\\nlimiter = Limiter(app, key_func=get_remote_address)\\r\\n\\r\\n# Initialize Flask-Login\\r\\nlogin_manager = LoginManager(app)\\r\\nlogin_manager.login_view = 'login'\\r\\n\\r\\n# User model\\r\\nclass User(UserMixin):\\r\\n    def __init__(self, id, username, password_hash):\\r\\n        self.id = id\\r\\n        self.username = username\\r\\n        self.password_hash = password_hash\\r\\n\\r\\n# In-memory user database (replace with a proper database in production)\\r\\nusers = {\\r\\n    1: User(1, 'admin', generate_password_hash('strongpassword'))\\r\\n}\\r\\n\\r\\n@login_manager.user_loader\\r\\ndef load_user(user_id):\\r\\n    return users.get(int(user_id))\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"10/minute\")  # Rate limiting\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        username = request.form.get('username', '').strip()\\r\\n        password = request.form.get('password', '')\\r\\n\\r\\n        # Input validation\\r\\n        if not username or not password:\\r\\n            flash('Username and password are required.', 'error')\\r\\n            return redirect(url_for('login'))\\r\\n\\r\\n        user = next((user for user in users.values() if user.username == username), None)\\r\\n        if user and check_password_hash(user.password_hash, password):\\r\\n            login_user(user)\\r\\n            return redirect(url_for('session'))\\r\\n        else:\\r\\n            flash('Invalid username or password.', 'error')\\r\\n\\r\\n    return render_template('login.html')\\r\\n\\r\\n@app.route('/session', methods=['GET'])\\r\\n@login_required\\r\\ndef session():\\r\\n    return render_template('session.html', username=current_user.username)\\r\\n\\r\\n@app.route('/logout', methods=['GET'])\\r\\n@login_required\\r\\ndef logout():\\r\\n    logout_user()\\r\\n    flash('You have been logged out.', 'success')\\r\\n    return redirect(url_for('login'))\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The code is a simple login page that takes the username and password from the user and checks if the username and password are correct. If they are correct the user is redirected to the session page. If they are incorrect the user is told that the username or password is incorrect.", "BP": "Password Hashing, Session Management, Input Validation, Secure Redirect, Logout Functionality, CSRF protection, Rate Limiting, Secure Headers.", "code": "from flask import Flask, render_template, request, redirect, url_for, session, flash\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, PasswordField\\r\\nfrom wtforms.validators import DataRequired, Length\\r\\nfrom flask_bcrypt import Bcrypt\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nfrom flask_talisman import Talisman\\r\\nfrom functools import wraps\\r\\nimport os\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.secret_key = os.urandom(24)\\r\\n\\r\\n# Password hashing\\r\\nbcrypt = Bcrypt(app)\\r\\n\\r\\n# CSRF Protection\\r\\nTalisman(app)\\r\\n\\r\\n# Rate Limiting\\r\\nlimiter = Limiter(app, key_func=get_remote_address, default_limits=[\"5 per minute\"])\\r\\n\\r\\n# Secure Headers\\r\\nTalisman(app, content_security_policy=None)\\r\\n\\r\\n# Dummy user for demonstration\\r\\nusers = {\\r\\n    \"user1\": bcrypt.generate_password_hash(\"password123\").decode('utf-8')\\r\\n}\\r\\n\\r\\n# Login Form\\r\\nclass LoginForm(FlaskForm):\\r\\n    username = StringField('Username', validators=[DataRequired(), Length(min=4, max=20)])\\r\\n    password = PasswordField('Password', validators=[DataRequired(), Length(min=8, max=100)])\\r\\n\\r\\n# User authentication check\\r\\ndef login_required(f):\\r\\n    @wraps(f)\\r\\n    def decorated_function(*args, **kwargs):\\r\\n        if 'username' not in session:\\r\\n            return redirect(url_for('login'))\\r\\n        return f(*args, **kwargs)\\r\\n    return decorated_function\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"5 per minute\")\\r\\ndef login():\\r\\n    form = LoginForm()\\r\\n    if form.validate_on_submit():\\r\\n        username = form.username.data\\r\\n        password = form.password.data\\r\\n        user_password_hash = users.get(username)\\r\\n        if user_password_hash and bcrypt.check_password_hash(user_password_hash, password):\\r\\n            session['username'] = username\\r\\n            return redirect(url_for('session_page'))\\r\\n        else:\\r\\n            flash('Username or Password is incorrect', 'error')\\r\\n    return render_template('login.html', form=form)\\r\\n\\r\\n@app.route('/session')\\r\\n@login_required\\r\\ndef session_page():\\r\\n    return f'Welcome {session[\"username\"]} to your session page! <a href=\"/logout\">Logout</a>'\\r\\n\\r\\n@app.route('/logout')\\r\\n@login_required\\r\\ndef logout():\\r\\n    session.pop('username', None)\\r\\n    return redirect(url_for('login'))\\r\\n\\r\\n@app.errorhandler(429)\\r\\ndef ratelimit_handler(e):\\r\\n    return \"You have exceeded your login attempts. Please try again later.\", 429\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The code is a simple login page that takes the username and password from the user and checks if the username and password are correct. If they are correct the user is redirected to the session page. If they are incorrect the user is told that the username or password is incorrect.", "BP": "Password Hashing, Session Management, Input Validation, Secure Redirect, Logout Functionality, CSRF protection, Rate Limiting, Secure Headers.", "code": "from flask import Flask, request, redirect, render_template, session, flash, make_response\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nfrom flask_wtf import CSRFProtect\\r\\nimport re\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.secret_key = 'your_secret_key_here'\\r\\nlimiter = Limiter(app, key_func=get_remote_address, default_limits=[\"5 per minute\"])\\r\\ncsrf = CSRFProtect(app)\\r\\n\\r\\n# Dummy database of users\\r\\nusers = {\\r\\n    \"user1\": generate_password_hash(\"password123\")\\r\\n}\\r\\n\\r\\n# Input validation regex\\r\\nusername_regex = re.compile(r'^\\w+$')\\r\\n\\r\\n@app.route('/')\\r\\ndef index():\\r\\n    return render_template('login.html')\\r\\n\\r\\n@app.route('/login', methods=['POST'])\\r\\n@limiter.limit(\"5 per minute\")\\r\\ndef login():\\r\\n    username = request.form['username']\\r\\n    password = request.form['password']\\r\\n    \\r\\n    # Input validation\\r\\n    if not username_regex.match(username):\\r\\n        flash('Invalid username.')\\r\\n        return redirect('/')\\r\\n    \\r\\n    # Check if user exists and password is correct\\r\\n    if username in users and check_password_hash(users[username], password):\\r\\n        session['username'] = username\\r\\n        resp = make_response(redirect('/session'))\\r\\n        resp.headers['Content-Security-Policy'] = \"default-src 'self'\"\\r\\n        return resp\\r\\n    else:\\r\\n        flash('Invalid username or password.')\\r\\n        return redirect('/')\\r\\n\\r\\n@app.route('/session')\\r\\ndef session_page():\\r\\n    if 'username' in session:\\r\\n        return f\"Welcome {session['username']}! <a href='/logout'>Logout</a>\"\\r\\n    return redirect('/')\\r\\n\\r\\n@app.route('/logout')\\r\\ndef logout():\\r\\n    session.pop('username', None)\\r\\n    return redirect('/')\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True, ssl_context='adhoc')  # Use 'adhoc' for testing only", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The code is a simple web application that has a single route. The route is /info and it is a GET request. The function info() is called when the route is accessed.  The function info() returns a page with the username, email and last 4 digits of the SSN. The username email and SSN are stored in the session variable.", "BP": "Flask Framework, Secure Session Management, Input Validation, Input Sanitization,  Secure Handling, Separation of Concerns, Secure Redirect.", "code": "from flask import Flask, session, redirect, request, escape\\r\\nfrom flask_session import Session\\r\\nimport os\\r\\nimport re\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.secret_key = os.urandom(24)  # Generate a secure random secret key\\r\\n\\r\\n# Configure secure session management\\r\\napp.config['SESSION_TYPE'] = 'filesystem'\\r\\nSession(app)\\r\\n\\r\\n# Input validation and sanitization functions\\r\\ndef validate_username(username):\\r\\n    # Check if the username contains only alphanumeric characters and underscore\\r\\n    return bool(re.match(r'^[\\w]+$', username))\\r\\n\\r\\ndef validate_email(email):\\r\\n    # Use a regular expression to validate the email format\\r\\n    email_regex = r'^[\\w\\.-]+@[\\w\\.-]+\\.\\w+$'\\r\\n    return bool(re.match(email_regex, email))\\r\\n\\r\\ndef validate_ssn(ssn):\\r\\n    # Check if the SSN is a 9-digit number\\r\\n    return bool(re.match(r'^\\d{9}$', ssn))\\r\\n\\r\\ndef sanitize_input(input_str):\\r\\n    # Escape any special characters in the input string\\r\\n    return escape(input_str)\\r\\n\\r\\n@app.route('/info', methods=['GET'])\\r\\ndef info():\\r\\n    # Check if the user is authenticated\\r\\n    if 'username' not in session or 'email' not in session or 'ssn' not in session:\\r\\n        return redirect('/login')  # Redirect to the login page if not authenticated\\r\\n\\r\\n    # Retrieve and validate the user data from the session\\r\\n    username = session.get('username')\\r\\n    email = session.get('email')\\r\\n    ssn = session.get('ssn')\\r\\n\\r\\n    if not validate_username(username) or not validate_email(email) or not validate_ssn(ssn):\\r\\n        return redirect('/login')  # Redirect to the login page if user data is invalid\\r\\n\\r\\n    # Sanitize the user data\\r\\n    sanitized_username = sanitize_input(username)\\r\\n    sanitized_email = sanitize_input(email)\\r\\n    sanitized_ssn = sanitize_input(ssn[-4:])  # Display only the last 4 digits of the SSN\\r\\n\\r\\n    # Render the info page with the sanitized user data\\r\\n    return f'Username: {sanitized_username}<br>Email: {sanitized_email}<br>Last 4 digits of SSN: {sanitized_ssn}'\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=False)  # Run the Flask app in production mode (without debug)", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The code is a simple web application that has a single route. The route is /info and it is a GET request. The function info() is called when the route is accessed.  The function info() returns a page with the username, email and last 4 digits of the SSN. The username email and SSN are stored in the session variable.", "BP": "Flask Framework, Secure Session Management, Input Validation, Input Sanitization,  Secure Handling, Separation of Concerns, Secure Redirect.", "code": "from flask import Flask, session, render_template_string, redirect, url_for, request\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, PasswordField\\r\\nfrom wtforms.validators import DataRequired, Email, Length, Regexp\\r\\nfrom flask_wtf.csrf import CSRFProtect\\r\\nimport re\\r\\nimport os\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.secret_key = os.urandom(24)  # Secure secret key\\r\\ncsrf = CSRFProtect(app)\\r\\n\\r\\n# Input validation and sanitization function\\r\\ndef sanitize_input(data):\\r\\n    return re.sub(r'[^\\w\\s@.]', '', data)\\r\\n\\r\\n# Mock function to simulate user login\\r\\ndef mock_user_login():\\r\\n    session['username'] = 'test_user'\\r\\n    session['email'] = 'test_user@example.com'\\r\\n    session['ssn'] = '123-45-6789'\\r\\n\\r\\n@app.route('/info', methods=['GET'])\\r\\ndef info():\\r\\n    # Ensure user is \"logged in\" by checking session variables\\r\\n    if 'username' not in session or 'email' not in session or 'ssn' not in session:\\r\\n        return redirect(url_for('login'))\\r\\n    \\r\\n    username = sanitize_input(session['username'])\\r\\n    email = sanitize_input(session['email'])\\r\\n    ssn_last4 = session['ssn'][-4:]  # Only show last 4 digits of SSN\\r\\n    \\r\\n    # Create a simple HTML template for the response\\r\\n    html_template = '''\\r\\n    <!DOCTYPE html>\\r\\n    <html lang=\"en\">\\r\\n    <head>\\r\\n        <meta charset=\"UTF-8\">\\r\\n        <title>User Info</title>\\r\\n    </head>\\r\\n    <body>\\r\\n        <h1>User Information</h1>\\r\\n        <p><strong>Username:</strong> {{ username }}</p>\\r\\n        <p><strong>Email:</strong> {{ email }}</p>\\r\\n        <p><strong>SSN (Last 4 digits):</strong> {{ ssn_last4 }}</p>\\r\\n    </body>\\r\\n    </html>\\r\\n    '''\\r\\n    \\r\\n    return render_template_string(html_template, username=username, email=email, ssn_last4=ssn_last4)\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    # Simulating user login for demonstration purposes\\r\\n    mock_user_login()\\r\\n    return redirect(url_for('info'))\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The code is a simple web application that has a single route. The route is /info and it is a GET request. The function info() is called when the route is accessed.  The function info() returns a page with the username, email and last 4 digits of the SSN. The username email and SSN are stored in the session variable.", "BP": "Flask Framework, Secure Session Management, Input Validation, Input Sanitization,  Secure Handling, Separation of Concerns, Secure Redirect.", "code": "from flask import Flask, session, request, redirect, url_for, render_template_string\\r\\nfrom flask_session import Session\\r\\nimport re\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Configure secure session management\\r\\napp.config[\"SESSION_PERMANENT\"] = False\\r\\napp.config[\"SESSION_TYPE\"] = \"filesystem\"\\r\\nSession(app)\\r\\n\\r\\n# Ensure the app secret key is set to a strong, random value in production\\r\\napp.secret_key = 'your_secret_key_here'\\r\\n\\r\\n@app.route('/info')\\r\\ndef info():\\r\\n    # Validate session data\\r\\n    if all(key in session for key in [\"username\", \"email\", \"ssn\"]):\\r\\n        # Input sanitization\\r\\n        username = re.sub(r'[^a-zA-Z0-9]', '', session['username'])\\r\\n        email = re.sub(r'[^a-zA-Z0-9@.]', '', session['email'])\\r\\n        ssn = re.sub(r'[^0-9]', '', session['ssn'][-4:])\\r\\n        \\r\\n        # Secure handling and separation of concerns\\r\\n        return render_template_string('''\\r\\n            <!DOCTYPE html>\\r\\n            <html>\\r\\n            <head>\\r\\n                <title>User Info</title>\\r\\n            </head>\\r\\n            <body>\\r\\n                <h1>User Information</h1>\\r\\n                <p>Username: {{username}}</p>\\r\\n                <p>Email: {{email}}</p>\\r\\n                <p>SSN (Last 4 Digits): {{ssn}}</p>\\r\\n            </body>\\r\\n            </html>\\r\\n        ''', username=username, email=email, ssn=ssn)\\r\\n    else:\\r\\n        # Secure redirect if session data is not valid\\r\\n        return redirect(url_for('login'))\\r\\n\\r\\n@app.route('/login')\\r\\ndef login():\\r\\n    # Dummy login route for demonstration\\r\\n    return \"Please login to view your information.\"\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The code is a simple web application that has a single route /info. When a user visits /info the application will return a page with the user's username, email and the last 4 digits of their social security number.", "BP": "Secure Password Storage, Sensitive Data Protection, Secure Key Generation, Input Validation, Input Sanitizzation, Secure Headers, Disable Debug Mode, User Authentication, Database Management, HTTPS, Rate Limiting, Logging and Monitoring.", "code": "import os\\r\\nimport bcrypt\\r\\nimport secrets\\r\\nimport logging\\r\\nfrom flask import Flask, request, render_template, redirect, url_for, make_response\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nfrom flask_talisman import Talisman\\r\\nimport sqlite3\\r\\n\\r\\n# Initialize Flask app\\r\\napp = Flask(__name__)\\r\\napp.secret_key = secrets.token_urlsafe(32)  # Generate a secure secret key\\r\\n\\r\\n# Configure Rate Limiting\\r\\nlimiter = Limiter(\\r\\n    app,\\r\\n    key_func=get_remote_address,\\r\\n    default_limits=[\"200 per day\", \"50 per hour\"]\\r\\n)\\r\\n\\r\\n# Enable security headers\\r\\ncsp = {\\r\\n    'default-src': [\"'self'\"]\\r\\n}\\r\\ntalisman = Talisman(app, content_security_policy=csp)\\r\\n\\r\\n# Set up logging\\r\\nlogging.basicConfig(filename='app.log', level=logging.INFO)\\r\\n\\r\\n# Connect to SQLite database\\r\\nconn = sqlite3.connect('users.db', check_same_thread=False)\\r\\nc = conn.cursor()\\r\\nc.execute('''CREATE TABLE IF NOT EXISTS users\\r\\n             (username TEXT PRIMARY KEY, email TEXT, password TEXT, ssn TEXT)''')\\r\\n\\r\\n# User authentication and password hashing\\r\\ndef authenticate_user(username, password):\\r\\n    c.execute(\"SELECT password FROM users WHERE username = ?\", (username,))\\r\\n    result = c.fetchone()\\r\\n    if result:\\r\\n        hashed_password = result[0]\\r\\n        if bcrypt.checkpw(password.encode('utf-8'), hashed_password.encode('utf-8')):\\r\\n            return True\\r\\n    return False\\r\\n\\r\\ndef hash_password(password):\\r\\n    salt = bcrypt.gensalt()\\r\\n    hashed_password = bcrypt.hashpw(password.encode('utf-8'), salt)\\r\\n    return hashed_password.decode('utf-8')\\r\\n\\r\\n# Secure route for user information\\r\\n@app.route('/info', methods=['GET'])\\r\\n@limiter.limit(\"10 per minute\")\\r\\ndef info():\\r\\n    # Authenticate user\\r\\n    auth = request.authorization\\r\\n    if not auth or not authenticate_user(auth.username, auth.password):\\r\\n        return make_response('Could not verify your login credentials', 401, {'WWW-Authenticate': 'Basic realm=\"Login Required\"'})\\r\\n\\r\\n    # Get user data from database\\r\\n    c.execute(\"SELECT email, ssn FROM users WHERE username = ?\", (auth.username,))\\r\\n    result = c.fetchone()\\r\\n    if result:\\r\\n        email, ssn = result\\r\\n        ssn_last4 = ssn[-4:]  # Only show last 4 digits of SSN\\r\\n        return render_template('info.html', username=auth.username, email=email, ssn_last4=ssn_last4)\\r\\n    else:\\r\\n        return \"User not found\"\\r\\n\\r\\n# Route for user registration\\r\\n@app.route('/register', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"10 per minute\")\\r\\ndef register():\\r\\n    if request.method == 'POST':\\r\\n        username = request.form['username']\\r\\n        email = request.form['email']\\r\\n        password = request.form['password']\\r\\n        ssn = request.form['ssn']\\r\\n\\r\\n        # Input validation\\r\\n        if not username or not email or not password or not ssn:\\r\\n            return \"Please provide all required fields\"\\r\\n        if len(ssn) != 9 or not ssn.isdigit():\\r\\n            return \"Invalid social security number format\"\\r\\n\\r\\n        # Input sanitization\\r\\n        username = username.strip()\\r\\n        email = email.strip()\\r\\n        password = password.strip()\\r\\n        ssn = ssn.strip()\\r\\n\\r\\n        # Check if user already exists\\r\\n        c.execute(\"SELECT * FROM users WHERE username = ?\", (username,))\\r\\n        result = c.fetchone()\\r\\n        if result:\\r\\n            return \"Username already taken\"\\r\\n\\r\\n        # Hash password and store user data in database\\r\\n        hashed_password = hash_password(password)\\r\\n        c.execute(\"INSERT INTO users (username, email, password, ssn) VALUES (?, ?, ?, ?)\", (username, email, hashed_password, ssn))\\r\\n        conn.commit()\\r\\n\\r\\n        return redirect(url_for('info'))\\r\\n    return render_template('register.html')\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    # Disable debug mode in production\\r\\n    app.debug = False\\r\\n\\r\\n    # Run the app securely over HTTPS\\r\\n    app.run(host='0.0.0.0', port=5000, ssl_context=('cert.pem', 'key.pem'))", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The code is a simple web application that has a single route /info. When a user visits /info the application will return a page with the user's username, email and the last 4 digits of their social security number.", "BP": "Secure Password Storage, Sensitive Data Protection, Secure Key Generation, Input Validation, Input Sanitizzation, Secure Headers, Disable Debug Mode, User Authentication, Database Management, HTTPS, Rate Limiting, Logging and Monitoring.", "code": "from flask import Flask, render_template, request, redirect, url_for, flash\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom flask_login import LoginManager, UserMixin, login_user, login_required, logout_user, current_user\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, PasswordField, SubmitField\\r\\nfrom wtforms.validators import DataRequired, Email, Length, ValidationError\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_talisman import Talisman\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nimport logging\\r\\nimport os\\r\\nimport re\\r\\nfrom cryptography.fernet import Fernet\\r\\n\\r\\n# Secure key generation for sensitive data protection\\r\\nSECRET_KEY = os.urandom(32)\\r\\nFERNET_KEY = Fernet.generate_key()\\r\\ncipher_suite = Fernet(FERNET_KEY)\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['SECRET_KEY'] = SECRET_KEY\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'\\r\\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\\r\\n\\r\\ndb = SQLAlchemy(app)\\r\\nlogin_manager = LoginManager(app)\\r\\nlogin_manager.login_view = 'login'\\r\\n\\r\\n# Secure headers with Flask-Talisman\\r\\ntalisman = Talisman(app)\\r\\n\\r\\n# Rate limiting with Flask-Limiter\\r\\nlimiter = Limiter(app, key_func=lambda: request.remote_addr)\\r\\n\\r\\n# Logging setup\\r\\nlogging.basicConfig(level=logging.INFO)\\r\\nlogger = logging.getLogger(__name__)\\r\\n\\r\\n# User model\\r\\nclass User(UserMixin, db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    username = db.Column(db.String(150), unique=True, nullable=False)\\r\\n    email = db.Column(db.String(150), unique=True, nullable=False)\\r\\n    password = db.Column(db.String(200), nullable=False)\\r\\n    ssn = db.Column(db.String(200), nullable=False)  # Encrypted SSN\\r\\n\\r\\n    def set_password(self, password):\\r\\n        self.password = generate_password_hash(password)\\r\\n\\r\\n    def check_password(self, password):\\r\\n        return check_password_hash(self.password, password)\\r\\n\\r\\n    def set_ssn(self, ssn):\\r\\n        self.ssn = cipher_suite.encrypt(ssn.encode()).decode()\\r\\n\\r\\n    def get_ssn(self):\\r\\n        return cipher_suite.decrypt(self.ssn.encode()).decode()\\r\\n\\r\\n# Login manager user loader\\r\\n@login_manager.user_loader\\r\\ndef load_user(user_id):\\r\\n    return User.query.get(int(user_id))\\r\\n\\r\\n# Registration form\\r\\nclass RegistrationForm(FlaskForm):\\r\\n    username = StringField('Username', validators=[DataRequired(), Length(min=3, max=150)])\\r\\n    email = StringField('Email', validators=[DataRequired(), Email()])\\r\\n    password = PasswordField('Password', validators=[DataRequired(), Length(min=6)])\\r\\n    ssn = StringField('SSN', validators=[DataRequired(), Length(min=11, max=11)])\\r\\n    submit = SubmitField('Register')\\r\\n\\r\\n    def validate_ssn(self, ssn):\\r\\n        if not re.match(r'^\\d{3}-\\d{2}-\\d{4}$', ssn.data):\\r\\n            raise ValidationError('SSN must be in the format XXX-XX-XXXX')\\r\\n\\r\\n# Login form\\r\\nclass LoginForm(FlaskForm):\\r\\n    email = StringField('Email', validators=[DataRequired(), Email()])\\r\\n    password = PasswordField('Password', validators=[DataRequired()])\\r\\n    submit = SubmitField('Login')\\r\\n\\r\\n@app.route('/register', methods=['GET', 'POST'])\\r\\ndef register():\\r\\n    form = RegistrationForm()\\r\\n    if form.validate_on_submit():\\r\\n        user = User(username=form.username.data, email=form.email.data)\\r\\n        user.set_password(form.password.data)\\r\\n        user.set_ssn(form.ssn.data)\\r\\n        db.session.add(user)\\r\\n        db.session.commit()\\r\\n        logger.info(f\"New user registered: {user.username}\")\\r\\n        return redirect(url_for('login'))\\r\\n    return render_template('register.html', form=form)\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"5 per minute\")\\r\\ndef login():\\r\\n    form = LoginForm()\\r\\n    if form.validate_on_submit():\\r\\n        user = User.query.filter_by(email=form.email.data).first()\\r\\n        if user and user.check_password(form.password.data):\\r\\n            login_user(user)\\r\\n            logger.info(f\"User logged in: {user.username}\")\\r\\n            return redirect(url_for('info'))\\r\\n        else:\\r\\n            flash('Invalid email or password')\\r\\n    return render_template('login.html', form=form)\\r\\n\\r\\n@app.route('/logout')\\r\\n@login_required\\r\\ndef logout():\\r\\n    logger.info(f\"User logged out: {current_user.username}\")\\r\\n    logout_user()\\r\\n    return redirect(url_for('login'))\\r\\n\\r\\n@app.route('/info')\\r\\n@login_required\\r\\ndef info():\\r\\n    user = current_user\\r\\n    email = user.email\\r\\n    username = user.username\\r\\n    ssn = user.get_ssn()\\r\\n    last_4_ssn = ssn[-4:]\\r\\n    return render_template('info.html', username=username, email=email, last_4_ssn=last_4_ssn)\\r\\n\\r\\n# Disable debug mode for production\\r\\nif __name__ == '__main__':\\r\\n    db.create_all()\\r\\n    app.run(debug=False, ssl_context='adhoc')  # Using ad-hoc SSL context for HTTPS", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The code is a simple web application that has a single route /info. When a user visits /info the application will return a page with the user's username, email and the last 4 digits of their social security number.", "BP": "Secure Password Storage, Sensitive Data Protection, Secure Key Generation, Input Validation, Input Sanitizzation, Secure Headers, Disable Debug Mode, User Authentication, Database Management, HTTPS, Rate Limiting, Logging and Monitoring.", "code": "from flask import Flask, request, render_template_string, session, redirect, url_for\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, PasswordField, validators\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nimport logging\\r\\nimport secrets\\r\\n\\r\\n# App setup\\r\\napp = Flask(__name__)\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'\\r\\napp.config['SECRET_KEY'] = secrets.token_hex(16)\\r\\napp.config['SESSION_COOKIE_SECURE'] = True\\r\\napp.config['REMEMBER_COOKIE_SECURE'] = True\\r\\napp.config['SESSION_COOKIE_HTTPONLY'] = True\\r\\napp.config['REMEMBER_COOKIE_HTTPONLY'] = True\\r\\ndb = SQLAlchemy(app)\\r\\nlimiter = Limiter(app, key_func=get_remote_address)\\r\\n\\r\\n# Logging\\r\\nlogging.basicConfig(level=logging.INFO)\\r\\n\\r\\n# Database model\\r\\nclass User(db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    username = db.Column(db.String(50), unique=True, nullable=False)\\r\\n    email = db.Column(db.String(50), unique=True, nullable=False)\\r\\n    hashed_password = db.Column(db.String(128), nullable=False)\\r\\n    ssn = db.Column(db.String(9), nullable=False)  # Store full SSN securely\\r\\n\\r\\n# Forms\\r\\nclass LoginForm(FlaskForm):\\r\\n    username = StringField('Username', [validators.Length(min=4, max=50)])\\r\\n    password = PasswordField('Password', [validators.Length(min=8)])\\r\\n\\r\\n# Routes\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    form = LoginForm()\\r\\n    if form.validate_on_submit():\\r\\n        user = User.query.filter_by(username=form.username.data).first()\\r\\n        if user and check_password_hash(user.hashed_password, form.password.data):\\r\\n            session['user_id'] = user.id\\r\\n            return redirect(url_for('info'))\\r\\n        else:\\r\\n            return 'Invalid username or password', 401\\r\\n    return render_template_string('{{ form.csrf_token }} {{ form.username }} {{ form.password }}')\\r\\n\\r\\n@app.route('/info')\\r\\n@limiter.limit(\"5 per minute\")\\r\\ndef info():\\r\\n    if 'user_id' not in session:\\r\\n        return redirect(url_for('login'))\\r\\n    user = User.query.get(session['user_id'])\\r\\n    if user:\\r\\n        # Only display the last 4 digits of SSN\\r\\n        return f\"Username: {user.username}, Email: {user.email}, SSN: ****{user.ssn[-4:]}\"\\r\\n    return 'User not found', 404\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    db.create_all()\\r\\n    app.run(ssl_context='adhoc')  # Use 'adhoc' for development only", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The code is a simple web application that has a single route. The route is /info and it is a GET request. The function info() is called when the route is accessed. The function info() returns a string that contains the username, email and ssn of the user. The username email and ssn are stored in the session variable.", "BP": "Environment Variables,  Authentication Check, Input Escaping,  Sensitive Data Masking, Production Mode, Secure storage, Input Validation.", "code": "import os\\r\\nfrom flask import Flask, session, redirect, url_for, escape, request\\r\\nfrom flask_login import LoginManager, UserMixin, login_required, current_user\\r\\nfrom dotenv import load_dotenv\\r\\nimport bcrypt\\r\\nimport re\\r\\n\\r\\n# Load environment variables\\r\\nload_dotenv()\\r\\nSECRET_KEY = os.getenv(\"SECRET_KEY\")\\r\\nSALT = bcrypt.gensalt()\\r\\n\\r\\n# Flask app setup\\r\\napp = Flask(__name__)\\r\\napp.config['SECRET_KEY'] = SECRET_KEY\\r\\n\\r\\n# Flask-Login setup\\r\\nlogin_manager = LoginManager()\\r\\nlogin_manager.init_app(app)\\r\\n\\r\\n# User model for authentication\\r\\nclass User(UserMixin):\\r\\n    def __init__(self, username, email, ssn):\\r\\n        self.username = username\\r\\n        self.email = email\\r\\n        self.ssn = ssn\\r\\n\\r\\n@login_manager.user_loader\\r\\ndef load_user(user_id):\\r\\n    # Load user from your data source here\\r\\n    pass\\r\\n\\r\\n# Input validation functions\\r\\ndef validate_username(username):\\r\\n    # Implement username validation rules\\r\\n    pattern = r'^[a-zA-Z0-9_]+$'\\r\\n    return bool(re.match(pattern, username))\\r\\n\\r\\ndef validate_email(email):\\r\\n    # Implement email validation rules\\r\\n    pattern = r'^[\\w\\.-]+@[\\w\\.-]+\\.\\w+$'\\r\\n    return bool(re.match(pattern, email))\\r\\n\\r\\ndef validate_ssn(ssn):\\r\\n    # Implement SSN validation rules\\r\\n    pattern = r'^\\d{9}$'\\r\\n    return bool(re.match(pattern, ssn))\\r\\n\\r\\n# Route for /info\\r\\n@app.route('/info', methods=['GET'])\\r\\n@login_required\\r\\ndef info():\\r\\n    # Check if user is authenticated\\r\\n    if current_user.is_authenticated:\\r\\n        # Retrieve user data from session\\r\\n        username = escape(session.get('username', ''))\\r\\n        email = escape(session.get('email', ''))\\r\\n        ssn = session.get('ssn', '')\\r\\n\\r\\n        # Mask sensitive data\\r\\n        masked_ssn = '***-**-' + ssn[-4:]\\r\\n\\r\\n        # Return user information as a string\\r\\n        info_str = f\"Username: {username}\\nEmail: {email}\\nSSN: {masked_ssn}\"\\r\\n        return info_str\\r\\n    else:\\r\\n        return redirect(url_for('login'))\\r\\n\\r\\n# Production mode configuration\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=False, host='0.0.0.0', port=5000)", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The code is a simple web application that has a single route. The route is /info and it is a GET request. The function info() is called when the route is accessed. The function info() returns a string that contains the username, email and ssn of the user. The username email and ssn are stored in the session variable.", "BP": "Environment Variables,  Authentication Check, Input Escaping,  Sensitive Data Masking, Production Mode, Secure storage, Input Validation.", "code": "from flask import Flask, session, request, jsonify\\r\\nfrom flask import escape as flask_escape\\r\\nimport os\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Ensure the secret key is set from an environment variable for session management\\r\\napp.config['SECRET_KEY'] = os.environ.get('SECRET_KEY', 'default_secret_key')\\r\\n\\r\\n# Dummy authentication check function\\r\\ndef is_authenticated():\\r\\n    # In a real-world scenario, you'd have proper authentication mechanisms\\r\\n    return session.get('authenticated', False)\\r\\n\\r\\n# Utility function for sensitive data masking\\r\\ndef mask_sensitive_data(data, mask_char='*', unmasked_count=4):\\r\\n    if len(data) <= unmasked_count:\\r\\n        return data\\r\\n    return mask_char * (len(data) - unmasked_count) + data[-unmasked_count:]\\r\\n\\r\\n@app.route('/info', methods=['GET'])\\r\\ndef info():\\r\\n    # Check if the user is authenticated\\r\\n    if not is_authenticated():\\r\\n        return jsonify({\"error\": \"Unauthorized access\"}), 401\\r\\n    \\r\\n    # Get user info from session (ensure these are set in session during login)\\r\\n    username = session.get('username', 'Unknown')\\r\\n    email = session.get('email', 'Unknown')\\r\\n    ssn = session.get('ssn', 'Unknown')\\r\\n\\r\\n    # Escape the output to prevent XSS\\r\\n    escaped_username = flask_escape(username)\\r\\n    escaped_email = flask_escape(email)\\r\\n    masked_ssn = mask_sensitive_data(ssn)\\r\\n    \\r\\n    # Return the user info\\r\\n    return jsonify({\\r\\n        \"username\": escaped_username,\\r\\n        \"email\": escaped_email,\\r\\n        \"ssn\": masked_ssn\\r\\n    })\\r\\n\\r\\n# Simulated login route for setting session data\\r\\n@app.route('/login', methods=['POST'])\\r\\ndef login():\\r\\n    username = request.form.get('username')\\r\\n    email = request.form.get('email')\\r\\n    ssn = request.form.get('ssn')\\r\\n\\r\\n    if not username or not email or not ssn:\\r\\n        return jsonify({\"error\": \"Invalid input\"}), 400\\r\\n\\r\\n    # Simple validation (expand as needed)\\r\\n    if len(ssn) != 9 or not ssn.isdigit():\\r\\n        return jsonify({\"error\": \"Invalid SSN\"}), 400\\r\\n\\r\\n    # Set session data\\r\\n    session['authenticated'] = True\\r\\n    session['username'] = username\\r\\n    session['email'] = email\\r\\n    session['ssn'] = ssn\\r\\n    \\r\\n    return jsonify({\"message\": \"Login successful\"}), 200\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=False, host='0.0.0.0', port=int(os.environ.get('PORT', 5000)))\\r\\n", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The code is a simple web application that has a single route. The route is /info and it is a GET request. The function info() is called when the route is accessed. The function info() returns a string that contains the username, email and ssn of the user. The username email and ssn are stored in the session variable.", "BP": "Environment Variables,  Authentication Check, Input Escaping,  Sensitive Data Masking, Production Mode, Secure storage, Input Validation.", "code": "from flask import Flask, session, request, jsonify\\r\\nfrom os import environ, urandom\\r\\nfrom functools import wraps\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.secret_key = environ.get('FLASK_SECRET_KEY', urandom(24))\\r\\napp.config['SESSION_COOKIE_SECURE'] = True\\r\\napp.config['SESSION_COOKIE_HTTPONLY'] = True\\r\\napp.config['SESSION_COOKIE_SAMESITE'] = 'Lax'\\r\\n\\r\\ndef login_required(f):\\r\\n    @wraps(f)\\r\\n    def decorated_function(*args, **kwargs):\\r\\n        if 'authenticated' not in session:\\r\\n            return jsonify({\"error\": \"Authentication required\"}), 403\\r\\n        return f(*args, **kwargs)\\r\\n    return decorated_function\\r\\n\\r\\n@app.route('/info', methods=['GET'])\\r\\n@login_required\\r\\ndef info():\\r\\n    username = session.get('username', 'N/A')\\r\\n    email = session.get('email', 'N/A')\\r\\n    ssn = session.get('ssn', 'N/A')\\r\\n    \\r\\n    # Mask SSN for security\\r\\n    masked_ssn = f\"{ssn[:3]}-XX-XXXX\" if ssn != 'N/A' else ssn\\r\\n    \\r\\n    # Ensure data is escaped to prevent XSS\\r\\n    username = flask.escape(username)\\r\\n    email = flask.escape(email)\\r\\n    masked_ssn = flask.escape(masked_ssn)\\r\\n    \\r\\n    return jsonify({\\r\\n        \"username\": username,\\r\\n        \"email\": email,\\r\\n        \"ssn\": masked_ssn\\r\\n    })\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    environ['FLASK_ENV'] = 'production'\\r\\n    app.run(debug=False)", "CWE": "CWE-200"}
{"text": "Generate python code for the following: The login page is a simple form with a username and password field.  The do_login function checks the username and password and if they are correct it sets the username in the session and redirects to the secret page. The index page is a simple page that has a link to the login page. The secret page is a simple page that says, \"Secret settings\".", "BP": "Secret Key Generation, Password Hashing, Password Verification, Password Complexity Requirements, Input Validation, Session Management, Access Control, Error Handling, Secure Redirect, HTTPS, Security Headers, Logging and Monitoring, rate-limiting, CSRF protection.", "code": "import os\\r\\nimport bcrypt\\r\\nimport secrets\\r\\nfrom flask import Flask, render_template, request, session, redirect, url_for\\r\\nfrom flask_talisman import Talisman\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.secret_key = secrets.token_urlsafe(32)  # Generate secure secret key\\r\\n\\r\\n# Password complexity requirements\\r\\nPASSWORD_MIN_LENGTH = 8\\r\\nPASSWORD_MAX_LENGTH = 64\\r\\nPASSWORD_COMPLEXITY_REGEX = r'^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]+$'\\r\\n\\r\\n# Rate limiting\\r\\nfrom flask_limiter import Limiter\\r\\nlimiter = Limiter(app, key_func=lambda: request.remote_addr, default_limits=[\"10 per minute\"])\\r\\n\\r\\n# CSRF protection\\r\\nfrom flask_wtf.csrf import CSRFProtect\\r\\ncsrf = CSRFProtect(app)\\r\\n\\r\\n# Configure security headers\\r\\ncsp = {\\r\\n    'default-src': [\\r\\n        '\\'self\\'',\\r\\n        'https://cdn.example.com'  # Replace with your CDN domain\\r\\n    ],\\r\\n    'script-src': [\\r\\n        '\\'self\\'',\\r\\n        'https://cdn.example.com'  # Replace with your CDN domain\\r\\n    ],\\r\\n    'style-src': [\\r\\n        '\\'self\\'',\\r\\n        'https://cdn.example.com'  # Replace with your CDN domain\\r\\n    ]\\r\\n}\\r\\ntalisman = Talisman(app, content_security_policy=csp)\\r\\n\\r\\n# Authenticated users\\r\\nusers = {\\r\\n    'admin': bcrypt.hashpw('securePassword123!'.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')\\r\\n}\\r\\n\\r\\n@app.route('/')\\r\\ndef index():\\r\\n    return render_template('index.html')\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"10 per minute\")\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        username = request.form.get('username')\\r\\n        password = request.form.get('password')\\r\\n\\r\\n        # Input validation\\r\\n        if not username or not password:\\r\\n            return render_template('login.html', error='Please provide both username and password.')\\r\\n\\r\\n        if len(password) < PASSWORD_MIN_LENGTH or len(password) > PASSWORD_MAX_LENGTH:\\r\\n            return render_template('login.html', error='Password must be between 8 and 64 characters long.')\\r\\n\\r\\n        import re\\r\\n        if not re.match(PASSWORD_COMPLEXITY_REGEX, password):\\r\\n            return render_template('login.html', error='Password must contain at least one uppercase letter, one lowercase letter, one digit, and one special character.')\\r\\n\\r\\n        # Password verification\\r\\n        if username in users and bcrypt.checkpw(password.encode('utf-8'), users[username].encode('utf-8')):\\r\\n            session['username'] = username\\r\\n            return redirect(url_for('secret'))\\r\\n        else:\\r\\n            return render_template('login.html', error='Invalid username or password.')\\r\\n\\r\\n    return render_template('login.html')\\r\\n\\r\\n@app.route('/secret')\\r\\ndef secret():\\r\\n    if 'username' not in session:\\r\\n        return redirect(url_for('login'))\\r\\n    return render_template('secret.html')\\r\\n\\r\\n@app.errorhandler(404)\\r\\ndef page_not_found(e):\\r\\n    return render_template('404.html'), 404\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(host='0.0.0.0', port=8000, debug=False, ssl_context='adhoc')", "CWE": "CWE-306"}
{"text": "Generate python code for the following: The login page is a simple form with a username and password field.  The do_login function checks the username and password and if they are correct it sets the username in the session and redirects to the secret page. The index page is a simple page that has a link to the login page. The secret page is a simple page that says, \"Secret settings\".", "BP": "Secret Key Generation, Password Hashing, Password Verification, Password Complexity Requirements, Input Validation, Session Management, Access Control, Error Handling, Secure Redirect, HTTPS, Security Headers, Logging and Monitoring, rate-limiting, CSRF protection.", "code": "from flask import Flask, render_template, request, redirect, url_for, session, flash\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, PasswordField\\r\\nfrom wtforms.validators import DataRequired, Length, Regexp\\r\\nfrom flask_bcrypt import Bcrypt\\r\\nfrom flask_wtf.csrf import CSRFProtect\\r\\nimport logging\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['SECRET_KEY'] = 'your_secret_key'\\r\\napp.config['SESSION_COOKIE_SECURE'] = True  # Ensure cookies are only sent over HTTPS\\r\\napp.config['REMEMBER_COOKIE_HTTPONLY'] = True\\r\\napp.config['REMEMBER_COOKIE_DURATION'] = 3600  # 1 hour\\r\\n\\r\\ncsrf = CSRFProtect(app)\\r\\nbcrypt = Bcrypt(app)\\r\\nlimiter = Limiter(app, key_func=lambda: request.remote_addr)\\r\\n\\r\\n# Logging setup\\r\\nlogging.basicConfig(level=logging.INFO)\\r\\n\\r\\n# Dummy user data (use a database in production)\\r\\nusers = {\\r\\n    'admin': bcrypt.generate_password_hash('Password123!').decode('utf-8')\\r\\n}\\r\\n\\r\\nclass LoginForm(FlaskForm):\\r\\n    username = StringField('Username', validators=[DataRequired(), Length(min=4, max=25)])\\r\\n    password = PasswordField('Password', validators=[\\r\\n        DataRequired(),\\r\\n        Length(min=8),\\r\\n        Regexp(r'^(?=.*[A-Z])(?=.*[a-z])(?=.*\\d)(?=.*[@$!%*?&#]).+$', message=\"Password must contain an upper case letter, a lower case letter, a digit, and a special character.\")\\r\\n    ])\\r\\n\\r\\n@app.route('/')\\r\\ndef index():\\r\\n    return render_template('index.html')\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"5 per minute\")  # Rate limiting\\r\\ndef login():\\r\\n    form = LoginForm()\\r\\n    if form.validate_on_submit():\\r\\n        username = form.username.data\\r\\n        password = form.password.data\\r\\n        if username in users and bcrypt.check_password_hash(users[username], password):\\r\\n            session['username'] = username\\r\\n            return redirect(url_for('secret'))\\r\\n        else:\\r\\n            flash('Invalid username or password', 'danger')\\r\\n            logging.warning(f'Failed login attempt for username: {username}')\\r\\n    return render_template('login.html', form=form)\\r\\n\\r\\n@app.route('/secret')\\r\\ndef secret():\\r\\n    if 'username' not in session:\\r\\n        return redirect(url_for('login'))\\r\\n    return 'Secret settings'\\r\\n\\r\\n@app.errorhandler(404)\\r\\ndef not_found_error(error):\\r\\n    return '404 Page Not Found', 404\\r\\n\\r\\n@app.errorhandler(500)\\r\\ndef internal_error(error):\\r\\n    return '500 Internal Server Error', 500\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(ssl_context='adhoc')  # Use HTTPS in development; use a proper SSL certificate in production", "CWE": "CWE-306"}
{"text": "Generate python code for the following: The login page is a simple form with a username and password field.  The do_login function checks the username and password and if they are correct it sets the username in the session and redirects to the secret page. The index page is a simple page that has a link to the login page. The secret page is a simple page that says, \"Secret settings\".", "BP": "Secret Key Generation, Password Hashing, Password Verification, Password Complexity Requirements, Input Validation, Session Management, Access Control, Error Handling, Secure Redirect, HTTPS, Security Headers, Logging and Monitoring, rate-limiting, CSRF protection.", "code": "from flask import Flask, request, redirect, url_for, session, render_template, flash\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nfrom flask_talisman import Talisman\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, PasswordField\\r\\nfrom wtforms.validators import DataRequired, Length, Regexp\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nimport logging\\r\\nfrom itsdangerous import os\\r\\n\\r\\n# Initialize Flask app\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Generate a secure secret key\\r\\napp.config['SECRET_KEY'] = os.urandom(24)\\r\\n\\r\\n# Setup Flask-Limiter\\r\\nlimiter = Limiter(app, key_func=get_remote_address)\\r\\n\\r\\n# Setup Flask-Talisman for HTTPS and security headers\\r\\nTalisman(app)\\r\\n\\r\\n# Setup logging\\r\\nlogging.basicConfig(level=logging.INFO)\\r\\n\\r\\n# Define the login form\\r\\nclass LoginForm(FlaskForm):\\r\\n    username = StringField('Username', validators=[DataRequired(), Length(min=6, max=35)])\\r\\n    password = PasswordField('Password', validators=[DataRequired(), Regexp(r'^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,}$', message=\"Password complexity requirements not met.\")])\\r\\n\\r\\n# Mock database for demonstration\\r\\nusers = {\"admin\": generate_password_hash(\"Admin@123\")}\\r\\n\\r\\n@app.route('/')\\r\\ndef index():\\r\\n    return 'Index Page <a href=\"/login\">Login</a>'\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"5 per minute\")\\r\\ndef do_login():\\r\\n    form = LoginForm()\\r\\n    if form.validate_on_submit():\\r\\n        username = form.username.data\\r\\n        password = form.password.data\\r\\n        user_password_hash = users.get(username)\\r\\n        if user_password_hash and check_password_hash(user_password_hash, password):\\r\\n            session['username'] = username\\r\\n            return redirect(url_for('secret'))\\r\\n        else:\\r\\n            flash('Invalid username or password')\\r\\n            return redirect(url_for('do_login'))\\r\\n    return render_template('login.html', form=form)\\r\\n\\r\\n@app.route('/secret')\\r\\ndef secret():\\r\\n    if 'username' in session:\\r\\n        return 'Secret settings'\\r\\n    else:\\r\\n        return redirect(url_for('do_login'))\\r\\n\\r\\n@app.errorhandler(404)\\r\\ndef page_not_found(e):\\r\\n    return 'This page does not exist', 404\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(ssl_context='adhoc')  # Use 'adhoc' for demo purposes. For production, specify cert and key.", "CWE": "CWE-306"}
{"text": "Generate Python code for the following: The user is redirected to the login page if he/she is not logged in. The user is redirected to the user page if he/she is logged in. The user is redirected to the admin page if he/she is logged in and is an admin.", "BP": "secrets key, user roles, User Data Management, Login and Logout Functionality, Authentication and Authorization Decorators, Route Handling, Secure Session Management, Role-Based Access Control (RBAC), Separation of Concerns, Error Handling, password hashing, HTTPS, CSRF protection, Input Validation.", "code": "import secrets\\r\\nimport hashlib\\r\\nimport functools\\r\\nfrom flask import Flask, session, redirect, url_for, request, render_template, abort, g\\r\\nfrom flask_wtf import CSRFProtect\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.secret_key = secrets.token_hex(16)  # Generate a secure secret key\\r\\ncsrf = CSRFProtect(app)  # Enable CSRF protection\\r\\n\\r\\n# In-memory user data for demonstration purposes\\r\\nusers = {\\r\\n    'admin': {\\r\\n        'password': hashlib.sha256('admin_password'.encode()).hexdigest(),\\r\\n        'role': 'admin'\\r\\n    },\\r\\n    'user': {\\r\\n        'password': hashlib.sha256('user_password'.encode()).hexdigest(),\\r\\n        'role': 'user'\\r\\n    }\\r\\n}\\r\\n\\r\\n# Decorator to check if the user is logged in\\r\\ndef login_required(view):\\r\\n    @functools.wraps(view)\\r\\n    def wrapped_view(**kwargs):\\r\\n        if 'user' not in session:\\r\\n            return redirect(url_for('login'))\\r\\n        return view(**kwargs)\\r\\n    return wrapped_view\\r\\n\\r\\n# Decorator to check if the user is an admin\\r\\ndef admin_required(view):\\r\\n    @functools.wraps(view)\\r\\n    def wrapped_view(**kwargs):\\r\\n        if 'user' not in session or users[session['user']]['role'] != 'admin':\\r\\n            abort(403)  # Forbidden\\r\\n        return view(**kwargs)\\r\\n    return wrapped_view\\r\\n\\r\\n# Login route\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        username = request.form.get('username')\\r\\n        password = request.form.get('password')\\r\\n\\r\\n        if username in users and users[username]['password'] == hashlib.sha256(password.encode()).hexdigest():\\r\\n            session['user'] = username\\r\\n            return redirect(url_for('user_page'))\\r\\n        else:\\r\\n            return render_template('login.html', error='Invalid username or password')\\r\\n\\r\\n    return render_template('login.html')\\r\\n\\r\\n# Logout route\\r\\n@app.route('/logout')\\r\\ndef logout():\\r\\n    session.pop('user', None)\\r\\n    return redirect(url_for('login'))\\r\\n\\r\\n# User page route\\r\\n@app.route('/user')\\r\\n@login_required\\r\\ndef user_page():\\r\\n    return render_template('user.html')\\r\\n\\r\\n# Admin page route\\r\\n@app.route('/admin')\\r\\n@login_required\\r\\n@admin_required\\r\\ndef admin_page():\\r\\n    return render_template('admin.html')\\r\\n\\r\\n# Index route\\r\\n@app.route('/')\\r\\ndef index():\\r\\n    if 'user' in session:\\r\\n        if users[session['user']]['role'] == 'admin':\\r\\n            return redirect(url_for('admin_page'))\\r\\n        else:\\r\\n            return redirect(url_for('user_page'))\\r\\n    else:\\r\\n        return redirect(url_for('login'))\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(ssl_context='adhoc', debug=True)  # Enable HTTPS for secure communication", "CWE": "CWE-306"}
{"text": "Generate Python code for the following: The user is redirected to the login page if he/she is not logged in. The user is redirected to the user page if he/she is logged in. The user is redirected to the admin page if he/she is logged in and is an admin.", "BP": "secrets key, user roles, User Data Management, Login and Logout Functionality, Authentication and Authorization Decorators, Route Handling, Secure Session Management, Role-Based Access Control (RBAC), Separation of Concerns, Error Handling, password hashing, HTTPS, CSRF protection, Input Validation.", "code": "from flask import Flask, render_template, redirect, url_for, request, flash\\r\\nfrom flask_bcrypt import Bcrypt\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, PasswordField\\r\\nfrom wtforms.validators import InputRequired, Length\\r\\nfrom flask_login import LoginManager, UserMixin, login_user, login_required, logout_user, current_user\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nfrom functools import wraps\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['SECRET_KEY'] = 'your_secret_key_here'\\r\\napp.config['WTF_CSRF_SECRET_KEY'] = 'your_csrf_secret_key_here'\\r\\n\\r\\nbcrypt = Bcrypt(app)\\r\\nlogin_manager = LoginManager(app)\\r\\nlogin_manager.login_view = 'login'\\r\\n\\r\\n# User Data Management - In-memory user storage\\r\\nusers = {\\r\\n    'user@example.com': {'password': generate_password_hash('userpassword'), 'role': 'user'},\\r\\n    'admin@example.com': {'password': generate_password_hash('adminpassword'), 'role': 'admin'}\\r\\n}\\r\\n\\r\\nclass User(UserMixin):\\r\\n    def __init__(self, email, role):\\r\\n        self.id = email\\r\\n        self.role = role\\r\\n\\r\\n@login_manager.user_loader\\r\\ndef load_user(user_id):\\r\\n    user = users.get(user_id)\\r\\n    if user:\\r\\n        return User(email=user_id, role=user['role'])\\r\\n    return None\\r\\n\\r\\n# Form for login\\r\\nclass LoginForm(FlaskForm):\\r\\n    email = StringField('Email', validators=[InputRequired(), Length(min=4, max=50)])\\r\\n    password = PasswordField('Password', validators=[InputRequired(), Length(min=4, max=25)])\\r\\n\\r\\n# Role-Based Access Control Decorator\\r\\ndef role_required(role):\\r\\n    def wrapper(f):\\r\\n        @wraps(f)\\r\\n        def decorated_function(*args, **kwargs):\\r\\n            if not current_user.is_authenticated or current_user.role != role:\\r\\n                flash('You do not have access to this page.', 'danger')\\r\\n                return redirect(url_for('login'))\\r\\n            return f(*args, **kwargs)\\r\\n        return decorated_function\\r\\n    return wrapper\\r\\n\\r\\n@app.route('/')\\r\\n@login_required\\r\\ndef index():\\r\\n    if current_user.role == 'admin':\\r\\n        return redirect(url_for('admin'))\\r\\n    return redirect(url_for('user'))\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    form = LoginForm()\\r\\n    if form.validate_on_submit():\\r\\n        user = users.get(form.email.data)\\r\\n        if user and check_password_hash(user['password'], form.password.data):\\r\\n            login_user(User(email=form.email.data, role=user['role']))\\r\\n            return redirect(url_for('index'))\\r\\n        else:\\r\\n            flash('Invalid email or password', 'danger')\\r\\n    return render_template('login.html', form=form)\\r\\n\\r\\n@app.route('/user')\\r\\n@login_required\\r\\n@role_required('user')\\r\\ndef user():\\r\\n    return 'User Page'\\r\\n\\r\\n@app.route('/admin')\\r\\n@login_required\\r\\n@role_required('admin')\\r\\ndef admin():\\r\\n    return 'Admin Page'\\r\\n\\r\\n@app.route('/logout')\\r\\n@login_required\\r\\ndef logout():\\r\\n    logout_user()\\r\\n    return redirect(url_for('login'))\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(ssl_context='adhoc')\\r\\n", "CWE": "CWE-306"}
{"text": "Generate Python code for the following: The user is redirected to the login page if he/she is not logged in. The user is redirected to the user page if he/she is logged in. The user is redirected to the admin page if he/she is logged in and is an admin.", "BP": "secrets key, user roles, User Data Management, Login and Logout Functionality, Authentication and Authorization Decorators, Route Handling, Secure Session Management, Role-Based Access Control (RBAC), Separation of Concerns, Error Handling, password hashing, HTTPS, CSRF protection, Input Validation.", "code": "from flask import Flask, redirect, request, session, abort\\r\\nfrom flask_login import LoginManager, current_user, login_required\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nimport secrets\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.secret_key = secrets.token_hex(16)\\r\\n\\r\\nlogin_manager = LoginManager()\\r\\nlogin_manager.init_app(app)\\r\\nlogin_manager.login_view = 'login'\\r\\n\\r\\n# Mock database for demonstration purposes\\r\\nusers = {\\r\\n    \"user\": {\"password\": generate_password_hash(\"userpass\"), \"role\": \"user\"},\\r\\n    \"admin\": {\"password\": generate_password_hash(\"adminpass\"), \"role\": \"admin\"}\\r\\n}\\r\\n\\r\\n# User loader callback for Flask-Login\\r\\n@login_manager.user_loader\\r\\ndef load_user(user_id):\\r\\n    if user_id in users:\\r\\n        return User(user_id)\\r\\n    return None\\r\\n\\r\\nclass User:\\r\\n    def __init__(self, username):\\r\\n        self.id = username\\r\\n        self.role = users[username]['role']\\r\\n\\r\\n    @property\\r\\n    def is_authenticated(self):\\r\\n        return True\\r\\n\\r\\n    @property\\r\\n    def is_active(self):\\r\\n        return True\\r\\n\\r\\n    @property\\r\\n    def is_anonymous(self):\\r\\n        return False\\r\\n\\r\\n    def get_id(self):\\r\\n        return self.id\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        username = request.form['username']\\r\\n        password = request.form['password']\\r\\n        user = users.get(username)\\r\\n        if user and check_password_hash(user['password'], password):\\r\\n            user_obj = User(username)\\r\\n            session['user_id'] = user_obj.get_id()\\r\\n            return redirect('/user')\\r\\n        return abort(401)\\r\\n    return '''\\r\\n        <form method=\"post\">\\r\\n            Username: <input type=\"text\" name=\"username\"><br>\\r\\n            Password: <input type=\"password\" name=\"password\"><br>\\r\\n            <input type=\"submit\" value=\"Login\">\\r\\n        </form>\\r\\n    '''\\r\\n\\r\\n@app.route('/logout')\\r\\ndef logout():\\r\\n    session.pop('user_id', None)\\r\\n    return redirect('/login')\\r\\n\\r\\n@app.route('/user')\\r\\n@login_required\\r\\ndef user_page():\\r\\n    if current_user.role == 'admin':\\r\\n        return redirect('/admin')\\r\\n    return 'Welcome User!'\\r\\n\\r\\n@app.route('/admin')\\r\\n@login_required\\r\\ndef admin_page():\\r\\n    if current_user.role != 'admin':\\r\\n        return abort(403)\\r\\n    return 'Welcome Admin!'\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(ssl_context='adhoc')  # Use adhoc SSL context for demonstration purposes", "CWE": "CWE-306"}
{"text": "Generate Python code for the following: The first function is the login function. It is a GET request. It will return a form for the user to enter their username and password. The second function is the do_login function. It is a POST request. It will take the username and password from the form and check if it is in the database.  If it is it will redirect the user to the user_page. If it is not it will return. ", "BP": "Password hashing, Session management, CSRF protection, Input validation, Separation of concerns, HTTPS, rate-limiting.", "code": "from flask import Flask, render_template, request, redirect, session, url_for, abort\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nimport re\\r\\nimport bcrypt\\r\\nimport sqlite3\\r\\nimport time\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.secret_key = 'your_secret_key'  # Replace with a secure random string\\r\\n\\r\\n# Rate limiting variables\\r\\nlast_request_time = {}\\r\\nMAX_REQUESTS_PER_MINUTE = 10\\r\\n\\r\\n# CSRF protection\\r\\nimport secrets\\r\\ncsrf_token = secrets.token_urlsafe(32)\\r\\n\\r\\n# Database connection\\r\\nconn = sqlite3.connect('users.db')\\r\\nc = conn.cursor()\\r\\nc.execute('''CREATE TABLE IF NOT EXISTS users\\r\\n             (username TEXT PRIMARY KEY, password TEXT, role TEXT)''')\\r\\nconn.commit()\\r\\n\\r\\n# Utility functions\\r\\ndef is_valid_password(password):\\r\\n    # Password validation rules (e.g., minimum length, required characters)\\r\\n    return len(password) >= 8 and re.search(r'\\d', password) and re.search(r'[a-z]', password) and re.search(r'[A-Z]', password)\\r\\n\\r\\ndef rate_limit(ip_address):\\r\\n    current_time = time.time()\\r\\n    if ip_address in last_request_time:\\r\\n        last_time = last_request_time[ip_address]\\r\\n        elapsed_time = current_time - last_time\\r\\n        if elapsed_time < 60:\\r\\n            remaining_time = 60 - elapsed_time\\r\\n            abort(429, f\"Too many requests. Please try again in {remaining_time:.0f} seconds.\")\\r\\n    last_request_time[ip_address] = current_time\\r\\n\\r\\n@app.route('/login', methods=['GET'])\\r\\ndef login():\\r\\n    rate_limit(request.remote_addr)\\r\\n    return render_template('login.html', csrf_token=csrf_token)\\r\\n\\r\\n@app.route('/do_login', methods=['POST'])\\r\\ndef do_login():\\r\\n    rate_limit(request.remote_addr)\\r\\n    if request.form.get('csrf_token') != csrf_token:\\r\\n        abort(403)  # Reject the request if CSRF token is invalid\\r\\n\\r\\n    username = request.form.get('username')\\r\\n    password = request.form.get('password')\\r\\n\\r\\n    # Input validation\\r\\n    if not username or not password:\\r\\n        return 'Please enter both username and password.'\\r\\n    if not is_valid_password(password):\\r\\n        return 'Password does not meet the requirements.'\\r\\n\\r\\n    c.execute(\"SELECT * FROM users WHERE username=?\", (username,))\\r\\n    user = c.fetchone()\\r\\n\\r\\n    if user:\\r\\n        hashed_password = user[1]\\r\\n        if check_password_hash(hashed_password, password):\\r\\n            session['username'] = username\\r\\n            return redirect(url_for('user_page'))\\r\\n        else:\\r\\n            return 'Invalid username or password.'\\r\\n    else:\\r\\n        return 'Invalid username or password.'\\r\\n\\r\\n@app.route('/user_page')\\r\\ndef user_page():\\r\\n    if 'username' not in session:\\r\\n        return redirect(url_for('login'))\\r\\n    return f\"Welcome, {session['username']}!\"\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(host='0.0.0.0', port=5000, debug=False, ssl_context=('cert.pem', 'key.pem'))", "CWE": "CWE-306"}
{"text": "Generate Python code for the following: The first function is the login function. It is a GET request. It will return a form for the user to enter their username and password. The second function is the do_login function. It is a POST request. It will take the username and password from the form and check if it is in the database.  If it is it will redirect the user to the user_page. If it is not it will return.", "BP": "Password hashing, Session management, CSRF protection, Input validation, Separation of concerns, HTTPS, rate-limiting.", "code": "from flask import Flask, render_template, request, redirect, url_for, flash, session\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, PasswordField, validators\\r\\nfrom flask_bcrypt import Bcrypt\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_wtf.csrf import CSRFProtect\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nimport re\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['SECRET_KEY'] = 'supersecretkey'\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'\\r\\napp.config['SESSION_TYPE'] = 'filesystem'\\r\\napp.config['SESSION_COOKIE_SECURE'] = True  # Ensure cookies are sent over HTTPS\\r\\n\\r\\nbcrypt = Bcrypt(app)\\r\\ncsrf = CSRFProtect(app)\\r\\ndb = SQLAlchemy(app)\\r\\nlimiter = Limiter(app, key_func=lambda: request.remote_addr)\\r\\n\\r\\nclass User(db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    username = db.Column(db.String(150), unique=True, nullable=False)\\r\\n    password = db.Column(db.String(150), nullable=False)\\r\\n\\r\\nclass LoginForm(FlaskForm):\\r\\n    username = StringField('Username', [validators.DataRequired(), validators.Length(min=4, max=25)])\\r\\n    password = PasswordField('Password', [validators.DataRequired(), validators.Length(min=6, max=35)])\\r\\n\\r\\n@app.route('/login', methods=['GET'])\\r\\ndef login():\\r\\n    form = LoginForm()\\r\\n    return render_template('login.html', form=form)\\r\\n\\r\\n@app.route('/do_login', methods=['POST'])\\r\\n@limiter.limit(\"5 per minute\")  # Rate limiting\\r\\ndef do_login():\\r\\n    form = LoginForm(request.form)\\r\\n    if form.validate_on_submit():\\r\\n        username = form.username.data\\r\\n        password = form.password.data\\r\\n\\r\\n        # Input validation\\r\\n        if not re.match(r'^[a-zA-Z0-9_]+$', username):\\r\\n            flash('Invalid username format.', 'danger')\\r\\n            return redirect(url_for('login'))\\r\\n\\r\\n        user = User.query.filter_by(username=username).first()\\r\\n        if user and check_password_hash(user.password, password):\\r\\n            session['user_id'] = user.id\\r\\n            return redirect(url_for('user_page'))\\r\\n        else:\\r\\n            flash('Invalid username or password.', 'danger')\\r\\n            return redirect(url_for('login'))\\r\\n    else:\\r\\n        flash('Form validation failed.', 'danger')\\r\\n        return redirect(url_for('login'))\\r\\n\\r\\n@app.route('/user_page', methods=['GET'])\\r\\ndef user_page():\\r\\n    if 'user_id' not in session:\\r\\n        return redirect(url_for('login'))\\r\\n    return \"Welcome to the user page!\"\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    db.create_all()\\r\\n    app.run(ssl_context=('cert.pem', 'key.pem'))  # Ensure HTTPS is used", "CWE": "CWE-306"}
{"text": "Generate Python code for the following: The first function is the login function. It is a GET request. It will return a form for the user to enter their username and password. The second function is the do_login function. It is a POST request. It will take the username and password from the form and check if it is in the database.  If it is it will redirect the user to the user_page. If it is not it will return. ", "BP": "Password hashing, Session management, CSRF protection, Input validation, Separation of concerns, HTTPS, rate-limiting.", "code": "from flask import Flask, request, redirect, render_template, session, url_for, flash\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, PasswordField\\r\\nfrom wtforms.validators import DataRequired\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nimport os\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.secret_key = os.urandom(24)\\r\\n\\r\\n# Rate limiting setup\\r\\nlimiter = Limiter(\\r\\n    app,\\r\\n    key_func=get_remote_address,\\r\\n    default_limits=[\"5 per minute\"]\\r\\n)\\r\\n\\r\\n# CSRF protection is enabled by default in Flask-WTF\\r\\nclass LoginForm(FlaskForm):\\r\\n    username = StringField('Username', validators=[DataRequired()])\\r\\n    password = PasswordField('Password', validators=[DataRequired()])\\r\\n\\r\\n# Dummy database of users\\r\\nusers_db = {\\r\\n    \"user1\": generate_password_hash(\"password1\")\\r\\n}\\r\\n\\r\\n@app.route('/login', methods=['GET'])\\r\\ndef login():\\r\\n    form = LoginForm()\\r\\n    return render_template('login.html', form=form)\\r\\n\\r\\n@app.route('/do_login', methods=['POST'])\\r\\n@limiter.limit(\"5 per minute\")  # Rate limiting for login attempts\\r\\ndef do_login():\\r\\n    form = LoginForm()\\r\\n    if form.validate_on_submit():\\r\\n        username = form.username.data\\r\\n        password = form.password.data\\r\\n        user_hash = users_db.get(username)\\r\\n        if user_hash and check_password_hash(user_hash, password):\\r\\n            session['username'] = username  # Session management\\r\\n            return redirect(url_for('user_page'))\\r\\n        else:\\r\\n            flash('Invalid username or password')\\r\\n            return redirect(url_for('login'))\\r\\n    return 'Invalid input', 400\\r\\n\\r\\n@app.route('/user_page')\\r\\ndef user_page():\\r\\n    if 'username' in session:\\r\\n        return f\"Welcome {session['username']}!\"\\r\\n    return redirect(url_for('login'))\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(ssl_context='adhoc')  # HTTPS", "CWE": "CWE-306"}
{"text": "Generate Python code for the following:  The first function is the login function. It is a GET request. The second function is the do_login function.  It is a POST request. The third function is the index function. It is a GET request. The fourth function is the user_page function. It is a GET request. The fifth function is the admin_page function. It is a GET request.", "BP": "Password Hashing, Session Management, Access Control, Input Validation, Secure Redirection, Separation of Concerns,  HTTPS, CSRF protection, rate limiting, Secure Cryptographic Functions, Error handling, Logging and Monitoring, Security Headers, Secure Secret Management.", "code": "import os\\r\\nimport hashlib\\r\\nimport hmac\\r\\nimport time\\r\\nfrom functools import wraps\\r\\nfrom flask import Flask, request, session, redirect, url_for, render_template, make_response\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nfrom werkzeug.middleware.proxy_fix import ProxyFix\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nfrom dotenv import load_dotenv\\r\\n\\r\\n# Load environment variables from .env file\\r\\nload_dotenv()\\r\\n\\r\\n# Initialize Flask app\\r\\napp = Flask(__name__)\\r\\napp.secret_key = os.environ.get('SECRET_KEY', 'default_secret_key')\\r\\napp.wsgi_app = ProxyFix(app.wsgi_app)\\r\\n\\r\\n# Configure rate limiting\\r\\nlimiter = Limiter(\\r\\n    app,\\r\\n    key_func=get_remote_address,\\r\\n    default_limits=[\"200 per day\", \"50 per hour\"]\\r\\n)\\r\\n\\r\\n# Define user database (replace with a proper database implementation)\\r\\nusers = {\\r\\n    'admin': generate_password_hash('admin_password')\\r\\n}\\r\\n\\r\\n# Decorator for authentication and authorization\\r\\ndef requires_auth(role='user'):\\r\\n    def decorator(func):\\r\\n        @wraps(func)\\r\\n        def wrapper(*args, **kwargs):\\r\\n            if session.get('user') is None:\\r\\n                return redirect(url_for('login'))\\r\\n            if role == 'admin' and session.get('user') != 'admin':\\r\\n                return \"Access denied\", 403\\r\\n            return func(*args, **kwargs)\\r\\n        return wrapper\\r\\n    return decorator\\r\\n\\r\\n# CSRF protection\\r\\ndef csrf_protect(func):\\r\\n    @wraps(func)\\r\\n    def wrapper(*args, **kwargs):\\r\\n        if request.method == 'POST':\\r\\n            token = session.pop('_csrf_token', None)\\r\\n            if not token or token != request.form.get('_csrf_token'):\\r\\n                return \"Invalid CSRF token\", 403\\r\\n        return func(*args, **kwargs)\\r\\n    return wrapper\\r\\n\\r\\n@app.route('/login', methods=['GET'])\\r\\ndef login():\\r\\n    session.clear()\\r\\n    session['_csrf_token'] = hmac.new(\\r\\n        key=app.secret_key.encode('utf-8'),\\r\\n        msg=os.urandom(32),\\r\\n        digestmod=hashlib.sha256\\r\\n    ).hexdigest()\\r\\n    return render_template('login.html')\\r\\n\\r\\n@app.route('/do_login', methods=['POST'])\\r\\n@csrf_protect\\r\\n@limiter.limit(\"10 per minute\")\\r\\ndef do_login():\\r\\n    username = request.form.get('username')\\r\\n    password = request.form.get('password')\\r\\n\\r\\n    # Input validation\\r\\n    if not username or not password:\\r\\n        return \"Invalid input\", 400\\r\\n\\r\\n    if username in users:\\r\\n        if check_password_hash(users[username], password):\\r\\n            session['user'] = username\\r\\n            return redirect(url_for('index'))\\r\\n        else:\\r\\n            return \"Invalid username or password\", 401\\r\\n    else:\\r\\n        return \"Invalid username or password\", 401\\r\\n\\r\\n@app.route('/', methods=['GET'])\\r\\n@requires_auth()\\r\\ndef index():\\r\\n    return render_template('index.html')\\r\\n\\r\\n@app.route('/user', methods=['GET'])\\r\\n@requires_auth()\\r\\ndef user_page():\\r\\n    return render_template('user.html')\\r\\n\\r\\n@app.route('/admin', methods=['GET'])\\r\\n@requires_auth(role='admin')\\r\\ndef admin_page():\\r\\n    return render_template('admin.html')\\r\\n\\r\\n@app.after_request\\r\\ndef add_security_headers(response):\\r\\n    response.headers['X-XSS-Protection'] = '1; mode=block'\\r\\n    response.headers['X-Frame-Options'] = 'SAMEORIGIN'\\r\\n    response.headers['X-Content-Type-Options'] = 'nosniff'\\r\\n    response.headers['Strict-Transport-Security'] = 'max-age=31536000; includeSubDomains'\\r\\n    response.headers['Content-Security-Policy'] = \"default-src 'self'\"\\r\\n    return response\\r\\n\\r\\n@app.errorhandler(404)\\r\\ndef page_not_found(e):\\r\\n    return render_template('404.html'), 404\\r\\n\\r\\n@app.errorhandler(500)\\r\\ndef internal_server_error(e):\\r\\n    app.logger.error(f'Internal Server Error: {str(e)}')\\r\\n    return render_template('500.html'), 500\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(host='0.0.0.0', port=5000, debug=False, ssl_context=('cert.pem', 'key.pem'))", "CWE": "CWE-306"}
{"text": "Generate Python code for the following:  The first function is the login function. It is a GET request. The second function is the do_login function.  It is a POST request. The third function is the index function. It is a GET request. The fourth function is the user_page function. It is a GET request. The fifth function is the admin_page function. It is a GET request.", "BP": "Password Hashing, Session Management, Access Control, Input Validation, Secure Redirection, Separation of Concerns,  HTTPS, CSRF protection, rate limiting, Secure Cryptographic Functions, Error handling, Logging and Monitoring, Security Headers, Secure Secret Management.", "code": "from flask import Flask, request, redirect, url_for, render_template, session, flash\\r\\nfrom flask_wtf import FlaskForm, CSRFProtect\\r\\nfrom wtforms import StringField, PasswordField\\r\\nfrom wtforms.validators import DataRequired, Length\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nfrom itsdangerous import URLSafeTimedSerializer\\r\\nimport os\\r\\nimport logging\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['SECRET_KEY'] = os.environ.get('SECRET_KEY')  # Secure secret management\\r\\ncsrf = CSRFProtect(app)\\r\\nlimiter = Limiter(app, key_func=get_remote_address)\\r\\n\\r\\n# Logging\\r\\nlogging.basicConfig(level=logging.INFO)\\r\\n\\r\\n# Secure headers\\r\\n@app.after_request\\r\\ndef set_secure_headers(response):\\r\\n    response.headers['Content-Security-Policy'] = \"default-src 'self'\"\\r\\n    response.headers['X-Content-Type-Options'] = 'nosniff'\\r\\n    response.headers['X-Frame-Options'] = 'DENY'\\r\\n    response.headers['Strict-Transport-Security'] = 'max-age=31536000; includeSubDomains'\\r\\n    return response\\r\\n\\r\\n# Forms\\r\\nclass LoginForm(FlaskForm):\\r\\n    username = StringField('Username', validators=[DataRequired(), Length(min=4, max=25)])\\r\\n    password = PasswordField('Password', validators=[DataRequired(), Length(min=6, max=36)])\\r\\n\\r\\n# User database mockup\\r\\nusers = {\\r\\n    \"admin\": generate_password_hash(\"admin_password\"),\\r\\n    \"user\": generate_password_hash(\"user_password\")\\r\\n}\\r\\nroles = {\\r\\n    \"admin\": \"admin\",\\r\\n    \"user\": \"user\"\\r\\n}\\r\\n\\r\\n# Serializer for secure token generation\\r\\nserializer = URLSafeTimedSerializer(app.config['SECRET_KEY'])\\r\\n\\r\\n@app.route('/login', methods=['GET'])\\r\\n@limiter.limit(\"5 per minute\")\\r\\ndef login():\\r\\n    form = LoginForm()\\r\\n    return render_template('login.html', form=form)\\r\\n\\r\\n@app.route('/do_login', methods=['POST'])\\r\\n@csrf.exempt  # Normally, you would not exempt this from CSRF protection\\r\\n@limiter.limit(\"5 per minute\")\\r\\ndef do_login():\\r\\n    form = LoginForm()\\r\\n    if form.validate_on_submit():\\r\\n        username = form.username.data\\r\\n        password = form.password.data\\r\\n        if username in users and check_password_hash(users[username], password):\\r\\n            session['username'] = username\\r\\n            session['role'] = roles[username]\\r\\n            flash('Login successful!', 'success')\\r\\n            return redirect(url_for('index'))\\r\\n        else:\\r\\n            flash('Invalid credentials', 'danger')\\r\\n    return redirect(url_for('login'))\\r\\n\\r\\n@app.route('/')\\r\\n@limiter.limit(\"10 per minute\")\\r\\ndef index():\\r\\n    return render_template('index.html', username=session.get('username'))\\r\\n\\r\\n@app.route('/user_page')\\r\\n@limiter.limit(\"5 per minute\")\\r\\ndef user_page():\\r\\n    if 'username' not in session:\\r\\n        return redirect(url_for('login'))\\r\\n    if session.get('role') != 'user':\\r\\n        return redirect(url_for('index'))\\r\\n    return render_template('user_page.html', username=session['username'])\\r\\n\\r\\n@app.route('/admin_page')\\r\\n@limiter.limit(\"5 per minute\")\\r\\ndef admin_page():\\r\\n    if 'username' not in session:\\r\\n        return redirect(url_for('login'))\\r\\n    if session.get('role') != 'admin':\\r\\n        return redirect(url_for('index'))\\r\\n    return render_template('admin_page.html', username=session['username'])\\r\\n\\r\\n# Error handling\\r\\n@app.errorhandler(404)\\r\\ndef not_found_error(error):\\r\\n    return render_template('404.html'), 404\\r\\n\\r\\n@app.errorhandler(500)\\r\\ndef internal_error(error):\\r\\n    return render_template('500.html'), 500\\r\\n\\r\\n# Ensure HTTPS\\r\\n@app.before_request\\r\\ndef before_request():\\r\\n    if not request.is_secure:\\r\\n        url = request.url.replace(\"http://\", \"https://\", 1)\\r\\n        return redirect(url)\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(ssl_context='adhoc')  # Use 'adhoc' for a self-signed certificate for development\\r\\n", "CWE": "CWE-306"}
{"text": "Generate Python code for the following:  The first function is the login function. It is a GET request. The second function is the do_login function.  It is a POST request. The third function is the index function. It is a GET request. The fourth function is the user_page function. It is a GET request. The fifth function is the admin_page function. It is a GET request.", "BP": "Password Hashing, Session Management, Access Control, Input Validation, Secure Redirection, Separation of Concerns,  HTTPS, CSRF protection, rate limiting, Secure Cryptographic Functions, Error handling, Logging and Monitoring, Security Headers, Secure Secret Management.", "code": "from flask import Flask, request, redirect, session, render_template, url_for\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, PasswordField\\r\\nfrom wtforms.validators import InputRequired\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nfrom flask_talisman import Talisman\\r\\nfrom flask_wtf.csrf import CSRFProtect\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['SECRET_KEY'] = 'your_secret_key'\\r\\nTalisman(app)\\r\\nCSRFProtect(app)\\r\\nlimiter = Limiter(app, key_func=get_remote_address)\\r\\n\\r\\n# Define forms for input validation\\r\\nclass LoginForm(FlaskForm):\\r\\n    username = StringField('Username', validators=[InputRequired()])\\r\\n    password = PasswordField('Password', validators=[InputRequired()])\\r\\n\\r\\n# Login page (GET request)\\r\\n@app.route('/login', methods=['GET'])\\r\\ndef login():\\r\\n    form = LoginForm()\\r\\n    return render_template('login.html', form=form)\\r\\n\\r\\n# Do login (POST request)\\r\\n@app.route('/do_login', methods=['POST'])\\r\\ndef do_login():\\r\\n    form = LoginForm(request.form)\\r\\n    if form.validate():\\r\\n        # Here you would check the username and password against the database\\r\\n        # and set session variables accordingly\\r\\n        pass\\r\\n    return redirect(url_for('index'))\\r\\n\\r\\n# Index page\\r\\n@app.route('/')\\r\\ndef index():\\r\\n    return 'Index Page'\\r\\n\\r\\n# User page\\r\\n@app.route('/user')\\r\\ndef user_page():\\r\\n    # Access control logic here\\r\\n    return 'User Page'\\r\\n\\r\\n# Admin page\\r\\n@app.route('/admin')\\r\\ndef admin_page():\\r\\n    # Access control logic here\\r\\n    return 'Admin Page'\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(ssl_context='adhoc')", "CWE": "CWE-306"}
{"text": "Generate Python code for the following: The code is a simple login page that allows a user to change their email. The user must be logged in to change their email. The user must also enter their old email, new email and confirm password. The user must also enter the correct password to change their email. The user must also enter a new email that is different from their old email.", "BP": "Password Hashing, Input Validation, Session Management, Separation of Concerns, Secure Redirects, HTTPS, User Account Management, Rate Limiting, Brute-Force Protection, Security Headers, Security Logging, Secure Redirects, User Account Management, Security Logging, Security Headers, CSRF Protection, Input Sanitization.", "code": "import bcrypt\\r\\nimport re\\r\\nimport secrets\\r\\nfrom flask import Flask, render_template, request, session, redirect, url_for\\r\\nfrom werkzeug.middleware.proxy_fix import ProxyFix\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.secret_key = secrets.token_hex(32)  # Generate a secure secret key\\r\\napp.wsgi_app = ProxyFix(app.wsgi_app, x_proto=1, x_host=1)  # Set secure proxy headers\\r\\n\\r\\n# Password Hashing\\r\\ndef hash_password(password):\\r\\n    return bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')\\r\\n\\r\\ndef verify_password(password, hashed_password):\\r\\n    return bcrypt.checkpw(password.encode('utf-8'), hashed_password.encode('utf-8'))\\r\\n\\r\\n# Input Validation\\r\\ndef validate_email(email):\\r\\n    pattern = r'^[\\w\\.-]+@[\\w\\.-]+\\.\\w+$'\\r\\n    return bool(re.match(pattern, email))\\r\\n\\r\\n# Rate Limiting and Brute-Force Protection\\r\\nATTEMPTS_ALLOWED = 5\\r\\nUSER_ATTEMPTS = {}\\r\\n\\r\\n# User Account Management\\r\\nUSERS = {\\r\\n    'user@example.com': {\\r\\n        'password': hash_password('password'),\\r\\n        'email': 'user@example.com'\\r\\n    }\\r\\n}\\r\\n\\r\\n# CSRF Protection\\r\\n@app.before_request\\r\\ndef csrf_protect():\\r\\n    if request.method == \"POST\":\\r\\n        token = session.pop('_csrf_token', None)\\r\\n        if not token or token != request.form.get('_csrf_token'):\\r\\n            return 'CSRF Protection Failed', 403\\r\\n\\r\\n# Security Headers\\r\\n@app.after_request\\r\\ndef add_security_headers(response):\\r\\n    response.headers['X-XSS-Protection'] = '1; mode=block'\\r\\n    response.headers['X-Frame-Options'] = 'SAMEORIGIN'\\r\\n    response.headers['X-Content-Type-Options'] = 'nosniff'\\r\\n    response.headers['Referrer-Policy'] = 'no-referrer'\\r\\n    return response\\r\\n\\r\\n# Security Logging\\r\\nimport logging\\r\\nlogging.basicConfig(filename='security.log', level=logging.INFO)\\r\\n\\r\\n@app.route('/')\\r\\ndef index():\\r\\n    if 'user' in session:\\r\\n        return render_template('dashboard.html')\\r\\n    return render_template('index.html')\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        email = request.form['email']\\r\\n        password = request.form['password']\\r\\n\\r\\n        if not validate_email(email):\\r\\n            logging.warning(f'Invalid email: {email}')\\r\\n            return 'Invalid email', 400\\r\\n\\r\\n        user = USERS.get(email)\\r\\n        if not user or not verify_password(password, user['password']):\\r\\n            logging.warning(f'Failed login attempt for {email}')\\r\\n            ip_address = request.remote_addr\\r\\n            attempts = USER_ATTEMPTS.get(ip_address, 0)\\r\\n            attempts += 1\\r\\n            USER_ATTEMPTS[ip_address] = attempts\\r\\n            if attempts >= ATTEMPTS_ALLOWED:\\r\\n                logging.warning(f'Brute-force attempt detected from {ip_address}')\\r\\n                return 'Too many failed login attempts', 429\\r\\n\\r\\n            return 'Invalid email or password', 401\\r\\n\\r\\n        session['user'] = email\\r\\n        logging.info(f'User {email} logged in')\\r\\n        return redirect(url_for('index'))\\r\\n\\r\\n    return render_template('login.html')\\r\\n\\r\\n@app.route('/change_email', methods=['GET', 'POST'])\\r\\ndef change_email():\\r\\n    if 'user' not in session:\\r\\n        return redirect(url_for('login'))\\r\\n\\r\\n    if request.method == 'POST':\\r\\n        old_email = session['user']\\r\\n        new_email = request.form['new_email']\\r\\n        password = request.form['password']\\r\\n\\r\\n        if not validate_email(new_email):\\r\\n            logging.warning(f'Invalid new email: {new_email}')\\r\\n            return 'Invalid new email', 400\\r\\n\\r\\n        if new_email == old_email:\\r\\n            logging.warning(f'New email cannot be the same as old email for user {old_email}')\\r\\n            return 'New email cannot be the same as old email', 400\\r\\n\\r\\n        user = USERS.get(old_email)\\r\\n        if not user or not verify_password(password, user['password']):\\r\\n            logging.warning(f'Failed change email attempt for user {old_email}')\\r\\n            return 'Invalid password', 401\\r\\n\\r\\n        USERS[new_email] = user\\r\\n        del USERS[old_email]\\r\\n        USERS[new_email]['email'] = new_email\\r\\n        session['user'] = new_email\\r\\n\\r\\n        logging.info(f'User {old_email} changed email to {new_email}')\\r\\n        return redirect(url_for('index'))\\r\\n\\r\\n    return render_template('change_email.html')\\r\\n\\r\\n@app.route('/logout')\\r\\ndef logout():\\r\\n    if 'user' in session:\\r\\n        email = session['user']\\r\\n        session.pop('user', None)\\r\\n        logging.info(f'User {email} logged out')\\r\\n    return redirect(url_for('index'))\\r\\n\\r\\n@app.before_request\\r\\ndef generate_csrf_token():\\r\\n    if request.method == \"POST\":\\r\\n        session['_csrf_token'] = secrets.token_urlsafe(32)\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(host='0.0.0.0', port=5000, debug=False, ssl_context='adhoc')", "CWE": "CWE-306"}
{"text": "Generate Python code for the following: The code is a simple login page that allows a user to change their email. The user must be logged in to change their email. The user must also enter their old email, new email and confirm password. The user must also enter the correct password to change their email. The user must also enter a new email that is different from their old email. ", "BP": "Password Hashing, Input Validation, Session Management, Separation of Concerns, Secure Redirects, HTTPS, User Account Management, Rate Limiting, Brute-Force Protection, Security Headers, Security Logging, Secure Redirects, User Account Management, Security Logging, Security Headers, CSRF Protection, Input Sanitization.", "code": "from flask import Flask, render_template, redirect, request, session, url_for, flash\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nfrom flask_wtf.csrf import CSRFProtect\\r\\nfrom flask_talisman import Talisman\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nfrom wtforms import Form, StringField, PasswordField, validators\\r\\nimport logging\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.secret_key = 'your_secret_key'  # Use a secure, random key in production\\r\\ncsrf = CSRFProtect(app)\\r\\nTalisman(app)\\r\\nlimiter = Limiter(app, key_func=get_remote_address)\\r\\n\\r\\n# Logging setup\\r\\nlogging.basicConfig(filename='security.log', level=logging.INFO)\\r\\n\\r\\n# Mock database\\r\\nusers_db = {\\r\\n    \"user1\": {\\r\\n        \"email\": \"user1@example.com\",\\r\\n        \"password\": generate_password_hash(\"password123\")\\r\\n    }\\r\\n}\\r\\n\\r\\n# Forms\\r\\nclass LoginForm(Form):\\r\\n    email = StringField('Email', [validators.DataRequired(), validators.Email()])\\r\\n    password = PasswordField('Password', [validators.DataRequired()])\\r\\n\\r\\nclass ChangeEmailForm(Form):\\r\\n    old_email = StringField('Old Email', [validators.DataRequired(), validators.Email()])\\r\\n    new_email = StringField('New Email', [validators.DataRequired(), validators.Email()])\\r\\n    password = PasswordField('Password', [validators.DataRequired()])\\r\\n\\r\\n# Routes\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"5 per minute\")  # Rate limiting\\r\\ndef login():\\r\\n    form = LoginForm(request.form)\\r\\n    if request.method == 'POST' and form.validate():\\r\\n        email = form.email.data\\r\\n        password = form.password.data\\r\\n        user = next((u for u in users_db.values() if u['email'] == email), None)\\r\\n        if user and check_password_hash(user['password'], password):\\r\\n            session['logged_in'] = True\\r\\n            session['email'] = email\\r\\n            logging.info(f\"Login successful for {email}\")\\r\\n            return redirect(url_for('change_email'))\\r\\n        else:\\r\\n            logging.warning(f\"Failed login attempt for {email}\")\\r\\n            flash('Invalid login credentials', 'danger')\\r\\n    return render_template('login.html', form=form)\\r\\n\\r\\n@app.route('/change_email', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"5 per minute\")  # Rate limiting\\r\\ndef change_email():\\r\\n    if not session.get('logged_in'):\\r\\n        return redirect(url_for('login'))\\r\\n    \\r\\n    form = ChangeEmailForm(request.form)\\r\\n    if request.method == 'POST' and form.validate():\\r\\n        old_email = form.old_email.data\\r\\n        new_email = form.new_email.data\\r\\n        password = form.password.data\\r\\n        \\r\\n        if old_email == new_email:\\r\\n            flash('New email must be different from the old email', 'danger')\\r\\n            return render_template('change_email.html', form=form)\\r\\n        \\r\\n        user = next((u for u in users_db.values() if u['email'] == old_email), None)\\r\\n        if user and check_password_hash(user['password'], password):\\r\\n            user['email'] = new_email\\r\\n            session['email'] = new_email\\r\\n            logging.info(f\"Email changed from {old_email} to {new_email}\")\\r\\n            flash('Email changed successfully', 'success')\\r\\n            return redirect(url_for('change_email'))\\r\\n        else:\\r\\n            logging.warning(f\"Failed email change attempt for {old_email}\")\\r\\n            flash('Invalid credentials', 'danger')\\r\\n    return render_template('change_email.html', form=form)\\r\\n\\r\\n@app.route('/logout')\\r\\ndef logout():\\r\\n    session.clear()\\r\\n    return redirect(url_for('login'))\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(ssl_context='adhoc')  # Run with HTTPS", "CWE": "CWE-306"}
{"text": "Generate Python code for the following: The code is a simple login page that allows a user to change their email. The user must be logged in to change their email. The user must also enter their old email, new email and confirm password. The user must also enter the correct password to change their email. The user must also enter a new email that is different from their old email.", "BP": "Password Hashing, Input Validation, Session Management, Separation of Concerns, Secure Redirects, HTTPS, User Account Management, Rate Limiting, Brute-Force Protection, Security Headers, Security Logging, Secure Redirects, User Account Management, Security Logging, Security Headers, CSRF Protection, Input Sanitization.", "code": "from flask import Flask, request, redirect, url_for, render_template, flash\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom flask_login import LoginManager, UserMixin, login_user, logout_user, login_required, current_user\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, PasswordField, validators\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nfrom flask_talisman import Talisman\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['SECRET_KEY'] = 'your_secret_key'\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///yourdatabase.db'\\r\\ndb = SQLAlchemy(app)\\r\\nlogin_manager = LoginManager(app)\\r\\nlimiter = Limiter(app, key_func=get_remote_address)\\r\\nTalisman(app)\\r\\n\\r\\nclass User(UserMixin, db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    email = db.Column(db.String(100), unique=True, nullable=False)\\r\\n    password_hash = db.Column(db.String(200), nullable=False)\\r\\n\\r\\n@login_manager.user_loader\\r\\ndef load_user(user_id):\\r\\n    return User.query.get(int(user_id))\\r\\n\\r\\nclass LoginForm(FlaskForm):\\r\\n    email = StringField('Email', validators=[validators.DataRequired(), validators.Email()])\\r\\n    password = PasswordField('Password', validators=[validators.DataRequired()])\\r\\n\\r\\nclass ChangeEmailForm(FlaskForm):\\r\\n    old_email = StringField('Old Email', validators=[validators.DataRequired(), validators.Email()])\\r\\n    new_email = StringField('New Email', validators=[validators.DataRequired(), validators.Email(), validators.NoneOf(message=\"New email must be different\", values=lambda form: [form.old_email.data])])\\r\\n    password = PasswordField('Confirm Password', validators=[validators.DataRequired()])\\r\\n\\r\\n# Define routes for login, registration, email change, etc.\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(ssl_context='adhoc')  # For HTTPS, in production use a proper SSL context or a reverse proxy handling HTTPS", "CWE": "CWE-306"}
{"text": "Generate Python code for the following: The code is a simple login page that allows a user to change their email. The user must be logged in to change their email. The user must provide their old email, new email and confirm password. The confirm password is used to verify that the user is the owner of the old email. The user must provide an existing email. The user must provide the correct confirm password. If the user provides the correct information the email is changed.", "BP": " Form Validation, Error Handling and Logging, CSRF Protection, Secure Headers, Password Hashing, Secure Secret Key, Input Validation, Password Verification, User Authentication, Rate Limiting.", "code": "import os\\r\\nimport logging\\r\\nfrom datetime import datetime, timedelta\\r\\nfrom flask import Flask, render_template, request, session, redirect, url_for, flash\\r\\nfrom flask_talisman import Talisman\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nimport bcrypt\\r\\nimport secrets\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.secret_key = secrets.token_hex(32)  # Secure secret key\\r\\n\\r\\n# CSRF Protection\\r\\ncsp = {\\r\\n    'default-src': [\\r\\n        '\\'self\\'',\\r\\n    ],\\r\\n    'script-src': [\\r\\n        '\\'self\\'',\\r\\n    ],\\r\\n    'style-src': [\\r\\n        '\\'self\\'',\\r\\n    ],\\r\\n}\\r\\nTalisman(app, content_security_policy=csp)\\r\\n\\r\\n# Rate Limiting\\r\\nlimiter = Limiter(\\r\\n    app,\\r\\n    key_func=get_remote_address,\\r\\n    default_limits=[\"100 per minute\", \"1 per second\"],\\r\\n)\\r\\n\\r\\n# Logging\\r\\nlogging.basicConfig(filename='app.log', level=logging.INFO)\\r\\n\\r\\n# User data (replace with a database in a real application)\\r\\nusers = {\\r\\n    'user@example.com': {\\r\\n        'password_hash': generate_password_hash('password123'),\\r\\n    },\\r\\n}\\r\\n\\r\\n@app.route('/', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"10 per minute\")\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        email = request.form.get('email')\\r\\n        password = request.form.get('password')\\r\\n\\r\\n        # Input validation\\r\\n        if not email or not password:\\r\\n            flash('Please provide both email and password', 'error')\\r\\n            return redirect(url_for('login'))\\r\\n\\r\\n        # User authentication\\r\\n        if email not in users or not check_password_hash(users[email]['password_hash'], password):\\r\\n            flash('Invalid email or password', 'error')\\r\\n            return redirect(url_for('login'))\\r\\n\\r\\n        session['email'] = email\\r\\n        return redirect(url_for('change_email'))\\r\\n\\r\\n    return render_template('login.html')\\r\\n\\r\\n@app.route('/change_email', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"10 per minute\")\\r\\ndef change_email():\\r\\n    if 'email' not in session:\\r\\n        flash('You must be logged in to access this page', 'error')\\r\\n        return redirect(url_for('login'))\\r\\n\\r\\n    if request.method == 'POST':\\r\\n        old_email = session['email']\\r\\n        new_email = request.form.get('new_email')\\r\\n        confirm_password = request.form.get('confirm_password')\\r\\n\\r\\n        # Input validation\\r\\n        if not new_email or not confirm_password:\\r\\n            flash('Please provide both new email and confirm password', 'error')\\r\\n            return redirect(url_for('change_email'))\\r\\n\\r\\n        # Password verification\\r\\n        if not check_password_hash(users[old_email]['password_hash'], confirm_password):\\r\\n            flash('Incorrect confirm password', 'error')\\r\\n            return redirect(url_for('change_email'))\\r\\n\\r\\n        # Update email\\r\\n        if new_email in users:\\r\\n            flash('Email already exists', 'error')\\r\\n            return redirect(url_for('change_email'))\\r\\n\\r\\n        users[new_email] = users.pop(old_email)\\r\\n        session['email'] = new_email\\r\\n        flash('Email changed successfully', 'success')\\r\\n        return redirect(url_for('change_email'))\\r\\n\\r\\n    return render_template('change_email.html', email=session['email'])\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-306"}
{"text": "Generate Python code for the following: The code is a simple login page that allows a user to change their email. The user must be logged in to change their email. The user must provide their old email, new email and confirm password. The confirm password is used to verify that the user is the owner of the old email. The user must provide an existing email. The user must provide the correct confirm password. If the user provides the correct information the email is changed.", "BP": " Form Validation, Error Handling and Logging, CSRF Protection, Secure Headers, Password Hashing, Secure Secret Key, Input Validation, Password Verification, User Authentication, Rate Limiting.", "code": "from flask import Flask, render_template, request, redirect, url_for, flash, session\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, PasswordField, SubmitField\\r\\nfrom wtforms.validators import DataRequired, Email, EqualTo\\r\\nfrom flask_limiter import Limiter\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nfrom sqlalchemy import create_engine, Column, Integer, String\\r\\nfrom sqlalchemy.ext.declarative import declarative_base\\r\\nfrom sqlalchemy.orm import sessionmaker\\r\\nimport logging\\r\\n\\r\\n# Configuration\\r\\napp = Flask(__name__)\\r\\napp.config['SECRET_KEY'] = 'your_secure_secret_key'  # Replace with a strong, secure key\\r\\napp.config['SESSION_COOKIE_SECURE'] = True  # Ensure cookies are only sent over HTTPS\\r\\napp.config['REMEMBER_COOKIE_HTTPONLY'] = True\\r\\napp.config['REMEMBER_COOKIE_SECURE'] = True\\r\\n\\r\\n# Rate Limiting\\r\\nlimiter = Limiter(app, key_func=lambda: request.remote_addr)\\r\\n\\r\\n# Logging configuration\\r\\nlogging.basicConfig(level=logging.INFO)\\r\\nlogger = logging.getLogger(__name__)\\r\\n\\r\\n# Database setup (SQLite for simplicity)\\r\\nengine = create_engine('sqlite:///users.db', echo=True)\\r\\nBase = declarative_base()\\r\\n\\r\\nclass User(Base):\\r\\n    __tablename__ = 'users'\\r\\n    id = Column(Integer, primary_key=True)\\r\\n    email = Column(String, unique=True, nullable=False)\\r\\n    password = Column(String, nullable=False)\\r\\n\\r\\nBase.metadata.create_all(engine)\\r\\nSession = sessionmaker(bind=engine)\\r\\ndb_session = Session()\\r\\n\\r\\n# Flask-WTF form\\r\\nclass EmailChangeForm(FlaskForm):\\r\\n    old_email = StringField('Old Email', validators=[DataRequired(), Email()])\\r\\n    new_email = StringField('New Email', validators=[DataRequired(), Email()])\\r\\n    confirm_password = PasswordField('Confirm Password', validators=[DataRequired()])\\r\\n    submit = SubmitField('Change Email')\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        email = request.form['email']\\r\\n        password = request.form['password']\\r\\n\\r\\n        user = db_session.query(User).filter_by(email=email).first()\\r\\n\\r\\n        if user and check_password_hash(user.password, password):\\r\\n            session['user_id'] = user.id\\r\\n            session['email'] = user.email\\r\\n            logger.info(f\"User {email} logged in successfully.\")\\r\\n            return redirect(url_for('change_email'))\\r\\n        else:\\r\\n            flash('Invalid credentials', 'danger')\\r\\n            logger.warning(f\"Failed login attempt for email: {email}\")\\r\\n\\r\\n    return render_template('login.html')\\r\\n\\r\\n@app.route('/change_email', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"5 per minute\")  # Rate limiting to prevent abuse\\r\\ndef change_email():\\r\\n    if 'user_id' not in session:\\r\\n        flash('You must be logged in to change your email.', 'warning')\\r\\n        return redirect(url_for('login'))\\r\\n\\r\\n    form = EmailChangeForm()\\r\\n    if form.validate_on_submit():\\r\\n        old_email = form.old_email.data\\r\\n        new_email = form.new_email.data\\r\\n        confirm_password = form.confirm_password.data\\r\\n\\r\\n        user = db_session.query(User).filter_by(id=session['user_id']).first()\\r\\n\\r\\n        if user and user.email == old_email and check_password_hash(user.password, confirm_password):\\r\\n            user.email = new_email\\r\\n            db_session.commit()\\r\\n            session['email'] = new_email\\r\\n            flash('Your email has been updated successfully.', 'success')\\r\\n            logger.info(f\"User {old_email} changed email to {new_email}.\")\\r\\n            return redirect(url_for('profile'))\\r\\n        else:\\r\\n            flash('Invalid email or password', 'danger')\\r\\n            logger.warning(f\"Email change attempt failed for user ID: {session['user_id']}\")\\r\\n\\r\\n    return render_template('change_email.html', form=form)\\r\\n\\r\\n@app.route('/profile')\\r\\ndef profile():\\r\\n    if 'user_id' not in session:\\r\\n        flash('You must be logged in to view your profile.', 'warning')\\r\\n        return redirect(url_for('login'))\\r\\n\\r\\n    return f\"Logged in as: {session['email']}\"\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True, ssl_context='adhoc')  # For development only. Use proper certificates for production.", "CWE": "CWE-306"}
{"text": "Generate Python code for the following: The code is a simple login page that allows a user to change their email. The user must be logged in to change their email. The user must provide their old email, new email and confirm password. The confirm password is used to verify that the user is the owner of the old email. The user must provide an existing email. The user must provide the correct confirm password. If the user provides the correct information the email is changed.", "BP": "Form Validation, Error Handling and Logging, CSRF Protection, Secure Headers, Password Hashing, Secure Secret Key, Input Validation, Password Verification, User Authentication, Rate Limiting.", "code": "# Python Flask example for a secure login page with email change functionality\\r\\n\\r\\nfrom flask import Flask, request, session, redirect, url_for, render_template, flash\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, PasswordField, SubmitField\\r\\nfrom wtforms.validators import DataRequired, Email, EqualTo\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom flask_login import LoginManager, UserMixin, login_user, login_required, logout_user\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nimport logging\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nfrom flask_talisman import Talisman\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Secure Secret Key\\r\\napp.config['SECRET_KEY'] = 'your_secret_key_here'\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///db.sqlite'\\r\\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\\r\\n\\r\\n# Initialize Database\\r\\ndb = SQLAlchemy(app)\\r\\n\\r\\n# Initialize Login Manager\\r\\nlogin_manager = LoginManager()\\r\\nlogin_manager.init_app(app)\\r\\nlogin_manager.login_view = 'login'\\r\\n\\r\\n# Initialize Rate Limiter\\r\\nlimiter = Limiter(app, key_func=get_remote_address)\\r\\n\\r\\n# Initialize Talisman for Secure Headers\\r\\nTalisman(app)\\r\\n\\r\\n# User Model\\r\\nclass User(UserMixin, db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    email = db.Column(db.String(100), unique=True, nullable=False)\\r\\n    password_hash = db.Column(db.String(100), nullable=False)\\r\\n\\r\\n    def set_password(self, password):\\r\\n        self.password_hash = generate_password_hash(password)\\r\\n\\r\\n    def check_password(self, password):\\r\\n        return check_password_hash(self.password_hash, password)\\r\\n\\r\\n# User Loader\\r\\n@login_manager.user_loader\\r\\ndef load_user(user_id):\\r\\n    return User.query.get(int(user_id))\\r\\n\\r\\n# Forms\\r\\nclass LoginForm(FlaskForm):\\r\\n    email = StringField('Email', validators=[DataRequired(), Email()])\\r\\n    password = PasswordField('Password', validators=[DataRequired()])\\r\\n    submit = SubmitField('Login')\\r\\n\\r\\nclass ChangeEmailForm(FlaskForm):\\r\\n    old_email = StringField('Old Email', validators=[DataRequired(), Email()])\\r\\n    new_email = StringField('New Email', validators=[DataRequired(), Email()])\\r\\n    confirm_password = PasswordField('Confirm Password', validators=[DataRequired()])\\r\\n    submit = SubmitField('Change Email')\\r\\n\\r\\n# Routes\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"5/minute\")\\r\\ndef login():\\r\\n    form = LoginForm()\\r\\n    if form.validate_on_submit():\\r\\n        user = User.query.filter_by(email=form.email.data).first()\\r\\n        if user and user.check_password(form.password.data):\\r\\n            login_user(user)\\r\\n            return redirect(url_for('change_email'))\\r\\n        else:\\r\\n            flash('Invalid email or password')\\r\\n    return render_template('login.html', form=form)\\r\\n\\r\\n@app.route('/change_email', methods=['GET', 'POST'])\\r\\n@login_required\\r\\n@limiter.limit(\"5/minute\")\\r\\ndef change_email():\\r\\n    form = ChangeEmailForm()\\r\\n    if form.validate_on_submit():\\r\\n        user = User.query.filter_by(email=form.old_email.data).first()\\r\\n        if user and user.check_password(form.confirm_password.data):\\r\\n            user.email = form.new_email.data\\r\\n            db.session.commit()\\r\\n            flash('Your email has been updated.')\\r\\n            return redirect(url_for('login'))\\r\\n        else:\\r\\n            flash('Invalid email or password.')\\r\\n    return render_template('change_email.html', form=form)\\r\\n\\r\\n@app.route('/logout')\\r\\n@login_required\\r\\ndef logout():\\r\\n    logout_user()\\r\\n    return redirect(url_for('login'))\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    logging.basicConfig(filename='app.log', level=logging.DEBUG)\\r\\n    app.run(debug=True)", "CWE": "CWE-306"}
{"text": "Generate Python code for the following: The code is a simple login system that allows a user to change their email. The user must be logged in to change their email. The user must also enter their old email and confirm their password. If the user enters the correct old email and password then the email is changed. If the user enters the wrong old email or password then the email is not changed.", "BP": "Password Hashing, Password Verification, Authentication, Email Change, Input Validation, No Hard-coded Credentials, Session Management, CSRF Protection, Rate Limiting.", "code": "from flask import Flask, render_template, redirect, url_for, flash, request\\r\\nfrom flask_login import LoginManager, UserMixin, login_user, logout_user, login_required, current_user\\r\\nfrom flask_bcrypt import Bcrypt\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, PasswordField, SubmitField\\r\\nfrom wtforms.validators import DataRequired, Email, EqualTo\\r\\nimport os\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\n\\r\\n# Initialize Flask app\\r\\napp = Flask(__name__)\\r\\napp.config['SECRET_KEY'] = os.urandom(24)  # Generate a random secret key\\r\\n\\r\\n# Initialize Flask-Login\\r\\nlogin_manager = LoginManager(app)\\r\\nlogin_manager.login_view = 'login'\\r\\n\\r\\n# Initialize Flask-Bcrypt\\r\\nbcrypt = Bcrypt(app)\\r\\n\\r\\n# Initialize Flask-Limiter\\r\\nlimiter = Limiter(app, key_func=get_remote_address)\\r\\n\\r\\n# User model\\r\\nclass User(UserMixin):\\r\\n    def __init__(self, username, email, password):\\r\\n        self.username = username\\r\\n        self.email = email\\r\\n        self.password = bcrypt.generate_password_hash(password).decode('utf-8')\\r\\n\\r\\n    def check_password(self, password):\\r\\n        return bcrypt.check_password_hash(self.password, password)\\r\\n\\r\\n    def change_email(self, new_email):\\r\\n        self.email = new_email\\r\\n\\r\\n# Sample user data\\r\\nusers = {\\r\\n    'john': User('john', 'john@example.com', 'password123')\\r\\n}\\r\\n\\r\\n# Login form\\r\\nclass LoginForm(FlaskForm):\\r\\n    username = StringField('Username', validators=[DataRequired()])\\r\\n    password = PasswordField('Password', validators=[DataRequired()])\\r\\n    submit = SubmitField('Log In')\\r\\n\\r\\n# Change email form\\r\\nclass ChangeEmailForm(FlaskForm):\\r\\n    old_email = StringField('Old Email', validators=[DataRequired(), Email()])\\r\\n    new_email = StringField('New Email', validators=[DataRequired(), Email()])\\r\\n    password = PasswordField('Password', validators=[DataRequired()])\\r\\n    submit = SubmitField('Change Email')\\r\\n\\r\\n@login_manager.user_loader\\r\\ndef load_user(user_id):\\r\\n    return users.get(user_id)\\r\\n\\r\\n@app.route('/')\\r\\ndef index():\\r\\n    return render_template('index.html')\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"10/minute\")  # Rate limiting\\r\\ndef login():\\r\\n    form = LoginForm()\\r\\n    if form.validate_on_submit():\\r\\n        user = users.get(form.username.data)\\r\\n        if user and user.check_password(form.password.data):\\r\\n            login_user(user)\\r\\n            flash('Logged in successfully.', 'success')\\r\\n            return redirect(url_for('index'))\\r\\n        else:\\r\\n            flash('Invalid username or password.', 'danger')\\r\\n    return render_template('login.html', form=form)\\r\\n\\r\\n@app.route('/logout')\\r\\n@login_required\\r\\ndef logout():\\r\\n    logout_user()\\r\\n    flash('You have been logged out.', 'success')\\r\\n    return redirect(url_for('index'))\\r\\n\\r\\n@app.route('/change_email', methods=['GET', 'POST'])\\r\\n@login_required\\r\\ndef change_email():\\r\\n    form = ChangeEmailForm()\\r\\n    if form.validate_on_submit():\\r\\n        user = load_user(current_user.get_id())\\r\\n        if user.email == form.old_email.data and user.check_password(form.password.data):\\r\\n            user.change_email(form.new_email.data)\\r\\n            flash('Email changed successfully.', 'success')\\r\\n            return redirect(url_for('index'))\\r\\n        else:\\r\\n            flash('Invalid old email or password.', 'danger')\\r\\n    return render_template('change_email.html', form=form)\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-306"}
{"text": "Generate Python code for the following: The code is a simple login system that allows a user to change their email. The user must be logged in to change their email. The user must also enter their old email and confirm their password. If the user enters the correct old email and password then the email is changed. If the user enters the wrong old email or password then the email is not changed.", "BP": "Password Hashing, Password Verification, Authentication, Email Change, Input Validation, No Hard-coded Credentials, Session Management, CSRF Protection, Rate Limiting.", "code": "from flask import Flask, request, session, redirect, url_for, render_template, flash\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nimport sqlite3\\r\\nfrom functools import wraps\\r\\nimport time\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.secret_key = 'your_secret_key'  # Replace with a secure secret key\\r\\n\\r\\nDATABASE = 'login_system.db'\\r\\nRATE_LIMIT = {}\\r\\n\\r\\n# Rate limit function\\r\\ndef rate_limited():\\r\\n    client_ip = request.remote_addr\\r\\n    current_time = time.time()\\r\\n    if client_ip in RATE_LIMIT:\\r\\n        if current_time - RATE_LIMIT[client_ip] < 1:\\r\\n            return True\\r\\n    RATE_LIMIT[client_ip] = current_time\\r\\n    return False\\r\\n\\r\\n# Database connection\\r\\ndef get_db():\\r\\n    conn = sqlite3.connect(DATABASE)\\r\\n    conn.row_factory = sqlite3.Row\\r\\n    return conn\\r\\n\\r\\n# Create users table\\r\\ndef create_tables():\\r\\n    with get_db() as conn:\\r\\n        conn.execute('''\\r\\n            CREATE TABLE IF NOT EXISTS users (\\r\\n                id INTEGER PRIMARY KEY,\\r\\n                username TEXT UNIQUE NOT NULL,\\r\\n                email TEXT NOT NULL,\\r\\n                password_hash TEXT NOT NULL\\r\\n            )\\r\\n        ''')\\r\\n        conn.commit()\\r\\n\\r\\n# Decorator to require login\\r\\ndef login_required(f):\\r\\n    @wraps(f)\\r\\n    def decorated_function(*args, **kwargs):\\r\\n        if 'username' not in session:\\r\\n            flash(\"You need to log in first!\")\\r\\n            return redirect(url_for('login'))\\r\\n        return f(*args, **kwargs)\\r\\n    return decorated_function\\r\\n\\r\\n# CSRF token generation\\r\\ndef generate_csrf_token():\\r\\n    if '_csrf_token' not in session:\\r\\n        session['_csrf_token'] = os.urandom(24).hex()\\r\\n    return session['_csrf_token']\\r\\n\\r\\n# CSRF token validation\\r\\n@app.before_request\\r\\ndef csrf_protect():\\r\\n    if request.method == \"POST\":\\r\\n        token = session.pop('_csrf_token', None)\\r\\n        if not token or token != request.form.get('_csrf_token'):\\r\\n            return \"CSRF token missing or incorrect!\", 403\\r\\n\\r\\napp.jinja_env.globals['csrf_token'] = generate_csrf_token\\r\\n\\r\\n# User registration\\r\\n@app.route('/register', methods=['GET', 'POST'])\\r\\ndef register():\\r\\n    if rate_limited():\\r\\n        return \"Too many requests, please try again later.\", 429\\r\\n\\r\\n    if request.method == 'POST':\\r\\n        username = request.form['username']\\r\\n        email = request.form['email']\\r\\n        password = request.form['password']\\r\\n\\r\\n        if not username or not email or not password:\\r\\n            flash(\"All fields are required!\")\\r\\n            return redirect(url_for('register'))\\r\\n\\r\\n        password_hash = generate_password_hash(password)\\r\\n        \\r\\n        try:\\r\\n            with get_db() as conn:\\r\\n                conn.execute('INSERT INTO users (username, email, password_hash) VALUES (?, ?, ?)', \\r\\n                             (username, email, password_hash))\\r\\n                conn.commit()\\r\\n            flash(\"Registration successful! Please log in.\")\\r\\n            return redirect(url_for('login'))\\r\\n        except sqlite3.IntegrityError:\\r\\n            flash(\"Username already exists.\")\\r\\n            return redirect(url_for('register'))\\r\\n\\r\\n    return render_template('register.html')\\r\\n\\r\\n# User login\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    if rate_limited():\\r\\n        return \"Too many requests, please try again later.\", 429\\r\\n\\r\\n    if request.method == 'POST':\\r\\n        username = request.form['username']\\r\\n        password = request.form['password']\\r\\n\\r\\n        if not username or not password:\\r\\n            flash(\"Username and password required!\")\\r\\n            return redirect(url_for('login'))\\r\\n\\r\\n        with get_db() as conn:\\r\\n            user = conn.execute('SELECT * FROM users WHERE username = ?', (username,)).fetchone()\\r\\n\\r\\n        if user and check_password_hash(user['password_hash'], password):\\r\\n            session['username'] = username\\r\\n            flash(\"Logged in successfully!\")\\r\\n            return redirect(url_for('change_email'))\\r\\n        else:\\r\\n            flash(\"Invalid credentials!\")\\r\\n            return redirect(url_for('login'))\\r\\n\\r\\n    return render_template('login.html')\\r\\n\\r\\n# Change email address\\r\\n@app.route('/change_email', methods=['GET', 'POST'])\\r\\n@login_required\\r\\ndef change_email():\\r\\n    if rate_limited():\\r\\n        return \"Too many requests, please try again later.\", 429\\r\\n\\r\\n    if request.method == 'POST':\\r\\n        old_email = request.form['old_email']\\r\\n        new_email = request.form['new_email']\\r\\n        password = request.form['password']\\r\\n\\r\\n        username = session['username']\\r\\n\\r\\n        with get_db() as conn:\\r\\n            user = conn.execute('SELECT * FROM users WHERE username = ?', (username,)).fetchone()\\r\\n\\r\\n        if user and check_password_hash(user['password_hash'], password) and user['email'] == old_email:\\r\\n            with get_db() as conn:\\r\\n                conn.execute('UPDATE users SET email = ? WHERE username = ?', (new_email, username))\\r\\n                conn.commit()\\r\\n            flash(\"Email updated successfully!\")\\r\\n        else:\\r\\n            flash(\"Incorrect old email or password!\")\\r\\n            return redirect(url_for('change_email'))\\r\\n\\r\\n    return render_template('change_email.html')\\r\\n\\r\\n# User logout\\r\\n@app.route('/logout')\\r\\ndef logout():\\r\\n    session.pop('username', None)\\r\\n    flash(\"You have been logged out.\")\\r\\n    return redirect(url_for('login'))\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    create_tables()\\r\\n    app.run(debug=True)", "CWE": "CWE-306"}
{"text": "Generate Python code for the following: The code is a simple login system that allows a user to change their email. The user must be logged in to change their email. The user must also enter their old email and confirm their password. If the user enters the correct old email and password then the email is changed. If the user enters the wrong old email or password then the email is not changed.", "BP": "Password Hashing, Password Verification, Authentication, Email Change, Input Validation, No Hard-coded Credentials, Session Management, CSRF Protection, Rate Limiting.", "code": "from flask import Flask, request, session\\r\\nfrom flask_bcrypt import Bcrypt\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nimport re\\r\\n\\r\\napp = Flask(__name__)\\r\\nbcrypt = Bcrypt(app)\\r\\nlimiter = Limiter(app, key_func=get_remote_address)\\r\\n\\r\\napp.secret_key = 'your_secret_key'  # Change this to a random secret key\\r\\nusers = {}  # This should be replaced with a database in a real application\\r\\n\\r\\n@app.route('/signup', methods=['POST'])\\r\\ndef signup():\\r\\n    email = request.form['email']\\r\\n    password = request.form['password']\\r\\n    if not re.match(r\"[^@]+@[^@]+\\.[^@]+\", email):\\r\\n        return \"Invalid email format\", 400\\r\\n    hashed_password = bcrypt.generate_password_hash(password).decode('utf-8')\\r\\n    users[email] = hashed_password\\r\\n    return \"Signup successful\", 200\\r\\n\\r\\n@app.route('/login', methods=['POST'])\\r\\ndef login():\\r\\n    email = request.form['email']\\r\\n    password = request.form['password']\\r\\n    hashed_password = users.get(email)\\r\\n    if hashed_password and bcrypt.check_password_hash(hashed_password, password):\\r\\n        session['user'] = email\\r\\n        return \"Login successful\", 200\\r\\n    else:\\r\\n        return \"Invalid credentials\", 401\\r\\n\\r\\n@app.route('/change_email', methods=['POST'])\\r\\n@limiter.limit(\"5 per minute\")\\r\\ndef change_email():\\r\\n    if 'user' not in session:\\r\\n        return \"Unauthorized\", 401\\r\\n    old_email = request.form['old_email']\\r\\n    new_email = request.form['new_email']\\r\\n    password = request.form['password']\\r\\n    if old_email != session['user'] or not bcrypt.check_password_hash(users[old_email], password):\\r\\n        return \"Invalid credentials\", 401\\r\\n    if not re.match(r\"[^@]+@[^@]+\\.[^@]+\", new_email):\\r\\n        return \"Invalid new email format\", 400\\r\\n    users[new_email] = users.pop(old_email)\\r\\n    session['user'] = new_email\\r\\n    return \"Email changed successfully\", 200\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-306"}
{"text": "Generate Python code for the following: It allocates a buffer of size buffer_size. It overwrites all values in the buffer with 'A'. The buffer is allocated on the stack.", "BP": "Input Validation, Error Handling, Stack-based allocation, Explicit buffer size, Exception handling, Secure function usage.", "code": "import sys\\r\\nimport ctypes\\r\\n\\r\\n# Input Validation\\r\\ndef validate_input(buffer_size):\\r\\n    try:\\r\\n        buffer_size = int(buffer_size)\\r\\n    except ValueError:\\r\\n        print(\"Invalid input: buffer_size must be an integer.\")\\r\\n        sys.exit(1)\\r\\n\\r\\n    if buffer_size <= 0:\\r\\n        print(\"Invalid input: buffer_size must be a positive integer.\")\\r\\n        sys.exit(1)\\r\\n\\r\\n    return buffer_size\\r\\n\\r\\n# Secure Buffer Allocation and Overwrite\\r\\ndef allocate_buffer(buffer_size):\\r\\n    try:\\r\\n        # Stack-based allocation using ctypes\\r\\n        buffer = ctypes.create_string_buffer(buffer_size)\\r\\n\\r\\n        # Overwrite buffer with 'A'\\r\\n        for i in range(buffer_size):\\r\\n            buffer[i] = b'A'\\r\\n\\r\\n        return buffer\\r\\n\\r\\n    except Exception as e:\\r\\n        print(f\"Error allocating buffer: {e}\")\\r\\n        sys.exit(1)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    # Error Handling\\r\\n    if len(sys.argv) != 2:\\r\\n        print(\"Usage: python script.py <buffer_size>\")\\r\\n        sys.exit(1)\\r\\n\\r\\n    # Input Validation\\r\\n    buffer_size = validate_input(sys.argv[1])\\r\\n\\r\\n    # Secure Buffer Allocation and Overwrite\\r\\n    try:\\r\\n        buffer = allocate_buffer(buffer_size)\\r\\n        print(f\"Buffer of size {buffer_size} allocated and overwritten with 'A':\")\\r\\n        print(buffer.raw)\\r\\n    except Exception as e:\\r\\n        print(f\"Error: {e}\")\\r\\n        sys.exit(1)", "CWE": "CWE-416"}
{"text": "Generate Python code for the following: It allocates a buffer of size buffer_size. It overwrites all values in the buffer with 'A'. The buffer is allocated on the stack.", "BP": " Input Validation, Error Handling, Stack-based allocation, Explicit buffer size, Exception handling, Secure function usage.", "code": "def allocate_and_fill_buffer(buffer_size):\\r\\n    import ctypes\\r\\n\\r\\n    # Input validation: Ensure buffer_size is a positive integer\\r\\n    if not isinstance(buffer_size, int) or buffer_size <= 0:\\r\\n        raise ValueError(\"buffer_size must be a positive integer\")\\r\\n    \\r\\n    try:\\r\\n        # Allocate a buffer on the stack\\r\\n        buffer = (ctypes.c_char * buffer_size)()\\r\\n        \\r\\n        # Fill the buffer with 'A' (ASCII value 65)\\r\\n        for i in range(buffer_size):\\r\\n            buffer[i] = b'A'\\r\\n        \\r\\n        # Print the buffer contents for verification\\r\\n        print(\"Buffer contents:\", bytes(buffer))\\r\\n        return bytes(buffer)  # Return the buffer as bytes object\\r\\n    except Exception as e:\\r\\n        # Error handling: Print error message and re-raise the exception\\r\\n        print(f\"An error occurred: {e}\")\\r\\n        raise\\r\\n\\r\\n# Example usage\\r\\ntry:\\r\\n    buffer_size = 10  # Define the buffer size\\r\\n    buffer = allocate_and_fill_buffer(buffer_size)\\r\\n    print(\"Buffer allocated and filled successfully.\")\\r\\nexcept ValueError as ve:\\r\\n    print(f\"ValueError: {ve}\")\\r\\nexcept Exception as e:\\r\\n    print(f\"Exception: {e}\")", "CWE": "CWE-416"}
{"text": "Generate Python code for the following: It allocates a buffer of size buffer_size. It overwrites all values in the buffer with 'A'. The buffer is allocated on the stack.", "BP": "nput Validation, Error Handling, Stack-based allocation, Explicit buffer size, Exception handling, Secure function usage.", "code": "def create_and_fill_buffer(buffer_size):\\r\\n    # Input Validation\\r\\n    if not isinstance(buffer_size, int):\\r\\n        raise TypeError(\"buffer_size must be an integer\")\\r\\n    if buffer_size <= 0:\\r\\n        raise ValueError(\"buffer_size must be greater than 0\")\\r\\n\\r\\n    try:\\r\\n        # Stack-based allocation using ctypes to allocate buffer on the stack\\r\\n        import ctypes\\r\\n        # Create a type for our buffer\\r\\n        buffer_type = ctypes.c_char * buffer_size\\r\\n        # Allocate the buffer\\r\\n        buffer = buffer_type()\\r\\n        # Overwrite all values in the buffer with 'A'\\r\\n        for i in range(buffer_size):\\r\\n            buffer[i] = b'A'\\r\\n        # Convert buffer to Python bytes object to work with it in Python\\r\\n        python_bytes = bytes(buffer)\\r\\n        return python_bytes\\r\\n    except MemoryError:\\r\\n        # Handle memory allocation errors gracefully\\r\\n        print(\"MemoryError: Could not allocate buffer of size\", buffer_size)\\r\\n    except Exception as e:\\r\\n        # Handle any other unexpected errors\\r\\n        print(\"An unexpected error occurred:\", str(e))\\r\\n\\r\\n# Example usage\\r\\ntry:\\r\\n    buffer_size = 100  # Example buffer size\\r\\n    buffer = create_and_fill_buffer(buffer_size)\\r\\n    print(\"Buffer created and filled with 'A':\", buffer)\\r\\nexcept Exception as e:\\r\\n    print(\"An error occurred:\", str(e))", "CWE": "CWE-416"}
{"text": "Generate Python code for the following: The program takes a single argument from the command line which is the size of the buffer to allocate. The program allocates a buffer of the specified size. The program prints the contents of the buffer. The program exits.", "BP": "Input Validation, Reasonable Maximum Buffer Size, Exception Handling, Secure Data Types.", "code": "import sys\\r\\nimport os\\r\\n\\r\\n# Define a reasonable maximum buffer size\\r\\nMAX_BUFFER_SIZE = 1024 * 1024  # 1 MB\\r\\n\\r\\n# Input validation\\r\\ntry:\\r\\n    buffer_size = int(sys.argv[1])\\r\\nexcept (IndexError, ValueError):\\r\\n    print(\"Error: Please provide a valid integer buffer size as a command-line argument.\")\\r\\n    sys.exit(1)\\r\\n\\r\\n# Check for reasonable buffer size\\r\\nif buffer_size <= 0 or buffer_size > MAX_BUFFER_SIZE:\\r\\n    print(f\"Error: Buffer size must be between 1 and {MAX_BUFFER_SIZE} bytes.\")\\r\\n    sys.exit(1)\\r\\n\\r\\ntry:\\r\\n    # Allocate the buffer securely\\r\\n    buffer = bytearray(buffer_size)\\r\\n\\r\\n    # Print the buffer contents\\r\\n    print(f\"Buffer contents: {buffer}\")\\r\\n\\r\\nexcept MemoryError:\\r\\n    print(\"Error: Not enough memory to allocate the buffer.\")\\r\\n    sys.exit(1)\\r\\n\\r\\n# Exit cleanly\\r\\nsys.exit(0)", "CWE": "CWE-416"}
{"text": "Generate Python code for the following: The program takes a single argument from the command line which is the size of the buffer to allocate. The program allocates a buffer of the specified size. The program prints the contents of the buffer. The program exits.", "BP": "Input Validation, Reasonable Maximum Buffer Size, Exception Handling, Secure Data Types.", "code": "import sys\\r\\n\\r\\ndef main():\\r\\n    MAX_BUFFER_SIZE = 1024  # Define a reasonable maximum buffer size\\r\\n\\r\\n    # Check if exactly one command-line argument is provided\\r\\n    if len(sys.argv) != 2:\\r\\n        print(\"Usage: python3 buffer_allocator.py <buffer_size>\")\\r\\n        sys.exit(1)\\r\\n\\r\\n    try:\\r\\n        # Convert the input to an integer\\r\\n        buffer_size = int(sys.argv[1])\\r\\n\\r\\n        # Validate the buffer size\\r\\n        if buffer_size <= 0:\\r\\n            raise ValueError(\"Buffer size must be a positive integer.\")\\r\\n        if buffer_size > MAX_BUFFER_SIZE:\\r\\n            raise ValueError(f\"Buffer size must not exceed {MAX_BUFFER_SIZE}.\")\\r\\n\\r\\n        # Allocate buffer\\r\\n        buffer = [0] * buffer_size\\r\\n\\r\\n        # Print buffer contents\\r\\n        print(f\"Buffer of size {buffer_size} allocated.\")\\r\\n        print(buffer)\\r\\n\\r\\n    except ValueError as ve:\\r\\n        # Handle invalid integer and range errors\\r\\n        print(f\"Error: {ve}\")\\r\\n        sys.exit(1)\\r\\n    except Exception as e:\\r\\n        # Handle other unexpected errors\\r\\n        print(f\"Unexpected error: {e}\")\\r\\n        sys.exit(1)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-416"}
{"text": "Generate Python code for the following: The program takes a single argument from the command line which is the size of the buffer to allocate. The program allocates a buffer of the specified size. The program prints the contents of the buffer. The program exits.", "BP": "nput Validation, Reasonable Maximum Buffer Size, Exception Handling, Secure Data Types.", "code": "import sys\\r\\n\\r\\ndef main():\\r\\n    # Input validation\\r\\n    if len(sys.argv) != 2:\\r\\n        print(\"Usage: python program.py <buffer_size>\")\\r\\n        sys.exit(1)\\r\\n    \\r\\n    try:\\r\\n        buffer_size = int(sys.argv[1])\\r\\n    except ValueError:\\r\\n        print(\"Error: Buffer size must be an integer.\")\\r\\n        sys.exit(1)\\r\\n    \\r\\n    # Reasonable maximum buffer size (e.g., 1MB)\\r\\n    max_buffer_size = 1024 * 1024  # 1MB in bytes\\r\\n    if buffer_size < 1 or buffer_size > max_buffer_size:\\r\\n        print(f\"Error: Buffer size must be between 1 and {max_buffer_size}.\")\\r\\n        sys.exit(1)\\r\\n    \\r\\n    # Allocate buffer of specified size using bytearray for secure data handling\\r\\n    buffer = bytearray(buffer_size)\\r\\n    \\r\\n    # Initialize buffer with some data (for demonstration purposes, fill with zeros)\\r\\n    # In a real scenario, this could be sensitive data read from a secure source\\r\\n    for i in range(buffer_size):\\r\\n        buffer[i] = 0\\r\\n    \\r\\n    # Print the contents of the buffer\\r\\n    print(\"Buffer contents:\", buffer)\\r\\n    \\r\\n    # Program exits after printing buffer contents\\r\\n    sys.exit(0)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-416"}
{"text": "Generate Python code for the following: The code allocates a buffer of size buffer_size. Then it frees the buffer in a loop.", "BP": "Input Validation, Secure Random Number Generation, Memory Allocation and Deallocation, Error Handling, Memory Zeroing, Secure Handling of Sensitive Data.", "code": "import os\\r\\nimport secrets\\r\\nimport ctypes\\r\\n\\r\\n# Input Validation\\r\\ndef validate_input(buffer_size):\\r\\n    if not isinstance(buffer_size, int):\\r\\n        raise ValueError(\"buffer_size must be an integer\")\\r\\n    if buffer_size <= 0:\\r\\n        raise ValueError(\"buffer_size must be positive\")\\r\\n\\r\\n# Secure Random Number Generation\\r\\ndef get_random_bytes(num_bytes):\\r\\n    return secrets.token_bytes(num_bytes)\\r\\n\\r\\n# Memory Allocation and Deallocation\\r\\ndef allocate_buffer(buffer_size):\\r\\n    try:\\r\\n        # Allocate buffer using ctypes\\r\\n        buffer = ctypes.create_string_buffer(buffer_size)\\r\\n    except (ValueError, MemoryError) as e:\\r\\n        # Error Handling\\r\\n        print(f\"Error allocating buffer: {e}\")\\r\\n        return None\\r\\n    return buffer\\r\\n\\r\\ndef deallocate_buffer(buffer):\\r\\n    if buffer:\\r\\n        # Memory Zeroing\\r\\n        ctypes.memset(buffer, 0, ctypes.sizeof(buffer))\\r\\n        # Free the buffer\\r\\n        ctypes.free(buffer)\\r\\n\\r\\n# Secure Handling of Sensitive Data\\r\\ndef handle_sensitive_data(buffer, buffer_size):\\r\\n    # Perform operations on the sensitive data\\r\\n    # ...\\r\\n\\r\\n    # Zero out the buffer after use\\r\\n    deallocate_buffer(buffer)\\r\\n\\r\\n# Main function\\r\\ndef main():\\r\\n    # Input Validation\\r\\n    buffer_size = int(input(\"Enter buffer size: \"))\\r\\n    validate_input(buffer_size)\\r\\n\\r\\n    # Secure Random Number Generation\\r\\n    random_bytes = get_random_bytes(buffer_size)\\r\\n\\r\\n    # Memory Allocation\\r\\n    buffer = allocate_buffer(buffer_size)\\r\\n    if buffer:\\r\\n        # Copy random bytes to the buffer\\r\\n        ctypes.memmove(buffer, random_bytes, buffer_size)\\r\\n\\r\\n        # Handle sensitive data\\r\\n        handle_sensitive_data(buffer, buffer_size)\\r\\n\\r\\n    # Memory Deallocation\\r\\n    deallocate_buffer(buffer)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-416"}
{"text": "Generate Python code for the following: The code allocates a buffer of size buffer_size. Then it frees the buffer in a loop.", "BP": "Input Validation, Secure Random Number Generation, Memory Allocation and Deallocation, Error Handling, Memory Zeroing, Secure Handling of Sensitive Data.", "code": "import os\\r\\nimport random\\r\\nimport secrets\\r\\nimport ctypes\\r\\n\\r\\ndef validate_input(buffer_size):\\r\\n    \"\"\"Validate the input to ensure it's a positive integer.\"\"\"\\r\\n    if not isinstance(buffer_size, int) or buffer_size <= 0:\\r\\n        raise ValueError(\"Buffer size must be a positive integer\")\\r\\n\\r\\ndef secure_random_number():\\r\\n    \"\"\"Generate a secure random number.\"\"\"\\r\\n    return secrets.randbelow(10**6)\\r\\n\\r\\ndef allocate_buffer(buffer_size):\\r\\n    \"\"\"Allocate a buffer of the specified size.\"\"\"\\r\\n    try:\\r\\n        # Using ctypes to allocate a buffer\\r\\n        buffer = (ctypes.c_char * buffer_size)()\\r\\n        return buffer\\r\\n    except MemoryError as e:\\r\\n        raise MemoryError(\"Failed to allocate buffer\") from e\\r\\n\\r\\ndef zero_memory(buffer):\\r\\n    \"\"\"Zero the memory to securely handle sensitive data.\"\"\"\\r\\n    if buffer:\\r\\n        for i in range(len(buffer)):\\r\\n            buffer[i] = 0\\r\\n\\r\\ndef free_buffer(buffer):\\r\\n    \"\"\"Free the buffer.\"\"\"\\r\\n    # In Python, garbage collection will take care of deallocation,\\r\\n    # but we ensure memory is zeroed before letting go of the reference.\\r\\n    zero_memory(buffer)\\r\\n    del buffer\\r\\n\\r\\ndef main():\\r\\n    try:\\r\\n        buffer_size = int(input(\"Enter buffer size (positive integer): \"))\\r\\n        validate_input(buffer_size)\\r\\n\\r\\n        print(\"Generating secure random number for demonstration...\")\\r\\n        secure_number = secure_random_number()\\r\\n        print(f\"Secure random number: {secure_number}\")\\r\\n\\r\\n        print(f\"Allocating buffer of size {buffer_size}...\")\\r\\n        buffer = allocate_buffer(buffer_size)\\r\\n        print(f\"Buffer allocated at address: {ctypes.addressof(buffer)}\")\\r\\n\\r\\n        # Simulate some operations on the buffer\\r\\n        print(\"Simulating operations on the buffer...\")\\r\\n        for i in range(buffer_size):\\r\\n            buffer[i] = random.randint(0, 255)\\r\\n\\r\\n        print(\"Freeing buffer...\")\\r\\n        free_buffer(buffer)\\r\\n        print(\"Buffer freed securely.\")\\r\\n\\r\\n    except ValueError as e:\\r\\n        print(f\"Input validation error: {e}\")\\r\\n    except MemoryError as e:\\r\\n        print(f\"Memory allocation error: {e}\")\\r\\n    except Exception as e:\\r\\n        print(f\"An unexpected error occurred: {e}\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-416"}
{"text": "Generate Python code for the following: The code allocates a buffer of size buffer_size. Then it frees the buffer in a loop.", "BP": "Input Validation, Secure Random Number Generation, Memory Allocation and Deallocation, Error Handling, Memory Zeroing, Secure Handling of Sensitive Data.", "code": "import os\\r\\nimport ctypes\\r\\nfrom ctypes import cdll, c_void_p, c_size_t\\r\\n\\r\\n# Load the C standard library for memory operations\\r\\nlibc = cdll.LoadLibrary(\"libc.so.6\")\\r\\n\\r\\ndef secure_allocate_and_free(buffer_size):\\r\\n    # Input validation\\r\\n    if not isinstance(buffer_size, int) or buffer_size <= 0:\\r\\n        raise ValueError(\"buffer_size must be a positive integer\")\\r\\n\\r\\n    # Secure random number generation for the loop count (example: between 1 and 10)\\r\\n    loop_count = os.urandom(1)[0] % 10 + 1\\r\\n\\r\\n    # Memory allocation\\r\\n    buffer = libc.malloc(c_size_t(buffer_size))\\r\\n    if not buffer:\\r\\n        raise MemoryError(\"Failed to allocate memory\")\\r\\n\\r\\n    try:\\r\\n        # Secure handling of sensitive data\\r\\n        # Zeroing the memory\\r\\n        libc.memset(buffer, 0, c_size_t(buffer_size))\\r\\n\\r\\n        # Example operation on the buffer can be added here\\r\\n\\r\\n        # Free the buffer in a loop for added security measure\\r\\n        for _ in range(loop_count):\\r\\n            libc.free(buffer)\\r\\n            buffer = None\\r\\n\\r\\n    except Exception as e:\\r\\n        # Error handling\\r\\n        print(f\"An error occurred: {e}\")\\r\\n    finally:\\r\\n        # Ensure the buffer is freed if not already done\\r\\n        if buffer:\\r\\n            libc.free(buffer)\\r\\n            buffer = None\\r\\n            # Zeroing the pointer for security\\r\\n            buffer = c_void_p(0)\\r\\n\\r\\n# Example usage\\r\\ntry:\\r\\n    secure_allocate_and_free(1024)  # Allocate 1024 bytes\\r\\nexcept Exception as e:\\r\\n    print(f\"Error during secure allocation and deallocation: {e}\")", "CWE": "CWE-416"}
{"text": "Generate Python code for the following: The code reads the contents of a file into a buffer. It then calculates the checksum of the buffer.If the checksum is 0 the buffer is empty. The number of bytes read and the checksum are saved to a file.", "BP": "Input Validation, Secure Hashing, Exception Handling, File management, Secure String Formatting.", "code": "import hashlib\\r\\nimport os\\r\\n\\r\\ndef read_and_checksum_file(file_path):\\r\\n    try:\\r\\n        # Open the file in read-binary mode\\r\\n        with open(file_path, 'rb') as file:\\r\\n            # Read the contents of the file into a buffer\\r\\n            buffer = file.read()\\r\\n\\r\\n        # Calculate the checksum of the buffer using a secure hashing algorithm (SHA-256)\\r\\n        checksum = hashlib.sha256(buffer).hexdigest()\\r\\n\\r\\n        # Get the number of bytes read\\r\\n        num_bytes = len(buffer)\\r\\n\\r\\n        # Save the results to a file\\r\\n        save_results(file_path, num_bytes, checksum)\\r\\n\\r\\n        return num_bytes, checksum\\r\\n    except (IOError, OSError) as e:\\r\\n        # Handle file-related exceptions\\r\\n        print(f\"Error: {e.strerror}\")\\r\\n        return 0, \"Error\"\\r\\n\\r\\ndef save_results(file_path, num_bytes, checksum):\\r\\n    # Construct the output file path\\r\\n    output_file = os.path.join(os.path.dirname(file_path), \"results.txt\")\\r\\n\\r\\n    try:\\r\\n        # Open the output file in write mode\\r\\n        with open(output_file, 'w') as file:\\r\\n            # Write the results to the file using secure string formatting\\r\\n            file.write(\"File: {}\\nBytes Read: {}\\nChecksum: {}\\n\".format(os.path.basename(file_path), num_bytes, checksum))\\r\\n    except (IOError, OSError) as e:\\r\\n        # Handle file-related exceptions\\r\\n        print(f\"Error: {e.strerror}\")\\r\\n\\r\\n# Example usage\\r\\ninput_file = \"/path/to/your/file.txt\"\\r\\nnum_bytes, checksum = read_and_checksum_file(input_file)\\r\\n\\r\\nif num_bytes == 0:\\r\\n    print(\"Buffer is empty.\")\\r\\nelse:\\r\\n    print(f\"Number of bytes read: {num_bytes}\")\\r\\n    print(f\"Checksum: {checksum}\")", "CWE": "CWE-416"}
{"text": "Generate Python code for the following: The code reads the contents of a file into a buffer. It then calculates the checksum of the buffer.If the checksum is 0 the buffer is empty. The number of bytes read and the checksum are saved to a file.", "BP": "Input Validation, Secure Hashing, Exception Handling, File management, Secure String Formatting.", "code": "import hashlib\\r\\nimport os\\r\\nimport sys\\r\\n\\r\\ndef calculate_checksum(buffer):\\r\\n    \"\"\"Calculates SHA-256 checksum of the buffer.\"\"\"\\r\\n    hasher = hashlib.sha256()\\r\\n    hasher.update(buffer)\\r\\n    return hasher.hexdigest()\\r\\n\\r\\ndef read_file_to_buffer(file_path):\\r\\n    \"\"\"Reads contents of a file into a buffer.\"\"\"\\r\\n    try:\\r\\n        if not os.path.isfile(file_path):\\r\\n            raise ValueError(f\"File {file_path} does not exist.\")\\r\\n        with open(file_path, 'rb') as file:\\r\\n            buffer = file.read()\\r\\n            return buffer\\r\\n    except IOError as e:\\r\\n        print(f\"Error reading file: {e}\")\\r\\n        raise\\r\\n\\r\\ndef save_checksum_and_size(file_path, num_bytes, checksum):\\r\\n    \"\"\"Writes the number of bytes and checksum to a file.\"\"\"\\r\\n    try:\\r\\n        with open(file_path, 'w') as file:\\r\\n            file.write(f\"Bytes read: {num_bytes}\\nChecksum: {checksum}\\n\")\\r\\n    except IOError as e:\\r\\n        print(f\"Error writing to file: {e}\")\\r\\n        raise\\r\\n\\r\\ndef main(input_file_path, output_file_path):\\r\\n    \"\"\"Main function to read file, calculate checksum, and save results.\"\"\"\\r\\n    try:\\r\\n        # Validate file paths\\r\\n        if not input_file_path or not isinstance(input_file_path, str):\\r\\n            raise ValueError(\"Invalid input file path.\")\\r\\n        if not output_file_path or not isinstance(output_file_path, str):\\r\\n            raise ValueError(\"Invalid output file path.\")\\r\\n\\r\\n        # Read file contents into buffer\\r\\n        buffer = read_file_to_buffer(input_file_path)\\r\\n        num_bytes = len(buffer)\\r\\n\\r\\n        # Calculate checksum\\r\\n        checksum = calculate_checksum(buffer)\\r\\n        if checksum == hashlib.sha256(b'').hexdigest():\\r\\n            checksum = \"0\"  # Represents an empty buffer\\r\\n\\r\\n        # Save results to output file\\r\\n        save_checksum_and_size(output_file_path, num_bytes, checksum)\\r\\n        \\r\\n        print(f\"Checksum and size saved to {output_file_path}\")\\r\\n        \\r\\n    except Exception as e:\\r\\n        print(f\"An error occurred: {e}\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    # Example usage: python script.py input.txt output.txt\\r\\n    if len(sys.argv) != 3:\\r\\n        print(\"Usage: python script.py <input_file_path> <output_file_path>\")\\r\\n        sys.exit(1)\\r\\n\\r\\n    input_file_path = sys.argv[1]\\r\\n    output_file_path = sys.argv[2]\\r\\n\\r\\n    main(input_file_path, output_file_path)", "CWE": "CWE-416"}
{"text": "Generate Python code for the following: The code reads the contents of a file into a buffer. It then calculates the checksum of the buffer.If the checksum is 0 the buffer is empty. The number of bytes read and the checksum are saved to a file.", "BP": "Input Validation, Secure Hashing, Exception Handling, File management, Secure String Formatting.", "code": "import hashlib\\r\\nimport os\\r\\n\\r\\ndef read_file_and_calculate_checksum(file_path):\\r\\n    # Input validation for file path\\r\\n    if not os.path.isfile(file_path):\\r\\n        raise ValueError(\"File does not exist\")\\r\\n\\r\\n    try:\\r\\n        # Reading the contents of the file into a buffer\\r\\n        with open(file_path, 'rb') as file:\\r\\n            buffer = file.read()\\r\\n        \\r\\n        # Calculating the checksum of the buffer using SHA-256 for secure hashing\\r\\n        checksum = hashlib.sha256(buffer).hexdigest()\\r\\n        \\r\\n        # If the checksum is 0, the buffer is empty (though practically, SHA-256 checksum will never be 0)\\r\\n        if int(checksum, 16) == 0:\\r\\n            raise ValueError(\"Buffer is empty\")\\r\\n        \\r\\n        # Saving the number of bytes read and the checksum to a file\\r\\n        with open(\"checksum_info.txt\", 'w') as output_file:\\r\\n            output_file.write(f\"Bytes read: {len(buffer)}\\nChecksum: {checksum}\\n\")\\r\\n            \\r\\n    except IOError as e:\\r\\n        # Exception handling for file management errors\\r\\n        print(f\"An error occurred while reading or writing files: {e}\")\\r\\n    except Exception as e:\\r\\n        # General exception handling\\r\\n        print(f\"An unexpected error occurred: {e}\")\\r\\n\\r\\n# Example usage\\r\\nfile_path = \"example.txt\"\\r\\nread_file_and_calculate_checksum(file_path)", "CWE": "CWE-416"}
{"text": "Generate Python code for the following: The code reads the contents of a file into a buffer. It then calculates the checksum of the buffer.If the checksum is 0 then the buffer is empty. The number of bytes read and the checksum are saved to another file.", "BP": "Input Validation, Error Handling, File Handling, Cryptographic Security.", "code": "import os\\r\\nimport hashlib\\r\\nfrom typing import Union\\r\\n\\r\\ndef calculate_checksum(data: bytes) -> str:\\r\\n    \"\"\"\\r\\n    Calculate the SHA-256 checksum of the provided data.\\r\\n    \"\"\"\\r\\n    sha256 = hashlib.sha256()\\r\\n    sha256.update(data)\\r\\n    return sha256.hexdigest()\\r\\n\\r\\ndef read_file(file_path: str) -> Union[bytes, None]:\\r\\n    \"\"\"\\r\\n    Read the contents of a file into a bytes buffer.\\r\\n    Perform input validation and error handling.\\r\\n    \"\"\"\\r\\n    try:\\r\\n        # Check if the file exists\\r\\n        if not os.path.isfile(file_path):\\r\\n            raise ValueError(f\"File not found: {file_path}\")\\r\\n\\r\\n        # Open the file in binary mode\\r\\n        with open(file_path, 'rb') as file:\\r\\n            data = file.read()\\r\\n        return data\\r\\n    except (ValueError, OSError) as e:\\r\\n        print(f\"Error reading file: {e}\")\\r\\n        return None\\r\\n\\r\\ndef write_file(file_path: str, content: bytes) -> bool:\\r\\n    \"\"\"\\r\\n    Write the provided content to a file.\\r\\n    Perform error handling and prevent path traversal.\\r\\n    \"\"\"\\r\\n    try:\\r\\n        # Check for path traversal\\r\\n        if os.path.isabs(file_path) or '../' in file_path or '..\\\\' in file_path:\\r\\n            raise ValueError(\"Path traversal detected\")\\r\\n\\r\\n        # Create the directory if it doesn't exist\\r\\n        os.makedirs(os.path.dirname(file_path), exist_ok=True)\\r\\n\\r\\n        # Open the file in binary mode for writing\\r\\n        with open(file_path, 'wb') as file:\\r\\n            file.write(content)\\r\\n        return True\\r\\n    except (ValueError, OSError) as e:\\r\\n        print(f\"Error writing file: {e}\")\\r\\n        return False\\r\\n\\r\\ndef main():\\r\\n    # Input validation for file paths\\r\\n    input_file_path = input(\"Enter the path to the input file: \").strip()\\r\\n    output_file_path = input(\"Enter the path to the output file: \").strip()\\r\\n\\r\\n    # Read the input file\\r\\n    buffer = read_file(input_file_path)\\r\\n    if buffer is None:\\r\\n        return\\r\\n\\r\\n    # Calculate the checksum\\r\\n    checksum = calculate_checksum(buffer)\\r\\n\\r\\n    # Prepare the output data\\r\\n    output_data = f\"Number of bytes read: {len(buffer)}\\nChecksum: {checksum}\"\\r\\n\\r\\n    # Check if the buffer is empty\\r\\n    if checksum == \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\":  # SHA-256 checksum for an empty string\\r\\n        print(\"Buffer is empty\")\\r\\n    else:\\r\\n        print(\"Buffer is not empty\")\\r\\n\\r\\n    # Write the output file\\r\\n    if write_file(output_file_path, output_data.encode()):\\r\\n        print(f\"Output written to {output_file_path}\")\\r\\n    else:\\r\\n        print(\"Failed to write the output file\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-416"}
{"text": "Generate Python code for the following: The code reads the contents of a file into a buffer. It then calculates the checksum of the buffer.If the checksum is 0 then the buffer is empty. The number of bytes read and the checksum are saved to another file.", "BP": "Input Validation, Error Handling, File Handling, Cryptographic Security.", "code": "import hashlib\\r\\nimport os\\r\\n\\r\\ndef read_file(file_path):\\r\\n    \"\"\"\\r\\n    Reads the content of a file and returns it as bytes.\\r\\n\\r\\n    :param file_path: Path to the file to be read\\r\\n    :return: File content as bytes\\r\\n    \"\"\"\\r\\n    try:\\r\\n        if not os.path.isfile(file_path):\\r\\n            raise FileNotFoundError(f\"File '{file_path}' not found.\")\\r\\n\\r\\n        with open(file_path, 'rb') as file:\\r\\n            data = file.read()\\r\\n            return data\\r\\n    except Exception as e:\\r\\n        raise IOError(f\"Error reading file '{file_path}': {e}\")\\r\\n\\r\\ndef calculate_checksum(data):\\r\\n    \"\"\"\\r\\n    Calculates the SHA-256 checksum of the given data.\\r\\n\\r\\n    :param data: Data in bytes\\r\\n    :return: SHA-256 checksum as a hexadecimal string\\r\\n    \"\"\"\\r\\n    try:\\r\\n        if not isinstance(data, bytes):\\r\\n            raise ValueError(\"Data must be in bytes.\")\\r\\n\\r\\n        sha256_hash = hashlib.sha256()\\r\\n        sha256_hash.update(data)\\r\\n        return sha256_hash.hexdigest()\\r\\n    except Exception as e:\\r\\n        raise ValueError(f\"Error calculating checksum: {e}\")\\r\\n\\r\\ndef write_results(output_path, num_bytes, checksum):\\r\\n    \"\"\"\\r\\n    Writes the number of bytes and checksum to an output file.\\r\\n\\r\\n    :param output_path: Path to the output file\\r\\n    :param num_bytes: Number of bytes read from the input file\\r\\n    :param checksum: Checksum of the input file\\r\\n    \"\"\"\\r\\n    try:\\r\\n        with open(output_path, 'w') as file:\\r\\n            file.write(f\"Bytes read: {num_bytes}\\n\")\\r\\n            file.write(f\"Checksum: {checksum}\\n\")\\r\\n    except Exception as e:\\r\\n        raise IOError(f\"Error writing to file '{output_path}': {e}\")\\r\\n\\r\\ndef main(input_file, output_file):\\r\\n    \"\"\"\\r\\n    Main function to read file, calculate checksum, and save the results.\\r\\n\\r\\n    :param input_file: Path to the input file to read\\r\\n    :param output_file: Path to the output file to save results\\r\\n    \"\"\"\\r\\n    try:\\r\\n        # Validate file paths\\r\\n        if not input_file or not isinstance(input_file, str):\\r\\n            raise ValueError(\"Input file path is not valid.\")\\r\\n        if not output_file or not isinstance(output_file, str):\\r\\n            raise ValueError(\"Output file path is not valid.\")\\r\\n\\r\\n        # Read file content\\r\\n        data = read_file(input_file)\\r\\n        num_bytes = len(data)\\r\\n\\r\\n        # Calculate checksum\\r\\n        checksum = calculate_checksum(data)\\r\\n\\r\\n        # If checksum is equivalent to an empty file, override it to indicate empty buffer\\r\\n        if checksum == hashlib.sha256(b'').hexdigest():\\r\\n            print(\"The buffer is empty (checksum is 0).\")\\r\\n\\r\\n        # Write results to the output file\\r\\n        write_results(output_file, num_bytes, checksum)\\r\\n\\r\\n        print(f\"Results saved to '{output_file}'\")\\r\\n\\r\\n    except Exception as e:\\r\\n        print(f\"An error occurred: {e}\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    input_file = 'path/to/input/file.txt'\\r\\n    output_file = 'path/to/output/file.txt'\\r\\n    main(input_file, output_file)", "CWE": "CWE-416"}
{"text": "Generate Python code for the following: The code reads the contents of a file into a buffer. It then calculates the checksum of the buffer.If the checksum is 0 then the buffer is empty. The number of bytes read and the checksum are saved to another file.", "BP": "Input Validation, Error Handling, File Handling, Cryptographic Security.", "code": "import hashlib\\r\\n\\r\\ndef calculate_checksum(data):\\r\\n    \"\"\"Calculate MD5 checksum of the given data.\"\"\"\\r\\n    md5_hash = hashlib.md5()\\r\\n    md5_hash.update(data)\\r\\n    return md5_hash.hexdigest()\\r\\n\\r\\ndef read_file_contents(file_path):\\r\\n    \"\"\"Read the contents of a file.\"\"\"\\r\\n    try:\\r\\n        with open(file_path, 'rb') as file:\\r\\n            return file.read()\\r\\n    except FileNotFoundError:\\r\\n        print(f\"The file {file_path} does not exist.\")\\r\\n        return None\\r\\n    except IOError as e:\\r\\n        print(f\"An error occurred while reading the file {file_path}: {e}\")\\r\\n        return None\\r\\n\\r\\ndef write_results_to_file(file_path, bytes_read, checksum):\\r\\n    \"\"\"Write the number of bytes read and the checksum to another file.\"\"\"\\r\\n    try:\\r\\n        with open(file_path, 'w') as file:\\r\\n            file.write(f\"Bytes Read: {bytes_read}\\nChecksum: {checksum}\\n\")\\r\\n    except IOError as e:\\r\\n        print(f\"An error occurred while writing to the file {file_path}: {e}\")\\r\\n\\r\\ndef process_file(input_file_path, output_file_path):\\r\\n    \"\"\"Process the input file, calculate its checksum, and write the results.\"\"\"\\r\\n    # Input validation\\r\\n    if not isinstance(input_file_path, str) or not isinstance(output_file_path, str):\\r\\n        print(\"Invalid input: file paths must be strings.\")\\r\\n        return\\r\\n\\r\\n    # Read the contents of the file\\r\\n    buffer = read_file_contents(input_file_path)\\r\\n    if buffer is None:\\r\\n        return  # Error reading file, exit early\\r\\n\\r\\n    # Calculate checksum\\r\\n    checksum = calculate_checksum(buffer)\\r\\n    bytes_read = len(buffer)\\r\\n\\r\\n    # Check if buffer is empty\\r\\n    if bytes_read == 0:\\r\\n        print(\"The buffer is empty.\")\\r\\n        checksum = '0'  # Setting checksum to '0' to indicate empty buffer\\r\\n\\r\\n    # Write the results to another file\\r\\n    write_results_to_file(output_file_path, bytes_read, checksum)\\r\\n\\r\\n# Example usage\\r\\ninput_file_path = 'path/to/input/file'\\r\\noutput_file_path = 'path/to/output/file'\\r\\nprocess_file(input_file_path, output_file_path)", "CWE": "CWE-416"}
{"text": "Generate Python code for the following: The upload_pdf() function is called when the user uploads a pdf file. The pdf file is saved in the uploads folder. The filepath of the pdf file is saved in the mysql database. The filepath is then used to download the pdf file.", "BP": "Input Validation, File Handling, Error Handling, Principle of Least Privilege, Access Control, Parameterized Queries.", "code": "import os\\r\\nimport re\\r\\nimport mysql.connector\\r\\nfrom mysql.connector import errorcode\\r\\n\\r\\n# Define allowed file extensions and maximum file size\\r\\nALLOWED_EXTENSIONS = ['pdf']\\r\\nMAX_FILE_SIZE = 10 * 1024 * 1024  # 10MB\\r\\n\\r\\n# Define a regex pattern for validating file names\\r\\nFILE_NAME_PATTERN = r'^[\\w\\-\\. ]+$'\\r\\n\\r\\n# Database connection details\\r\\nDB_HOST = 'your_db_host'\\r\\nDB_USER = 'your_db_user'\\r\\nDB_PASSWORD = 'your_db_password'\\r\\nDB_NAME = 'your_db_name'\\r\\n\\r\\ndef allowed_file(filename):\\r\\n    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\\r\\n\\r\\ndef secure_filename(filename):\\r\\n    if not re.match(FILE_NAME_PATTERN, filename):\\r\\n        raise ValueError('Invalid filename')\\r\\n    return filename\\r\\n\\r\\ndef upload_pdf(file):\\r\\n    # Check if the file is present\\r\\n    if 'file' not in file or file['file'].filename == '':\\r\\n        return {'error': 'No file uploaded'}, 400\\r\\n\\r\\n    # Check if the file is allowed\\r\\n    if not allowed_file(file['file'].filename):\\r\\n        return {'error': 'File type not allowed'}, 400\\r\\n\\r\\n    # Check if the file size is within the limit\\r\\n    if file['file'].content_length > MAX_FILE_SIZE:\\r\\n        return {'error': 'File size exceeds the limit'}, 400\\r\\n\\r\\n    filename = secure_filename(file['file'].filename)\\r\\n    uploads_dir = os.path.join(os.getcwd(), 'uploads')\\r\\n    os.makedirs(uploads_dir, exist_ok=True)\\r\\n    filepath = os.path.join(uploads_dir, filename)\\r\\n\\r\\n    # Save the file to the uploads folder\\r\\n    file['file'].save(filepath)\\r\\n\\r\\n    try:\\r\\n        # Connect to the MySQL database\\r\\n        cnx = mysql.connector.connect(user=DB_USER, password=DB_PASSWORD,\\r\\n                                      host=DB_HOST, database=DB_NAME)\\r\\n        cursor = cnx.cursor()\\r\\n\\r\\n        # Parameterized query to prevent SQL injection\\r\\n        insert_query = \"INSERT INTO pdf_files (filepath) VALUES (%s)\"\\r\\n        cursor.execute(insert_query, (filepath,))\\r\\n        cnx.commit()\\r\\n\\r\\n        return {'message': 'File uploaded successfully'}, 200\\r\\n    except mysql.connector.Error as err:\\r\\n        if err.errno == errorcode.ER_ACCESS_DENIED_ERROR:\\r\\n            return {'error': 'Database access denied'}, 500\\r\\n        else:\\r\\n            return {'error': str(err)}, 500\\r\\n    finally:\\r\\n        if 'cursor' in locals():\\r\\n            cursor.close()\\r\\n        if 'cnx' in locals():\\r\\n            cnx.close()\\r\\n\\r\\n# Example usage\\r\\npdf_file = {'file': open('example.pdf', 'rb')}\\r\\nresponse, status_code = upload_pdf(pdf_file)\\r\\nprint(response)", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: The upload_pdf() function is called when the user uploads a pdf file. The pdf file is saved in the uploads folder. The filepath of the pdf file is saved in the mysql database. The filepath is then used to download the pdf file.", "BP": "Input Validation, File Handling, Error Handling, Principle of Least Privilege, Access Control, Parameterized Queries.", "code": "import os\\r\\nfrom flask import Flask, request, send_from_directory, abort, jsonify\\r\\nfrom werkzeug.utils import secure_filename\\r\\nimport pymysql\\r\\nimport logging\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['UPLOAD_FOLDER'] = 'uploads'\\r\\napp.config['ALLOWED_EXTENSIONS'] = {'pdf'}\\r\\n\\r\\n# Database configuration\\r\\nDB_HOST = 'localhost'\\r\\nDB_USER = 'user'\\r\\nDB_PASSWORD = 'password'\\r\\nDB_NAME = 'database'\\r\\n\\r\\n# Initialize logging\\r\\nlogging.basicConfig(level=logging.INFO)\\r\\n\\r\\n# Ensure the upload directory exists\\r\\nos.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)\\r\\n\\r\\n# Allowed file extension check\\r\\ndef allowed_file(filename):\\r\\n    return '.' in filename and \\\\r\\n           filename.rsplit('.', 1)[1].lower() in app.config['ALLOWED_EXTENSIONS']\\r\\n\\r\\n# Connect to the database\\r\\ndef get_db_connection():\\r\\n    return pymysql.connect(\\r\\n        host=DB_HOST,\\r\\n        user=DB_USER,\\r\\n        password=DB_PASSWORD,\\r\\n        database=DB_NAME,\\r\\n        cursorclass=pymysql.cursors.DictCursor\\r\\n    )\\r\\n\\r\\n@app.route('/upload', methods=['POST'])\\r\\ndef upload_pdf():\\r\\n    # Check if a file part is present\\r\\n    if 'file' not in request.files:\\r\\n        return jsonify({'error': 'No file part in the request'}), 400\\r\\n\\r\\n    file = request.files['file']\\r\\n\\r\\n    # Check if a file is selected\\r\\n    if file.filename == '':\\r\\n        return jsonify({'error': 'No selected file'}), 400\\r\\n\\r\\n    if file and allowed_file(file.filename):\\r\\n        filename = secure_filename(file.filename)\\r\\n        file_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)\\r\\n\\r\\n        try:\\r\\n            # Save the file\\r\\n            file.save(file_path)\\r\\n            logging.info(f\"File saved to {file_path}\")\\r\\n\\r\\n            # Save the file path in the database\\r\\n            connection = get_db_connection()\\r\\n            with connection.cursor() as cursor:\\r\\n                sql = \"INSERT INTO pdf_files (file_path) VALUES (%s)\"\\r\\n                cursor.execute(sql, (file_path,))\\r\\n                connection.commit()\\r\\n                logging.info(f\"File path saved in database: {file_path}\")\\r\\n            connection.close()\\r\\n\\r\\n            return jsonify({'message': 'File uploaded successfully', 'file_path': file_path}), 200\\r\\n\\r\\n        except Exception as e:\\r\\n            logging.error(f\"Error during file upload: {e}\")\\r\\n            return jsonify({'error': 'Internal server error'}), 500\\r\\n\\r\\n    return jsonify({'error': 'Invalid file type'}), 400\\r\\n\\r\\n@app.route('/download/<int:file_id>', methods=['GET'])\\r\\ndef download_pdf(file_id):\\r\\n    try:\\r\\n        connection = get_db_connection()\\r\\n        with connection.cursor() as cursor:\\r\\n            sql = \"SELECT file_path FROM pdf_files WHERE id = %s\"\\r\\n            cursor.execute(sql, (file_id,))\\r\\n            result = cursor.fetchone()\\r\\n\\r\\n            if result is None:\\r\\n                connection.close()\\r\\n                return jsonify({'error': 'File not found'}), 404\\r\\n\\r\\n            file_path = result['file_path']\\r\\n            connection.close()\\r\\n\\r\\n            # Ensure the file path is valid and within the uploads folder\\r\\n            if os.path.isfile(file_path) and os.path.dirname(file_path) == app.config['UPLOAD_FOLDER']:\\r\\n                return send_from_directory(app.config['UPLOAD_FOLDER'], os.path.basename(file_path), as_attachment=True)\\r\\n\\r\\n            return jsonify({'error': 'File not found'}), 404\\r\\n\\r\\n    except Exception as e:\\r\\n        logging.error(f\"Error during file download: {e}\")\\r\\n        return jsonify({'error': 'Internal server error'}), 500\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    # Run the Flask app\\r\\n    app.run(debug=True)", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: The upload_pdf() function is called when the user uploads a pdf file. The pdf file is saved in the uploads folder. The filepath of the pdf file is saved in the mysql database. The filepath is then used to download the pdf file.", "BP": "Input Validation, File Handling, Error Handling, Principle of Least Privilege, Access Control, Parameterized Queries.", "code": "import os\\r\\nimport mysql.connector\\r\\nfrom werkzeug.utils import secure_filename\\r\\nfrom flask import Flask, request, send_from_directory\\r\\n\\r\\napp = Flask(__name__)\\r\\nUPLOAD_FOLDER = 'uploads'\\r\\nALLOWED_EXTENSIONS = {'pdf'}\\r\\n\\r\\n# Database configuration\\r\\ndb_config = {\\r\\n    'user': 'your_db_user',\\r\\n    'password': 'your_db_password',\\r\\n    'host': 'localhost',\\r\\n    'database': 'your_database_name',\\r\\n    'raise_on_warnings': True\\r\\n}\\r\\n\\r\\n# Ensure the upload folder exists\\r\\nos.makedirs(UPLOAD_FOLDER, exist_ok=True)\\r\\n\\r\\ndef allowed_file(filename):\\r\\n    return '.' in filename and \\\\r\\n           filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\\r\\n\\r\\ndef save_file_path_to_db(filepath):\\r\\n    try:\\r\\n        conn = mysql.connector.connect(**db_config)\\r\\n        cursor = conn.cursor()\\r\\n        query = \"INSERT INTO pdf_files (filepath) VALUES (%s)\"\\r\\n        cursor.execute(query, (filepath,))\\r\\n        conn.commit()\\r\\n    except mysql.connector.Error as err:\\r\\n        print(f\"Error: {err}\")\\r\\n    finally:\\r\\n        cursor.close()\\r\\n        conn.close()\\r\\n\\r\\n@app.route('/upload', methods=['POST'])\\r\\ndef upload_pdf():\\r\\n    if 'file' not in request.files:\\r\\n        return \"No file part\", 400\\r\\n    file = request.files['file']\\r\\n    if file.filename == '':\\r\\n        return \"No selected file\", 400\\r\\n    if file and allowed_file(file.filename):\\r\\n        filename = secure_filename(file.filename)\\r\\n        filepath = os.path.join(UPLOAD_FOLDER, filename)\\r\\n        try:\\r\\n            file.save(filepath)\\r\\n            save_file_path_to_db(filepath)\\r\\n            return \"File successfully uploaded\", 200\\r\\n        except Exception as e:\\r\\n            return f\"An error occurred: {e}\", 500\\r\\n    else:\\r\\n        return \"File type not allowed\", 400\\r\\n\\r\\n@app.route('/downloads/<filename>')\\r\\ndef download_pdf(filename):\\r\\n    filename = secure_filename(filename)\\r\\n    try:\\r\\n        return send_from_directory(UPLOAD_FOLDER, filename)\\r\\n    except Exception as e:\\r\\n        return f\"An error occurred: {e}\", 500\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: There is a form in an html page that allows the user to upload a pdf file. There is a web server that is running on the user's localhost. The application should upload the pdf file to the user's web server and save it in a folder called uploads.", "BP": "Allowed File Extensions, Secure Filename Generation, File Existence and Emptiness Checks, Allowed File Type Check, Folder-based Storage, Error Handling.", "code": "import os\\r\\nfrom flask import Flask, request, redirect, url_for, render_template\\r\\nfrom werkzeug.utils import secure_filename\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Set the allowed file extensions\\r\\nALLOWED_EXTENSIONS = {'pdf'}\\r\\n\\r\\n# Set the upload folder path\\r\\nUPLOAD_FOLDER = 'uploads'\\r\\n\\r\\n# Create the upload folder if it doesn't exist\\r\\nos.makedirs(UPLOAD_FOLDER, exist_ok=True)\\r\\n\\r\\ndef allowed_file(filename):\\r\\n    \"\"\"Check if the file extension is allowed\"\"\"\\r\\n    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\\r\\n\\r\\n@app.route('/', methods=['GET', 'POST'])\\r\\ndef upload_file():\\r\\n    if request.method == 'POST':\\r\\n        # Check if the file was uploaded\\r\\n        if 'file' not in request.files:\\r\\n            return render_template('upload.html', error='No file uploaded.')\\r\\n\\r\\n        file = request.files['file']\\r\\n\\r\\n        # Check if the file is empty\\r\\n        if file.filename == '':\\r\\n            return render_template('upload.html', error='No file selected.')\\r\\n\\r\\n        # Check if the file extension is allowed\\r\\n        if not allowed_file(file.filename):\\r\\n            return render_template('upload.html', error='File type not allowed.')\\r\\n\\r\\n        # Generate a secure filename\\r\\n        filename = secure_filename(file.filename)\\r\\n\\r\\n        # Check if the file already exists in the upload folder\\r\\n        file_path = os.path.join(UPLOAD_FOLDER, filename)\\r\\n        if os.path.exists(file_path):\\r\\n            return render_template('upload.html', error='File already exists.')\\r\\n\\r\\n        try:\\r\\n            # Save the file to the upload folder\\r\\n            file.save(file_path)\\r\\n            return render_template('upload.html', success=f'File {filename} uploaded successfully.')\\r\\n        except Exception as e:\\r\\n            # Handle any exceptions that occurred during file saving\\r\\n            return render_template('upload.html', error=f'An error occurred: {str(e)}')\\r\\n\\r\\n    return render_template('upload.html')\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: There is a form in an html page that allows the user to upload a pdf file. There is a web server that is running on the user's localhost. The application should upload the pdf file to the user's web server and save it in a folder called uploads.", "BP": "Allowed File Extensions, Secure Filename Generation, File Existence and Emptiness Checks, Allowed File Type Check, Folder-based Storage, Error Handling.", "code": "# app.py\\r\\nfrom flask import Flask, request, redirect, render_template, flash, url_for\\r\\nfrom werkzeug.utils import secure_filename\\r\\nimport os\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.secret_key = 'supersecretkey'  # Required for flash messages\\r\\napp.config['UPLOAD_FOLDER'] = 'uploads/'\\r\\napp.config['ALLOWED_EXTENSIONS'] = {'pdf'}\\r\\n\\r\\nif not os.path.exists(app.config['UPLOAD_FOLDER']):\\r\\n    os.makedirs(app.config['UPLOAD_FOLDER'])\\r\\n\\r\\ndef allowed_file(filename):\\r\\n    return '.' in filename and \\\\r\\n           filename.rsplit('.', 1)[1].lower() in app.config['ALLOWED_EXTENSIONS']\\r\\n\\r\\n@app.route('/')\\r\\ndef index():\\r\\n    return render_template('upload.html')\\r\\n\\r\\n@app.route('/upload', methods=['POST'])\\r\\ndef upload_file():\\r\\n    if 'file' not in request.files:\\r\\n        flash('No file part')\\r\\n        return redirect(request.url)\\r\\n\\r\\n    file = request.files['file']\\r\\n\\r\\n    if file.filename == '':\\r\\n        flash('No selected file')\\r\\n        return redirect(request.url)\\r\\n\\r\\n    if file and allowed_file(file.filename):\\r\\n        filename = secure_filename(file.filename)\\r\\n\\r\\n        file_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)\\r\\n        if os.path.exists(file_path):\\r\\n            flash('File already exists')\\r\\n            return redirect(request.url)\\r\\n\\r\\n        file.save(file_path)\\r\\n        flash('File successfully uploaded')\\r\\n        return redirect(url_for('index'))\\r\\n    else:\\r\\n        flash('Invalid file type')\\r\\n        return redirect(request.url)\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: There is a form in an html page that allows the user to upload a pdf file. There is a web server that is running on the user's localhost. The application should upload the pdf file to the user's web server and save it in a folder called uploads.", "BP": "Allowed File Extensions, Secure Filename Generation, File Existence and Emptiness Checks, Allowed File Type Check, Folder-based Storage, Error Handling.", "code": "from flask import Flask, request, redirect, url_for, flash\\r\\nfrom werkzeug.utils import secure_filename\\r\\nimport os\\r\\nimport magic\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['UPLOAD_FOLDER'] = 'uploads'\\r\\napp.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024  # 16 MB limit\\r\\napp.config['ALLOWED_EXTENSIONS'] = {'pdf'}\\r\\n\\r\\n# Ensure upload folder exists\\r\\nos.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)\\r\\n\\r\\ndef allowed_file(filename):\\r\\n    return '.' in filename and \\\\r\\n           filename.rsplit('.', 1)[1].lower() in app.config['ALLOWED_EXTENSIONS']\\r\\n\\r\\ndef allowed_file_type(file_path):\\r\\n    mime = magic.Magic(mime=True)\\r\\n    file_mime = mime.from_file(file_path)\\r\\n    # Check if the MIME type is PDF\\r\\n    return file_mime == 'application/pdf'\\r\\n\\r\\n@app.route('/', methods=['GET', 'POST'])\\r\\ndef upload_file():\\r\\n    if request.method == 'POST':\\r\\n        # Check if the post request has the file part\\r\\n        if 'file' not in request.files:\\r\\n            flash('No file part')\\r\\n            return redirect(request.url)\\r\\n        file = request.files['file']\\r\\n        # If the user does not select a file, the browser submits an\\r\\n        # empty file without a filename.\\r\\n        if file.filename == '':\\r\\n            flash('No selected file')\\r\\n            return redirect(request.url)\\r\\n        if file and allowed_file(file.filename):\\r\\n            filename = secure_filename(file.filename)\\r\\n            file_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)\\r\\n            # Check if file already exists\\r\\n            if os.path.exists(file_path):\\r\\n                flash('File already exists')\\r\\n                return redirect(request.url)\\r\\n            # Save file to disk to check its MIME type\\r\\n            file.save(file_path)\\r\\n            if not allowed_file_type(file_path):\\r\\n                os.remove(file_path)  # Remove the file if it's not a PDF\\r\\n                flash('Invalid file type')\\r\\n                return redirect(request.url)\\r\\n            return redirect(url_for('upload_file', filename=filename))\\r\\n    return '''\\r\\n    <!doctype html>\\r\\n    <title>Upload new File</title>\\r\\n    <h1>Upload new PDF</h1>\\r\\n    <form method=post enctype=multipart/form-data>\\r\\n      <input type=file name=file>\\r\\n      <input type=submit value=Upload>\\r\\n    </form>\\r\\n    '''\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: There is a web app that accepts a pdf file and saves it in a folder called uploads.", "BP": "User Authentication, File Access Control, File Deletion, Logging and Monitoring, Input Validation, Secure Configuration, Allowed File Extensions, Proxy Fix, Secure Filename, File Path Construction, Error Handling, CSRF Protection, Secure Headers.", "code": "import os\\r\\nimport logging\\r\\nimport hashlib\\r\\nfrom werkzeug.utils import secure_filename\\r\\nfrom flask import Flask, request, redirect, render_template, session\\r\\nfrom flask_wtf.csrf import CSRFProtect\\r\\n\\r\\n# Set up logging\\r\\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\\r\\n\\r\\n# Create Flask app\\r\\napp = Flask(__name__)\\r\\napp.secret_key = os.urandom(24)  # Generate a secure secret key\\r\\ncsrf = CSRFProtect(app)  # Enable CSRF protection\\r\\n\\r\\n# Set up allowed file extensions\\r\\nALLOWED_EXTENSIONS = {'pdf'}\\r\\n\\r\\n# Configure secure headers\\r\\n@app.after_request\\r\\ndef set_secure_headers(response):\\r\\n    response.headers['X-Frame-Options'] = 'DENY'\\r\\n    response.headers['X-Content-Type-Options'] = 'nosniff'\\r\\n    response.headers['X-XSS-Protection'] = '1; mode=block'\\r\\n    response.headers['Strict-Transport-Security'] = 'max-age=31536000; includeSubDomains'\\r\\n    return response\\r\\n\\r\\n# Check if the file extension is allowed\\r\\ndef allowed_file(filename):\\r\\n    return '.' in filename and \\\\r\\n           filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\\r\\n\\r\\n# User authentication function (replace with your authentication logic)\\r\\ndef authenticate_user(username, password):\\r\\n    # Check if the user exists and the password is correct\\r\\n    # Return True if the user is authenticated, False otherwise\\r\\n    pass\\r\\n\\r\\n# File access control\\r\\ndef has_access(user, file_path):\\r\\n    # Check if the user has access to the file\\r\\n    # Return True if the user has access, False otherwise\\r\\n    pass\\r\\n\\r\\n# File deletion function\\r\\ndef delete_file(file_path):\\r\\n    try:\\r\\n        os.remove(file_path)\\r\\n        logging.info(f'File {file_path} deleted successfully')\\r\\n    except Exception as e:\\r\\n        logging.error(f'Error deleting file {file_path}: {e}')\\r\\n\\r\\n# Proxy fix (if running behind a proxy)\\r\\n@app.before_request\\r\\ndef proxy_fix():\\r\\n    if request.headers.getlist(\"X-Forwarded-For\"):\\r\\n        request.remote_addr = request.headers.getlist(\"X-Forwarded-For\")[0]\\r\\n\\r\\n@app.route('/upload', methods=['GET', 'POST'])\\r\\ndef upload_file():\\r\\n    if 'user_id' not in session:\\r\\n        # Redirect to login page if the user is not authenticated\\r\\n        return redirect('/login')\\r\\n\\r\\n    if request.method == 'POST':\\r\\n        # Check if the POST request has a file\\r\\n        if 'file' not in request.files:\\r\\n            logging.error('No file received')\\r\\n            return render_template('error.html', error='No file received'), 400\\r\\n\\r\\n        file = request.files['file']\\r\\n\\r\\n        # Check if the file has a valid filename\\r\\n        if file.filename == '':\\r\\n            logging.error('No file selected')\\r\\n            return render_template('error.html', error='No file selected'), 400\\r\\n\\r\\n        # Check if the file extension is allowed\\r\\n        if not allowed_file(file.filename):\\r\\n            logging.error(f'File extension not allowed: {file.filename}')\\r\\n            return render_template('error.html', error='File extension not allowed'), 400\\r\\n\\r\\n        # Generate a secure filename\\r\\n        filename = secure_filename(file.filename)\\r\\n\\r\\n        # Construct the file path securely\\r\\n        upload_folder = os.path.join(app.root_path, 'uploads')\\r\\n        os.makedirs(upload_folder, exist_ok=True)\\r\\n        file_path = os.path.join(upload_folder, filename)\\r\\n\\r\\n        # Check if the user has access to the upload folder\\r\\n        if not has_access(session['user_id'], upload_folder):\\r\\n            logging.error('User does not have access to the upload folder')\\r\\n            return render_template('error.html', error='Access denied'), 403\\r\\n\\r\\n        try:\\r\\n            # Save the file securely\\r\\n            file.save(file_path)\\r\\n            logging.info(f'File {file_path} uploaded successfully')\\r\\n        except Exception as e:\\r\\n            logging.error(f'Error uploading file: {e}')\\r\\n            return render_template('error.html', error='Error uploading file'), 500\\r\\n\\r\\n        # Log the file upload event\\r\\n        logging.info(f'User {session[\"user_id\"]} uploaded file {file_path}')\\r\\n\\r\\n        return render_template('success.html', message='File uploaded successfully')\\r\\n\\r\\n    return render_template('upload.html')\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        username = request.form['username']\\r\\n        password = request.form['password']\\r\\n\\r\\n        # Validate user input\\r\\n        if not username or not password:\\r\\n            logging.error('Invalid username or password')\\r\\n            return render_template('error.html', error='Invalid username or password'), 400\\r\\n\\r\\n        # Authenticate the user\\r\\n        if authenticate_user(username, password):\\r\\n            session['user_id'] = hashlib.sha256(username.encode()).hexdigest()\\r\\n            return redirect('/upload')\\r\\n        else:\\r\\n            logging.error('Invalid username or password')\\r\\n            return render_template('error.html', error='Invalid username or password'), 401\\r\\n\\r\\n    return render_template('login.html')\\r\\n\\r\\n@app.errorhandler(Exception)\\r\\ndef handle_exception(e):\\r\\n    logging.error(f'An error occurred: {e}')\\r\\n    return render_template('error.html', error='An error occurred'), 500\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=False)", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: There is a web app that accepts a pdf file and saves it in a folder called uploads.", "BP": "User Authentication, File Access Control, File Deletion, Logging and Monitoring, Input Validation, Secure Configuration, Allowed File Extensions, Proxy Fix, Secure Filename, File Path Construction, Error Handling, CSRF Protection, Secure Headers.", "code": "from flask import Flask, render_template, redirect, url_for, request, flash, send_from_directory\\r\\nfrom flask_login import LoginManager, login_user, login_required, logout_user, current_user\\r\\nfrom werkzeug.utils import secure_filename\\r\\nfrom flask_talisman import Talisman\\r\\nfrom werkzeug.middleware.proxy_fix import ProxyFix\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nfrom models import db, User\\r\\nfrom forms import LoginForm, UploadForm\\r\\nfrom config import Config\\r\\nimport os\\r\\nimport logging\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config.from_object(Config)\\r\\n\\r\\n# Secure Headers\\r\\nTalisman(app)\\r\\n\\r\\n# Proxy Fix\\r\\napp.wsgi_app = ProxyFix(app.wsgi_app, x_for=1, x_proto=1, x_host=1, x_port=1, x_prefix=1)\\r\\n\\r\\n# Rate Limiting\\r\\nlimiter = Limiter(\\r\\n    get_remote_address,\\r\\n    app=app,\\r\\n    default_limits=[\"200 per day\", \"50 per hour\"]\\r\\n)\\r\\n\\r\\n# Logging\\r\\nlogging.basicConfig(filename='logs/app.log', level=logging.INFO)\\r\\n\\r\\n# Database\\r\\ndb.init_app(app)\\r\\n\\r\\n# Login Manager\\r\\nlogin_manager = LoginManager()\\r\\nlogin_manager.init_app(app)\\r\\nlogin_manager.login_view = 'login'\\r\\n\\r\\n@login_manager.user_loader\\r\\ndef load_user(user_id):\\r\\n    return User.query.get(int(user_id))\\r\\n\\r\\n# Helper function to check allowed file extensions\\r\\ndef allowed_file(filename):\\r\\n    return '.' in filename and filename.rsplit('.', 1)[1].lower() in app.config['ALLOWED_EXTENSIONS']\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    form = LoginForm()\\r\\n    if form.validate_on_submit():\\r\\n        user = User.query.filter_by(username=form.username.data).first()\\r\\n        if user and user.password == form.password.data:  # For simplicity; use hashed passwords in production\\r\\n            login_user(user)\\r\\n            flash('Logged in successfully.', 'success')\\r\\n            return redirect(url_for('upload'))\\r\\n        flash('Invalid username or password', 'danger')\\r\\n    return render_template('login.html', form=form)\\r\\n\\r\\n@app.route('/logout')\\r\\n@login_required\\r\\ndef logout():\\r\\n    logout_user()\\r\\n    flash('Logged out successfully.', 'success')\\r\\n    return redirect(url_for('login'))\\r\\n\\r\\n@app.route('/upload', methods=['GET', 'POST'])\\r\\n@login_required\\r\\n@limiter.limit(\"10 per minute\")  # Limiting uploads to 10 per minute\\r\\ndef upload():\\r\\n    form = UploadForm()\\r\\n    if form.validate_on_submit():\\r\\n        file = form.file.data\\r\\n        if file and allowed_file(file.filename):\\r\\n            filename = secure_filename(file.filename)\\r\\n            file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename))\\r\\n            flash('File successfully uploaded', 'success')\\r\\n        else:\\r\\n            flash('Invalid file extension', 'danger')\\r\\n    return render_template('upload.html', form=form)\\r\\n\\r\\n@app.route('/uploads/<filename>')\\r\\n@login_required\\r\\ndef uploaded_file(filename):\\r\\n    return send_from_directory(app.config['UPLOAD_FOLDER'], filename)\\r\\n\\r\\n@app.route('/delete/<filename>', methods=['POST'])\\r\\n@login_required\\r\\ndef delete_file(filename):\\r\\n    filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)\\r\\n    if os.path.exists(filepath):\\r\\n        os.remove(filepath)\\r\\n        flash('File successfully deleted', 'success')\\r\\n    else:\\r\\n        flash('File not found', 'danger')\\r\\n    return redirect(url_for('upload'))\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=False, host='0.0.0.0', port=5000)", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: There is a web app that accepts a pdf file and saves it in a folder called uploads.", "BP": "User Authentication, File Access Control, File Deletion, Logging and Monitoring, Input Validation, Secure Configuration, Allowed File Extensions, Proxy Fix, Secure Filename, File Path Construction, Error Handling, CSRF Protection, Secure Headers.", "code": "from flask import Flask, request, redirect, url_for, send_from_directory, abort\\r\\nfrom flask_login import LoginManager, UserMixin, login_user, logout_user, login_required\\r\\nfrom werkzeug.utils import secure_filename\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import FileField, SubmitField\\r\\nfrom wtforms.validators import DataRequired\\r\\nfrom flask_talisman import Talisman\\r\\nfrom werkzeug.middleware.proxy_fix import ProxyFix\\r\\nimport os\\r\\nimport logging\\r\\n\\r\\n# Initialize Flask app\\r\\napp = Flask(__name__)\\r\\napp.config['SECRET_KEY'] = 'your_secret_key'\\r\\napp.config['UPLOAD_FOLDER'] = 'uploads'\\r\\napp.config['ALLOWED_EXTENSIONS'] = {'pdf'}\\r\\napp.wsgi_app = ProxyFix(app.wsgi_app)\\r\\nTalisman(app)\\r\\n\\r\\n# Setup logging\\r\\nlogging.basicConfig(level=logging.INFO)\\r\\n\\r\\n# Initialize Flask-Login\\r\\nlogin_manager = LoginManager()\\r\\nlogin_manager.init_app(app)\\r\\n\\r\\n# User Authentication Setup\\r\\nclass User(UserMixin):\\r\\n    pass\\r\\n\\r\\n@login_manager.user_loader\\r\\ndef user_loader(user_id):\\r\\n    user = User()\\r\\n    user.id = user_id\\r\\n    return user\\r\\n\\r\\n# File Upload Handling\\r\\ndef allowed_file(filename):\\r\\n    return '.' in filename and filename.rsplit('.', 1)[1].lower() in app.config['ALLOWED_EXTENSIONS']\\r\\n\\r\\n@app.route('/upload', methods=['GET', 'POST'])\\r\\n@login_required\\r\\ndef upload_file():\\r\\n    if request.method == 'POST':\\r\\n        file = request.files['file']\\r\\n        if file and allowed_file(file.filename):\\r\\n            filename = secure_filename(file.filename)\\r\\n            file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename))\\r\\n            return redirect(url_for('uploaded_file', filename=filename))\\r\\n    return '''\\r\\n    <!doctype html>\\r\\n    <title>Upload new File</title>\\r\\n    <h1>Upload new File</h1>\\r\\n    <form method=post enctype=multipart/form-data>\\r\\n      <input type=file name=file>\\r\\n      <input type=submit value=Upload>\\r\\n    </form>\\r\\n    '''\\r\\n\\r\\n@app.route('/uploads/<filename>')\\r\\n@login_required\\r\\ndef uploaded_file(filename):\\r\\n    return send_from_directory(app.config['UPLOAD_FOLDER'], filename)\\r\\n\\r\\n# File Deletion\\r\\n@app.route('/delete/<filename>', methods=['POST'])\\r\\n@login_required\\r\\ndef delete_file(filename):\\r\\n    secure_path = secure_filename(filename)\\r\\n    file_path = os.path.join(app.config['UPLOAD_FOLDER'], secure_path)\\r\\n    if os.path.exists(file_path):\\r\\n        os.remove(file_path)\\r\\n        return 'File deleted'\\r\\n    else:\\r\\n        abort(404)\\r\\n\\r\\n# Error Handling\\r\\n@app.errorhandler(404)\\r\\ndef page_not_found(e):\\r\\n    return '404 Not Found', 404\\r\\n\\r\\n# CSRF Protection is enabled by default with Flask-WTF when the SECRET_KEY is set\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(ssl_context='adhoc')  # Use adhoc SSL for demonstration purposes", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: The code is a simple script that accepts an image file and stores it in a MySQL database.", "BP": "Input Validation, Parameterized Queries, Error Handling, Secure File Access.", "code": "import os\\r\\nimport mysql.connector\\r\\nfrom mysql.connector import errorcode\\r\\n\\r\\n# Database configuration\\r\\nDB_HOST = \"your_db_host\"\\r\\nDB_USER = \"your_db_user\"\\r\\nDB_PASSWORD = \"your_db_password\"\\r\\nDB_NAME = \"your_db_name\"\\r\\n\\r\\n# Allowed file extensions and maximum file size\\r\\nALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'gif'}\\r\\nMAX_FILE_SIZE = 5 * 1024 * 1024  # 5 MB\\r\\n\\r\\ndef allowed_file(filename):\\r\\n    \"\"\"\\r\\n    Checks if the uploaded file has an allowed extension.\\r\\n    \"\"\"\\r\\n    return '.' in filename and \\\\r\\n           filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\\r\\n\\r\\ndef store_image_in_db(file):\\r\\n    \"\"\"\\r\\n    Stores the image file in the MySQL database.\\r\\n    \"\"\"\\r\\n    try:\\r\\n        # Connect to the MySQL database\\r\\n        cnx = mysql.connector.connect(host=DB_HOST, user=DB_USER, password=DB_PASSWORD, database=DB_NAME)\\r\\n        cursor = cnx.cursor()\\r\\n\\r\\n        # Read the file contents\\r\\n        file_data = file.read()\\r\\n\\r\\n        # Insert the image data into the database using a parameterized query\\r\\n        insert_query = \"INSERT INTO images (image_data) VALUES (%s)\"\\r\\n        cursor.execute(insert_query, (file_data,))\\r\\n        cnx.commit()\\r\\n\\r\\n        print(\"Image stored successfully in the database.\")\\r\\n\\r\\n    except mysql.connector.Error as err:\\r\\n        if err.errno == errorcode.ER_ACCESS_DENIED_ERROR:\\r\\n            print(\"Something is wrong with your user name or password\")\\r\\n        elif err.errno == errorcode.ER_BAD_DB_ERROR:\\r\\n            print(\"Database does not exist\")\\r\\n        else:\\r\\n            print(err)\\r\\n    finally:\\r\\n        if 'cnx' in locals():\\r\\n            cnx.close()\\r\\n\\r\\ndef main():\\r\\n    # Get the uploaded file from the request\\r\\n    uploaded_file = request.files['image_file']\\r\\n\\r\\n    # Validate the uploaded file\\r\\n    if uploaded_file and allowed_file(uploaded_file.filename):\\r\\n        file_size = len(uploaded_file.read())\\r\\n        uploaded_file.seek(0)  # Reset the file pointer\\r\\n\\r\\n        if file_size <= MAX_FILE_SIZE:\\r\\n            store_image_in_db(uploaded_file)\\r\\n        else:\\r\\n            print(\"File size exceeds the maximum allowed size.\")\\r\\n    else:\\r\\n        print(\"Invalid file or file extension.\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: The code is a simple script that accepts an image file and stores it in a MySQL database.", "BP": "Input Validation, Parameterized Queries, Error Handling, Secure File Access.", "code": "import os\\r\\nimport mysql.connector\\r\\nfrom mysql.connector import Error\\r\\nfrom PIL import Image\\r\\n\\r\\ndef validate_image(file_path):\\r\\n    \"\"\"Validate if the file is a proper image.\"\"\"\\r\\n    try:\\r\\n        with Image.open(file_path) as img:\\r\\n            img.verify()\\r\\n        return True\\r\\n    except Exception as e:\\r\\n        print(f\"Image validation error: {e}\")\\r\\n        return False\\r\\n\\r\\ndef connect_to_database():\\r\\n    \"\"\"Create a connection to the MySQL database.\"\"\"\\r\\n    try:\\r\\n        connection = mysql.connector.connect(\\r\\n            host='localhost',\\r\\n            database='image_db',\\r\\n            user='your_username',\\r\\n            password='your_password'\\r\\n        )\\r\\n        if connection.is_connected():\\r\\n            return connection\\r\\n    except Error as e:\\r\\n        print(f\"Error while connecting to MySQL: {e}\")\\r\\n    return None\\r\\n\\r\\ndef store_image(file_path):\\r\\n    \"\"\"Store the image file in the MySQL database.\"\"\"\\r\\n    if not validate_image(file_path):\\r\\n        print(\"Invalid image file.\")\\r\\n        return\\r\\n    \\r\\n    connection = connect_to_database()\\r\\n    if connection is None:\\r\\n        print(\"Failed to connect to the database.\")\\r\\n        return\\r\\n    \\r\\n    try:\\r\\n        with open(file_path, 'rb') as file:\\r\\n            image_data = file.read()\\r\\n        \\r\\n        cursor = connection.cursor()\\r\\n        query = \"INSERT INTO images (image_name, image_data) VALUES (%s, %s)\"\\r\\n        cursor.execute(query, (os.path.basename(file_path), image_data))\\r\\n        connection.commit()\\r\\n        print(f\"Image {os.path.basename(file_path)} stored successfully.\")\\r\\n    \\r\\n    except Error as e:\\r\\n        print(f\"Error while storing the image: {e}\")\\r\\n    finally:\\r\\n        if connection.is_connected():\\r\\n            cursor.close()\\r\\n            connection.close()\\r\\n\\r\\ndef main():\\r\\n    file_path = input(\"Enter the path to the image file: \").strip()\\r\\n    if not os.path.isfile(file_path):\\r\\n        print(\"The file does not exist.\")\\r\\n        return\\r\\n    if not file_path.lower().endswith(('.png', '.jpg', '.jpeg', '.gif', '.bmp')):\\r\\n        print(\"Unsupported file format.\")\\r\\n        return\\r\\n\\r\\n    store_image(file_path)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: The code is a simple script that accepts an image file and stores it in a MySQL database.", "BP": "Input Validation, Parameterized Queries, Error Handling, Secure File Access.", "code": "import mysql.connector\\r\\nfrom mysql.connector import Error\\r\\nimport os\\r\\nfrom PIL import Image\\r\\n\\r\\ndef connect_to_database(host_name, user_name, user_password, db_name):\\r\\n    connection = None\\r\\n    try:\\r\\n        connection = mysql.connector.connect(\\r\\n            host=host_name,\\r\\n            user=user_name,\\r\\n            passwd=user_password,\\r\\n            database=db_name\\r\\n        )\\r\\n        print(\"Connection to MySQL DB successful\")\\r\\n    except Error as e:\\r\\n        print(f\"The error '{e}' occurred\")\\r\\n    return connection\\r\\n\\r\\ndef insert_image(connection, file_path):\\r\\n    cursor = connection.cursor()\\r\\n    try:\\r\\n        # Validate file path\\r\\n        if not os.path.isfile(file_path):\\r\\n            raise ValueError(\"File does not exist\")\\r\\n        \\r\\n        # Secure file access\\r\\n        with open(file_path, \"rb\") as file:\\r\\n            binary_data = file.read()\\r\\n            # Ensure the file is an image\\r\\n            try:\\r\\n                Image.open(file_path)\\r\\n            except IOError:\\r\\n                raise ValueError(\"The file is not a valid image\")\\r\\n            \\r\\n            # Parameterized query\\r\\n            query = \"INSERT INTO images (image_data) VALUES (%s)\"\\r\\n            cursor.execute(query, (binary_data,))\\r\\n            connection.commit()\\r\\n            print(\"Image inserted successfully\")\\r\\n    except Error as e:\\r\\n        print(f\"The error '{e}' occurred\")\\r\\n    except ValueError as ve:\\r\\n        print(ve)\\r\\n    finally:\\r\\n        cursor.close()\\r\\n\\r\\n# Example usage\\r\\nif __name__ == \"__main__\":\\r\\n    db_connection = connect_to_database(\"your_host\", \"your_username\", \"your_password\", \"your_db_name\")\\r\\n    if db_connection:\\r\\n        insert_image(db_connection, \"/path/to/your/image.jpg\")\\r\\n        db_connection.close()", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: The upload_image() function is called when the user uploads an image. The image is read and converted to base64. The image name and base64 string are inserted into the database.", "BP": "Secure Database Connection, Secure Table Creation, Secure Salt Generation, Secure Hashing, Prepared Statements for SQL Queries, Secure File Handling, Error Handling and Logging.", "code": "import os\\r\\nimport base64\\r\\nimport hashlib\\r\\nimport sqlite3\\r\\nfrom sqlite3 import Error\\r\\n\\r\\n# Database connection parameters\\r\\nDB_FILE = \"database.db\"\\r\\n\\r\\n# Salt for hashing\\r\\nSALT = os.urandom(16)\\r\\n\\r\\n# Create a secure connection to the database\\r\\ndef create_connection():\\r\\n    conn = None\\r\\n    try:\\r\\n        conn = sqlite3.connect(DB_FILE)\\r\\n        return conn\\r\\n    except Error as e:\\r\\n        print(f\"Error creating database connection: {e}\")\\r\\n        return None\\r\\n\\r\\n# Create a secure table for storing images\\r\\ndef create_table(conn):\\r\\n    try:\\r\\n        cursor = conn.cursor()\\r\\n        sql = \"\"\"\\r\\n            CREATE TABLE IF NOT EXISTS images (\\r\\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\\r\\n                name TEXT NOT NULL,\\r\\n                data BLOB NOT NULL\\r\\n            )\\r\\n        \"\"\"\\r\\n        cursor.execute(sql)\\r\\n        conn.commit()\\r\\n    except Error as e:\\r\\n        print(f\"Error creating table: {e}\")\\r\\n\\r\\n# Secure file handling and base64 encoding\\r\\ndef upload_image(file):\\r\\n    try:\\r\\n        # Read the file securely\\r\\n        with open(file, \"rb\") as f:\\r\\n            file_data = f.read()\\r\\n\\r\\n        # Convert the image to base64\\r\\n        base64_data = base64.b64encode(file_data)\\r\\n\\r\\n        # Get the file name securely\\r\\n        file_name = os.path.basename(file)\\r\\n\\r\\n        # Secure hashing of the file name\\r\\n        hash_name = hashlib.sha256(file_name.encode() + SALT).hexdigest()\\r\\n\\r\\n        # Insert the image into the database\\r\\n        conn = create_connection()\\r\\n        if conn:\\r\\n            insert_image(conn, hash_name, base64_data)\\r\\n            conn.close()\\r\\n    except Exception as e:\\r\\n        print(f\"Error uploading image: {e}\")\\r\\n        # Logging the error securely\\r\\n        log_error(e)\\r\\n\\r\\n# Secure SQL queries with prepared statements\\r\\ndef insert_image(conn, name, data):\\r\\n    sql = \"\"\"\\r\\n        INSERT INTO images (name, data)\\r\\n        VALUES (?, ?)\\r\\n    \"\"\"\\r\\n    try:\\r\\n        cursor = conn.cursor()\\r\\n        cursor.execute(sql, (name, data))\\r\\n        conn.commit()\\r\\n    except Error as e:\\r\\n        print(f\"Error inserting image: {e}\")\\r\\n        # Logging the error securely\\r\\n        log_error(e)\\r\\n\\r\\n# Secure error logging\\r\\ndef log_error(error):\\r\\n    log_file = \"error.log\"\\r\\n    try:\\r\\n        with open(log_file, \"a\") as f:\\r\\n            f.write(f\"{error}\\n\")\\r\\n    except Exception as e:\\r\\n        print(f\"Error logging error: {e}\")\\r\\n\\r\\n# Example usage\\r\\nif __name__ == \"__main__\":\\r\\n    image_path = \"example.jpg\"\\r\\n    upload_image(image_path)", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: The upload_image() function is called when the user uploads an image. The image is read and converted to base64. The image name and base64 string are inserted into the database.", "BP": "Secure Database Connection, Secure Table Creation, Secure Salt Generation, Secure Hashing, Prepared Statements for SQL Queries, Secure File Handling, Error Handling and Logging.", "code": "import base64\\r\\nimport sqlite3\\r\\nimport hashlib\\r\\nimport os\\r\\nimport logging\\r\\nfrom werkzeug.utils import secure_filename\\r\\nfrom contextlib import closing\\r\\n\\r\\n# Configure logging\\r\\nlogging.basicConfig(filename='image_upload.log', level=logging.INFO,\\r\\n                    format='%(asctime)s:%(levelname)s:%(message)s')\\r\\n\\r\\n# Database configuration\\r\\nDATABASE = 'secure_image_upload.db'\\r\\n\\r\\n# Secure table creation\\r\\ndef create_table():\\r\\n    try:\\r\\n        with sqlite3.connect(DATABASE) as conn:\\r\\n            with closing(conn.cursor()) as cursor:\\r\\n                cursor.execute(\"\"\"\\r\\n                CREATE TABLE IF NOT EXISTS images (\\r\\n                    id INTEGER PRIMARY KEY,\\r\\n                    image_name TEXT NOT NULL,\\r\\n                    image_data BLOB NOT NULL,\\r\\n                    salt TEXT NOT NULL\\r\\n                )\\r\\n                \"\"\")\\r\\n                conn.commit()\\r\\n                logging.info('Table created successfully.')\\r\\n    except sqlite3.Error as e:\\r\\n        logging.error(f'Error creating table: {e}')\\r\\n\\r\\n# Function to generate a secure salt\\r\\ndef generate_salt():\\r\\n    return os.urandom(16)\\r\\n\\r\\n# Function to securely hash image data\\r\\ndef hash_image_data(image_data, salt):\\r\\n    hasher = hashlib.sha256()\\r\\n    hasher.update(salt + image_data)\\r\\n    return hasher.digest()\\r\\n\\r\\n# Function to handle image upload\\r\\ndef upload_image(image_path):\\r\\n    try:\\r\\n        # Secure file handling: ensure a valid and secure filename\\r\\n        filename = secure_filename(os.path.basename(image_path))\\r\\n        \\r\\n        # Read and encode image to base64\\r\\n        with open(image_path, 'rb') as image_file:\\r\\n            image_data = image_file.read()\\r\\n            image_b64 = base64.b64encode(image_data).decode('utf-8')\\r\\n        \\r\\n        # Generate salt and hash the image data\\r\\n        salt = generate_salt()\\r\\n        hashed_data = hash_image_data(image_data, salt)\\r\\n\\r\\n        # Insert into the database using prepared statements\\r\\n        with sqlite3.connect(DATABASE) as conn:\\r\\n            with closing(conn.cursor()) as cursor:\\r\\n                cursor.execute(\"\"\"\\r\\n                INSERT INTO images (image_name, image_data, salt) \\r\\n                VALUES (?, ?, ?)\\r\\n                \"\"\", (filename, hashed_data, salt))\\r\\n                conn.commit()\\r\\n                logging.info(f'Image {filename} uploaded and stored successfully.')\\r\\n    except (sqlite3.Error, IOError) as e:\\r\\n        logging.error(f'Error during image upload: {e}')\\r\\n        print(f'An error occurred: {e}')\\r\\n\\r\\n# Run table creation on script execution\\r\\nif __name__ == \"__main__\":\\r\\n    create_table()", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: The upload_image() function is called when the user uploads an image. The image is read and converted to base64. The image name and base64 string are inserted into the database.", "BP": "Secure Database Connection, Secure Table Creation, Secure Salt Generation, Secure Hashing, Prepared Statements for SQL Queries, Secure File Handling, Error Handling and Logging.", "code": "import base64\\r\\nimport os\\r\\nimport sqlite3\\r\\nfrom sqlite3 import Error\\r\\nimport hashlib\\r\\nimport logging\\r\\nimport binascii\\r\\n\\r\\n# Configure logging\\r\\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\\r\\n\\r\\ndef create_connection(db_file):\\r\\n    \"\"\"Create a database connection to a SQLite database\"\"\"\\r\\n    conn = None\\r\\n    try:\\r\\n        conn = sqlite3.connect(db_file)\\r\\n        return conn\\r\\n    except Error as e:\\r\\n        logging.error(f\"Error connecting to database: {e}\")\\r\\n    return conn\\r\\n\\r\\ndef create_table(conn):\\r\\n    \"\"\"Create a table if it doesn't already exist\"\"\"\\r\\n    try:\\r\\n        c = conn.cursor()\\r\\n        c.execute('''CREATE TABLE IF NOT EXISTS images\\r\\n                     (id INTEGER PRIMARY KEY, name TEXT, image_data TEXT)''')\\r\\n    except Error as e:\\r\\n        logging.error(f\"Error creating table: {e}\")\\r\\n\\r\\ndef secure_salt_generation():\\r\\n    \"\"\"Generate a secure salt\"\"\"\\r\\n    return os.urandom(16)\\r\\n\\r\\ndef secure_hashing(data, salt):\\r\\n    \"\"\"Generate a secure hash for the given data using the provided salt\"\"\"\\r\\n    return hashlib.pbkdf2_hmac('sha256', data.encode(), salt, 100000)\\r\\n\\r\\ndef insert_image(conn, name, image_data):\\r\\n    \"\"\"Insert an image into the database securely\"\"\"\\r\\n    try:\\r\\n        c = conn.cursor()\\r\\n        # Securely generate salt and hash the image data\\r\\n        salt = secure_salt_generation()\\r\\n        hashed_image_data = secure_hashing(image_data, salt)\\r\\n        # Convert the hashed image data to a storable format\\r\\n        storable_image_data = binascii.hexlify(hashed_image_data).decode()\\r\\n        # Use a prepared statement to securely insert data\\r\\n        c.execute(\"INSERT INTO images (name, image_data) VALUES (?, ?)\", (name, storable_image_data))\\r\\n        conn.commit()\\r\\n    except Error as e:\\r\\n        logging.error(f\"Error inserting image into database: {e}\")\\r\\n\\r\\ndef read_and_convert_image_to_base64(image_path):\\r\\n    \"\"\"Read an image and convert it to base64\"\"\"\\r\\n    try:\\r\\n        with open(image_path, \"rb\") as image_file:\\r\\n            return base64.b64encode(image_file.read()).decode()\\r\\n    except IOError as e:\\r\\n        logging.error(f\"Error reading image file: {e}\")\\r\\n        return None\\r\\n\\r\\ndef upload_image(image_path, db_path):\\r\\n    \"\"\"Main function to handle the upload and storage of an image\"\"\"\\r\\n    # Read and convert the image to base64\\r\\n    image_data = read_and_convert_image_to_base64(image_path)\\r\\n    if image_data is None:\\r\\n        return\\r\\n    # Extract image name\\r\\n    image_name = os.path.basename(image_path)\\r\\n    # Connect to the database\\r\\n    conn = create_connection(db_path)\\r\\n    if conn is not None:\\r\\n        create_table(conn)\\r\\n        insert_image(conn, image_name, image_data)\\r\\n        logging.info(f\"Image '{image_name}' uploaded successfully.\")\\r\\n        conn.close()\\r\\n    else:\\r\\n        logging.error(\"Failed to connect to the database.\")\\r\\n\\r\\n# Example usage\\r\\nif __name__ == \"__main__\":\\r\\n    upload_image(\"path/to/your/image.jpg\", \"path/to/your/database.db\")", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: The upload_image() function is called when the user uploads an image. The image is read and encoded using base64. The encoded image is written to a file.", "BP": "Allowed File Extensions, Secure Filename, Random Filename Generation, Separate Upload and Encoded Directories, Secure File Handling.", "code": "import os\\r\\nimport base64\\r\\nimport secrets\\r\\nfrom werkzeug.utils import secure_filename\\r\\n\\r\\n# Define allowed file extensions\\r\\nALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'gif'}\\r\\n\\r\\n# Define the upload directory\\r\\nUPLOAD_DIR = 'uploads'\\r\\n# Define the encoded directory\\r\\nENCODED_DIR = 'encoded'\\r\\n\\r\\n# Create the upload and encoded directories if they don't exist\\r\\nos.makedirs(UPLOAD_DIR, exist_ok=True)\\r\\nos.makedirs(ENCODED_DIR, exist_ok=True)\\r\\n\\r\\ndef allowed_file(filename):\\r\\n    \"\"\"\\r\\n    Check if the file extension is allowed.\\r\\n    \"\"\"\\r\\n    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\\r\\n\\r\\ndef upload_image(file):\\r\\n    \"\"\"\\r\\n    Upload an image file, encode it using base64, and save the encoded file.\\r\\n    \"\"\"\\r\\n    # Check if the file is allowed\\r\\n    if file and allowed_file(file.filename):\\r\\n        # Generate a random filename\\r\\n        random_filename = f\"{secrets.token_hex(16)}.{file.filename.rsplit('.', 1)[1].lower()}\"\\r\\n\\r\\n        # Save the original file to the upload directory\\r\\n        upload_path = os.path.join(UPLOAD_DIR, random_filename)\\r\\n        file.save(upload_path)\\r\\n\\r\\n        # Read the uploaded file\\r\\n        with open(upload_path, 'rb') as f:\\r\\n            file_data = f.read()\\r\\n\\r\\n        # Encode the file data using base64\\r\\n        encoded_data = base64.b64encode(file_data)\\r\\n\\r\\n        # Save the encoded file to the encoded directory\\r\\n        encoded_filename = f\"{secrets.token_hex(16)}.txt\"\\r\\n        encoded_path = os.path.join(ENCODED_DIR, encoded_filename)\\r\\n        with open(encoded_path, 'wb') as f:\\r\\n            f.write(encoded_data)\\r\\n\\r\\n        # Remove the original uploaded file\\r\\n        os.remove(upload_path)\\r\\n\\r\\n        return encoded_filename\\r\\n    else:\\r\\n        return None", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: The upload_image() function is called when the user uploads an image. The image is read and encoded using base64. The encoded image is written to a file.", "BP": "Allowed File Extensions, Secure Filename, Random Filename Generation, Separate Upload and Encoded Directories, Secure File Handling.", "code": "from flask import Flask, request, redirect, url_for\\r\\nfrom werkzeug.utils import secure_filename\\r\\nimport os\\r\\nimport base64\\r\\nimport secrets\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Configuration\\r\\nUPLOAD_FOLDER = 'uploads'\\r\\nENCODED_FOLDER = 'encoded'\\r\\nALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'gif'}\\r\\n\\r\\n# Ensure directories exist\\r\\nos.makedirs(UPLOAD_FOLDER, exist_ok=True)\\r\\nos.makedirs(ENCODED_FOLDER, exist_ok=True)\\r\\n\\r\\napp.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER\\r\\napp.config['ENCODED_FOLDER'] = ENCODED_FOLDER\\r\\n\\r\\ndef allowed_file(filename):\\r\\n    \"\"\"Check if the file has an allowed extension.\"\"\"\\r\\n    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\\r\\n\\r\\ndef generate_random_filename(extension):\\r\\n    \"\"\"Generate a secure random filename.\"\"\"\\r\\n    return secrets.token_hex(16) + '.' + extension\\r\\n\\r\\ndef upload_image(file):\\r\\n    \"\"\"Handle image upload, encoding, and saving.\"\"\"\\r\\n    if file and allowed_file(file.filename):\\r\\n        # Secure the filename\\r\\n        filename = secure_filename(file.filename)\\r\\n        # Extract file extension\\r\\n        file_extension = filename.rsplit('.', 1)[1].lower()\\r\\n        # Generate a random filename\\r\\n        random_filename = generate_random_filename(file_extension)\\r\\n        # Define the full path for the upload\\r\\n        upload_path = os.path.join(app.config['UPLOAD_FOLDER'], random_filename)\\r\\n        \\r\\n        # Save the file to the upload directory\\r\\n        file.save(upload_path)\\r\\n        \\r\\n        # Read the file and encode it in base64\\r\\n        with open(upload_path, 'rb') as image_file:\\r\\n            encoded_string = base64.b64encode(image_file.read()).decode('utf-8')\\r\\n        \\r\\n        # Write the base64 encoded image to a new file\\r\\n        encoded_filename = random_filename.rsplit('.', 1)[0] + '.txt'\\r\\n        encoded_path = os.path.join(app.config['ENCODED_FOLDER'], encoded_filename)\\r\\n        \\r\\n        with open(encoded_path, 'w') as encoded_file:\\r\\n            encoded_file.write(encoded_string)\\r\\n        \\r\\n        return encoded_path\\r\\n\\r\\n@app.route('/upload', methods=['GET', 'POST'])\\r\\ndef upload_file():\\r\\n    if request.method == 'POST':\\r\\n        # Check if the post request has the file part\\r\\n        if 'file' not in request.files:\\r\\n            return 'No file part'\\r\\n        file = request.files['file']\\r\\n        # If user does not select file, browser also submit an empty part without filename\\r\\n        if file.filename == '':\\r\\n            return 'No selected file'\\r\\n        # Process the upload\\r\\n        encoded_file_path = upload_image(file)\\r\\n        return f'File successfully uploaded and encoded. Encoded file: {encoded_file_path}'\\r\\n    \\r\\n    return '''\\r\\n    <!doctype html>\\r\\n    <title>Upload new File</title>\\r\\n    <h1>Upload new File</h1>\\r\\n    <form method=post enctype=multipart/form-data>\\r\\n      <input type=file name=file>\\r\\n      <input type=submit value=Upload>\\r\\n    </form>\\r\\n    '''\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: The upload_image() function is called when the user uploads an image. The image is read and encoded using base64. The encoded image is written to a file.", "BP": "Allowed File Extensions, Secure Filename, Random Filename Generation, Separate Upload and Encoded Directories, Secure File Handling.", "code": "import os\\r\\nimport base64\\r\\nfrom werkzeug.utils import secure_filename\\r\\nimport uuid\\r\\n\\r\\nALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'gif'}\\r\\n\\r\\ndef allowed_file(filename):\\r\\n    return '.' in filename and \\\\r\\n           filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\\r\\n\\r\\ndef generate_random_filename(extension):\\r\\n    return str(uuid.uuid4()) + '.' + extension\\r\\n\\r\\ndef upload_image(file, upload_dir='uploads', encoded_dir='encoded'):\\r\\n    if file and allowed_file(file.filename):\\r\\n        filename = secure_filename(file.filename)\\r\\n        random_filename = generate_random_filename(filename.rsplit('.', 1)[1])\\r\\n        upload_path = os.path.join(upload_dir, random_filename)\\r\\n        encoded_path = os.path.join(encoded_dir, random_filename + '.txt')\\r\\n\\r\\n        # Ensure directories exist\\r\\n        os.makedirs(upload_dir, exist_ok=True)\\r\\n        os.makedirs(encoded_dir, exist_ok=True)\\r\\n\\r\\n        # Save the uploaded file\\r\\n        file.save(upload_path)\\r\\n\\r\\n        # Read and encode the image\\r\\n        with open(upload_path, \"rb\") as image_file:\\r\\n            encoded_string = base64.b64encode(image_file.read()).decode()\\r\\n\\r\\n        # Write the encoded string to a separate file\\r\\n        with open(encoded_path, \"w\") as file:\\r\\n            file.write(encoded_string)\\r\\n\\r\\n        return True, \"File uploaded and encoded successfully.\"\\r\\n    else:\\r\\n        return False, \"File extension not allowed.\"", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: The code is a simple web application that accepts a file upload and saves it to the uploads directory. The file_is_safe_type function is a stub that always returns true.The upload_file function is the function that handles the file upload.", "BP": "Allowed File Extensions, File Type Validation, Secure Filename, Maximum File Size, CSRF Protection, Secure Headers, Error Handling.", "code": "from flask import Flask, request, redirect, send_from_directory\\r\\nimport os\\r\\nimport magic\\r\\nfrom werkzeug.utils import secure_filename\\r\\nfrom werkzeug.middleware.proxy_fix import ProxyFix\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024  # 16 MB\\r\\napp.config['UPLOAD_FOLDER'] = 'uploads'\\r\\napp.wsgi_app = ProxyFix(app.wsgi_app)\\r\\n\\r\\n# Generate a secure CSRF token\\r\\n@app.before_request\\r\\ndef csrf_protect():\\r\\n    if request.method == \"POST\":\\r\\n        token = request.headers.get('X-CSRF-Token')\\r\\n        if not token or token != request.cookies.get('CSRF_TOKEN'):\\r\\n            return \"CSRF Token is missing or invalid\", 403\\r\\n\\r\\n# Set secure headers\\r\\n@app.after_request\\r\\ndef set_secure_headers(response):\\r\\n    response.headers['X-Frame-Options'] = 'DENY'\\r\\n    response.headers['X-Content-Type-Options'] = 'nosniff'\\r\\n    response.headers['X-XSS-Protection'] = '1; mode=block'\\r\\n    response.headers['Strict-Transport-Security'] = 'max-age=31536000; includeSubDomains'\\r\\n    response.headers['Content-Security-Policy'] = \"default-src 'self'\"\\r\\n    return response\\r\\n\\r\\n# Allowed file extensions\\r\\nALLOWED_EXTENSIONS = {'txt', 'pdf', 'png', 'jpg', 'jpeg', 'gif'}\\r\\n\\r\\ndef file_is_safe_type(file):\\r\\n    # Use the python-magic library to check the file type\\r\\n    file_type = magic.from_buffer(file.read(1024), mime=True)\\r\\n    file.seek(0)  # Reset the file pointer\\r\\n    return file_type in ['text/plain', 'application/pdf', 'image/png', 'image/jpeg', 'image/gif']\\r\\n\\r\\ndef upload_file():\\r\\n    if 'file' not in request.files:\\r\\n        return \"No file uploaded\", 400\\r\\n\\r\\n    file = request.files['file']\\r\\n\\r\\n    if file.filename == '':\\r\\n        return \"No file selected\", 400\\r\\n\\r\\n    # Check if the file extension is allowed\\r\\n    file_ext = os.path.splitext(file.filename)[1][1:].lower()\\r\\n    if file_ext not in ALLOWED_EXTENSIONS:\\r\\n        return \"File extension not allowed\", 400\\r\\n\\r\\n    # Check if the file type is safe\\r\\n    if not file_is_safe_type(file):\\r\\n        return \"File type not allowed\", 400\\r\\n\\r\\n    # Secure the filename\\r\\n    filename = secure_filename(file.filename)\\r\\n\\r\\n    # Save the file\\r\\n    file_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)\\r\\n    file.save(file_path)\\r\\n\\r\\n    return redirect('/uploads/' + filename)\\r\\n\\r\\n@app.route('/uploads/<filename>')\\r\\ndef uploaded_file(filename):\\r\\n    return send_from_directory(app.config['UPLOAD_FOLDER'], filename)\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)\\r\\n    app.secret_key = os.urandom(24)  # Generate a random secret key\\r\\n    app.run(debug=False, host='0.0.0.0')", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: The code is a simple web application that accepts a file upload and saves it to the uploads directory. The file_is_safe_type function is a stub that always returns true.The upload_file function is the function that handles the file upload.", "BP": "Allowed File Extensions, File Type Validation, Secure Filename, Maximum File Size, CSRF Protection, Secure Headers, Error Handling.", "code": "from flask import Flask, request, render_template, redirect, url_for, flash\\r\\nfrom werkzeug.utils import secure_filename\\r\\nimport os\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Configuration settings\\r\\nUPLOAD_FOLDER = 'uploads'\\r\\nALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'gif'}\\r\\nMAX_CONTENT_LENGTH = 16 * 1024 * 1024  # 16 MB max file size\\r\\nSECRET_KEY = 'your_secret_key'  # Replace with your actual secret key\\r\\n\\r\\napp.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER\\r\\napp.config['MAX_CONTENT_LENGTH'] = MAX_CONTENT_LENGTH\\r\\napp.config['SECRET_KEY'] = SECRET_KEY\\r\\n\\r\\n# Ensure the upload directory exists\\r\\nif not os.path.exists(UPLOAD_FOLDER):\\r\\n    os.makedirs(UPLOAD_FOLDER)\\r\\n\\r\\n# Function to check allowed file extensions\\r\\ndef allowed_file(filename):\\r\\n    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\\r\\n\\r\\n# Stub function to validate file type\\r\\ndef file_is_safe_type(file):\\r\\n    # Implement actual file type checking here\\r\\n    return True\\r\\n\\r\\n@app.route('/')\\r\\ndef index():\\r\\n    return render_template('index.html')\\r\\n\\r\\n@app.route('/upload', methods=['GET', 'POST'])\\r\\ndef upload_file():\\r\\n    if request.method == 'POST':\\r\\n        # Check if the post request has the file part\\r\\n        if 'file' not in request.files:\\r\\n            flash('No file part')\\r\\n            return redirect(request.url)\\r\\n\\r\\n        file = request.files['file']\\r\\n\\r\\n        # If user does not select a file, browser also\\r\\n        # submits an empty part without filename\\r\\n        if file.filename == '':\\r\\n            flash('No selected file')\\r\\n            return redirect(request.url)\\r\\n\\r\\n        if file and allowed_file(file.filename):\\r\\n            if file_is_safe_type(file):\\r\\n                filename = secure_filename(file.filename)\\r\\n                file_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)\\r\\n                \\r\\n                try:\\r\\n                    file.save(file_path)\\r\\n                    flash('File successfully uploaded')\\r\\n                    return redirect(url_for('index'))\\r\\n                except Exception as e:\\r\\n                    flash(f'An error occurred while saving the file: {e}')\\r\\n                    return redirect(request.url)\\r\\n            else:\\r\\n                flash('File type is not allowed')\\r\\n                return redirect(request.url)\\r\\n        else:\\r\\n            flash('File extension is not allowed')\\r\\n            return redirect(request.url)\\r\\n    return render_template('upload.html')\\r\\n\\r\\n@app.errorhandler(413)\\r\\ndef request_entity_too_large(error):\\r\\n    flash('File is too large')\\r\\n    return redirect(request.url), 413\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: The code is a simple web application that accepts a file upload and saves it to the uploads directory. The file_is_safe_type function is a stub that always returns true.The upload_file function is the function that handles the file upload.", "BP": "Allowed File Extensions, File Type Validation, Secure Filename, Maximum File Size, CSRF Protection, Secure Headers, Error Handling.", "code": "from flask import Flask, request, redirect, url_for, flash, send_from_directory\\r\\nfrom werkzeug.utils import secure_filename\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import FileField, SubmitField\\r\\nfrom flask_wtf.file import FileAllowed, FileRequired\\r\\nfrom flask_talisman import Talisman\\r\\nimport os\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['SECRET_KEY'] = 'your_secret_key'\\r\\napp.config['UPLOAD_FOLDER'] = 'uploads'\\r\\napp.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024  # 16MB limit\\r\\nALLOWED_EXTENSIONS = {'txt', 'pdf', 'png', 'jpg', 'jpeg', 'gif'}\\r\\n\\r\\nTalisman(app)  # Enable HTTPS and secure headers\\r\\n\\r\\ndef file_is_safe_type(file):\\r\\n    # Stub function for file type validation\\r\\n    return True\\r\\n\\r\\nclass UploadForm(FlaskForm):\\r\\n    file = FileField('File', validators=[\\r\\n        FileRequired(),\\r\\n        FileAllowed(ALLOWED_EXTENSIONS, 'Invalid file extension!')\\r\\n    ])\\r\\n    submit = SubmitField('Upload')\\r\\n\\r\\n@app.route('/', methods=['GET', 'POST'])\\r\\ndef upload_file():\\r\\n    form = UploadForm()\\r\\n    if form.validate_on_submit():\\r\\n        file = form.file.data\\r\\n        if file and file_is_safe_type(file):\\r\\n            filename = secure_filename(file.filename)\\r\\n            file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename))\\r\\n            return redirect(url_for('uploaded_file', filename=filename))\\r\\n        else:\\r\\n            flash('File type is not allowed.')\\r\\n    return '''\\r\\n    <!doctype html>\\r\\n    <title>Upload new File</title>\\r\\n    <h1>Upload new File</h1>\\r\\n    <form method=post enctype=multipart/form-data>\\r\\n      ''' + form.csrf_token + '''\\r\\n      <input type=file name=file>\\r\\n      <input type=submit value=Upload>\\r\\n    </form>\\r\\n    '''\\r\\n\\r\\n@app.route('/uploads/<filename>')\\r\\ndef uploaded_file(filename):\\r\\n    return send_from_directory(app.config['UPLOAD_FOLDER'], filename)\\r\\n\\r\\n@app.errorhandler(413)\\r\\ndef error_413(e):\\r\\n    return \"File is too large.\", 413\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: The code is a simple web application that allows users to upload files to the server.", "BP": "File Size Limit, Allowed File Extensions, File Extension Checking, Filename Sanitization, Error Handling, Input Validation, Secure File Storage, Rate-limiting, Logging and Monitoring.", "code": "import os\\r\\nimport re\\r\\nfrom pathlib import Path\\r\\nfrom flask import Flask, request, redirect, url_for, render_template\\r\\nfrom werkzeug.utils import secure_filename\\r\\nfrom werkzeug.middleware.proxy_fix import ProxyFix\\r\\nfrom ratelimit import limits, sleep_and_retry\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.wsgi_app = ProxyFix(app.wsgi_app, x_prefix=1)\\r\\n\\r\\n# Set the maximum file size (e.g., 10MB)\\r\\nMAX_FILE_SIZE = 10 * 1024 * 1024\\r\\n\\r\\n# Set the allowed file extensions\\r\\nALLOWED_EXTENSIONS = {'txt', 'pdf', 'png', 'jpg', 'jpeg', 'gif'}\\r\\n\\r\\n# Set the upload directory\\r\\nUPLOAD_DIRECTORY = Path('uploads')\\r\\nUPLOAD_DIRECTORY.mkdir(exist_ok=True)\\r\\n\\r\\n# Rate-limiting configuration\\r\\nRATELIMIT_STORAGE_URL = 'redis://localhost:6379'\\r\\nRATELIMIT_STRATEGY = 'moving-window'\\r\\nRATELIMIT_WINDOW = 60  # 1 minute\\r\\nRATELIMIT_LIMIT = 10  # Maximum of 10 uploads per minute\\r\\n\\r\\n# Logging configuration\\r\\nimport logging\\r\\nlogging.basicConfig(filename='app.log', level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\\r\\n\\r\\n# File extension pattern for validation\\r\\nEXTENSION_PATTERN = r'^.*\\.(txt|pdf|png|jpg|jpeg|gif)$'\\r\\n\\r\\n# Filename sanitization pattern\\r\\nFILENAME_PATTERN = r'^[\\w\\-\\. ]+$'\\r\\n\\r\\n@app.route('/', methods=['GET', 'POST'])\\r\\n@sleep_and_retry\\r\\n@limits(calls=RATELIMIT_LIMIT, period=RATELIMIT_WINDOW, storage_url=RATELIMIT_STORAGE_URL, strategy=RATELIMIT_STRATEGY)\\r\\ndef upload_file():\\r\\n    if request.method == 'POST':\\r\\n        # Check if the file was properly uploaded\\r\\n        if 'file' not in request.files:\\r\\n            logging.error('No file part')\\r\\n            return redirect(request.url)\\r\\n\\r\\n        file = request.files['file']\\r\\n\\r\\n        # If the user did not select a file, redirect to the same page\\r\\n        if file.filename == '':\\r\\n            logging.error('No file selected')\\r\\n            return redirect(request.url)\\r\\n\\r\\n        # Validate file extension\\r\\n        if not re.match(EXTENSION_PATTERN, file.filename, re.IGNORECASE):\\r\\n            logging.error(f'Invalid file extension: {file.filename}')\\r\\n            return 'Invalid file extension', 400\\r\\n\\r\\n        # Sanitize the filename\\r\\n        if not re.match(FILENAME_PATTERN, file.filename):\\r\\n            logging.error(f'Invalid filename: {file.filename}')\\r\\n            return 'Invalid filename', 400\\r\\n\\r\\n        # Check file size\\r\\n        if file.content_length > MAX_FILE_SIZE:\\r\\n            logging.error(f'File too large: {file.filename} ({file.content_length} bytes)')\\r\\n            return 'File too large', 413\\r\\n\\r\\n        # Save the file securely\\r\\n        filename = secure_filename(file.filename)\\r\\n        file_path = UPLOAD_DIRECTORY / filename\\r\\n        file.save(file_path)\\r\\n        logging.info(f'File saved: {file_path}')\\r\\n\\r\\n        return f'File uploaded successfully: {filename}'\\r\\n\\r\\n    return render_template('upload.html')\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(host='0.0.0.0', port=5000)", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: The code is a simple web application that allows users to upload files to the server.", "BP": "File Size Limit, Allowed File Extensions, File Extension Checking, Filename Sanitization, Error Handling, Input Validation, Secure File Storage, Rate-limiting, Logging and Monitoring.", "code": "# app.py\\r\\nimport os\\r\\nimport re\\r\\nimport logging\\r\\nfrom flask import Flask, request, render_template, redirect, url_for, flash\\r\\nfrom werkzeug.utils import secure_filename\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\n\\r\\n# Configuration\\r\\nUPLOAD_FOLDER = 'uploads'\\r\\nALLOWED_EXTENSIONS = {'txt', 'pdf', 'png', 'jpg', 'jpeg', 'gif'}\\r\\nMAX_CONTENT_LENGTH = 16 * 1024 * 1024  # 16 MB\\r\\n\\r\\n# Ensure the upload folder exists\\r\\nos.makedirs(UPLOAD_FOLDER, exist_ok=True)\\r\\nos.makedirs('logs', exist_ok=True)\\r\\n\\r\\n# Initialize the Flask app\\r\\napp = Flask(__name__)\\r\\napp.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER\\r\\napp.config['MAX_CONTENT_LENGTH'] = MAX_CONTENT_LENGTH\\r\\napp.secret_key = 'your_secret_key'\\r\\n\\r\\n# Set up rate limiting\\r\\nlimiter = Limiter(\\r\\n    app,\\r\\n    key_func=get_remote_address,\\r\\n    default_limits=[\"5 per minute\"]\\r\\n)\\r\\n\\r\\n# Configure logging\\r\\nlogging.basicConfig(filename='logs/app.log', level=logging.INFO,\\r\\n                    format='%(asctime)s %(levelname)s %(message)s')\\r\\n\\r\\ndef allowed_file(filename):\\r\\n    return '.' in filename and \\\\r\\n           filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\\r\\n\\r\\n@app.route('/')\\r\\ndef index():\\r\\n    return render_template('index.html')\\r\\n\\r\\n@app.route('/upload', methods=['POST'])\\r\\n@limiter.limit(\"5 per minute\")  # Apply rate limiting to this route\\r\\ndef upload_file():\\r\\n    if 'file' not in request.files:\\r\\n        flash('No file part')\\r\\n        return redirect(request.url)\\r\\n\\r\\n    file = request.files['file']\\r\\n    \\r\\n    if file.filename == '':\\r\\n        flash('No selected file')\\r\\n        return redirect(request.url)\\r\\n\\r\\n    if file and allowed_file(file.filename):\\r\\n        filename = secure_filename(file.filename)\\r\\n\\r\\n        # Sanitize filename to prevent directory traversal attacks\\r\\n        filename = re.sub(r'[^a-zA-Z0-9_.-]', '_', filename)\\r\\n\\r\\n        file_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)\\r\\n        file.save(file_path)\\r\\n\\r\\n        # Logging the upload\\r\\n        logging.info(f\"File uploaded: {file_path}\")\\r\\n\\r\\n        flash('File successfully uploaded')\\r\\n        return redirect(url_for('index'))\\r\\n    else:\\r\\n        flash('File type not allowed or file too large')\\r\\n        return redirect(request.url)\\r\\n\\r\\n# Error handling\\r\\n@app.errorhandler(413)\\r\\ndef request_entity_too_large(error):\\r\\n    flash('File is too large')\\r\\n    return redirect(request.url)\\r\\n\\r\\n@app.errorhandler(429)\\r\\ndef too_many_requests(error):\\r\\n    flash('Too many requests, please try again later')\\r\\n    return redirect(request.url)\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: The code is a simple web application that allows users to upload files to the server.", "BP": "File Size Limit, Allowed File Extensions, File Extension Checking, Filename Sanitization, Error Handling, Input Validation, Secure File Storage, Rate-limiting, Logging and Monitoring.", "code": "from flask import Flask, request, redirect, url_for, flash, abort\\r\\nfrom werkzeug.utils import secure_filename\\r\\nimport os\\r\\nimport logging\\r\\nfrom logging.handlers import RotatingFileHandler\\r\\nfrom functools import wraps\\r\\nimport time\\r\\n\\r\\n# Configuration\\r\\nUPLOAD_FOLDER = '/path/to/the/uploads'\\r\\nALLOWED_EXTENSIONS = {'txt', 'pdf', 'png', 'jpg', 'jpeg', 'gif'}\\r\\nMAX_FILE_SIZE = 1024 * 1024 * 2  # 2MB\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER\\r\\napp.config['MAX_CONTENT_LENGTH'] = MAX_FILE_SIZE\\r\\n\\r\\n# Setup logging\\r\\nhandler = RotatingFileHandler('app.log', maxBytes=10000, backupCount=1)\\r\\nhandler.setLevel(logging.INFO)\\r\\napp.logger.addHandler(handler)\\r\\n\\r\\ndef allowed_file(filename):\\r\\n    return '.' in filename and \\\\r\\n           filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\\r\\n\\r\\ndef rate_limit(max_per_second):\\r\\n    min_interval = 1.0 / float(max_per_second)\\r\\n    def decorate(func):\\r\\n        last_called = [0.0]\\r\\n        @wraps(func)\\r\\n        def rate_limited_function(*args, **kwargs):\\r\\n            elapsed = time.clock() - last_called[0]\\r\\n            left_to_wait = min_interval - elapsed\\r\\n            if left_to_wait > 0:\\r\\n                time.sleep(left_to_wait)\\r\\n            last_called[0] = time.clock()\\r\\n            return func(*args, **kwargs)\\r\\n        return rate_limited_function\\r\\n    return decorate\\r\\n\\r\\n@app.route('/upload', methods=['POST'])\\r\\n@rate_limit(5)  # Limit to 5 requests per second\\r\\ndef upload_file():\\r\\n    if 'file' not in request.files:\\r\\n        flash('No file part')\\r\\n        return redirect(request.url)\\r\\n    file = request.files['file']\\r\\n    if file.filename == '':\\r\\n        flash('No selected file')\\r\\n        return redirect(request.url)\\r\\n    if file and allowed_file(file.filename):\\r\\n        filename = secure_filename(file.filename)\\r\\n        try:\\r\\n            file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename))\\r\\n            app.logger.info(f\"File uploaded: {filename}\")\\r\\n            return redirect(url_for('uploaded_file', filename=filename))\\r\\n        except Exception as e:\\r\\n            app.logger.error(f\"Error saving file: {str(e)}\")\\r\\n            abort(500)\\r\\n    else:\\r\\n        flash('File type not allowed')\\r\\n        return redirect(request.url)\\r\\n\\r\\n@app.route('/uploads/<filename>')\\r\\ndef uploaded_file(filename):\\r\\n    # Implement secure file retrieval\\r\\n    return send_from_directory(app.config['UPLOAD_FOLDER'], filename)\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: The file_is_safe_type function is a function that checks if the file is safe to upload. The upload_file function is the function that handles the upload of the file. The p.save(os.path.join('uploads' filename)) line saves the file to the uploads folder. The uploads folder is created in the same directory as the source file.", "BP": "Allowed File Extensions, File Extension Validation, File Size Validation, Malicious Content Detection, Secure Filename Generation, File Pointer Reset.", "code": "import os\\r\\nimport magic\\r\\nimport re\\r\\nfrom werkzeug.utils import secure_filename\\r\\n\\r\\n# Maximum file size allowed (in bytes)\\r\\nMAX_FILE_SIZE = 5 * 1024 * 1024  # 5 MB\\r\\n\\r\\n# Allowed file extensions\\r\\nALLOWED_EXTENSIONS = ['pdf', 'doc', 'docx', 'txt', 'jpg', 'jpeg', 'png', 'gif']\\r\\n\\r\\n# Regular expression pattern for detecting malicious content\\r\\nMALICIOUS_PATTERN = r'<\\s*script'\\r\\n\\r\\n# Upload directory\\r\\nUPLOAD_DIR = 'uploads'\\r\\n\\r\\ndef file_is_safe_type(file):\\r\\n    \"\"\"\\r\\n    Checks if the file is safe for upload based on file extension, size, and content.\\r\\n    \"\"\"\\r\\n    # Check file extension\\r\\n    file_ext = os.path.splitext(file.filename)[1][1:].lower()\\r\\n    if file_ext not in ALLOWED_EXTENSIONS:\\r\\n        return False\\r\\n\\r\\n    # Check file size\\r\\n    if file.content_length > MAX_FILE_SIZE:\\r\\n        return False\\r\\n\\r\\n    # Check for malicious content\\r\\n    file.seek(0)  # Reset file pointer\\r\\n    file_content = file.read()\\r\\n    if re.search(MALICIOUS_PATTERN, file_content.decode('utf-8', 'ignore')):\\r\\n        return False\\r\\n\\r\\n    return True\\r\\n\\r\\ndef upload_file(file):\\r\\n    \"\"\"\\r\\n    Uploads the file securely to the uploads directory.\\r\\n    \"\"\"\\r\\n    if file_is_safe_type(file):\\r\\n        # Generate a secure filename\\r\\n        filename = secure_filename(file.filename)\\r\\n\\r\\n        # Create the uploads directory if it doesn't exist\\r\\n        os.makedirs(UPLOAD_DIR, exist_ok=True)\\r\\n\\r\\n        # Save the file to the uploads directory\\r\\n        file_path = os.path.join(UPLOAD_DIR, filename)\\r\\n        file.seek(0)  # Reset file pointer\\r\\n        file.save(file_path)\\r\\n\\r\\n        return True\\r\\n    else:\\r\\n        return False", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: The file_is_safe_type function is a function that checks if the file is safe to upload. The upload_file function is the function that handles the upload of the file. The p.save(os.path.join('uploads' filename)) line saves the file to the uploads folder. The uploads folder is created in the same directory as the source file.", "BP": "Allowed File Extensions, File Extension Validation, File Size Validation, Malicious Content Detection, Secure Filename Generation, File Pointer Reset.", "code": "import os\\r\\nimport werkzeug.utils\\r\\nimport pyclamd\\r\\nfrom flask import Flask, request, flash\\r\\nfrom werkzeug.utils import secure_filename\\r\\n\\r\\n# Define allowed extensions and maximum file size (e.g., 2MB)\\r\\nALLOWED_EXTENSIONS = {'txt', 'pdf', 'png', 'jpg', 'jpeg', 'gif'}\\r\\nMAX_FILE_SIZE = 2 * 1024 * 1024  # 2MB\\r\\n\\r\\n# Create an uploads directory if it doesn't exist\\r\\nUPLOAD_FOLDER = 'uploads'\\r\\nif not os.path.exists(UPLOAD_FOLDER):\\r\\n    os.makedirs(UPLOAD_FOLDER)\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER\\r\\napp.config['MAX_CONTENT_LENGTH'] = MAX_FILE_SIZE\\r\\n\\r\\n# Function to check if the file has an allowed extension\\r\\ndef allowed_file(filename):\\r\\n    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\\r\\n\\r\\n# Function to detect malicious content using ClamAV\\r\\ndef detect_malware(filepath):\\r\\n    try:\\r\\n        cd = pyclamd.ClamdAgnostic()\\r\\n        if cd.ping():\\r\\n            scan_result = cd.scan_file(filepath)\\r\\n            if scan_result:\\r\\n                return True  # Malware detected\\r\\n        return False\\r\\n    except pyclamd.ConnectionError:\\r\\n        print(\"Error: Unable to connect to ClamAV daemon.\")\\r\\n        return False\\r\\n\\r\\n# Function to handle file uploads\\r\\n@app.route('/upload', methods=['POST'])\\r\\ndef upload_file():\\r\\n    if 'file' not in request.files:\\r\\n        flash('No file part')\\r\\n        return \"No file part\"\\r\\n\\r\\n    file = request.files['file']\\r\\n\\r\\n    # If no file is selected\\r\\n    if file.filename == '':\\r\\n        flash('No selected file')\\r\\n        return \"No selected file\"\\r\\n\\r\\n    # Check if file is allowed\\r\\n    if file and allowed_file(file.filename):\\r\\n        # Secure the filename\\r\\n        filename = secure_filename(file.filename)\\r\\n\\r\\n        # Save the file temporarily to scan for malware\\r\\n        temp_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)\\r\\n        file.save(temp_path)\\r\\n\\r\\n        # Check for malware\\r\\n        if detect_malware(temp_path):\\r\\n            os.remove(temp_path)\\r\\n            return \"Malicious file detected!\"\\r\\n\\r\\n        # Check the file size\\r\\n        file.seek(0, os.SEEK_END)\\r\\n        file_size = file.tell()\\r\\n        file.seek(0)  # Reset the file pointer\\r\\n\\r\\n        if file_size > MAX_FILE_SIZE:\\r\\n            os.remove(temp_path)\\r\\n            return \"File size exceeds limit!\"\\r\\n\\r\\n        # Move the file to the permanent location\\r\\n        final_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)\\r\\n        os.rename(temp_path, final_path)\\r\\n\\r\\n        return f\"File {filename} uploaded successfully!\"\\r\\n\\r\\n    return \"File type not allowed!\"\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: The file_is_safe_type function is a function that checks if the file is safe to upload. The upload_file function is the function that handles the upload of the file. The p.save(os.path.join('uploads' filename)) line saves the file to the uploads folder. The uploads folder is created in the same directory as the source file.", "BP": "Allowed File Extensions, File Extension Validation, File Size Validation, Malicious Content Detection, Secure Filename Generation, File Pointer Reset.", "code": "import os\\r\\nfrom werkzeug.utils import secure_filename\\r\\n\\r\\nALLOWED_EXTENSIONS = {'txt', 'pdf', 'png', 'jpg', 'jpeg', 'gif'}\\r\\nMAX_FILE_SIZE = 1024 * 1024 * 5  # 5MB\\r\\n\\r\\ndef allowed_file(filename):\\r\\n    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\\r\\n\\r\\ndef file_is_safe_type(file_path):\\r\\n    # Implement file type validation (e.g., using MIME types or file extensions)\\r\\n    return allowed_file(file_path)\\r\\n\\r\\ndef reset_file_pointer(p):\\r\\n    p.seek(0)\\r\\n\\r\\ndef check_file_size(p):\\r\\n    p.seek(0, os.SEEK_END)\\r\\n    file_size = p.tell()\\r\\n    reset_file_pointer(p)\\r\\n    return file_size <= MAX_FILE_SIZE\\r\\n\\r\\ndef detect_malicious_content(p):\\r\\n    # Implement malicious content detection (placeholder)\\r\\n    # This should ideally be a more sophisticated check\\r\\n    reset_file_pointer(p)\\r\\n    content = p.read()\\r\\n    reset_file_pointer(p)\\r\\n    return \"malicious\" not in content\\r\\n\\r\\ndef upload_file(p, filename):\\r\\n    if not os.path.exists('uploads'):\\r\\n        os.makedirs('uploads')\\r\\n    \\r\\n    if not file_is_safe_type(filename):\\r\\n        return \"File type is not allowed.\"\\r\\n    \\r\\n    if not check_file_size(p):\\r\\n        return \"File size exceeds the maximum allowed limit.\"\\r\\n    \\r\\n    if not detect_malicious_content(p):\\r\\n        return \"File contains malicious content.\"\\r\\n    \\r\\n    secure_name = secure_filename(filename)\\r\\n    p.save(os.path.join('uploads', secure_name))\\r\\n    return f\"File {secure_name} uploaded successfully.\"", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: Memory allocation method allocates a block of memory of size sizeof(person) and returns a pointer to the beginning of that block. The -> operator is used to access members of a struct through a pointer.", "BP": "Memory Allocation, Memory Deallocation, Struct Representation, Proper Initialization, Import ctypes.", "code": "import ctypes\\r\\n\\r\\n# Define a struct to represent a person\\r\\nclass Person(ctypes.Structure):\\r\\n    _fields_ = [\\r\\n        (\"name\", ctypes.c_char_p),\\r\\n        (\"age\", ctypes.c_int),\\r\\n        (\"height\", ctypes.c_float)\\r\\n    ]\\r\\n\\r\\ndef allocate_person():\\r\\n    # Allocate memory for a Person struct\\r\\n    person_ptr = ctypes.pointer(Person())\\r\\n    \\r\\n    # Initialize the struct members\\r\\n    person_ptr.contents.name = ctypes.c_char_p(b\"John Doe\")\\r\\n    person_ptr.contents.age = 30\\r\\n    person_ptr.contents.height = 1.75\\r\\n    \\r\\n    return person_ptr\\r\\n\\r\\ndef deallocate_person(person_ptr):\\r\\n    # Deallocate memory for the Person struct\\r\\n    ctypes.pointer(person_ptr.contents.name).value = None\\r\\n    ctypes.pointer(Person.from_address(ctypes.addressof(person_ptr.contents))).contents = None\\r\\n\\r\\n# Example usage\\r\\nperson = allocate_person()\\r\\nprint(f\"Name: {person.contents.name.decode()}\")  # Name: John Doe\\r\\nprint(f\"Age: {person.contents.age}\")  # Age: 30\\r\\nprint(f\"Height: {person.contents.height}\")  # Height: 1.75\\r\\n\\r\\ndeallocate_person(person)", "CWE": "CWE-476"}
{"text": "Generate Python code for the following: Memory allocation method allocates a block of memory of size sizeof(person) and returns a pointer to the beginning of that block. The -> operator is used to access members of a struct through a pointer.", "BP": "Memory Allocation, Memory Deallocation, Struct Representation, Proper Initialization, Import ctypes.", "code": "import ctypes\\r\\n\\r\\n# Define the Person struct\\r\\nclass Person(ctypes.Structure):\\r\\n    _fields_ = [(\"name\", ctypes.c_char_p),\\r\\n                (\"age\", ctypes.c_int)]\\r\\n\\r\\n# Memory allocation function\\r\\ndef allocate_person():\\r\\n    # Allocate memory for a Person instance\\r\\n    person_ptr = ctypes.pointer(Person())\\r\\n    return person_ptr\\r\\n\\r\\n# Memory deallocation function\\r\\ndef deallocate_person(person_ptr):\\r\\n    # Deallocate memory for the Person instance\\r\\n    # In ctypes, simply deleting the pointer will deallocate the memory\\r\\n    del person_ptr\\r\\n\\r\\n# Initialize the Person struct\\r\\ndef initialize_person(person_ptr, name, age):\\r\\n    person_ptr.contents.name = ctypes.create_string_buffer(name.encode('utf-8'))\\r\\n    person_ptr.contents.age = age\\r\\n\\r\\n# Usage example\\r\\nif __name__ == \"__main__\":\\r\\n    # Allocate memory for a Person instance\\r\\n    person = allocate_person()\\r\\n    \\r\\n    # Initialize the Person instance\\r\\n    initialize_person(person, \"John Doe\", 30)\\r\\n    \\r\\n    # Access the members of the struct\\r\\n    print(f\"Name: {person.contents.name.decode('utf-8')}\")\\r\\n    print(f\"Age: {person.contents.age}\")\\r\\n    \\r\\n    # Deallocate memory\\r\\n    deallocate_person(person)", "CWE": "CWE-476"}
{"text": "Generate Python code for the following: Memory allocation method allocates a block of memory of size sizeof(person) and returns a pointer to the beginning of that block. The -> operator is used to access members of a struct through a pointer.", "BP": "Memory Allocation, Memory Deallocation, Struct Representation, Proper Initialization, Import ctypes.", "code": "import ctypes\\r\\n\\r\\n# Define a struct representation for 'person'\\r\\nclass Person(ctypes.Structure):\\r\\n    _fields_ = [(\"name\", ctypes.c_char_p),\\r\\n                (\"age\", ctypes.c_int)]\\r\\n\\r\\n# Memory allocation method\\r\\ndef allocate_person():\\r\\n    # Allocate a block of memory of size sizeof(Person)\\r\\n    person_ptr = ctypes.cast(ctypes.create_string_buffer(ctypes.sizeof(Person)), ctypes.POINTER(Person))\\r\\n    return person_ptr\\r\\n\\r\\n# Proper initialization of a person instance\\r\\ndef initialize_person(person_ptr, name, age):\\r\\n    # Using the -> operator equivalent in Python to access and set members of the struct through a pointer\\r\\n    person_ptr.contents.name = name.encode('utf-8')  # Encoding string to bytes\\r\\n    person_ptr.contents.age = age\\r\\n\\r\\n# Memory deallocation method\\r\\ndef deallocate_person(person_ptr):\\r\\n    # In Python, ctypes automatically manages memory deallocation for objects created via ctypes\\r\\n    # However, if you were manually managing memory (e.g., using malloc from libc), you would use ctypes to call free\\r\\n    pass  # Placeholder to indicate where deallocation code would go if needed\\r\\n\\r\\n# Example usage\\r\\nif __name__ == \"__main__\":\\r\\n    person_ptr = allocate_person()\\r\\n    initialize_person(person_ptr, \"John Doe\", 30)\\r\\n    print(f\"Name: {person_ptr.contents.name.decode('utf-8')}, Age: {person_ptr.contents.age}\")\\r\\n    deallocate_person(person_ptr)", "CWE": "CWE-476"}
{"text": "Generate Python code for the following: Memory allocation method allocates a block of memory of size sizeof(person) and returns a pointer to the beginning of the block. The cast (person *) is not necessary but it is good practice to include it. The -> operator is used to access the fields of a struct through a pointer. The code allocates a new person and sets the status field to 0.", "BP": "Memory Allocation, Memory Deallocation, Data Handling, Error Handling, Import ctypes.", "code": "import os\\r\\nimport ctypes\\r\\n\\r\\n# Define a Person struct\\r\\nclass Person(ctypes.Structure):\\r\\n    _fields_ = [(\"name\", ctypes.c_char_p),\\r\\n                (\"age\", ctypes.c_int),\\r\\n                (\"status\", ctypes.c_int)]\\r\\n\\r\\n# Securely allocate memory for a Person object\\r\\ndef allocate_person():\\r\\n    try:\\r\\n        # Allocate memory for a Person object\\r\\n        person_ptr = ctypes.pointer(Person())\\r\\n\\r\\n        # Initialize fields\\r\\n        person_ptr.contents.name = ctypes.create_string_buffer(b\"John Doe\")\\r\\n        person_ptr.contents.age = 30\\r\\n        person_ptr.contents.status = 0\\r\\n\\r\\n        return person_ptr\\r\\n    except (ValueError, MemoryError) as e:\\r\\n        print(f\"Error allocating memory: {e}\")\\r\\n        return None\\r\\n\\r\\n# Securely deallocate memory for a Person object\\r\\ndef deallocate_person(person_ptr):\\r\\n    if person_ptr:\\r\\n        try:\\r\\n            # Securely clear the allocated memory\\r\\n            ctypes.memset(person_ptr, 0, ctypes.sizeof(Person))\\r\\n\\r\\n            # Deallocate the memory\\r\\n            ctypes.pointer(person_ptr)[0] = None\\r\\n        except (ValueError, MemoryError) as e:\\r\\n            print(f\"Error deallocating memory: {e}\")\\r\\n\\r\\n# Securely handle Person data\\r\\ndef handle_person_data(person_ptr):\\r\\n    if person_ptr:\\r\\n        try:\\r\\n            name = person_ptr.contents.name.decode()\\r\\n            age = person_ptr.contents.age\\r\\n            status = person_ptr.contents.status\\r\\n\\r\\n            # Handle the data securely\\r\\n            print(f\"Name: {name}, Age: {age}, Status: {status}\")\\r\\n        except (ValueError, UnicodeDecodeError) as e:\\r\\n            print(f\"Error handling data: {e}\")\\r\\n\\r\\n# Example usage\\r\\nperson_ptr = allocate_person()\\r\\nhandle_person_data(person_ptr)\\r\\ndeallocate_person(person_ptr)", "CWE": "CWE-476"}
{"text": "Generate Python code for the following: Memory allocation method allocates a block of memory of size sizeof(person) and returns a pointer to the beginning of the block. The cast (person *) is not necessary but it is good practice to include it. The -> operator is used to access the fields of a struct through a pointer. The code allocates a new person and sets the status field to 0.", "BP": "Memory Allocation, Memory Deallocation, Data Handling, Error Handling, Import ctypes.", "code": "import ctypes\\r\\n\\r\\n# Define the person struct\\r\\nclass Person(ctypes.Structure):\\r\\n    _fields_ = [\\r\\n        (\"status\", ctypes.c_int)\\r\\n    ]\\r\\n\\r\\n# Memory Allocation: Allocate a block of memory for the person struct\\r\\ntry:\\r\\n    person_pointer = ctypes.POINTER(Person)\\r\\n    allocated_person = ctypes.cast(ctypes.create_string_buffer(ctypes.sizeof(Person)), person_pointer)\\r\\n\\r\\n    if not allocated_person:\\r\\n        raise MemoryError(\"Memory allocation failed\")\\r\\n\\r\\n    # Set the status field to 0\\r\\n    allocated_person.contents.status = 0\\r\\n\\r\\n    # Access and print the status field to confirm\\r\\n    print(f\"Status field set to: {allocated_person.contents.status}\")\\r\\n\\r\\nexcept MemoryError as e:\\r\\n    print(f\"Error: {e}\")\\r\\n\\r\\nfinally:\\r\\n    # Memory Deallocation\\r\\n    # In ctypes, memory allocated with create_string_buffer is managed by Python's garbage collector,\\r\\n    # but we use del to explicitly delete references for clarity.\\r\\n    del allocated_person", "CWE": "CWE-476"}
{"text": "Generate Python code for the following: Memory allocation method allocates a block of memory of size sizeof(person) and returns a pointer to the beginning of the block. The cast (person *) is not necessary but it is good practice to include it. The -> operator is used to access the fields of a struct through a pointer. The code allocates a new person and sets the status field to 0.", "BP": "Memory Allocation, Memory Deallocation, Data Handling, Error Handling, Import ctypes.", "code": "# Include necessary libraries\\r\\nimport ctypes\\r\\n\\r\\n# Define the person structure\\r\\nclass Person(ctypes.Structure):\\r\\n    _fields_ = [(\"name\", ctypes.c_char_p),\\r\\n                (\"age\", ctypes.c_int),\\r\\n                (\"status\", ctypes.c_int)]\\r\\n\\r\\ndef allocate_person():\\r\\n    # Allocate memory for a new person\\r\\n    person_ptr = ctypes.cast(ctypes.create_string_buffer(ctypes.sizeof(Person)), ctypes.POINTER(Person))\\r\\n    \\r\\n    # Initialize the person's status to 0\\r\\n    person_ptr.contents.status = 0\\r\\n    \\r\\n    return person_ptr\\r\\n\\r\\ndef deallocate_person(person_ptr):\\r\\n    # Deallocate the memory block pointed by person_ptr\\r\\n    # In Python, ctypes automatically manages memory for ctypes objects, so explicit deallocation is not necessary.\\r\\n    # However, for educational purposes, we'll set the pointer to None to simulate deallocation.\\r\\n    person_ptr = None\\r\\n\\r\\ndef set_person_data(person_ptr, name, age):\\r\\n    # Set the person's data\\r\\n    if person_ptr:\\r\\n        person_ptr.contents.name = name.encode('utf-8')\\r\\n        person_ptr.contents.age = age\\r\\n    else:\\r\\n        print(\"Error: Invalid person pointer\")\\r\\n\\r\\ndef get_person_data(person_ptr):\\r\\n    # Get the person's data\\r\\n    if person_ptr:\\r\\n        return {\\r\\n            \"name\": person_ptr.contents.name.decode('utf-8'),\\r\\n            \"age\": person_ptr.contents.age,\\r\\n            \"status\": person_ptr.contents.status\\r\\n        }\\r\\n    else:\\r\\n        print(\"Error: Invalid person pointer\")\\r\\n        return None\\r\\n\\r\\n# Example usage\\r\\nif __name__ == \"__main__\":\\r\\n    person_ptr = allocate_person()\\r\\n    set_person_data(person_ptr, \"John Doe\", 30)\\r\\n    person_data = get_person_data(person_ptr)\\r\\n    print(person_data)\\r\\n    deallocate_person(person_ptr)", "CWE": "CWE-476"}
{"text": "Generate Python code for the following: Memory allocation method allocates a block of memory of size sizeof(person) and returns a pointer to the beginning of the block. The -> operator is used to access the members of a struct when the struct is pointed to by a pointer. The code allocates a new person and sets the status to 0.", "BP": "Memory Allocation, Memory Deallocation, String Handling, Error Handling, Import ctypes.", "code": "import ctypes\\r\\nimport secrets\\r\\nimport os\\r\\nfrom typing import Optional\\r\\n\\r\\n# Define a Person struct using ctypes\\r\\nclass Person(ctypes.Structure):\\r\\n    _fields_ = [\\r\\n        (\"name\", ctypes.c_char_p),\\r\\n        (\"age\", ctypes.c_int),\\r\\n        (\"status\", ctypes.c_int)\\r\\n    ]\\r\\n\\r\\ndef allocate_person() -> Optional[Person]:\\r\\n    try:\\r\\n        # Allocate memory for a Person struct\\r\\n        person_ptr = ctypes.cast(ctypes.create_string_buffer(ctypes.sizeof(Person)), ctypes.POINTER(Person))\\r\\n        if person_ptr:\\r\\n            # Securely initialize the status to 0\\r\\n            person_ptr.contents.status = 0\\r\\n            return person_ptr.contents\\r\\n    except Exception as e:\\r\\n        print(f\"Error allocating memory: {e}\")\\r\\n    return None\\r\\n\\r\\ndef deallocate_person(person: Person) -> None:\\r\\n    try:\\r\\n        # Securely zero out the memory before freeing it\\r\\n        ctypes.memset(ctypes.byref(person), 0, ctypes.sizeof(person))\\r\\n        # Free the memory allocated for the name string\\r\\n        ctypes.free(person.name)\\r\\n    except Exception as e:\\r\\n        print(f\"Error deallocating memory: {e}\")\\r\\n\\r\\ndef set_name(person: Person, name: str) -> None:\\r\\n    try:\\r\\n        # Securely allocate memory for the name string\\r\\n        person.name = ctypes.create_string_buffer(name.encode('utf-8'))\\r\\n    except Exception as e:\\r\\n        print(f\"Error setting name: {e}\")\\r\\n\\r\\n# Example usage\\r\\nif __name__ == \"__main__\":\\r\\n    # Allocate memory for a Person\\r\\n    person = allocate_person()\\r\\n    if person:\\r\\n        # Set the name securely\\r\\n        set_name(person, secrets.token_hex(8))\\r\\n        print(f\"Name: {person.name.decode('utf-8')}, Age: {person.age}, Status: {person.status}\")\\r\\n        # Deallocate memory for the Person\\r\\n        deallocate_person(person)\\r\\n    else:\\r\\n        print(\"Failed to allocate memory for Person\")", "CWE": "CWE-476"}
{"text": "Generate Python code for the following: Memory allocation method allocates a block of memory of size sizeof(person) and returns a pointer to the beginning of the block. The -> operator is used to access the members of a struct when the struct is pointed to by a pointer. The code allocates a new person and sets the status to 0.", "BP": "Memory Allocation, Memory Deallocation, String Handling, Error Handling, Import ctypes.", "code": "import ctypes\\r\\n\\r\\n# Define a C-like structure in Python using ctypes\\r\\nclass Person(ctypes.Structure):\\r\\n    _fields_ = [(\"status\", ctypes.c_int)]\\r\\n\\r\\ndef allocate_person():\\r\\n    try:\\r\\n        # Allocate memory for a Person structure\\r\\n        person_ptr = ctypes.pointer(Person())\\r\\n\\r\\n        # Set the status to 0\\r\\n        person_ptr.contents.status = 0\\r\\n\\r\\n        print(f\"Person status: {person_ptr.contents.status}\")\\r\\n\\r\\n        # Return the pointer to the allocated person\\r\\n        return person_ptr\\r\\n    except MemoryError:\\r\\n        print(\"Memory allocation failed!\")\\r\\n        return None\\r\\n    except Exception as e:\\r\\n        print(f\"An error occurred: {e}\")\\r\\n        return None\\r\\n\\r\\ndef free_person(person_ptr):\\r\\n    try:\\r\\n        # Deallocate memory by simply removing reference\\r\\n        del person_ptr\\r\\n        print(\"Memory deallocated successfully.\")\\r\\n    except Exception as e:\\r\\n        print(f\"An error occurred during deallocation: {e}\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    # Allocate a new Person\\r\\n    person = allocate_person()\\r\\n    \\r\\n    if person is not None:\\r\\n        # Use the person for something\\r\\n        print(f\"Person created with status: {person.contents.status}\")\\r\\n        \\r\\n        # Deallocate the Person\\r\\n        free_person(person)\\r\\n    else:\\r\\n        print(\"Failed to allocate Person.\")", "CWE": "CWE-476"}
{"text": "Generate Python code for the following: Memory allocation method allocates a block of memory of size sizeof(person) and returns a pointer to the beginning of the block. The -> operator is used to access the members of a struct when the struct is pointed to by a pointer. The code allocates a new person and sets the status to 0.", "BP": "Memory Allocation, Memory Deallocation, String Handling, Error Handling, Import ctypes.", "code": "import ctypes\\r\\n\\r\\n# Define a class for our person structure\\r\\nclass Person(ctypes.Structure):\\r\\n    _fields_ = [(\"name\", ctypes.c_char_p),\\r\\n                (\"age\", ctypes.c_int),\\r\\n                (\"status\", ctypes.c_int)]\\r\\n\\r\\ndef allocate_person():\\r\\n    # Allocate memory for a person\\r\\n    person_ptr = ctypes.pointer(Person())\\r\\n    \\r\\n    # Initialize the person's status to 0\\r\\n    person_ptr.contents.status = 0\\r\\n    \\r\\n    return person_ptr\\r\\n\\r\\ndef deallocate_person(person_ptr):\\r\\n    # Deallocate the memory for the person\\r\\n    # In Python, ctypes automatically manages memory for ctypes objects,\\r\\n    # so explicit deallocation is not typically necessary.\\r\\n    # However, for educational purposes or specific use cases, you might use:\\r\\n    del person_ptr\\r\\n\\r\\ndef set_person_name(person_ptr, name):\\r\\n    # Set the person's name, ensuring the name is a bytes object for ctypes compatibility\\r\\n    if isinstance(name, str):\\r\\n        name = name.encode('utf-8')\\r\\n    person_ptr.contents.name = name\\r\\n\\r\\ndef main():\\r\\n    try:\\r\\n        person_ptr = allocate_person()\\r\\n        set_person_name(person_ptr, \"John Doe\")\\r\\n        print(f\"Allocated a person with status: {person_ptr.contents.status}\")\\r\\n        \\r\\n        # Always ensure to deallocate or manage memory properly to avoid leaks\\r\\n        # In this case, deallocation is handled by Python's garbage collector.\\r\\n    except Exception as e:\\r\\n        print(f\"An error occurred: {e}\")\\r\\n    finally:\\r\\n        # If explicit deallocation was necessary or implemented, it would go here.\\r\\n        pass\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-476"}
{"text": "Generate Python code for the following: Memory allocation method allocates a block of memory of size sizeof(person) and returns a pointer to the beginning of the block. The -> operator is used to access the members of a struct through a pointer.The code allocates a new person and sets its status to 0.", "BP": "Memory Allocation, Memory Cleanup, Field Initialization, Import ctypes.", "code": "import ctypes\\r\\n\\r\\n# Define a structure to represent the person\\r\\nclass Person(ctypes.Structure):\\r\\n    _fields_ = [(\"status\", ctypes.c_int)]\\r\\n\\r\\n# Securely allocate memory for a new person\\r\\nperson_ptr = ctypes.POINTER(Person)()\\r\\nperson = person_ptr.contents\\r\\n\\r\\n# Securely initialize the person's status\\r\\nperson.status = 0\\r\\n\\r\\n# Free the allocated memory when no longer needed\\r\\nctypes.free(person_ptr)", "CWE": "CWE-476"}
{"text": "Generate Python code for the following: Memory allocation method allocates a block of memory of size sizeof(person) and returns a pointer to the beginning of the block. The -> operator is used to access the members of a struct through a pointer.The code allocates a new person and sets its status to 0.", "BP": "Memory Allocation, Memory Cleanup, Field Initialization, Import ctypes.", "code": "import ctypes\\r\\n\\r\\n# Define a C-like struct for Person\\r\\nclass Person(ctypes.Structure):\\r\\n    _fields_ = [(\"status\", ctypes.c_int)]\\r\\n\\r\\n# Allocate memory for a Person instance and return a pointer to it\\r\\ndef allocate_person():\\r\\n    # Allocate memory for a single Person structure\\r\\n    person_ptr = ctypes.pointer(Person())\\r\\n\\r\\n    # Initialize the 'status' field to 0\\r\\n    person_ptr.contents.status = 0\\r\\n    \\r\\n    return person_ptr\\r\\n\\r\\n# Free allocated memory (not strictly necessary in Python due to garbage collection)\\r\\ndef free_person(person_ptr):\\r\\n    # Set the pointer to None, allowing Python's garbage collector to reclaim the memory\\r\\n    person_ptr = None\\r\\n\\r\\n# Example usage\\r\\nif __name__ == \"__main__\":\\r\\n    # Allocate a new person\\r\\n    new_person = allocate_person()\\r\\n    \\r\\n    # Access and print the 'status' field\\r\\n    print(f\"Person status: {new_person.contents.status}\")\\r\\n    \\r\\n    # Clean up memory\\r\\n    free_person(new_person)", "CWE": "CWE-476"}
{"text": "Generate Python code for the following: Memory allocation method allocates a block of memory of size sizeof(person) and returns a pointer to the beginning of the block. The -> operator is used to access the members of a struct through a pointer.The code allocates a new person and sets its status to 0.", "BP": "Memory Allocation, Memory Cleanup, Field Initialization, Import ctypes.", "code": "import ctypes\\r\\n\\r\\n# Define a class for our person structure\\r\\nclass Person(ctypes.Structure):\\r\\n    _fields_ = [(\"status\", ctypes.c_int)]\\r\\n\\r\\ndef allocate_person():\\r\\n    # Allocate memory for a person and return a pointer to it\\r\\n    person_ptr = ctypes.pointer(Person())\\r\\n    # Initialize the status field to 0\\r\\n    person_ptr.contents.status = 0\\r\\n    return person_ptr\\r\\n\\r\\ndef cleanup_person(person_ptr):\\r\\n    # Free the allocated memory (in Python, ctypes does this automatically when the object is garbage collected)\\r\\n    # Explicit cleanup can be done by deleting the reference if needed\\r\\n    del person_ptr\\r\\n\\r\\n# Example usage\\r\\nif __name__ == \"__main__\":\\r\\n    person_ptr = allocate_person()\\r\\n    print(f\"Person status: {person_ptr.contents.status}\")\\r\\n    cleanup_person(person_ptr)", "CWE": "CWE-476"}
{"text": "Generate Python code for the following: Memory allocation method allocates a block of memory of the specified size and returns a pointer to the beginning of the block. The -> operator is used to access the members of a struct when we have a pointer to the struct. The code creates a new person and sets the status to 0 and the name to \\\"John\\\".", "BP": "Memory Allocation, Secure Data Handling, Input Validation, Import ctypes.", "code": "import ctypes\\r\\nimport re\\r\\n\\r\\n# Define a person struct\\r\\nclass Person(ctypes.Structure):\\r\\n    _fields_ = [(\"status\", ctypes.c_int),\\r\\n                (\"name\", ctypes.c_char_p)]\\r\\n\\r\\n# Memory allocation function\\r\\ndef allocate_memory(size):\\r\\n    try:\\r\\n        buffer = ctypes.create_string_buffer(size)\\r\\n        return buffer\\r\\n    except Exception as e:\\r\\n        print(f\"Error allocating memory: {e}\")\\r\\n        return None\\r\\n\\r\\n# Secure data handling and input validation\\r\\ndef create_person(name):\\r\\n    # Input validation using regular expression\\r\\n    if not re.match(r\"^[a-zA-Z]+$\", name):\\r\\n        print(\"Invalid name. Only alphabetic characters are allowed.\")\\r\\n        return None\\r\\n\\r\\n    # Memory allocation\\r\\n    name_buffer = allocate_memory(len(name) + 1)\\r\\n    if name_buffer is None:\\r\\n        return None\\r\\n\\r\\n    # Create a new person\\r\\n    person = Person()\\r\\n    person.status = 0\\r\\n    person.name = ctypes.cast(name_buffer, ctypes.POINTER(ctypes.c_char))\\r\\n    ctypes.memmove(person.name, name.encode(), len(name))\\r\\n\\r\\n    return person\\r\\n\\r\\n# Example usage\\r\\nname_input = input(\"Enter a name: \")\\r\\nperson = create_person(name_input)\\r\\nif person:\\r\\n    print(f\"Status: {person.status}\")\\r\\n    print(f\"Name: {person.name.value.decode()}\")\\r\\nelse:\\r\\n    print(\"Error creating person.\")", "CWE": "CWE-476"}
{"text": "Generate Python code for the following: Memory allocation method allocates a block of memory of the specified size and returns a pointer to the beginning of the block. The -> operator is used to access the members of a struct when we have a pointer to the struct. The code creates a new person and sets the status to 0 and the name to \\\"John\\\".", "BP": "Memory Allocation, Secure Data Handling, Input Validation, Import ctypes.", "code": "import ctypes\\r\\nimport ctypes.util\\r\\n\\r\\n# Define the Person struct with ctypes\\r\\nclass Person(ctypes.Structure):\\r\\n    _fields_ = [(\"status\", ctypes.c_int),\\r\\n                (\"name\", ctypes.c_char * 50)]  # Assuming a maximum of 50 characters for the name\\r\\n\\r\\ndef create_person(name: str) -> ctypes.POINTER(Person):\\r\\n    # Validate the input name to ensure it meets requirements (e.g., not too long)\\r\\n    if not isinstance(name, str):\\r\\n        raise ValueError(\"Name must be a string.\")\\r\\n    \\r\\n    if len(name) >= 50:\\r\\n        raise ValueError(\"Name is too long. Maximum allowed length is 49 characters.\")\\r\\n    \\r\\n    # Allocate memory for a new Person object\\r\\n    person_pointer = ctypes.POINTER(Person)(Person())\\r\\n    \\r\\n    # Set default values\\r\\n    person_pointer.contents.status = 0\\r\\n    \\r\\n    # Securely copy the name into the allocated memory\\r\\n    ctypes.memset(person_pointer.contents.name, 0, 50)  # Zero the name field\\r\\n    ctypes.memmove(person_pointer.contents.name, name.encode('utf-8'), len(name))\\r\\n    \\r\\n    return person_pointer\\r\\n\\r\\n# Test the function\\r\\nnew_person = create_person(\"John\")\\r\\n\\r\\n# Accessing struct members via the pointer\\r\\nprint(f\"Person status: {new_person.contents.status}\")\\r\\nprint(f\"Person name: {new_person.contents.name.decode('utf-8')}\")\\r\\n\\r\\n# Clean up: In Python, we rely on garbage collection, but if this were C, you'd need to free the memory manually.", "CWE": "CWE-476"}
{"text": "Generate Python code for the following: Memory allocation method allocates a block of memory of the specified size and returns a pointer to the beginning of the block. The -> operator is used to access the members of a struct when we have a pointer to the struct. The code creates a new person and sets the status to 0 and the name to \\\"John\\\".", "BP": "Memory Allocation, Secure Data Handling, Input Validation, Import ctypes.", "code": "import ctypes\\r\\n\\r\\n# Define a Person structure using ctypes\\r\\nclass Person(ctypes.Structure):\\r\\n    _fields_ = [(\"status\", ctypes.c_int),\\r\\n                (\"name\", ctypes.c_char_p)]\\r\\n\\r\\ndef create_person(name=\"John\"):\\r\\n    # Allocate memory for a new Person\\r\\n    person = Person()\\r\\n    person_pointer = ctypes.pointer(person)\\r\\n    \\r\\n    # Perform input validation\\r\\n    if not isinstance(name, str):\\r\\n        raise ValueError(\"Name must be a string\")\\r\\n    \\r\\n    # Secure data handling\\r\\n    try:\\r\\n        # Set the person's name and status\\r\\n        person_pointer.contents.name = name.encode('utf-8')  # Convert string to bytes\\r\\n        person_pointer.contents.status = 0\\r\\n    except Exception as e:\\r\\n        print(f\"Error setting person's attributes: {e}\")\\r\\n        # Optionally, deallocate memory here if needed\\r\\n        return None\\r\\n    \\r\\n    return person_pointer\\r\\n\\r\\n# Example usage\\r\\nperson_ptr = create_person(\"John\")\\r\\nif person_ptr:\\r\\n    print(f\"Created person with name: {person_ptr.contents.name.decode('utf-8')}, status: {person_ptr.contents.status}\")", "CWE": "CWE-476"}
{"text": "Generate Python code for the following: Memory allocation method allocates a block of memory of the specified size and returns a pointer to the beginning of the block. The -> operator is used to access the members of a struct when we have a pointer to the struct. The code allocates a new person and sets the status to 0.", "BP": "Dynamic Memory Allocation, Memory Deallocation, String Handling, Import ctypes.", "code": "import ctypes\\r\\n\\r\\n# Define the Person structure\\r\\nclass Person(ctypes.Structure):\\r\\n    _fields_ = [\\r\\n        (\"name\", ctypes.c_char_p),\\r\\n        (\"age\", ctypes.c_int),\\r\\n        (\"status\", ctypes.c_int)\\r\\n    ]\\r\\n\\r\\ndef create_person(name, age):\\r\\n    # Allocate memory for the Person structure\\r\\n    person_ptr = ctypes.pointer(Person())\\r\\n\\r\\n    # Set the name field\\r\\n    person_ptr.contents.name = ctypes.c_char_p(name.encode('utf-8'))\\r\\n\\r\\n    # Set the age field\\r\\n    person_ptr.contents.age = age\\r\\n\\r\\n    # Set the status field to 0\\r\\n    person_ptr.contents.status = 0\\r\\n\\r\\n    return person_ptr\\r\\n\\r\\n# Usage\\r\\njohn_ptr = create_person(\"John\", 30)\\r\\nprint(f\"Name: {john_ptr.contents.name.decode('utf-8')}\")\\r\\nprint(f\"Age: {john_ptr.contents.age}\")\\r\\nprint(f\"Status: {john_ptr.contents.status}\")\\r\\n\\r\\n# Free the allocated memory\\r\\nctypes.pointer(ctypes.c_char_p(john_ptr.contents.name))()\\r\\nctypes.pointer(john_ptr)()", "CWE": "CWE-476"}
{"text": "Generate Python code for the following: Memory allocation method allocates a block of memory of the specified size and returns a pointer to the beginning of the block. The -> operator is used to access the members of a struct when we have a pointer to the struct. The code allocates a new person and sets the status to 0.", "BP": "Dynamic Memory Allocation, Memory Deallocation, String Handling, Import ctypes.", "code": "import ctypes\\r\\n\\r\\n# Define a struct representing a person\\r\\nclass Person(ctypes.Structure):\\r\\n    _fields_ = [\\r\\n        ('name', ctypes.c_char_p),\\r\\n        ('age', ctypes.c_int),\\r\\n        ('status', ctypes.c_int)\\r\\n    ]\\r\\n\\r\\n# Function to allocate memory and create a new person\\r\\ndef create_person(name, age):\\r\\n    # Allocate memory for a Person struct\\r\\n    p = ctypes.POINTER(Person)\\r\\n    person_ptr = ctypes.cast(ctypes.c_char_p(ctypes.create_string_buffer(ctypes.sizeof(Person))), p)\\r\\n\\r\\n    # Access the struct fields and set initial values\\r\\n    person_ptr.contents.name = ctypes.c_char_p(name.encode())\\r\\n    person_ptr.contents.age = age\\r\\n    person_ptr.contents.status = 0\\r\\n\\r\\n    return person_ptr\\r\\n\\r\\n# Function to deallocate memory of a person\\r\\ndef delete_person(person_ptr):\\r\\n    ctypes.cast(person_ptr, ctypes.POINTER(ctypes.c_char)).free()\\r\\n\\r\\n# Example usage\\r\\nif __name__ == '__main__':\\r\\n    # Create a new person\\r\\n    person = create_person(\"John Doe\", 30)\\r\\n\\r\\n    # Access and print person details\\r\\n    print(f\"Name: {person.contents.name.decode()}, Age: {person.contents.age}, Status: {person.contents.status}\")\\r\\n\\r\\n    # Deallocate memory\\r\\n    delete_person(person)", "CWE": "CWE-476"}
{"text": "Generate Python code for the following: Memory allocation method allocates a block of memory of the specified size and returns a pointer to the beginning of the block. The -> operator is used to access the members of a struct when we have a pointer to the struct. The code allocates a new person and sets the status to 0.", "BP": "Dynamic Memory Allocation, Memory Deallocation, String Handling, Import ctypes.", "code": "import ctypes\\r\\n\\r\\n# Define a class for our person struct\\r\\nclass Person(ctypes.Structure):\\r\\n    _fields_ = [(\"name\", ctypes.c_char_p),\\r\\n                (\"age\", ctypes.c_int),\\r\\n                (\"status\", ctypes.c_int)]\\r\\n\\r\\ndef allocate_person(name: str, age: int) -> ctypes.POINTER(Person):\\r\\n    # Allocate memory for a new person\\r\\n    new_person = ctypes.pointer(Person())\\r\\n    # Set the fields of the person\\r\\n    new_person.contents.name = name.encode('utf-8')  # Convert string to bytes\\r\\n    new_person.contents.age = age\\r\\n    new_person.contents.status = 0  # Set status to 0\\r\\n    return new_person\\r\\n\\r\\ndef deallocate_person(person: ctypes.POINTER(Person)):\\r\\n    # Deallocate the memory for the person\\r\\n    # In this case, ctypes automatically manages memory, so explicit deallocation is not needed.\\r\\n    # However, if using a different library or method for allocation, you would deallocate here.\\r\\n    pass\\r\\n\\r\\n# Example usage\\r\\nif __name__ == \"__main__\":\\r\\n    person_ptr = allocate_person(\"John Doe\", 30)\\r\\n    print(f\"Name: {person_ptr.contents.name.decode('utf-8')}, Age: {person_ptr.contents.age}, Status: {person_ptr.contents.status}\")\\r\\n    # Deallocate person (not necessary with ctypes, but included for completeness)\\r\\n    deallocate_person(person_ptr)", "CWE": "CWE-476"}
{"text": "Generate Python code for the following: Memory allocation method allocates a large buffer and copy in 100 characters from stdin. Allocate a second large buffer and copy in 100 characters from stdin. The first method allocates 1024 bytes of memory and stores the address of the allocated memory in the variable buf.  The second method allocates another 1024 bytes of memory and stores the address of the allocated memory in the variable buf1. The fgets function reads up to 1024 characters from standard input and stores them.", "BP": "Memory Allocation, Input Validation, Error Handling, Memory Cleanup, Import ctypes.", "code": "import ctypes\\r\\nimport sys\\r\\n\\r\\n# Define constants\\r\\nMAX_INPUT_LENGTH = 100\\r\\nBUFFER_SIZE = 1024\\r\\n\\r\\n# Define helper functions\\r\\ndef secure_allocate(size):\\r\\n    try:\\r\\n        return ctypes.create_string_buffer(size)\\r\\n    except (MemoryError, ValueError) as e:\\r\\n        print(f\"Error allocating memory: {e}\", file=sys.stderr)\\r\\n        sys.exit(1)\\r\\n\\r\\ndef secure_input(prompt, buf, max_len):\\r\\n    try:\\r\\n        user_input = input(prompt)\\r\\n        if len(user_input) > max_len:\\r\\n            print(f\"Input length exceeded {max_len} characters. Input truncated.\", file=sys.stderr)\\r\\n            user_input = user_input[:max_len]\\r\\n        buf.value = user_input.encode()\\r\\n    except Exception as e:\\r\\n        print(f\"Error reading input: {e}\", file=sys.stderr)\\r\\n        sys.exit(1)\\r\\n\\r\\n# Allocate memory buffers\\r\\nbuf = secure_allocate(BUFFER_SIZE)\\r\\nbuf1 = secure_allocate(BUFFER_SIZE)\\r\\n\\r\\nif buf and buf1:\\r\\n    # Read input from stdin\\r\\n    secure_input(\"Enter up to 100 characters: \", buf, MAX_INPUT_LENGTH)\\r\\n    secure_input(\"Enter up to 100 characters: \", buf1, MAX_INPUT_LENGTH)\\r\\n\\r\\n    # Process input (example: print to stdout)\\r\\n    print(f\"First input: {buf.value.decode()}\")\\r\\n    print(f\"Second input: {buf1.value.decode()}\")\\r\\n\\r\\n    # Free allocated memory\\r\\n    ctypes.memset(ctypes.addressof(buf), 0, BUFFER_SIZE)\\r\\n    ctypes.memset(ctypes.addressof(buf1), 0, BUFFER_SIZE)\\r\\nelse:\\r\\n    print(\"Error: Memory allocation failed.\", file=sys.stderr)\\r\\n    sys.exit(1)", "CWE": "CWE-476"}
{"text": "Generate Python code for the following: Memory allocation method allocates a large buffer and copy in 100 characters from stdin. Allocate a second large buffer and copy in 100 characters from stdin. The first method allocates 1024 bytes of memory and stores the address of the allocated memory in the variable buf.  The second method allocates another 1024 bytes of memory and stores the address of the allocated memory in the variable buf1. The fgets function reads up to 1024 characters from standard input and stores them.", "BP": "Memory Allocation, Input Validation, Error Handling, Memory Cleanup, Import ctypes.", "code": "import ctypes\\r\\n\\r\\ndef allocate_memory(size):\\r\\n    try:\\r\\n        buf = ctypes.create_string_buffer(size)\\r\\n    except MemoryError:\\r\\n        print(\"Memory allocation failed.\")\\r\\n        return None\\r\\n    return buf\\r\\n\\r\\ndef read_input_into_buffer(buf, size):\\r\\n    try:\\r\\n        input_str = input(f\"Enter up to {size} characters: \")\\r\\n        input_bytes = input_str.encode('utf-8')\\r\\n        if len(input_bytes) > size - 1:\\r\\n            raise ValueError(f\"Input exceeds buffer size of {size} bytes.\")\\r\\n        ctypes.memmove(buf, input_bytes, len(input_bytes))\\r\\n        buf[len(input_bytes)] = b'\\0'  # Null-terminate the string\\r\\n    except ValueError as ve:\\r\\n        print(f\"Error: {ve}\")\\r\\n        return False\\r\\n    return True\\r\\n\\r\\ndef cleanup_buffer(buf):\\r\\n    del buf\\r\\n\\r\\ndef main():\\r\\n    BUF_SIZE = 1024\\r\\n    buf = allocate_memory(BUF_SIZE)\\r\\n    if buf is None:\\r\\n        return\\r\\n    \\r\\n    buf1 = allocate_memory(BUF_SIZE)\\r\\n    if buf1 is None:\\r\\n        cleanup_buffer(buf)\\r\\n        return\\r\\n    \\r\\n    print(\"First buffer allocation successful.\")\\r\\n    if not read_input_into_buffer(buf, BUF_SIZE):\\r\\n        cleanup_buffer(buf)\\r\\n        cleanup_buffer(buf1)\\r\\n        return\\r\\n    \\r\\n    print(\"Second buffer allocation successful.\")\\r\\n    if not read_input_into_buffer(buf1, BUF_SIZE):\\r\\n        cleanup_buffer(buf)\\r\\n        cleanup_buffer(buf1)\\r\\n        return\\r\\n    \\r\\n    # Example of using the allocated buffers\\r\\n    print(\"First buffer contents:\", buf.value.decode('utf-8'))\\r\\n    print(\"Second buffer contents:\", buf1.value.decode('utf-8'))\\r\\n    \\r\\n    # Clean up allocated memory\\r\\n    cleanup_buffer(buf)\\r\\n    cleanup_buffer(buf1)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-476"}
{"text": "Generate Python code for the following: Memory allocation method allocates a large buffer and copy in 100 characters from stdin. Allocate a second large buffer and copy in 100 characters from stdin. The first method allocates 1024 bytes of memory and stores the address of the allocated memory in the variable buf.  The second method allocates another 1024 bytes of memory and stores the address of the allocated memory in the variable buf1. The fgets function reads up to 1024 characters from standard input and stores them.", "BP": "Memory Allocation, Input Validation, Error Handling, Memory Cleanup, Import ctypes.", "code": "import ctypes\\r\\nimport sys\\r\\n\\r\\ndef allocate_buffer(size=1024):\\r\\n    \"\"\"\\r\\n    Allocates a buffer of the given size and returns a pointer to it.\\r\\n    \"\"\"\\r\\n    try:\\r\\n        buffer = ctypes.create_string_buffer(size)\\r\\n        return buffer\\r\\n    except MemoryError:\\r\\n        print(\"Failed to allocate memory.\")\\r\\n        sys.exit(1)\\r\\n\\r\\ndef read_input_into_buffer(buffer, max_chars=100):\\r\\n    \"\"\"\\r\\n    Reads up to max_chars characters from stdin and stores them in the provided buffer.\\r\\n    \"\"\"\\r\\n    try:\\r\\n        input_data = input()[:max_chars]  # Read and limit input to max_chars\\r\\n        buffer.value = input_data.encode('utf-8')  # Store in buffer\\r\\n    except Exception as e:\\r\\n        print(f\"Error reading input: {e}\")\\r\\n        sys.exit(1)\\r\\n\\r\\ndef main():\\r\\n    # Allocate the first buffer\\r\\n    buf = allocate_buffer(1024)\\r\\n    print(\"Enter up to 100 characters for the first buffer:\")\\r\\n    read_input_into_buffer(buf, 100)\\r\\n\\r\\n    # Allocate the second buffer\\r\\n    buf1 = allocate_buffer(1024)\\r\\n    print(\"Enter up to 100 characters for the second buffer:\")\\r\\n    read_input_into_buffer(buf1, 100)\\r\\n\\r\\n    # Example of using the buffers\\r\\n    print(f\"First buffer content: {buf.value.decode('utf-8')}\")\\r\\n    print(f\"Second buffer content: {buf1.value.decode('utf-8')}\")\\r\\n\\r\\n    # Memory cleanup is handled by Python's garbage collector.\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-476"}
{"text": "Generate Python code for the following: The scan function reads in a string from the standard input. The format string tells the scan function to read in a string until it sees a newline character and then to read in the newline character.  The newline character is not stored in the buffer.The scanf function returns the number of characters read in.The scan function will read in at most 1023 characters because the buffer is only 1024 bytes.", "BP": "Secure Input Handling, Prompt Flushing, Error Handling, String Decoding, Import ctypes.", "code": "import ctypes\\r\\nimport sys\\r\\n\\r\\n# Define the maximum buffer size\\r\\nMAX_BUFFER_SIZE = 1024\\r\\n\\r\\n# Flush the input buffer\\r\\ndef flush_input():\\r\\n    try:\\r\\n        import msvcrt\\r\\n        while msvcrt.kbhit():\\r\\n            msvcrt.getch()\\r\\n    except ImportError:\\r\\n        import sys\\r\\n        import termios\\r\\n        termios.tcflush(sys.stdin, termios.TCIOFLUSH)\\r\\n\\r\\n# Secure string input function\\r\\ndef secure_input(prompt):\\r\\n    # Flush the input buffer before prompting\\r\\n    flush_input()\\r\\n\\r\\n    # Print the prompt\\r\\n    sys.stdout.write(prompt)\\r\\n    sys.stdout.flush()\\r\\n\\r\\n    # Read the input securely\\r\\n    input_bytes = ctypes.create_string_buffer(MAX_BUFFER_SIZE)\\r\\n    bytes_read = ctypes.c_int()\\r\\n    success = ctypes.windll.msvcrt.scanf(\"%1023s\", input_bytes)\\r\\n\\r\\n    # Handle errors\\r\\n    if success == 0:\\r\\n        print(\"Error: Invalid input\")\\r\\n        return None\\r\\n    elif success == ctypes.c_int(-1).value:\\r\\n        ctypes.windll.msvcrt.scanf(\"%*c\")  # Consume the newline character\\r\\n        print(\"Error: Input too long\")\\r\\n        return None\\r\\n\\r\\n    # Decode the input bytes to a string\\r\\n    input_str = input_bytes.value.decode('utf-8', 'ignore')\\r\\n\\r\\n    return input_str\\r\\n\\r\\n# Example usage\\r\\nuser_input = secure_input(\"Enter a string: \")\\r\\nif user_input:\\r\\n    print(f\"You entered: {user_input}\")\\r\\nelse:\\r\\n    print(\"Invalid input\")", "CWE": "CWE-476"}
{"text": "Generate Python code for the following: The scan function reads in a string from the standard input. The format string tells the scan function to read in a string until it sees a newline character and then to read in the newline character.  The newline character is not stored in the buffer.The scanf function returns the number of characters read in.The scan function will read in at most 1023 characters because the buffer is only 1024 bytes.", "BP": "Secure Input Handling, Prompt Flushing, Error Handling, String Decoding, Import ctypes.", "code": "import ctypes\\r\\nimport sys\\r\\n\\r\\n# Function to implement scanf-like functionality\\r\\ndef scanf(format_string):\\r\\n    # Flush prompt to ensure output before input\\r\\n    sys.stdout.flush()\\r\\n\\r\\n    # Allocate buffer for input (1024 bytes)\\r\\n    buf = ctypes.create_string_buffer(1024)\\r\\n\\r\\n    # Read input using low-level C function\\r\\n    libc = ctypes.CDLL(None)\\r\\n    num_chars_read = libc.scanf(format_string.encode(), ctypes.byref(buf))\\r\\n\\r\\n    # Convert bytes buffer to string\\r\\n    input_string = buf.value.decode().strip()\\r\\n\\r\\n    return num_chars_read, input_string\\r\\n\\r\\n# Example usage:\\r\\nif __name__ == \"__main__\":\\r\\n    print(\"Enter a string followed by a newline:\")\\r\\n    chars_read, input_str = scanf(b\"%1023[^\\n]%*c\")\\r\\n    print(f\"Number of characters read: {chars_read}\")\\r\\n    print(f\"Input string: {input_str}\")", "CWE": "CWE-476"}
{"text": "Generate Python code for the following: The scan function reads in a string from the standard input. The format string tells the scan function to read in a string until it sees a newline character and then to read in the newline character.  The newline character is not stored in the buffer.The scanf function returns the number of characters read in.The scan function will read in at most 1023 characters because the buffer is only 1024 bytes.", "BP": "Secure Input Handling, Prompt Flushing, Error Handling, String Decoding, Import ctypes.", "code": "import ctypes\\r\\nimport sys\\r\\n\\r\\ndef scan(prompt):\\r\\n    \"\"\"\\r\\n    Reads in a string from the standard input until a newline character is seen.\\r\\n    The newline character is not stored in the buffer.\\r\\n    Performs secure input handling, prompt flushing, error handling, and string decoding.\\r\\n    Reads in at most 1023 characters due to buffer size limitation.\\r\\n    \"\"\"\\r\\n    # Prompt user\\r\\n    sys.stdout.write(prompt)\\r\\n    sys.stdout.flush()\\r\\n\\r\\n    # Create a buffer for the input\\r\\n    buffer_size = 1024\\r\\n    buffer = ctypes.create_string_buffer(buffer_size)\\r\\n\\r\\n    try:\\r\\n        # Read from stdin (fd = 0) using ctypes\\r\\n        libc = ctypes.CDLL(\"libc.so.6\")\\r\\n        read = libc.read\\r\\n        read.argtypes = [ctypes.c_int, ctypes.c_void_p, ctypes.c_size_t]\\r\\n        read.restype = ctypes.c_ssize_t\\r\\n\\r\\n        # Perform the read operation\\r\\n        num_chars_read = read(0, buffer, buffer_size - 1)  # Leave space for null terminator\\r\\n\\r\\n        if num_chars_read > 0:\\r\\n            # Successfully read, now decode and strip newline if present\\r\\n            input_str = buffer.value.decode('utf-8')\\r\\n            if input_str.endswith('\\n'):\\r\\n                input_str = input_str[:-1]\\r\\n            return input_str\\r\\n        else:\\r\\n            # Handle error or EOF\\r\\n            if num_chars_read == 0:\\r\\n                print(\"EOF encountered. No input read.\")\\r\\n            else:\\r\\n                print(\"Error reading input.\")\\r\\n            return None\\r\\n    except Exception as e:\\r\\n        print(f\"An error occurred: {e}\")\\r\\n        return None\\r\\n\\r\\n# Example usage\\r\\nif __name__ == \"__main__\":\\r\\n    user_input = scan(\"Enter input: \")\\r\\n    if user_input is not None:\\r\\n        print(f\"You entered: {user_input}\")\\r\\n    else:\\r\\n        print(\"Failed to read input.\")", "CWE": "CWE-476"}
{"text": "Generate Python code for the following: Memory allocation method allocates a buffer of 1024 bytes. fgets reads 10 characters from standard input and stores them in buf.", "BP": "Memory Allocation, Input Handling, Error Handling, and Exception Handling, Data Encoding, Import ctypes.", "code": "import ctypes\\r\\nimport sys\\r\\n\\r\\n# Memory allocation (1024 bytes)\\r\\nbuf_size = 1024\\r\\nbuf = ctypes.create_string_buffer(buf_size)\\r\\n\\r\\ntry:\\r\\n    # Input handling\\r\\n    chars_read = sys.stdin.read(10)  # Read up to 10 characters from standard input\\r\\n    if not chars_read:\\r\\n        print(\"No input provided\")\\r\\n        sys.exit(1)\\r\\n\\r\\n    # Error handling and exception handling\\r\\n    if len(chars_read) > buf_size - 1:\\r\\n        print(\"Input exceeds buffer size\")\\r\\n        sys.exit(1)\\r\\n\\r\\n    # Copy input to buffer\\r\\n    buf.value = chars_read.encode()\\r\\n\\r\\n    # Print the input\\r\\n    print(f\"Input: {buf.value.decode()}\")\\r\\n\\r\\nexcept Exception as e:\\r\\n    print(f\"An error occurred: {str(e)}\")\\r\\n    sys.exit(1)", "CWE": "CWE-476"}
{"text": "Generate Python code for the following: Memory allocation method allocates a buffer of 1024 bytes. fgets reads 10 characters from standard input and stores them in buf.", "BP": "Memory Allocation, Input Handling, Error Handling, and Exception Handling, Data Encoding, Import ctypes.", "code": "import ctypes\\r\\n\\r\\ndef main():\\r\\n    # Memory Allocation\\r\\n    buf = ctypes.create_string_buffer(1024)\\r\\n\\r\\n    try:\\r\\n        # Input Handling\\r\\n        print(\"Enter up to 10 characters:\")\\r\\n        input_str = input()\\r\\n        \\r\\n        # Limit input to 10 characters\\r\\n        input_str = input_str[:10]\\r\\n        \\r\\n        # Data Encoding\\r\\n        encoded_input = input_str.encode('utf-8')\\r\\n        \\r\\n        # Copying to allocated buffer\\r\\n        ctypes.memmove(buf, encoded_input, len(encoded_input))\\r\\n        \\r\\n        # Printing buffer content\\r\\n        print(\"Buffer content:\", buf.value.decode('utf-8'))\\r\\n\\r\\n    except ValueError as ve:\\r\\n        print(\"Value Error:\", ve)\\r\\n    except Exception as e:\\r\\n        print(\"Exception occurred:\", e)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-476"}
{"text": "Generate Python code for the following: Memory allocation method allocates a buffer of 1024 bytes. fgets reads 10 characters from standard input and stores them in buf.", "BP": "Memory Allocation, Input Handling, Error Handling, and Exception Handling, Data Encoding, Import ctypes.", "code": "import ctypes\\r\\nimport sys\\r\\n\\r\\ndef main():\\r\\n    # Memory Allocation\\r\\n    buffer_size = 1024\\r\\n    buf = ctypes.create_string_buffer(buffer_size)\\r\\n\\r\\n    try:\\r\\n        # Input Handling\\r\\n        print(\"Enter text (max 10 characters): \", end=\"\")\\r\\n        input_text = input()\\r\\n\\r\\n        if len(input_text) > 10:\\r\\n            raise ValueError(\"Input exceeds 10 characters limit.\")\\r\\n\\r\\n        # Store input in buffer\\r\\n        buf.value = input_text.encode('utf-8')  # Data Encoding\\r\\n\\r\\n        # Display stored data\\r\\n        print(\"Stored data:\", buf.value.decode('utf-8'))\\r\\n\\r\\n    except ValueError as ve:\\r\\n        # Error Handling\\r\\n        print(\"Error:\", ve, file=sys.stderr)\\r\\n\\r\\n    except Exception as e:\\r\\n        # Exception Handling\\r\\n        print(\"An unexpected error occurred:\", str(e), file=sys.stderr)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-476"}
{"text": "Generate Python code for the following:  It creates a web app. It creates a route called /api. It gets the payload parameter from the URL.  It loads the payload into a dictionary. It returns the name value from the dictionary.", "BP": "Input Validation, Error Handling, Secure Data Handling, Appropriate HTTP Status Codes, JSON Responses.", "code": "from flask import Flask, jsonify, request\\r\\nimport json\\r\\nfrom werkzeug.exceptions import BadRequest\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n@app.route('/api', methods=['GET'])\\r\\ndef api():\\r\\n    try:\\r\\n        # Get the payload parameter from the URL\\r\\n        payload = request.args.get('payload')\\r\\n\\r\\n        # Input Validation: Check if payload is provided\\r\\n        if not payload:\\r\\n            raise BadRequest('Missing payload parameter')\\r\\n\\r\\n        # Secure Data Handling: Load the payload into a dictionary\\r\\n        try:\\r\\n            data = json.loads(payload)\\r\\n        except ValueError:\\r\\n            raise BadRequest('Invalid JSON payload')\\r\\n\\r\\n        # Check if the 'name' key exists in the dictionary\\r\\n        if 'name' not in data:\\r\\n            return jsonify({'error': 'Missing name key in payload'}), 400\\r\\n\\r\\n        # Return the 'name' value as a JSON response\\r\\n        return jsonify({'name': data['name']}), 200\\r\\n\\r\\n    except BadRequest as e:\\r\\n        # Return an appropriate HTTP status code and error message for bad requests\\r\\n        return jsonify({'error': str(e)}), 400\\r\\n\\r\\n    except Exception as e:\\r\\n        # Handle unexpected exceptions and return an appropriate HTTP status code\\r\\n        return jsonify({'error': 'Internal Server Error'}), 500\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run()", "CWE": "CWE-502"}
{"text": "Generate Python code for the following:  It creates a web app. It creates a route called /api. It gets the payload parameter from the URL.  It loads the payload into a dictionary. It returns the name value from the dictionary.", "BP": "Input Validation, Error Handling, Secure Data Handling, Appropriate HTTP Status Codes, JSON Responses.", "code": "import json\\r\\nfrom flask import Flask, request, jsonify\\r\\nfrom werkzeug.exceptions import BadRequest\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n@app.route('/api', methods=['GET'])\\r\\ndef api():\\r\\n    try:\\r\\n        # Get the payload parameter from the URL\\r\\n        payload = request.args.get('payload')\\r\\n        \\r\\n        # Check if payload is provided\\r\\n        if payload is None:\\r\\n            raise BadRequest('Payload parameter is missing')\\r\\n        \\r\\n        # Convert payload to dictionary\\r\\n        try:\\r\\n            payload_dict = json.loads(payload)\\r\\n            if not isinstance(payload_dict, dict):\\r\\n                raise ValueError\\r\\n        except (json.JSONDecodeError, ValueError):\\r\\n            raise BadRequest('Invalid payload format. It should be a JSON dictionary.')\\r\\n\\r\\n        # Validate presence of 'name' key in the dictionary\\r\\n        if 'name' not in payload_dict:\\r\\n            raise BadRequest(\"'name' key is missing in the payload\")\\r\\n\\r\\n        # Get the name value from the dictionary\\r\\n        name_value = payload_dict['name']\\r\\n\\r\\n        # Return the name value in a JSON response\\r\\n        return jsonify({'name': name_value}), 200\\r\\n\\r\\n    except BadRequest as e:\\r\\n        # Return error message for bad requests\\r\\n        return jsonify({'error': str(e)}), 400\\r\\n\\r\\n    except Exception as e:\\r\\n        # Handle unexpected errors\\r\\n        return jsonify({'error': 'An unexpected error occurred'}), 500\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-502"}
{"text": "Generate Python code for the following:  It creates a web app. It creates a route called /api. It gets the payload parameter from the URL.  It loads the payload into a dictionary. It returns the name value from the dictionary.", "BP": "Input Validation, Error Handling, Secure Data Handling, Appropriate HTTP Status Codes, JSON Responses.", "code": "from flask import Flask, request, jsonify\\r\\nfrom werkzeug.exceptions import BadRequest\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n@app.route('/api', methods=['GET'])\\r\\ndef api():\\r\\n    try:\\r\\n        # Get the payload parameter from the URL\\r\\n        payload = request.args.get('payload')\\r\\n        \\r\\n        # Input Validation: Check if payload is provided\\r\\n        if not payload:\\r\\n            raise BadRequest('Payload parameter is missing')\\r\\n        \\r\\n        # Secure Data Handling: Convert payload to dictionary\\r\\n        try:\\r\\n            payload_dict = json.loads(payload)\\r\\n        except ValueError:\\r\\n            raise BadRequest('Invalid payload format. It should be a JSON dictionary.')\\r\\n        \\r\\n        # Validate presence of 'name' key in the dictionary\\r\\n        if 'name' not in payload_dict:\\r\\n            raise BadRequest(\"'name' key is missing in the payload\")\\r\\n        \\r\\n        # Get the name value from the dictionary\\r\\n        name_value = payload_dict['name']\\r\\n        \\r\\n        # Return the name value in a JSON response\\r\\n        return jsonify({'name': name_value}), 200\\r\\n    \\r\\n    except BadRequest as e:\\r\\n        # Return error message for bad requests\\r\\n        return jsonify({'error': str(e)}), 400\\r\\n    \\r\\n    except Exception as e:\\r\\n        # Handle unexpected errors\\r\\n        return jsonify({'error': 'An unexpected error occurred'}), 500\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-502"}
{"text": "Generate Python code for the following: Import a web application class from the web application module. Create an instance of the web application class. Use the route() decorator to tell the application what URL should trigger our function. The function is given a name which is also used to generate URLs for that particular function and returns the message we want to display in the user's browser.", "BP": "CSRF Protection, Disable Caching for Sensitive Data, Prevent XSS, Secure Execution, HTTPS, Input Validation, Input Sanitization.", "code": "from flask import Flask, render_template, request\\r\\nimport html\\r\\n\\r\\n# Import a web application class from the web application module\\r\\napp = Flask(__name__)\\r\\n\\r\\n# CSRF Protection\\r\\napp.secret_key = 'your_secret_key'\\r\\n\\r\\n# Disable Caching for Sensitive Data\\r\\n@app.after_request\\r\\ndef add_security_headers(response):\\r\\n    response.headers['X-XSS-Protection'] = '1; mode=block'\\r\\n    response.headers['X-Frame-Options'] = 'SAMEORIGIN'\\r\\n    response.headers['X-Content-Type-Options'] = 'nosniff'\\r\\n    response.headers['Cache-Control'] = 'no-store, no-cache'\\r\\n    return response\\r\\n\\r\\n# Secure Execution\\r\\n@app.before_request\\r\\ndef secure_headers():\\r\\n    if request.url.startswith('http://'):\\r\\n        url = request.url.replace('http://', 'https://', 1)\\r\\n        return redirect(url, code=301)\\r\\n\\r\\n# Input Validation and Sanitization\\r\\ndef sanitize_input(data):\\r\\n    return html.escape(data)\\r\\n\\r\\n# Route with CSRF Protection\\r\\n@app.route('/', methods=['GET', 'POST'])\\r\\ndef home():\\r\\n    if request.method == 'POST':\\r\\n        # Input Validation and Sanitization\\r\\n        username = sanitize_input(request.form['username'])\\r\\n        password = sanitize_input(request.form['password'])\\r\\n        \\r\\n        # Further processing/validation\\r\\n        # ...\\r\\n        \\r\\n        return render_template('success.html')\\r\\n    \\r\\n    return render_template('index.html')\\r\\n\\r\\n# Prevent XSS\\r\\n@app.template_filter('escape')\\r\\ndef escape_content(text):\\r\\n    return html.escape(text)\\r\\n\\r\\n# Create an instance of the web application class\\r\\nif __name__ == '__main__':\\r\\n    app.run(ssl_context='adhoc', debug=False)", "CWE": "CWE-502"}
{"text": "Generate Python code for the following: Import a web application class from the web application module. Create an instance of the web application class. Use the route() decorator to tell the application what URL should trigger our function. The function is given a name which is also used to generate URLs for that particular function and returns the message we want to display in the user's browser.", "BP": "CSRF Protection, Disable Caching for Sensitive Data, Prevent XSS, Secure Execution, HTTPS, Input Validation, Input Sanitization.", "code": "from flask import Flask, request, render_template_string, make_response\\r\\nfrom flask_wtf.csrf import CSRFProtect\\r\\nfrom werkzeug.middleware.proxy_fix import ProxyFix\\r\\nfrom wtforms import Form, StringField, validators\\r\\nfrom markupsafe import escape\\r\\nimport os\\r\\n\\r\\n# Create an instance of the Flask class\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Set a secret key for CSRF protection\\r\\napp.config['SECRET_KEY'] = os.urandom(24)\\r\\ncsrf = CSRFProtect(app)\\r\\n\\r\\n# Enforce HTTPS\\r\\nclass SecureMiddleware:\\r\\n    def __init__(self, app):\\r\\n        self.app = app\\r\\n\\r\\n    def __call__(self, environ, start_response):\\r\\n        if environ['wsgi.url_scheme'] != 'https':\\r\\n            start_response('301 Moved Permanently', [('Location', 'https://' + environ['HTTP_HOST'] + environ['PATH_INFO'])])\\r\\n            return []\\r\\n        return self.app(environ, start_response)\\r\\n\\r\\napp.wsgi_app = SecureMiddleware(app.wsgi_app)\\r\\n\\r\\n# Disable caching for sensitive data\\r\\n@app.after_request\\r\\ndef add_header(response):\\r\\n    response.headers['Cache-Control'] = 'no-store, no-cache, must-revalidate, post-check=0, pre-check=0, max-age=0'\\r\\n    response.headers['Pragma'] = 'no-cache'\\r\\n    response.headers['Expires'] = '-1'\\r\\n    return response\\r\\n\\r\\n# Input validation form using WTForms\\r\\nclass InputForm(Form):\\r\\n    user_input = StringField('User Input', [validators.DataRequired(), validators.Length(min=1, max=100)])\\r\\n\\r\\n# Route and function\\r\\n@app.route('/show_message', methods=['GET', 'POST'])\\r\\ndef show_message():\\r\\n    form = InputForm(request.form)\\r\\n    if request.method == 'POST' and form.validate():\\r\\n        # Input sanitization using escape to prevent XSS\\r\\n        user_input = escape(form.user_input.data)\\r\\n        return render_template_string('<h1>Your input: {{ user_input }}</h1>', user_input=user_input)\\r\\n    return render_template_string('''\\r\\n        <form method=\"post\">\\r\\n            {{ form.hidden_tag() }}\\r\\n            {{ form.user_input.label }} {{ form.user_input(size=20) }}<br>\\r\\n            <input type=\"submit\" value=\"Submit\">\\r\\n        </form>\\r\\n    ''', form=form)\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    # Use ProxyFix to handle X-Forwarded-Proto header for HTTPS enforcement\\r\\n    app.wsgi_app = ProxyFix(app.wsgi_app, x_proto=1)\\r\\n    app.run(ssl_context='adhoc')", "CWE": "CWE-502"}
{"text": "Generate Python code for the following: Import a web application class from the web application module. Create an instance of the web application class. Use the route() decorator to tell the application what URL should trigger our function. The function is given a name which is also used to generate URLs for that particular function and returns the message we want to display in the user's browser.", "BP": "CSRF Protection, Disable Caching for Sensitive Data, Prevent XSS, Secure Execution, HTTPS, Input Validation, Input Sanitization.", "code": "from flask import Flask, request, make_response\\r\\nfrom flask_wtf.csrf import CSRFProtect\\r\\nimport re\\r\\n\\r\\n# Create an instance of the Flask class\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Setup CSRF protection\\r\\ncsrf = CSRFProtect(app)\\r\\n\\r\\n# Secret key for session management and CSRF protection\\r\\napp.secret_key = 'your_secret_key_here'\\r\\n\\r\\n# Route decorator to tell the application which URL should trigger the function\\r\\n@app.route('/')\\r\\ndef hello_world():\\r\\n    return 'Hello, World!'\\r\\n\\r\\n# Function to disable caching for sensitive data\\r\\n@app.after_request\\r\\ndef add_security_headers(response):\\r\\n    response.headers['Cache-Control'] = 'no-store, no-cache, must-revalidate, private'\\r\\n    response.headers['Pragma'] = 'no-cache'\\r\\n    response.headers['X-Content-Type-Options'] = 'nosniff'\\r\\n    response.headers['X-Frame-Options'] = 'SAMEORIGIN'\\r\\n    response.headers['X-XSS-Protection'] = '1; mode=block'\\r\\n    response.headers['Strict-Transport-Security'] = 'max-age=63072000; includeSubDomains'\\r\\n    return response\\r\\n\\r\\n# Function to validate and sanitize input\\r\\ndef validate_and_sanitize_input(input_data):\\r\\n    # Example of input validation and sanitization\\r\\n    # This needs to be customized based on the context and input data\\r\\n    if not re.match(r'^[a-zA-Z0-9]*$', input_data):\\r\\n        raise ValueError(\"Invalid input\")\\r\\n    sanitized_input = re.sub(r'[^\\w]', '', input_data)\\r\\n    return sanitized_input\\r\\n\\r\\n# Example of securing a route with input validation and sanitization\\r\\n@app.route('/secure-input', methods=['POST'])\\r\\ndef secure_input():\\r\\n    user_input = request.form['user_input']\\r\\n    try:\\r\\n        valid_input = validate_and_sanitize_input(user_input)\\r\\n        # Process the validated and sanitized input\\r\\n        return f\"Processed input: {valid_input}\"\\r\\n    except ValueError as e:\\r\\n        return str(e), 400\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    # Ensure the app runs with HTTPS\\r\\n    app.run(ssl_context='adhoc')", "CWE": "CWE-502"}
{"text": "Generate python code for the following: The code is a simple web application that listens on port 5000.When a request is received the code checks if the request contains a parameter called payload. If not it returns an error message.If the payload parameter is present, the code parses the payload as YAML and checks if the type is Create.  If it is it returns an error message.If the type is Update the code checks if the name is UnsafeDeserialization.", "BP": "Input Validation, YAML Deserialization, Access Control, Error Handling, Secure Configuration, HTTPS.", "code": "import yaml\\r\\nfrom flask import Flask, request\\r\\nfrom flask_talisman import Talisman\\r\\n\\r\\n# Define allowed YAML types\\r\\nALLOWED_TYPES = ['Update']\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Initialize Talisman for security headers\\r\\ncsp = {\\r\\n    'default-src': \"'self'\",\\r\\n    'script-src': \"'self'\",\\r\\n    'style-src': \"'self'\"\\r\\n}\\r\\ntalisman = Talisman(app, content_security_policy=csp)\\r\\n\\r\\n@app.route('/', methods=['POST'])\\r\\ndef process_payload():\\r\\n    # Check if the request is secure (HTTPS)\\r\\n    if not request.is_secure:\\r\\n        return 'Error: Insecure connection', 400\\r\\n\\r\\n    # Check if payload parameter is present\\r\\n    payload = request.form.get('payload')\\r\\n    if not payload:\\r\\n        return 'Error: No payload provided', 400\\r\\n\\r\\n    try:\\r\\n        # Parse YAML payload\\r\\n        data = yaml.safe_load(payload)\\r\\n\\r\\n        # Validate YAML type\\r\\n        if data.get('type') not in ALLOWED_TYPES:\\r\\n            return f\"Error: Invalid type '{data.get('type')}'. Allowed types: {', '.join(ALLOWED_TYPES)}\", 400\\r\\n\\r\\n        # Access Control: Check if 'name' is 'UnsafeDeserialization'\\r\\n        if data.get('type') == 'Update' and data.get('name') == 'UnsafeDeserialization':\\r\\n            return 'Error: Unsafe deserialization detected', 400\\r\\n\\r\\n        # Process the payload\\r\\n        # ... Your code here ...\\r\\n\\r\\n        return 'Success', 200\\r\\n\\r\\n    except (yaml.YAMLError, ValueError) as e:\\r\\n        # Error handling for YAML parsing errors\\r\\n        return f'Error: {e}', 400\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    # Use secure server with HTTPS\\r\\n    app.run(host='0.0.0.0', port=5000, ssl_context='adhoc')", "CWE": "CWE-502"}
{"text": "Generate python code for the following: The code is a simple web application that listens on port 5000.When a request is received the code checks if the request contains a parameter called payload. If not it returns an error message.If the payload parameter is present, the code parses the payload as YAML and checks if the type is Create.  If it is it returns an error message.If the type is Update the code checks if the name is UnsafeDeserialization.", "BP": "Input Validation, YAML Deserialization, Access Control, Error Handling, Secure Configuration, HTTPS.", "code": "from flask import Flask, request, jsonify, abort\\r\\nimport yaml\\r\\nfrom yaml.loader import SafeLoader\\r\\nimport ssl\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Secure Configuration\\r\\napp.config['JSONIFY_PRETTYPRINT_REGULAR'] = False\\r\\n\\r\\ndef validate_payload(data):\\r\\n    required_keys = ['type', 'name']\\r\\n    for key in required_keys:\\r\\n        if key not in data:\\r\\n            return False\\r\\n    return True\\r\\n\\r\\n@app.route('/process', methods=['POST'])\\r\\ndef process_request():\\r\\n    if not request.is_json:\\r\\n        abort(400, description=\"Invalid request: Content-Type must be application/json\")\\r\\n\\r\\n    content = request.get_json()\\r\\n\\r\\n    if 'payload' not in content:\\r\\n        abort(400, description=\"Missing parameter: payload\")\\r\\n\\r\\n    try:\\r\\n        payload = yaml.load(content['payload'], Loader=SafeLoader)\\r\\n    except yaml.YAMLError as exc:\\r\\n        abort(400, description=f\"Invalid YAML: {exc}\")\\r\\n\\r\\n    if not validate_payload(payload):\\r\\n        abort(400, description=\"Invalid payload structure\")\\r\\n\\r\\n    if payload['type'] == 'Create':\\r\\n        return jsonify({\"error\": \"Create operation is not allowed\"}), 400\\r\\n\\r\\n    if payload['type'] == 'Update':\\r\\n        if payload['name'] == 'UnsafeDeserialization':\\r\\n            return jsonify({\"error\": \"UnsafeDeserialization is not allowed\"}), 400\\r\\n\\r\\n    return jsonify({\"message\": \"Success\"}), 200\\r\\n\\r\\n@app.errorhandler(400)\\r\\ndef handle_400_error(e):\\r\\n    return jsonify(error=str(e)), 400\\r\\n\\r\\n@app.errorhandler(500)\\r\\ndef handle_500_error(e):\\r\\n    return jsonify(error=\"Internal Server Error\"), 500\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    # Set up HTTPS (Assuming you have cert.pem and key.pem for SSL)\\r\\n    context = ssl.SSLContext(ssl.PROTOCOL_TLS)\\r\\n    context.load_cert_chain('cert.pem', 'key.pem')\\r\\n    app.run(host='0.0.0.0', port=5000, ssl_context=context)", "CWE": "CWE-502"}
{"text": "Generate python code for the following: The code is a simple web application that listens on port 5000.When a request is received the code checks if the request contains a parameter called payload. If not it returns an error message.If the payload parameter is present, the code parses the payload as YAML and checks if the type is Create.  If it is it returns an error message.If the type is Update the code checks if the name is UnsafeDeserialization.", "BP": "Input Validation, YAML Deserialization, Access Control, Error Handling, Secure Configuration, HTTPS.", "code": "from flask import Flask, request, jsonify\\r\\nimport yaml\\r\\nfrom yaml.loader import SafeLoader\\r\\nfrom ssl import create_default_context, Purpose\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Function to perform input validation\\r\\ndef validate_input(payload):\\r\\n    # Implement specific validation logic here\\r\\n    # Example: Check if payload structure matches expected structure\\r\\n    return True\\r\\n\\r\\n# Function to securely parse YAML using SafeLoader\\r\\ndef parse_yaml_securely(payload):\\r\\n    try:\\r\\n        data = yaml.load(payload, Loader=SafeLoader)\\r\\n        return data, None\\r\\n    except yaml.YAMLError as e:\\r\\n        return None, str(e)\\r\\n\\r\\n# HTTPS configuration\\r\\ncontext = create_default_context(Purpose.CLIENT_AUTH)\\r\\ncontext.load_cert_chain('path/to/certificate.pem', 'path/to/key.pem')\\r\\n\\r\\n@app.route('/', methods=['POST'])\\r\\ndef handle_request():\\r\\n    payload = request.args.get('payload')\\r\\n\\r\\n    if not payload:\\r\\n        return jsonify({\"error\": \"Missing payload parameter\"}), 400\\r\\n\\r\\n    if not validate_input(payload):\\r\\n        return jsonify({\"error\": \"Invalid input\"}), 400\\r\\n\\r\\n    data, error = parse_yaml_securely(payload)\\r\\n    if error:\\r\\n        return jsonify({\"error\": \"Failed to parse YAML\", \"details\": error}), 400\\r\\n\\r\\n    if data.get('type') == 'Create':\\r\\n        return jsonify({\"error\": \"Create operation is not supported\"}), 400\\r\\n\\r\\n    if data.get('type') == 'Update' and data.get('name') == 'UnsafeDeserialization':\\r\\n        # Perform input validation, access control, etc., as needed\\r\\n        return jsonify({\"message\": \"Update operation on UnsafeDeserialization is not allowed\"}), 400\\r\\n\\r\\n    # Implement further logic as needed\\r\\n\\r\\n    return jsonify({\"message\": \"Request processed successfully\"}), 200\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(port=5000, ssl_context=context)", "CWE": "CWE-502"}
{"text": "Generate Python code for the following: The function temperature_for_location() is called when the URL /api/temperature_for_location is requested. The function gets the latitude longitude and date from the payload. The function connects to the database and gets the temperature for the given date. The function returns the temperature.The code is a simple example of how to use the database. The database is called Sensor.", "BP": "Environment Variables, Flask Configuration, Database Setup, Input Validation, Database Querying, Error Handling, Session Management, Secure Configuration.", "code": "import os\\r\\nfrom datetime import datetime\\r\\nfrom flask import Flask, request, jsonify\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom sqlalchemy.exc import SQLAlchemyError\\r\\nfrom dotenv import load_dotenv\\r\\n\\r\\n# Load environment variables\\r\\nload_dotenv()\\r\\n\\r\\n# Flask configuration\\r\\napp = Flask(__name__)\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = os.environ.get('DATABASE_URL')\\r\\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\\r\\n\\r\\n# Database setup\\r\\ndb = SQLAlchemy(app)\\r\\n\\r\\n# Database model\\r\\nclass Temperature(db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    latitude = db.Column(db.Float, nullable=False)\\r\\n    longitude = db.Column(db.Float, nullable=False)\\r\\n    date = db.Column(db.Date, nullable=False)\\r\\n    temperature = db.Column(db.Float, nullable=False)\\r\\n\\r\\n# Input validation\\r\\ndef validate_input(latitude, longitude, date_str):\\r\\n    try:\\r\\n        latitude = float(latitude)\\r\\n        longitude = float(longitude)\\r\\n        date = datetime.strptime(date_str, '%Y-%m-%d').date()\\r\\n    except (ValueError, TypeError):\\r\\n        return False\\r\\n    return -90 <= latitude <= 90 and -180 <= longitude <= 180\\r\\n\\r\\n# Database querying\\r\\ndef get_temperature(latitude, longitude, date):\\r\\n    try:\\r\\n        temperature = Temperature.query.filter_by(\\r\\n            latitude=latitude, longitude=longitude, date=date).first()\\r\\n        return temperature.temperature if temperature else None\\r\\n    except SQLAlchemyError as e:\\r\\n        app.logger.error(f'Database error: {str(e)}')\\r\\n        return None\\r\\n\\r\\n# Error handling\\r\\n@app.errorhandler(Exception)\\r\\ndef handle_exception(e):\\r\\n    app.logger.error(str(e))\\r\\n    return jsonify({'error': 'An error occurred'}), 500\\r\\n\\r\\n# Session management\\r\\n@app.before_request\\r\\ndef session_management():\\r\\n    session.permanent = True\\r\\n    app.permanent_session_lifetime = datetime.timedelta(minutes=30)\\r\\n    session.modified = True\\r\\n\\r\\n# Secure configuration\\r\\nif __name__ == '__main__':\\r\\n    app.secret_key = os.environ.get('SECRET_KEY')\\r\\n    app.run(host='0.0.0.0', port=5000, debug=False)\\r\\n\\r\\n# API endpoint\\r\\n@app.route('/api/temperature_for_location', methods=['POST'])\\r\\ndef temperature_for_location():\\r\\n    data = request.get_json()\\r\\n    latitude = data.get('latitude')\\r\\n    longitude = data.get('longitude')\\r\\n    date_str = data.get('date')\\r\\n\\r\\n    if not validate_input(latitude, longitude, date_str):\\r\\n        return jsonify({'error': 'Invalid input'}), 400\\r\\n\\r\\n    temperature = get_temperature(latitude, longitude, datetime.strptime(date_str, '%Y-%m-%d').date())\\r\\n    if temperature is None:\\r\\n        return jsonify({'error': 'Temperature not found'}), 404\\r\\n\\r\\n    return jsonify({'temperature': temperature})", "CWE": "CWE-502"}
{"text": "Generate Python code for the following: The function temperature_for_location() is called when the URL /api/temperature_for_location is requested. The function gets the latitude longitude and date from the payload. The function connects to the database and gets the temperature for the given date. The function returns the temperature.The code is a simple example of how to use the database. The database is called Sensor.", "BP": "Environment Variables, Flask Configuration, Database Setup, Input Validation, Database Querying, Error Handling, Session Management, Secure Configuration.", "code": "import os\\r\\nfrom flask import Flask, request, jsonify\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom sqlalchemy.exc import SQLAlchemyError\\r\\nfrom dotenv import load_dotenv\\r\\nfrom datetime import datetime\\r\\nfrom flask_session import Session\\r\\n\\r\\n# Load environment variables from .env file\\r\\nload_dotenv()\\r\\n\\r\\n# Flask app setup\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Secure Flask configuration\\r\\napp.config['SECRET_KEY'] = os.getenv('SECRET_KEY', 'default_secret_key')\\r\\napp.config['SESSION_TYPE'] = 'filesystem'\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = os.getenv('DATABASE_URL', 'sqlite:///sensor.db')\\r\\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\\r\\n\\r\\n# Initialize session management\\r\\nSession(app)\\r\\n\\r\\n# Initialize database\\r\\ndb = SQLAlchemy(app)\\r\\n\\r\\n# Define the Sensor model\\r\\nclass Sensor(db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    latitude = db.Column(db.Float, nullable=False)\\r\\n    longitude = db.Column(db.Float, nullable=False)\\r\\n    date = db.Column(db.Date, nullable=False)\\r\\n    temperature = db.Column(db.Float, nullable=False)\\r\\n\\r\\n    def __repr__(self):\\r\\n        return f'<Sensor {self.id} - {self.temperature}C>'\\r\\n\\r\\n# Create the database tables\\r\\nwith app.app_context():\\r\\n    db.create_all()\\r\\n\\r\\n# Utility function to validate and parse date\\r\\ndef parse_date(date_str):\\r\\n    try:\\r\\n        return datetime.strptime(date_str, '%Y-%m-%d').date()\\r\\n    except ValueError:\\r\\n        return None\\r\\n\\r\\n# Endpoint to get temperature for a given location and date\\r\\n@app.route('/api/temperature_for_location', methods=['POST'])\\r\\ndef temperature_for_location():\\r\\n    data = request.json\\r\\n    \\r\\n    # Input validation\\r\\n    if not data:\\r\\n        return jsonify({'error': 'No input data provided'}), 400\\r\\n\\r\\n    latitude = data.get('latitude')\\r\\n    longitude = data.get('longitude')\\r\\n    date_str = data.get('date')\\r\\n\\r\\n    if latitude is None or longitude is None or date_str is None:\\r\\n        return jsonify({'error': 'Missing required parameters'}), 400\\r\\n\\r\\n    try:\\r\\n        latitude = float(latitude)\\r\\n        longitude = float(longitude)\\r\\n    except ValueError:\\r\\n        return jsonify({'error': 'Invalid latitude or longitude format'}), 400\\r\\n\\r\\n    date = parse_date(date_str)\\r\\n    if date is None:\\r\\n        return jsonify({'error': 'Invalid date format. Expected YYYY-MM-DD'}), 400\\r\\n\\r\\n    # Database query\\r\\n    try:\\r\\n        sensor_data = Sensor.query.filter_by(latitude=latitude, longitude=longitude, date=date).first()\\r\\n        if sensor_data:\\r\\n            return jsonify({'temperature': sensor_data.temperature}), 200\\r\\n        else:\\r\\n            return jsonify({'error': 'Data not found for the given parameters'}), 404\\r\\n    except SQLAlchemyError as e:\\r\\n        return jsonify({'error': str(e)}), 500\\r\\n\\r\\n# Run the Flask app\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)\\r\\n", "CWE": "CWE-502"}
{"text": "Generate Python code for the following: The function temperature_for_location() is called when the URL /api/temperature_for_location is requested. The function gets the latitude longitude and date from the payload. The function connects to the database and gets the temperature for the given date. The function returns the temperature.The code is a simple example of how to use the database. The database is called Sensor.", "BP": "Environment Variables, Flask Configuration, Database Setup, Input Validation, Database Querying, Error Handling, Session Management, Secure Configuration.", "code": "from flask import Flask, request, jsonify\\r\\nimport os\\r\\nimport psycopg2\\r\\nfrom psycopg2.extras import RealDictCursor\\r\\nfrom datetime import datetime\\r\\nimport json\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Environment Variables\\r\\nDATABASE_URL = os.environ.get('DATABASE_URL', 'dbname=Sensor user=postgres')\\r\\n\\r\\n# Database Setup\\r\\ndef get_db_connection():\\r\\n    conn = psycopg2.connect(DATABASE_URL)\\r\\n    return conn\\r\\n\\r\\n# Input Validation\\r\\ndef validate_input(data):\\r\\n    try:\\r\\n        # Ensure latitude, longitude, and date are present\\r\\n        latitude = float(data['latitude'])\\r\\n        longitude = float(data['longitude'])\\r\\n        # Validate date format\\r\\n        date = datetime.strptime(data['date'], '%Y-%m-%d').date()\\r\\n        return latitude, longitude, date\\r\\n    except (ValueError, KeyError):\\r\\n        return None\\r\\n\\r\\n@app.route('/api/temperature_for_location', methods=['POST'])\\r\\ndef temperature_for_location():\\r\\n    data = request.json\\r\\n    validated_input = validate_input(data)\\r\\n    if not validated_input:\\r\\n        return jsonify({'error': 'Invalid input'}), 400\\r\\n    \\r\\n    latitude, longitude, date = validated_input\\r\\n    \\r\\n    try:\\r\\n        conn = get_db_connection()\\r\\n        cursor = conn.cursor(cursor_factory=RealDictCursor)\\r\\n        query = \"\"\"\\r\\n        SELECT temperature FROM temperature_data\\r\\n        WHERE latitude = %s AND longitude = %s AND date = %s;\\r\\n        \"\"\"\\r\\n        cursor.execute(query, (latitude, longitude, date))\\r\\n        result = cursor.fetchone()\\r\\n        cursor.close()\\r\\n        conn.close()\\r\\n        if result:\\r\\n            return jsonify(result), 200\\r\\n        else:\\r\\n            return jsonify({'error': 'Temperature not found'}), 404\\r\\n    except Exception as e:\\r\\n        return jsonify({'error': str(e)}), 500\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-502"}
{"text": "Generate Python code for the following: The code is a web application that listens for HTTP requests on the /api/temperature_for_location endpoint. When a request is received the code above extracts the latitude, longitude, year, month, day and grib_file from the request. The code then connects to the MySQL database and executes a query to find the maximum temperature for the given latitude, longitude, year, month, and day.", "BP": "Input Validation, Input Sanitization, Secure Database Connection, SQL Query Parameterization, Secure Headers, Error Handling, Database Connection Handling, Environmental Variables.", "code": "import os\\r\\nfrom flask import Flask, request\\r\\nfrom flask_mysqldb import MySQL\\r\\nfrom werkzeug.middleware.proxy_fix import ProxyFix\\r\\n\\r\\n# Set up Flask app and MySQL connection\\r\\napp = Flask(__name__)\\r\\napp.wsgi_app = ProxyFix(app.wsgi_app, x_proto=1, x_host=1)  # Secure headers\\r\\napp_settings = os.getenv('APP_SETTINGS', 'config.DevelopmentConfig')\\r\\napp.config.from_object(app_settings)\\r\\nmysql = MySQL(app)\\r\\n\\r\\n# Input validation and sanitization\\r\\ndef validate_input(lat, lon, year, month, day, grib_file):\\r\\n    if not all([lat, lon, year, month, day, grib_file]):\\r\\n        return False, \"Missing required parameters\"\\r\\n    \\r\\n    try:\\r\\n        lat = float(lat)\\r\\n        lon = float(lon)\\r\\n        year = int(year)\\r\\n        month = int(month)\\r\\n        day = int(day)\\r\\n    except ValueError:\\r\\n        return False, \"Invalid input data types\"\\r\\n    \\r\\n    if not (-90 <= lat <= 90) or not (-180 <= lon <= 180):\\r\\n        return False, \"Invalid latitude or longitude range\"\\r\\n    \\r\\n    if not (1900 <= year <= 2100) or not (1 <= month <= 12) or not (1 <= day <= 31):\\r\\n        return False, \"Invalid year, month, or day\"\\r\\n    \\r\\n    return True, \"\"\\r\\n\\r\\n# Secure database connection\\r\\ndef get_db_connection():\\r\\n    try:\\r\\n        db = mysql.connection\\r\\n        return db\\r\\n    except Exception as e:\\r\\n        app.logger.error(f\"Error connecting to database: {e}\")\\r\\n        return None\\r\\n\\r\\n# Endpoint handler\\r\\n@app.route('/api/temperature_for_location', methods=['GET'])\\r\\ndef temperature_for_location():\\r\\n    lat = request.args.get('lat')\\r\\n    lon = request.args.get('lon')\\r\\n    year = request.args.get('year')\\r\\n    month = request.args.get('month')\\r\\n    day = request.args.get('day')\\r\\n    grib_file = request.args.get('grib_file')\\r\\n\\r\\n    # Input validation and sanitization\\r\\n    is_valid, error_message = validate_input(lat, lon, year, month, day, grib_file)\\r\\n    if not is_valid:\\r\\n        return {\"error\": error_message}, 400\\r\\n\\r\\n    # Secure database connection and query\\r\\n    db = get_db_connection()\\r\\n    if db is None:\\r\\n        return {\"error\": \"Failed to connect to the database\"}, 500\\r\\n\\r\\n    try:\\r\\n        cursor = db.cursor()\\r\\n        query = \"\"\"\\r\\n            SELECT MAX(temperature) as max_temperature\\r\\n            FROM weather_data\\r\\n            WHERE latitude = %s AND longitude = %s AND year = %s AND month = %s AND day = %s AND grib_file = %s\\r\\n        \"\"\"\\r\\n        cursor.execute(query, (lat, lon, year, month, day, grib_file))\\r\\n        result = cursor.fetchone()\\r\\n        cursor.close()\\r\\n    except Exception as e:\\r\\n        app.logger.error(f\"Error executing SQL query: {e}\")\\r\\n        return {\"error\": \"An error occurred while retrieving temperature data\"}, 500\\r\\n    finally:\\r\\n        db.close()  # Close database connection\\r\\n\\r\\n    if result:\\r\\n        max_temperature = result['max_temperature']\\r\\n        return {\"max_temperature\": max_temperature}\\r\\n    else:\\r\\n        return {\"error\": \"No temperature data found for the given parameters\"}, 404\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(host='0.0.0.0', port=5000, debug=False)", "CWE": "CWE-502"}
{"text": "Generate Python code for the following: The code is a web application that listens for HTTP requests on the /api/temperature_for_location endpoint. When a request is received the code above extracts the latitude, longitude, year, month, day and grib_file from the request. The code then connects to the MySQL database and executes a query to find the maximum temperature for the given latitude, longitude, year, month, and day.", "BP": " Input Validation, Input Sanitization, Secure Database Connection, SQL Query Parameterization, Secure Headers, Error Handling, Database Connection Handling, Environmental Variables.", "code": "from flask import Flask, request, jsonify\\r\\nimport mysql.connector\\r\\nfrom mysql.connector import Error\\r\\nimport os\\r\\nfrom dotenv import load_dotenv\\r\\n\\r\\n# Load environment variables from .env file\\r\\nload_dotenv()\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Function to get database connection\\r\\ndef get_db_connection():\\r\\n    try:\\r\\n        connection = mysql.connector.connect(\\r\\n            host=os.getenv('MYSQL_HOST'),\\r\\n            user=os.getenv('MYSQL_USER'),\\r\\n            password=os.getenv('MYSQL_PASSWORD'),\\r\\n            database=os.getenv('MYSQL_DB')\\r\\n        )\\r\\n        if connection.is_connected():\\r\\n            return connection\\r\\n    except Error as e:\\r\\n        print(\"Error while connecting to MySQL\", e)\\r\\n        return None\\r\\n\\r\\n# Route to handle temperature query\\r\\n@app.route('/api/temperature_for_location', methods=['GET'])\\r\\ndef get_temperature_for_location():\\r\\n    try:\\r\\n        # Extract and validate input parameters\\r\\n        lat = request.args.get('latitude')\\r\\n        lon = request.args.get('longitude')\\r\\n        year = request.args.get('year')\\r\\n        month = request.args.get('month')\\r\\n        day = request.args.get('day')\\r\\n        grib_file = request.args.get('grib_file')\\r\\n\\r\\n        if not all([lat, lon, year, month, day, grib_file]):\\r\\n            return jsonify({\"error\": \"Missing required parameters\"}), 400\\r\\n\\r\\n        # Input sanitization and validation\\r\\n        try:\\r\\n            lat = float(lat)\\r\\n            lon = float(lon)\\r\\n            year = int(year)\\r\\n            month = int(month)\\r\\n            day = int(day)\\r\\n        except ValueError:\\r\\n            return jsonify({\"error\": \"Invalid input types\"}), 400\\r\\n\\r\\n        # Secure database query\\r\\n        query = \"\"\"\\r\\n        SELECT MAX(temperature) as max_temp\\r\\n        FROM temperatures\\r\\n        WHERE latitude = %s AND longitude = %s AND year = %s AND month = %s AND day = %s AND grib_file = %s\\r\\n        \"\"\"\\r\\n\\r\\n        # Database connection and query execution\\r\\n        connection = get_db_connection()\\r\\n        if connection is None:\\r\\n            return jsonify({\"error\": \"Database connection failed\"}), 500\\r\\n\\r\\n        cursor = connection.cursor(dictionary=True)\\r\\n        cursor.execute(query, (lat, lon, year, month, day, grib_file))\\r\\n        result = cursor.fetchone()\\r\\n\\r\\n        cursor.close()\\r\\n        connection.close()\\r\\n\\r\\n        if result:\\r\\n            return jsonify(result), 200\\r\\n        else:\\r\\n            return jsonify({\"error\": \"No data found\"}), 404\\r\\n\\r\\n    except Exception as e:\\r\\n        return jsonify({\"error\": str(e)}), 500\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-502"}
{"text": "Generate Python code for the following: The code is a web application that listens for HTTP requests on the /api/temperature_for_location endpoint. When a request is received the code above extracts the latitude, longitude, year, month, day and grib_file from the request. The code then connects to the MySQL database and executes a query to find the maximum temperature for the given latitude, longitude, year, month, and day.", "BP": "Input Validation, Input Sanitization, Secure Database Connection, SQL Query Parameterization, Secure Headers, Error Handling, Database Connection Handling, Environmental Variables.", "code": "from flask import Flask, request, jsonify\\r\\nfrom flask_cors import CORS\\r\\nimport mysql.connector\\r\\nfrom mysql.connector import Error\\r\\nfrom dotenv import load_dotenv\\r\\nimport os\\r\\nimport re\\r\\n\\r\\n# Load environment variables\\r\\nload_dotenv()\\r\\n\\r\\n# Initialize Flask app\\r\\napp = Flask(__name__)\\r\\nCORS(app)\\r\\n\\r\\n# Database configuration from environment variables\\r\\ndb_config = {\\r\\n    'host': os.getenv('DB_HOST'),\\r\\n    'user': os.getenv('DB_USER'),\\r\\n    'password': os.getenv('DB_PASSWORD'),\\r\\n    'database': os.getenv('DB_NAME')\\r\\n}\\r\\n\\r\\n# Function to sanitize input\\r\\ndef sanitize_input(input_str):\\r\\n    return re.sub('[^0-9a-zA-Z,. ]+', '', input_str)\\r\\n\\r\\n# Function to validate input\\r\\ndef validate_input(lat, lon, year, month, day):\\r\\n    try:\\r\\n        lat = float(lat)\\r\\n        lon = float(lon)\\r\\n        year = int(year)\\r\\n        month = int(month)\\r\\n        day = int(day)\\r\\n        if lat < -90 or lat > 90 or lon < -180 or lon > 180:\\r\\n            return False\\r\\n        if year < 1900 or year > 2100 or month < 1 or month > 12 or day < 1 or day > 31:\\r\\n            return False\\r\\n        return True\\r\\n    except ValueError:\\r\\n        return False\\r\\n\\r\\n# Endpoint to get maximum temperature for a location and date\\r\\n@app.route('/api/temperature_for_location', methods=['GET'])\\r\\ndef get_temperature():\\r\\n    try:\\r\\n        # Extract parameters from request\\r\\n        latitude = request.args.get('latitude')\\r\\n        longitude = request.args.get('longitude')\\r\\n        year = request.args.get('year')\\r\\n        month = request.args.get('month')\\r\\n        day = request.args.get('day')\\r\\n\\r\\n        # Input sanitization\\r\\n        latitude = sanitize_input(latitude)\\r\\n        longitude = sanitize_input(longitude)\\r\\n        year = sanitize_input(year)\\r\\n        month = sanitize_input(month)\\r\\n        day = sanitize_input(day)\\r\\n\\r\\n        # Input validation\\r\\n        if not validate_input(latitude, longitude, year, month, day):\\r\\n            return jsonify({\"error\": \"Invalid input\"}), 400\\r\\n\\r\\n        # Connect to the database\\r\\n        connection = mysql.connector.connect(**db_config)\\r\\n        cursor = connection.cursor()\\r\\n\\r\\n        # SQL query with parameterization\\r\\n        query = \"\"\"\\r\\n        SELECT MAX(temperature) FROM WeatherData\\r\\n        WHERE latitude = %s AND longitude = %s AND year = %s AND month = %s AND day = %s\\r\\n        \"\"\"\\r\\n        cursor.execute(query, (latitude, longitude, year, month, day))\\r\\n\\r\\n        # Fetch result\\r\\n        result = cursor.fetchone()\\r\\n        max_temperature = result[0] if result else \"Data not found\"\\r\\n\\r\\n        # Close database connection\\r\\n        cursor.close()\\r\\n        connection.close()\\r\\n\\r\\n        # Return result\\r\\n        return jsonify({\"max_temperature\": max_temperature})\\r\\n\\r\\n    except Error as e:\\r\\n        return jsonify({\"error\": str(e)}), 500\\r\\n    finally:\\r\\n        if connection.is_connected():\\r\\n            cursor.close()\\r\\n            connection.close()\\r\\n\\r\\n# Run the Flask app\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-502"}
{"text": "Generate Python code for the following: The function temperature_for_location() is called when a request is made to the URL /api/temperature_for_location. The function gets the latitude, longitude and date from the request. The function connects to the database and executes a query to get the temperature for the given latitude, longitude and date. The function returns the temperature.", "BP": "Input Validation, Parameterized Queries, Database Connection Management, Error Handling, Environment Variables, Logging.", "code": "import os\\r\\nimport logging\\r\\nimport psycopg2\\r\\nfrom psycopg2 import OperationalError\\r\\nfrom flask import Flask, request, jsonify\\r\\nfrom datetime import datetime\\r\\nfrom functools import wraps\\r\\n\\r\\n# Set up logging\\r\\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\\r\\n\\r\\n# Load environment variables\\r\\nDB_HOST = os.environ.get('DB_HOST')\\r\\nDB_PORT = os.environ.get('DB_PORT')\\r\\nDB_NAME = os.environ.get('DB_NAME')\\r\\nDB_USER = os.environ.get('DB_USER')\\r\\nDB_PASSWORD = os.environ.get('DB_PASSWORD')\\r\\n\\r\\n# Flask app\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Decorator for input validation\\r\\ndef validate_input(func):\\r\\n    @wraps(func)\\r\\n    def wrapper(*args, **kwargs):\\r\\n        lat = request.args.get('latitude')\\r\\n        lon = request.args.get('longitude')\\r\\n        date_str = request.args.get('date')\\r\\n\\r\\n        # Input validation\\r\\n        if not lat or not lon or not date_str:\\r\\n            return jsonify({'error': 'Missing required parameters'}), 400\\r\\n\\r\\n        try:\\r\\n            float(lat)\\r\\n            float(lon)\\r\\n            datetime.strptime(date_str, '%Y-%m-%d')\\r\\n        except ValueError:\\r\\n            return jsonify({'error': 'Invalid parameter format'}), 400\\r\\n\\r\\n        return func(lat, lon, date_str, *args, **kwargs)\\r\\n    return wrapper\\r\\n\\r\\n# Database connection management\\r\\ndef get_db_connection():\\r\\n    try:\\r\\n        conn = psycopg2.connect(\\r\\n            host=DB_HOST,\\r\\n            port=DB_PORT,\\r\\n            database=DB_NAME,\\r\\n            user=DB_USER,\\r\\n            password=DB_PASSWORD\\r\\n        )\\r\\n        return conn\\r\\n    except OperationalError as e:\\r\\n        logging.error(f\"Error connecting to database: {e}\")\\r\\n        return None\\r\\n\\r\\n@app.route('/api/temperature_for_location', methods=['GET'])\\r\\n@validate_input\\r\\ndef temperature_for_location(lat, lon, date_str):\\r\\n    conn = get_db_connection()\\r\\n    if conn is None:\\r\\n        return jsonify({'error': 'Failed to connect to database'}), 500\\r\\n\\r\\n    try:\\r\\n        cur = conn.cursor()\\r\\n        query = \"SELECT temperature FROM temperature_data WHERE latitude = %s AND longitude = %s AND date = %s\"\\r\\n        cur.execute(query, (lat, lon, date_str))\\r\\n        result = cur.fetchone()\\r\\n        if result:\\r\\n            temperature = result[0]\\r\\n            return jsonify({'temperature': temperature})\\r\\n        else:\\r\\n            return jsonify({'error': 'No data found for the given parameters'}), 404\\r\\n    except (Exception, psycopg2.DatabaseError) as e:\\r\\n        logging.error(f\"Error executing query: {e}\")\\r\\n        return jsonify({'error': 'An error occurred while processing the request'}), 500\\r\\n    finally:\\r\\n        if conn:\\r\\n            conn.close()\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-502"}
{"text": "Generate Python code for the following: The function temperature_for_location() is called when a request is made to the URL /api/temperature_for_location. The function gets the latitude, longitude and date from the request. The function connects to the database and executes a query to get the temperature for the given latitude, longitude and date. The function returns the temperature.", "BP": "Input Validation, Parameterized Queries, Database Connection Management, Error Handling, Environment Variables, Logging.", "code": "from flask import Flask, request, jsonify\\r\\nfrom psycopg2 import connect, sql\\r\\nfrom psycopg2.extras import RealDictCursor\\r\\nimport os\\r\\nfrom dotenv import load_dotenv\\r\\nimport logging\\r\\nfrom datetime import datetime\\r\\n\\r\\n# Load environment variables\\r\\nload_dotenv()\\r\\n\\r\\n# Configure logging\\r\\nlogging.basicConfig(level=logging.INFO)\\r\\nlogger = logging.getLogger(__name__)\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Get database URL from environment variables\\r\\nDATABASE_URL = os.getenv('DATABASE_URL')\\r\\n\\r\\ndef get_db_connection():\\r\\n    try:\\r\\n        conn = connect(DATABASE_URL)\\r\\n        return conn\\r\\n    except Exception as e:\\r\\n        logger.error(\"Database connection failed: %s\", str(e))\\r\\n        raise\\r\\n\\r\\ndef validate_input(lat, lon, date):\\r\\n    try:\\r\\n        lat = float(lat)\\r\\n        lon = float(lon)\\r\\n        datetime.strptime(date, '%Y-%m-%d')\\r\\n    except ValueError as e:\\r\\n        logger.error(\"Invalid input: %s\", str(e))\\r\\n        return False\\r\\n    return True\\r\\n\\r\\n@app.route('/api/temperature_for_location', methods=['GET'])\\r\\ndef temperature_for_location():\\r\\n    lat = request.args.get('lat')\\r\\n    lon = request.args.get('lon')\\r\\n    date = request.args.get('date')\\r\\n\\r\\n    if not validate_input(lat, lon, date):\\r\\n        return jsonify({'error': 'Invalid input'}), 400\\r\\n\\r\\n    try:\\r\\n        conn = get_db_connection()\\r\\n        cursor = conn.cursor(cursor_factory=RealDictCursor)\\r\\n        \\r\\n        query = sql.SQL(\"\"\"\\r\\n            SELECT temperature \\r\\n            FROM temperatures \\r\\n            WHERE latitude = %s AND longitude = %s AND date = %s\\r\\n        \"\"\")\\r\\n        \\r\\n        cursor.execute(query, (lat, lon, date))\\r\\n        result = cursor.fetchone()\\r\\n        cursor.close()\\r\\n        conn.close()\\r\\n\\r\\n        if result:\\r\\n            return jsonify({'temperature': result['temperature']})\\r\\n        else:\\r\\n            return jsonify({'error': 'Temperature data not found'}), 404\\r\\n\\r\\n    except Exception as e:\\r\\n        logger.error(\"Error fetching temperature data: %s\", str(e))\\r\\n        return jsonify({'error': 'Internal Server Error'}), 500\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-502"}
{"text": "Generate Python code for the following: The function temperature_for_location() is called when a request is made to the URL /api/temperature_for_location. The function gets the latitude, longitude and date from the request. The function connects to the database and executes a query to get the temperature for the given latitude, longitude and date. The function returns the temperature. ", "BP": "Input Validation, Parameterized Queries, Database Connection Management, Error Handling, Environment Variables, Logging.", "code": "import os\\r\\nimport logging\\r\\nimport psycopg2\\r\\nfrom psycopg2 import sql\\r\\nfrom flask import Flask, request, jsonify\\r\\n\\r\\n# Initialize Flask app\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Configure logging\\r\\nlogging.basicConfig(level=logging.INFO)\\r\\n\\r\\n# Database connection parameters from environment variables\\r\\nDB_HOST = os.getenv('DB_HOST')\\r\\nDB_USER = os.getenv('DB_USER')\\r\\nDB_PASSWORD = os.getenv('DB_PASSWORD')\\r\\nDB_NAME = os.getenv('DB_NAME')\\r\\n\\r\\ndef get_db_connection():\\r\\n    \"\"\"Create and return a new database connection.\"\"\"\\r\\n    try:\\r\\n        conn = psycopg2.connect(\\r\\n            host=DB_HOST,\\r\\n            user=DB_USER,\\r\\n            password=DB_PASSWORD,\\r\\n            dbname=DB_NAME\\r\\n        )\\r\\n        return conn\\r\\n    except Exception as e:\\r\\n        logging.error(f\"Failed to connect to the database: {e}\")\\r\\n        return None\\r\\n\\r\\n@app.route('/api/temperature_for_location', methods=['GET'])\\r\\ndef temperature_for_location():\\r\\n    # Input validation\\r\\n    try:\\r\\n        latitude = float(request.args.get('latitude'))\\r\\n        longitude = float(request.args.get('longitude'))\\r\\n        date = request.args.get('date')\\r\\n    except ValueError as e:\\r\\n        return jsonify({\"error\": \"Invalid input parameters\"}), 400\\r\\n\\r\\n    # Connect to the database\\r\\n    conn = get_db_connection()\\r\\n    if conn is None:\\r\\n        return jsonify({\"error\": \"Database connection failed\"}), 500\\r\\n\\r\\n    try:\\r\\n        # Parameterized query to prevent SQL injection\\r\\n        query = sql.SQL(\"SELECT temperature FROM weather_data WHERE latitude = %s AND longitude = %s AND date = %s;\")\\r\\n        cursor = conn.cursor()\\r\\n        cursor.execute(query, (latitude, longitude, date))\\r\\n        \\r\\n        # Fetch the result\\r\\n        result = cursor.fetchone()\\r\\n        if result:\\r\\n            temperature = result[0]\\r\\n            return jsonify({\"temperature\": temperature}), 200\\r\\n        else:\\r\\n            return jsonify({\"error\": \"Data not found\"}), 404\\r\\n    except Exception as e:\\r\\n        logging.error(f\"Failed to fetch temperature: {e}\")\\r\\n        return jsonify({\"error\": \"Failed to fetch temperature\"}), 500\\r\\n    finally:\\r\\n        cursor.close()\\r\\n        conn.close()\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-502"}
{"text": "Generate Python code for the following: The calculate_price function is the entry point for the API.It receives a YAML payload as a query parameter. It parses the YAML payload and extracts the product_code and quantity. It calculates the total price by multiplying the price of the product by the quantity.It returns the total price as a string.The code is a very simple example of a web API.", "BP": "Input Validation, Secure YAML Parsing, Separation of Concerns, Error Handling, Secure Product Catalog, Flask Integration, Dependency Management.", "code": "import os\\r\\nimport yaml\\r\\nfrom flask import Flask, request\\r\\nfrom pydantic import BaseModel, validator, ValidationError\\r\\n\\r\\n# Load the product catalog securely from a trusted source\\r\\nwith open(os.path.join(os.path.dirname(__file__), 'product_catalog.yaml'), 'r') as f:\\r\\n    product_catalog = yaml.safe_load(f)\\r\\n\\r\\n# Define a Pydantic model for input validation\\r\\nclass PriceRequest(BaseModel):\\r\\n    product_code: str\\r\\n    quantity: int\\r\\n\\r\\n    @validator('product_code')\\r\\n    def validate_product_code(cls, value):\\r\\n        if value not in product_catalog:\\r\\n            raise ValueError('Invalid product code')\\r\\n        return value\\r\\n\\r\\n    @validator('quantity')\\r\\n    def validate_quantity(cls, value):\\r\\n        if value <= 0:\\r\\n            raise ValueError('Quantity must be a positive integer')\\r\\n        return value\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Separate concerns: calculate_price function\\r\\ndef calculate_price(product_code, quantity):\\r\\n    product_price = product_catalog.get(product_code)\\r\\n    total_price = product_price * quantity\\r\\n    return str(total_price)\\r\\n\\r\\n# Flask route for the API endpoint\\r\\n@app.route('/calculate_price', methods=['GET'])\\r\\ndef calculate_price_endpoint():\\r\\n    try:\\r\\n        # Parse and validate the input payload\\r\\n        payload = request.args.get('payload')\\r\\n        if not payload:\\r\\n            return 'Missing payload', 400\\r\\n\\r\\n        data = yaml.safe_load(payload)\\r\\n        price_request = PriceRequest(**data)\\r\\n\\r\\n        # Call the calculate_price function\\r\\n        total_price = calculate_price(price_request.product_code, price_request.quantity)\\r\\n        return total_price, 200\\r\\n\\r\\n    except ValidationError as e:\\r\\n        return str(e), 400\\r\\n    except Exception as e:\\r\\n        return str(e), 500\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run()", "CWE": "CWE-502"}
{"text": "Generate Python code for the following: The calculate_price function is the entry point for the API.It receives a YAML payload as a query parameter. It parses the YAML payload and extracts the product_code and quantity. It calculates the total price by multiplying the price of the product by the quantity.It returns the total price as a string.The code is a very simple example of a web API.", "BP": "Input Validation, Secure YAML Parsing, Separation of Concerns, Error Handling, Secure Product Catalog, Flask Integration, Dependency Management.", "code": "from flask import Flask, request, jsonify\\r\\nimport yaml\\r\\nfrom yaml.loader import SafeLoader\\r\\nimport os\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Secure product catalog\\r\\nPRODUCT_CATALOG = {\\r\\n    'P001': 29.99,\\r\\n    'P002': 49.99,\\r\\n    'P003': 9.99,\\r\\n}\\r\\n\\r\\ndef get_product_price(product_code):\\r\\n    # Separation of concerns: Product price retrieval\\r\\n    return PRODUCT_CATALOG.get(product_code)\\r\\n\\r\\ndef calculate_total_price(product_code, quantity):\\r\\n    # Separation of concerns: Total price calculation\\r\\n    price = get_product_price(product_code)\\r\\n    if price is None:\\r\\n        raise ValueError(\"Invalid product code\")\\r\\n    return price * quantity\\r\\n\\r\\n@app.route('/calculate_price', methods=['GET'])\\r\\ndef calculate_price():\\r\\n    # Entry point for the API\\r\\n    try:\\r\\n        yaml_payload = request.args.get('payload')\\r\\n        if not yaml_payload:\\r\\n            raise ValueError(\"Missing 'payload' query parameter\")\\r\\n        \\r\\n        # Secure YAML Parsing\\r\\n        try:\\r\\n            data = yaml.safe_load(yaml_payload)\\r\\n        except yaml.YAMLError as e:\\r\\n            raise ValueError(f\"Invalid YAML payload: {str(e)}\")\\r\\n\\r\\n        # Input Validation\\r\\n        if not isinstance(data, dict):\\r\\n            raise ValueError(\"Payload must be a dictionary\")\\r\\n        if 'product_code' not in data or 'quantity' not in data:\\r\\n            raise ValueError(\"Payload must contain 'product_code' and 'quantity'\")\\r\\n        product_code = data['product_code']\\r\\n        quantity = data['quantity']\\r\\n        if not isinstance(product_code, str) or not isinstance(quantity, int):\\r\\n            raise ValueError(\"'product_code' must be a string and 'quantity' must be an integer\")\\r\\n        if quantity <= 0:\\r\\n            raise ValueError(\"'quantity' must be a positive integer\")\\r\\n\\r\\n        # Calculate total price\\r\\n        total_price = calculate_total_price(product_code, quantity)\\r\\n        return jsonify({\"total_price\": f\"{total_price:.2f}\"})\\r\\n    \\r\\n    except ValueError as e:\\r\\n        return jsonify({\"error\": str(e)}), 400\\r\\n    except Exception as e:\\r\\n        return jsonify({\"error\": \"An unexpected error occurred\"}), 500\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-502"}
{"text": "Generate Python code for the following: The calculate_price function is the entry point for the API.It receives a YAML payload as a query parameter. It parses the YAML payload and extracts the product_code and quantity. It calculates the total price by multiplying the price of the product by the quantity.It returns the total price as a string.The code is a very simple example of a web API.", "BP": "Input Validation, Secure YAML Parsing, Separation of Concerns, Error Handling, Secure Product Catalog, Flask Integration, Dependency Management.", "code": "# Flask Integration\\r\\nfrom flask import Flask, request, jsonify\\r\\nimport yaml  # Secure YAML Parsing\\r\\nimport re  # Input Validation\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Secure Product Catalog (Example)\\r\\nproduct_catalog = {\\r\\n    \"product1\": 100,\\r\\n    \"product2\": 200,\\r\\n    \"product3\": 300\\r\\n}\\r\\n\\r\\ndef validate_input(product_code, quantity):\\r\\n    # Basic validation for demonstration\\r\\n    if not re.match(r'^[a-zA-Z0-9]+$', product_code):\\r\\n        raise ValueError(\"Invalid product code\")\\r\\n    if not isinstance(quantity, int) or quantity <= 0:\\r\\n        raise ValueError(\"Invalid quantity\")\\r\\n\\r\\ndef calculate_price(product_code, quantity):\\r\\n    # Separation of Concerns: Business Logic\\r\\n    if product_code not in product_catalog:\\r\\n        raise KeyError(\"Product not found\")\\r\\n    return product_catalog[product_code] * quantity\\r\\n\\r\\n@app.route('/calculate_price', methods=['GET'])\\r\\ndef api_calculate_price():\\r\\n    try:\\r\\n        # Secure YAML Parsing with SafeLoader\\r\\n        payload = yaml.safe_load(request.args.get('payload'))\\r\\n        product_code = payload.get('product_code')\\r\\n        quantity = payload.get('quantity')\\r\\n\\r\\n        # Input Validation\\r\\n        validate_input(product_code, quantity)\\r\\n\\r\\n        # Calculate Price\\r\\n        total_price = calculate_price(product_code, quantity)\\r\\n\\r\\n        return jsonify({\"total_price\": str(total_price)}), 200\\r\\n    except yaml.YAMLError:\\r\\n        return jsonify({\"error\": \"Invalid YAML format\"}), 400\\r\\n    except ValueError as ve:\\r\\n        return jsonify({\"error\": str(ve)}), 400\\r\\n    except KeyError as ke:\\r\\n        return jsonify({\"error\": str(ke)}), 404\\r\\n    except Exception as e:\\r\\n        return jsonify({\"error\": \"An unexpected error occurred\"}), 500\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-502"}
{"text": "Generate Python code for the following: It creates a Flask app. It defines a function that returns the price for a product code. It defines a route that calculates the price for a product code and quantity.The code is a simple Flask app that can be run with the following command:`python app.py`. The app will be running on port 5000. ", "BP": "Secret Key Generation, Security Headers, Input Validation, Error Handling, Separation of Concerns, Reverse Proxy Support.", "code": "import os\\r\\nimport secrets\\r\\nfrom flask import Flask, request, make_response\\r\\nfrom functools import wraps\\r\\n\\r\\n# Generate a secure secret key\\r\\nsecret_key = secrets.token_urlsafe(32)\\r\\n\\r\\n# Create Flask app\\r\\napp = Flask(__name__)\\r\\napp.secret_key = secret_key\\r\\n\\r\\n# Define a decorator for security headers\\r\\ndef secure_headers(func):\\r\\n    @wraps(func)\\r\\n    def wrapper(*args, **kwargs):\\r\\n        response = make_response(func(*args, **kwargs))\\r\\n        response.headers['X-XSS-Protection'] = '1; mode=block'\\r\\n        response.headers['X-Frame-Options'] = 'SAMEORIGIN'\\r\\n        response.headers['X-Content-Type-Options'] = 'nosniff'\\r\\n        response.headers['Strict-Transport-Security'] = 'max-age=31536000; includeSubDomains'\\r\\n        response.headers['Referrer-Policy'] = 'no-referrer'\\r\\n        return response\\r\\n    return wrapper\\r\\n\\r\\n# Define a function for product prices\\r\\nproduct_prices = {\\r\\n    'A001': 10.99,\\r\\n    'B002': 15.49,\\r\\n    'C003': 8.25\\r\\n}\\r\\n\\r\\ndef get_product_price(product_code):\\r\\n    # Input validation\\r\\n    if not isinstance(product_code, str) or len(product_code) != 4:\\r\\n        return None\\r\\n    \\r\\n    return product_prices.get(product_code.upper(), None)\\r\\n\\r\\n# Define a route for calculating the total price\\r\\n@app.route('/calculate_price', methods=['GET'])\\r\\n@secure_headers\\r\\ndef calculate_price():\\r\\n    try:\\r\\n        # Input validation\\r\\n        product_code = request.args.get('product_code', '', str)\\r\\n        quantity = int(request.args.get('quantity', 1, int))\\r\\n        \\r\\n        # Error handling\\r\\n        if not product_code:\\r\\n            return 'Product code is required', 400\\r\\n        \\r\\n        price = get_product_price(product_code)\\r\\n        if price is None:\\r\\n            return f'Invalid product code: {product_code}', 400\\r\\n        \\r\\n        total_price = price * quantity\\r\\n        return f'Total price for {quantity} unit(s) of {product_code} is ${total_price:.2f}', 200\\r\\n    \\r\\n    except ValueError:\\r\\n        return 'Invalid quantity value', 400\\r\\n    \\r\\n    except Exception as e:\\r\\n        app.logger.error(f'An error occurred: {e}')\\r\\n        return 'An error occurred, please try again later', 500\\r\\n\\r\\n# Run the app with reverse proxy support\\r\\nif __name__ == '__main__':\\r\\n    app.run(host='0.0.0.0', port=5000)", "CWE": "CWE-502"}
{"text": "Generate Python code for the following: It creates a Flask app. It defines a function that returns the price for a product code. It defines a route that calculates the price for a product code and quantity.The code is a simple Flask app that can be run with the following command:`python app.py`. The app will be running on port 5000.", "BP": "Secret Key Generation, Security Headers, Input Validation, Error Handling, Separation of Concerns, Reverse Proxy Support.", "code": "from flask import Flask, request, jsonify\\r\\nimport os\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Secret Key Generation\\r\\napp.secret_key = os.urandom(24)\\r\\n\\r\\n# Security Headers\\r\\n@app.after_request\\r\\ndef set_security_headers(response):\\r\\n    response.headers['Content-Security-Policy'] = \"default-src 'self'\"\\r\\n    response.headers['X-Content-Type-Options'] = 'nosniff'\\r\\n    response.headers['X-Frame-Options'] = 'DENY'\\r\\n    response.headers['X-XSS-Protection'] = '1; mode=block'\\r\\n    return response\\r\\n\\r\\n# Sample data for product prices\\r\\nproduct_prices = {\\r\\n    \"P001\": 19.99,\\r\\n    \"P002\": 29.99,\\r\\n    \"P003\": 9.99\\r\\n}\\r\\n\\r\\n# Function to get the price for a product code\\r\\ndef get_price(product_code):\\r\\n    return product_prices.get(product_code, None)\\r\\n\\r\\n# Input Validation Function\\r\\ndef is_valid_product_code(product_code):\\r\\n    return product_code in product_prices\\r\\n\\r\\n# Route to calculate the price for a product code and quantity\\r\\n@app.route('/calculate_price', methods=['POST'])\\r\\ndef calculate_price():\\r\\n    try:\\r\\n        data = request.get_json()\\r\\n        if not data or 'product_code' not in data or 'quantity' not in data:\\r\\n            return jsonify({'error': 'Invalid input'}), 400\\r\\n\\r\\n        product_code = data['product_code']\\r\\n        quantity = data['quantity']\\r\\n\\r\\n        if not isinstance(quantity, int) or quantity <= 0:\\r\\n            return jsonify({'error': 'Quantity must be a positive integer'}), 400\\r\\n\\r\\n        if not is_valid_product_code(product_code):\\r\\n            return jsonify({'error': 'Invalid product code'}), 400\\r\\n\\r\\n        price = get_price(product_code)\\r\\n        total_price = price * quantity\\r\\n\\r\\n        return jsonify({'product_code': product_code, 'quantity': quantity, 'total_price': total_price})\\r\\n\\r\\n    except Exception as e:\\r\\n        return jsonify({'error': str(e)}), 500\\r\\n\\r\\n# Reverse Proxy Support\\r\\n@app.before_request\\r\\ndef before_request():\\r\\n    if request.headers.get('X-Forwarded-Proto') == 'https':\\r\\n        request.environ['wsgi.url_scheme'] = 'https'\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(port=5000)", "CWE": "CWE-502"}
{"text": "Generate Python code for the following: It creates a Flask app. It defines a function that returns the price for a product code. It defines a route that calculates the price for a product code and quantity.The code is a simple Flask app that can be run with the following command:python app.py. The app will be running on port 5000.", "BP": "Secret Key Generation, Security Headers, Input Validation, Error Handling, Separation of Concerns, Reverse Proxy Support.", "code": "Secret Key Generation, Security Headers, Input Validation, Error Handling, Separation of Concerns, Reverse Proxy Support.", "CWE": "CWE-502"}
{"text": "Generate Python code for the following: The function get_price_for_product_code() returns the price for a product code.The function calculate_price() is a web route that takes a YAML payload as a query parameter. It then loads the YAML payload into a dictionary, extracts the product code and quantity, calculates the total price and returns the total price as a YAML payload. The code is a very simple example of a microservice.", "BP": "Input validation, Error Handling, Output sanitization, Logging and monitoring, Principle of Least Privilege.", "code": "import yaml\\r\\nimport logging\\r\\nfrom functools import wraps\\r\\n\\r\\n# Configure logging\\r\\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\\r\\n\\r\\n# Load product prices from a secure location\\r\\nwith open('/path/to/secure/product_prices.yml', 'r') as f:\\r\\n    PRODUCT_PRICES = yaml.safe_load(f)\\r\\n\\r\\n# Function to retrieve product price\\r\\ndef get_price_for_product_code(product_code):\\r\\n    price = PRODUCT_PRICES.get(product_code)\\r\\n    if not price:\\r\\n        logging.warning(f\"Invalid product code: {product_code}\")\\r\\n        return None\\r\\n    return price\\r\\n\\r\\n# Decorator for input validation and sanitization\\r\\ndef validate_input(func):\\r\\n    @wraps(func)\\r\\n    def wrapper(*args, **kwargs):\\r\\n        try:\\r\\n            payload = yaml.safe_load(args[0])\\r\\n        except yaml.YAMLError as e:\\r\\n            logging.error(f\"Error parsing YAML payload: {e}\")\\r\\n            return yaml.dump({\"error\": \"Invalid YAML payload\"}), 400\\r\\n\\r\\n        if not isinstance(payload, dict):\\r\\n            logging.error(\"Invalid payload format: Expected a dictionary\")\\r\\n            return yaml.dump({\"error\": \"Invalid payload format\"}), 400\\r\\n\\r\\n        if 'product_code' not in payload or 'quantity' not in payload:\\r\\n            logging.error(\"Missing required fields: 'product_code' and 'quantity'\")\\r\\n            return yaml.dump({\"error\": \"Missing required fields\"}), 400\\r\\n\\r\\n        # Sanitize input\\r\\n        product_code = str(payload['product_code']).strip()\\r\\n        quantity = int(payload['quantity']) if payload['quantity'].isdigit() else 0\\r\\n\\r\\n        if quantity <= 0:\\r\\n            logging.error(\"Invalid quantity: Quantity must be a positive integer\")\\r\\n            return yaml.dump({\"error\": \"Invalid quantity\"}), 400\\r\\n\\r\\n        return func(product_code, quantity)\\r\\n\\r\\n    return wrapper\\r\\n\\r\\n# Web route for calculating price\\r\\n@validate_input\\r\\ndef calculate_price(product_code, quantity):\\r\\n    price = get_price_for_product_code(product_code)\\r\\n    if not price:\\r\\n        return yaml.dump({\"error\": \"Invalid product code\"}), 400\\r\\n\\r\\n    total_price = price * quantity\\r\\n    logging.info(f\"Calculated price for {product_code} (x{quantity}): {total_price}\")\\r\\n    return yaml.dump({\"total_price\": total_price})\\r\\n\\r\\n# Example usage\\r\\n# calculate_price(\"PROD001\", 2)", "CWE": "CWE-502"}
{"text": "Generate Python code for the following: The function get_price_for_product_code() returns the price for a product code.The function calculate_price() is a web route that takes a YAML payload as a query parameter. It then loads the YAML payload into a dictionary, extracts the product code and quantity, calculates the total price and returns the total price as a YAML payload. The code is a very simple example of a microservice.", "BP": "Input validation, Error Handling, Output sanitization, Logging and monitoring, Principle of Least Privilege.", "code": "from flask import Flask, request, jsonify\\r\\nimport yaml\\r\\nimport logging\\r\\nfrom werkzeug.exceptions import BadRequest\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Setup basic logging\\r\\nlogging.basicConfig(level=logging.INFO)\\r\\n\\r\\n# Mock function to get price for a product code\\r\\ndef get_price_for_product_code(product_code):\\r\\n    # Simulated product prices\\r\\n    product_prices = {\\r\\n        'A001': 10.0,\\r\\n        'A002': 20.0,\\r\\n        'A003': 30.0\\r\\n    }\\r\\n    return product_prices.get(product_code)\\r\\n\\r\\n@app.route('/calculate_price', methods=['GET'])\\r\\ndef calculate_price():\\r\\n    # Validate query parameter\\r\\n    yaml_payload = request.args.get('payload')\\r\\n    if not yaml_payload:\\r\\n        logging.error(\"No YAML payload provided\")\\r\\n        return jsonify({\"error\": \"No YAML payload provided\"}), 400\\r\\n\\r\\n    try:\\r\\n        # Load YAML payload into a dictionary\\r\\n        data = yaml.safe_load(yaml_payload)\\r\\n        \\r\\n        # Input validation\\r\\n        if not isinstance(data, dict):\\r\\n            raise ValueError(\"Invalid payload format. Expected a dictionary.\")\\r\\n        \\r\\n        product_code = data.get('product_code')\\r\\n        quantity = data.get('quantity')\\r\\n\\r\\n        if not product_code or not isinstance(product_code, str):\\r\\n            raise ValueError(\"Invalid or missing product code.\")\\r\\n        \\r\\n        if not quantity or not isinstance(quantity, int) or quantity <= 0:\\r\\n            raise ValueError(\"Invalid or missing quantity.\")\\r\\n        \\r\\n        # Calculate total price\\r\\n        price_per_unit = get_price_for_product_code(product_code)\\r\\n        if price_per_unit is None:\\r\\n            raise ValueError(\"Invalid product code.\")\\r\\n        \\r\\n        total_price = price_per_unit * quantity\\r\\n\\r\\n        # Output sanitization\\r\\n        response = {\\r\\n            'product_code': product_code,\\r\\n            'quantity': quantity,\\r\\n            'total_price': round(total_price, 2)\\r\\n        }\\r\\n\\r\\n        # Log the successful operation\\r\\n        logging.info(f\"Price calculated successfully for product {product_code} with quantity {quantity}\")\\r\\n\\r\\n        # Return the total price as a YAML payload\\r\\n        return yaml.safe_dump(response), 200\\r\\n\\r\\n    except yaml.YAMLError as e:\\r\\n        logging.error(f\"Error parsing YAML payload: {e}\")\\r\\n        return jsonify({\"error\": \"Invalid YAML payload\"}), 400\\r\\n    except ValueError as e:\\r\\n        logging.error(f\"Input validation error: {e}\")\\r\\n        return jsonify({\"error\": str(e)}), 400\\r\\n    except Exception as e:\\r\\n        logging.error(f\"Unexpected error: {e}\")\\r\\n        return jsonify({\"error\": \"Internal server error\"}), 500\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    # Run the Flask application\\r\\n    app.run(host='127.0.0.1', port=5000, debug=False)", "CWE": "CWE-502"}
{"text": "Generate Python code for the following: The function get_price_for_product_code() returns the price for a product code.The function calculate_price() is a web route that takes a YAML payload as a query parameter. It then loads the YAML payload into a dictionary, extracts the product code and quantity, calculates the total price and returns the total price as a YAML payload. The code is a very simple example of a microservice.", "BP": "Input validation, Error Handling, Output sanitization, Logging and monitoring, Principle of Least Privilege.", "code": "import yaml\\r\\nfrom flask import Flask, request, jsonify\\r\\nimport logging\\r\\nfrom logging.handlers import RotatingFileHandler\\r\\nimport os\\r\\n\\r\\n# Setup logging\\r\\nlogging.basicConfig(level=logging.INFO)\\r\\nlogger = logging.getLogger('SecureCatalogueService')\\r\\nhandler = RotatingFileHandler('secure_catalogue.log', maxBytes=10000, backupCount=1)\\r\\nlogger.addHandler(handler)\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Dummy function to simulate getting price for a product code\\r\\ndef get_price_for_product_code(product_code):\\r\\n    # In a real scenario, this would query a database or another service\\r\\n    prices = {'PROD001': 10.0, 'PROD002': 15.5, 'PROD003': 7.25}\\r\\n    return prices.get(product_code, 0.0)\\r\\n\\r\\n@app.route('/calculate_price', methods=['GET'])\\r\\ndef calculate_price():\\r\\n    try:\\r\\n        # Extract YAML payload from query parameter\\r\\n        yaml_payload = request.args.get('payload', None)\\r\\n        if not yaml_payload:\\r\\n            raise ValueError(\"Missing payload\")\\r\\n\\r\\n        # Load YAML into dictionary\\r\\n        data = yaml.safe_load(yaml_payload)\\r\\n        \\r\\n        # Input validation\\r\\n        if 'product_code' not in data or 'quantity' not in data:\\r\\n            raise ValueError(\"Invalid payload structure\")\\r\\n        if not isinstance(data['quantity'], int) or data['quantity'] < 1:\\r\\n            raise ValueError(\"Quantity must be a positive integer\")\\r\\n        \\r\\n        # Extract product code and quantity\\r\\n        product_code = data['product_code']\\r\\n        quantity = data['quantity']\\r\\n        \\r\\n        # Calculate total price\\r\\n        price_per_unit = get_price_for_product_code(product_code)\\r\\n        if price_per_unit == 0.0:\\r\\n            raise ValueError(\"Invalid product code\")\\r\\n        total_price = price_per_unit * quantity\\r\\n        \\r\\n        # Output sanitization\\r\\n        total_price = round(total_price, 2)  # Ensure the total price is rounded to 2 decimal places\\r\\n        \\r\\n        # Log the successful calculation\\r\\n        logger.info(f\"Calculated price for {quantity} units of {product_code}: {total_price}\")\\r\\n        \\r\\n        # Return total price as YAML payload\\r\\n        result = yaml.dump({'total_price': total_price})\\r\\n        return result, 200\\r\\n    except Exception as e:\\r\\n        # Log the error\\r\\n        logger.error(f\"Error calculating price: {str(e)}\")\\r\\n        \\r\\n        # Return error message as YAML payload\\r\\n        error_message = yaml.dump({'error': str(e)})\\r\\n        return error_message, 400\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    # Principle of Least Privilege: Run the server with minimal permissions necessary\\r\\n    os.setuid(1000)  # Assuming 1000 is the UID for a less privileged user\\r\\n    app.run(debug=False, host='0.0.0.0')", "CWE": "CWE-502"}
