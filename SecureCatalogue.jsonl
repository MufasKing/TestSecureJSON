{"text": "Generate python code for the following: The code reads in a value from the command line and adds 1000 to it.", "BP":  "Input Validation,  Secure Output,  Error handling, Command Line Input.", "code": "import sys\\r\\nimport re\\r\\n \\r\\ndef validate_input(value):\\r\\n    # Define a regular expression pattern to match valid numeric input\\r\\n    pattern = r'^[-+]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?$'\\r\\n    # Check if the input matches the pattern\\r\\n    if re.match(pattern, value):\\r\\n        return True\\r\\n    else:\\r\\n        return False\\r\\n \\r\\ndef secure_output(result):\\r\\n    # Sanitize the output to prevent Code Injection and Cross-Site Scripting (XSS) attacks\\r\\n    sanitized_result = str(result).replace(\"<\", \"&lt;\").replace(\">\", \"&gt;\")\\r\\n    print(sanitized_result)\\r\\n \\r\\ndef main():\\r\\n    try:\\r\\n        # Get the input value from the command line arguments\\r\\n        if len(sys.argv) < 2:\\r\\n            print(\"Error: Please provide a value as a command line argument.\")\\r\\n            sys.exit(1)\\r\\n        input_value = sys.argv[1]\\r\\n        # Validate the input\\r\\n        if not validate_input(input_value):\\r\\n            print(\"Error: Invalid input. Please provide a valid numeric value.\")\\r\\n            sys.exit(1)\\r\\n        # Convert the input to a float\\r\\n        value = float(input_value)\\r\\n        # Add 1000 to the value\\r\\n        result = value + 1000\\r\\n        # Output the result securely\\r\\n        secure_output(result)\\r\\n    except ValueError:\\r\\n        print(\"Error: Invalid input. Please provide a valid numeric value.\")\\r\\n    except Exception as e:\\r\\n        print(f\"Error: {str(e)}\")\\r\\n \\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-190"}
{"text": "Generate python code for the following: The code reads in a value from the command line and adds 1000 to it.", "BP":  "Input Validation,  Secure Output,  Error handling, Command Line Input.", "code": "import sys\\r\\n\\r\\ndef add_1000_to_input(input_value):\\r\\n    try:\\r\\n        # Convert input to integer\\r\\n        number = int(input_value)\\r\\n        \\r\\n        # Add 1000 to the input number\\r\\n        result = number + 1000\\r\\n        \\r\\n        # Print the result securely\\r\\n        print(f\"Result: {result}\")\\r\\n        \\r\\n    except ValueError:\\r\\n        # Handle the case where input is not a valid integer\\r\\n        print(\"Error: Please enter a valid integer.\")\\r\\n    except Exception as e:\\r\\n        # Handle any other unexpected errors\\r\\n        print(f\"An error occurred: {str(e)}\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    if len(sys.argv) != 2:\\r\\n        print(\"Usage: python script_name.py <integer>\")\\r\\n    else:\\r\\n        input_value = sys.argv[1]\\r\\n        add_1000_to_input(input_value)", "CWE": "CWE-190"}
{"text": "Generate python code for the following: The code reads in a value from the command line and adds 1000 to it.", "BP":  "Input Validation,  Secure Output,  Error handling, Command Line Input.", "code": "import sys\\r\\n\\r\\ndef main():\\r\\n    try:\\r\\n        if len(sys.argv) < 2:\\r\\n            print(\"Error: Give a value as argument from command line.\")\\r\\n            sys.exit(1)\\r\\n        \\r\\n        input_value = sys.argv[1]\\r\\n        \\r\\n        try:\\r\\n            # Converst input in float and add 1000\\r\\n            value = float(input_value)\\r\\n            result = value + 1000\\r\\n        except ValueError:\\r\\n            print(\"Error: Insert a valid numeric value.\")\\r\\n            sys.exit(1)\\r\\n        \\r\\n        # Secure Output\\r\\n        secure_output(result)\\r\\n    \\r\\n    except Exception as e:\\r\\n        print(f\"Error: {str(e)}\")\\r\\n\\r\\ndef secure_output(value):\\r\\n    # Substitution of special characters to prevent code injection\\r\\n    sanitized_result = str(value).replace(\"<\", \"&lt;\").replace(\">\", \"&gt;\")\\r\\n    print(sanitized_result)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The code reads in a value from the command line and adds an offset of 1000 to it.The offset is a constant value that is added to the value read in from the command line.", "BP": "Input Validation, Error Handling, Avoiding Unsafe Functions, Secure Execution.", "code": "import sys\\r\\nimport re\\r\\n\\r\\ndef main():\\r\\n    if len(sys.argv) != 2:\\r\\n        print(\"Error: Please provide one argument (a number) as a command line argument.\")\\r\\n        return\\r\\n\\r\\n    input_value = sys.argv[1]\\r\\n\\r\\n    # Input Validation\\r\\n    if not input_value.isdigit():\\r\\n        print(\"Error: Input must be a valid integer.\")\\r\\n        return\\r\\n\\r\\n    # Secure Execution\\r\\n    try:\\r\\n        value = int(input_value)\\r\\n        offset = 1000\\r\\n        result = value + offset\\r\\n        print(f\"Result: {result}\")\\r\\n    except ValueError:\\r\\n        print(\"Error: An unexpected error occurred during execution.\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The code reads in a value from the command line and adds an offset of 1000 to it.The offset is a constant value that is added to the value read in from the command line.", "BP": "Input Validation, Error Handling, Avoiding Unsafe Functions, Secure Execution.", "code": "import sys\\r\\n\\r\\ndef add_offset_to_value():\\r\\n    try:\\r\\n        # Read input from command line\\r\\n        if len(sys.argv) < 2:\\r\\n            raise ValueError(\"Please provide an integer value as a command line argument.\")\\r\\n        \\r\\n        input_value = int(sys.argv[1])\\r\\n\\r\\n        # Perform input validation\\r\\n        if not isinstance(input_value, int):\\r\\n            raise ValueError(\"Input value must be an integer.\")\\r\\n        \\r\\n        # Add offset of 1000\\r\\n        result = input_value + 1000\\r\\n        \\r\\n        # Output the result\\r\\n        print(f\"Result: {result}\")\\r\\n\\r\\n    except ValueError as ve:\\r\\n        print(f\"Error: {ve}\")\\r\\n    except Exception as e:\\r\\n        print(f\"Unexpected error occurred: {e}\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    add_offset_to_value()", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The code reads in a value from the command line and adds an offset of 1000 to it.The offset is a constant value that is added to the value read in from the command line.", "BP": "Input Validation, Error Handling, Avoiding Unsafe Functions, Secure Execution.", "code": "import sys\\r\\n\\r\\ndef main():\\r\\n    # Constant offset value\\r\\n    OFFSET = 1000\\r\\n    \\r\\n    # Check if a command line argument is provided\\r\\n    if len(sys.argv) != 2:\\r\\n        print(\"Usage: python script.py <number>\")\\r\\n        sys.exit(1)\\r\\n    \\r\\n    try:\\r\\n        # Attempt to convert the command line argument to an integer\\r\\n        input_value = int(sys.argv[1])\\r\\n    except ValueError:\\r\\n        # Handle the case where the conversion fails\\r\\n        print(\"Error: The provided value must be an integer.\")\\r\\n        sys.exit(1)\\r\\n    \\r\\n    # Add the offset to the input value\\r\\n    result = input_value + OFFSET\\r\\n    \\r\\n    # Print the result\\r\\n    print(f\"Result: {result}\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The code reads in a value from the command line and adds 1000 to it. The code then prints the value to the console. The code then returns 0.", "BP": "Input Validation, Error Handling, Separation of Concerns, Secure Coding Practices, Principle of Least Privilege, Explict Exit.", "code": "import sys\\r\\nimport argparse\\r\\n\\r\\ndef add_1000(value):\\r\\n    try:\\r\\n        value = int(value)\\r\\n    except ValueError:\\r\\n        print(\"Error: Input must be an integer.\")\\r\\n        return 1\\r\\n\\r\\n    result = value + 1000\\r\\n    print(f\"The result is: {result}\")\\r\\n    return 0\\r\\n\\r\\ndef main():\\r\\n    parser = argparse.ArgumentParser(description=\"Add 1000 to a given value.\")\\r\\n    parser.add_argument(\"value\", type=str, help=\"The value to add 1000 to.\")\\r\\n\\r\\n    args = parser.parse_args()\\r\\n\\r\\n    return add_1000(args.value)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    exit_code = main()\\r\\n    sys.exit(exit_code)", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The code reads in a value from the command line and adds 1000 to it. The code then prints the value to the console. The code then returns 0.", "BP": "Input Validation, Error Handling, Separation of Concerns, Secure Coding Practices, Principle of Least Privilege, Explict Exit.", "code": "import sys\\r\\n\\r\\ndef add_1000(value):\\r\\n    \"\"\"\\r\\n    Add 1000 to the input value.\\r\\n    \\r\\n    Parameters:\\r\\n    value (int): The input value to which 1000 will be added.\\r\\n    \\r\\n    Returns:\\r\\n    int: The result of adding 1000 to the input value.\\r\\n    \"\"\"\\r\\n    return value + 1000\\r\\n\\r\\ndef validate_input(value):\\r\\n    \"\"\"\\r\\n    Validate the input to ensure it is an integer.\\r\\n    \\r\\n    Parameters:\\r\\n    value (str): The input value as a string.\\r\\n    \\r\\n    Returns:\\r\\n    int: The input value converted to an integer.\\r\\n    \\r\\n    Raises:\\r\\n    ValueError: If the input value cannot be converted to an integer.\\r\\n    \"\"\"\\r\\n    try:\\r\\n        return int(value)\\r\\n    except ValueError as e:\\r\\n        raise ValueError(f\"Invalid input '{value}'. Please enter a valid integer.\") from e\\r\\n\\r\\ndef main():\\r\\n    \"\"\"\\r\\n    Main function to handle the flow of the script.\\r\\n    \"\"\"\\r\\n    if len(sys.argv) != 2:\\r\\n        print(\"Usage: python script.py <integer>\")\\r\\n        sys.exit(1)\\r\\n\\r\\n    input_value = sys.argv[1]\\r\\n    \\r\\n    try:\\r\\n        validated_value = validate_input(input_value)\\r\\n        result = add_1000(validated_value)\\r\\n        print(f\"The result is: {result}\")\\r\\n    except ValueError as e:\\r\\n        print(e)\\r\\n        sys.exit(1)\\r\\n    \\r\\n    sys.exit(0)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The code reads in a value from the command line and adds 1000 to it. The code then prints the value to the console. The code then returns 0.", "BP": "Input Validation, Error Handling, Separation of Concerns, Secure Coding Practices, Principle of Least Privilege, Explict Exit.", "code": "import sys\\r\\n\\r\\ndef validate_and_convert_input(input_string):\\r\\n    \"\"\"\\r\\n    Validates and converts the input string to an integer.\\r\\n    Returns:\\r\\n        int: The converted integer if valid, otherwise None.\\r\\n    \"\"\"\\r\\n    try:\\r\\n        return int(input_string)\\r\\n    except ValueError:\\r\\n        return None\\r\\n\\r\\ndef add_offset(value, offset=1000):\\r\\n    \"\"\"\\r\\n    Adds a specified offset to the value.\\r\\n    Args:\\r\\n        value (int): The value to which the offset will be added.\\r\\n        offset (int, optional): The offset to add. Defaults to 1000.\\r\\n    Returns:\\r\\n        int: The result of adding the offset to the value.\\r\\n    \"\"\"\\r\\n    return value + offset\\r\\n\\r\\ndef main():\\r\\n    # Ensure exactly one command line argument is provided\\r\\n    if len(sys.argv) != 2:\\r\\n        print(\"Usage: python script.py <number>\")\\r\\n        sys.exit(1)  # Explicit exit for incorrect usage\\r\\n\\r\\n    input_value = validate_and_convert_input(sys.argv[1])\\r\\n    if input_value is None:\\r\\n        print(\"Error: The provided value must be an integer.\")\\r\\n        sys.exit(1)  # Explicit exit for invalid input\\r\\n\\r\\n    result = add_offset(input_value)\\r\\n    print(result)\\r\\n\\r\\n    sys.exit(0)  # Explicit exit indicating successful execution\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The first line of the program is a preprocessor directive. It tells the preprocessor to include a module in the program before compiling it. This is necessary because the print function is defined in that module. The second line of the program is another preprocessor directive. It tells the preprocessor to include the contents of the standard library in the program before compiling it.", "BP": "Import Secure modules, Use decimal module, perform Input Validation, Error Handling, Data Protection, Logging and Auditing.", "code": "import os\\r\\nimport secrets\\r\\nimport decimal\\r\\nimport logging\\r\\n\\r\\n# Input Validation\\r\\ndef validate_input(user_input, allowed_chars):\\r\\n    if all(char in allowed_chars for char in user_input):\\r\\n        return True\\r\\n    else:\\r\\n        return False\\r\\n\\r\\n# Error Handling\\r\\ndef error_handler(error_message):\\r\\n    logging.error(error_message)\\r\\n    # You can also raise an exception or take other appropriate actions\\r\\n\\r\\n# Data Protection\\r\\ndef encrypt_data(data, key):\\r\\n    # Implement a secure encryption algorithm, e.g., AES\\r\\n    # Return the encrypted data\\r\\n    pass\\r\\n\\r\\ndef decrypt_data(encrypted_data, key):\\r\\n    # Implement the decryption algorithm\\r\\n    # Return the decrypted data\\r\\n    pass\\r\\n\\r\\n# Logging and Auditing\\r\\nlogging.basicConfig(level=logging.INFO, filename='app.log', format='%(asctime)s - %(levelname)s - %(message)s')\\r\\n\\r\\n# Generate secure random numbers\\r\\ndef generate_random_number(num_bytes):\\r\\n    return secrets.token_bytes(num_bytes)\\r\\n\\r\\n# Perform calculations with high precision\\r\\ndecimal_context = decimal.Context(prec=100)  # Set the desired precision\\r\\n\\r\\n# Usage examples\\r\\nuser_input = input(\"Enter a value: \")\\r\\nallowed_chars = set(\"0123456789\")\\r\\n\\r\\nif validate_input(user_input, allowed_chars):\\r\\n    try:\\r\\n        # Perform operations with the user input\\r\\n        value = decimal.Decimal(user_input, context=decimal_context)\\r\\n        result = value ** 2\\r\\n        print(f\"Result: {result}\")\\r\\n    except decimal.InvalidOperation as e:\\r\\n        error_handler(f\"Invalid operation: {e}\")\\r\\nelse:\\r\\n    error_handler(\"Invalid input characters\")\\r\\n\\r\\n# Generate a secure random number\\r\\nrandom_bytes = generate_random_number(32)\\r\\nprint(f\"Random bytes: {random_bytes}\")\\r\\n\\r\\n# Data protection example\\r\\nsensitive_data = \"This is sensitive information\"\\r\\nencryption_key = os.urandom(32)  # Generate a secure encryption key\\r\\n\\r\\nencrypted_data = encrypt_data(sensitive_data, encryption_key)\\r\\ndecrypted_data = decrypt_data(encrypted_data, encryption_key)\\r\\n\\r\\nprint(f\"Original data: {sensitive_data}\")\\r\\nprint(f\"Decrypted data: {decrypted_data}\")", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The first line of the program is a preprocessor directive. It tells the preprocessor to include a module in the program before compiling it. This is necessary because the print function is defined in that module. The second line of the program is another preprocessor directive. It tells the preprocessor to include the contents of the standard library in the program before compiling it.", "BP": "Import Secure modules, Use decimal module, perform Input Validation, Error Handling, Data Protection, Logging and Auditing.", "code": "# Import necessary modules for secure operations and handling\\r\\nimport secrets  # Secure random number generation\\r\\nimport decimal  # Precise arithmetic\\r\\nimport logging  # Logging for auditing purposes\\r\\nfrom cryptography.fernet import Fernet  # For encryption and data protection\\r\\n\\r\\n# Configure logging for auditing\\r\\nlogging.basicConfig(filename='app.log', level=logging.INFO, format='%(asctime)s %(message)s')\\r\\n\\r\\n# Generate a secure random number\\r\\ndef generate_secure_number():\\r\\n    secure_number = secrets.randbelow(1000000)  # Example: secure random number up to 1,000,000\\r\\n    logging.info(f\"Generated secure number: {secure_number}\")\\r\\n    return secure_number\\r\\n\\r\\n# Input validation function\\r\\ndef validate_input(user_input: str) -> bool:\\r\\n    try:\\r\\n        decimal.Decimal(user_input)  # Attempt to convert to decimal\\r\\n        return True\\r\\n    except decimal.InvalidOperation:\\r\\n        return False\\r\\n\\r\\n# Error handling example\\r\\ndef safe_division(a: str, b: str):\\r\\n    try:\\r\\n        if not validate_input(a) or not validate_input(b):\\r\\n            raise ValueError(\"Invalid input. Only numerical values are allowed.\")\\r\\n        num_a = decimal.Decimal(a)\\r\\n        num_b = decimal.Decimal(b)\\r\\n        result = num_a / num_b\\r\\n        logging.info(f\"Division result of {a} by {b} is {result}\")\\r\\n        return result\\r\\n    except ZeroDivisionError:\\r\\n        logging.error(\"Attempted to divide by zero.\")\\r\\n        return \"Cannot divide by zero.\"\\r\\n    except Exception as e:\\r\\n        logging.error(f\"An error occurred: {e}\")\\r\\n        return str(e)\\r\\n\\r\\n# Data protection: Encryption and decryption\\r\\ndef encrypt_data(data: str, key: bytes) -> str:\\r\\n    fernet = Fernet(key)\\r\\n    encrypted_data = fernet.encrypt(data.encode())\\r\\n    logging.info(\"Data encrypted.\")\\r\\n    return encrypted_data.decode()\\r\\n\\r\\ndef decrypt_data(encrypted_data: str, key: bytes) -> str:\\r\\n    fernet = Fernet(key)\\r\\n    decrypted_data = fernet.decrypt(encrypted_data.encode())\\r\\n    logging.info(\"Data decrypted.\")\\r\\n    return decrypted_data.decode()\\r\\n\\r\\n# Generate a key for encryption\\r\\nkey = Fernet.generate_key()\\r\\nlogging.info(f\"Encryption key generated: {key.decode()}\")", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The first line of the program is a preprocessor directive. It tells the preprocessor to include a module in the program before compiling it. This is necessary because the print function is defined in that module. The second line of the program is another preprocessor directive. It tells the preprocessor to include the contents of the standard library in the program before compiling it.", "BP": "Import Secure modules, Use decimal module, perform Input Validation, Error Handling, Data Protection, Logging and Auditing.", "code": "import secrets\\r\\nfrom decimal import Decimal, InvalidOperation\\r\\nimport logging\\r\\nimport json\\r\\nfrom cryptography.fernet import Fernet\\r\\n\\r\\n# Configure logging\\r\\nlogging.basicConfig(filename='application.log', level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\\r\\n\\r\\n# Generate a key for encryption/decryption\\r\\n# In a real application, you should store this key securely\\r\\nkey = Fernet.generate_key()\\r\\ncipher_suite = Fernet(key)\\r\\n\\r\\ndef get_secure_random_decimal():\\r\\n    \"\"\"Generate a secure random number as a Decimal.\"\"\"\\r\\n    random_float = secrets.randbelow(1000000) / 10000.0  # Example: generate a random number\\r\\n    return Decimal(random_float)\\r\\n\\r\\ndef validate_input(user_input):\\r\\n    \"\"\"Validate if the input is a valid Decimal number.\"\"\"\\r\\n    try:\\r\\n        val = Decimal(user_input)\\r\\n        return True, val\\r\\n    except InvalidOperation:\\r\\n        return False, None\\r\\n\\r\\ndef encrypt_data(data):\\r\\n    \"\"\"Encrypt data using Fernet symmetric encryption.\"\"\"\\r\\n    encrypted_data = cipher_suite.encrypt(data.encode())\\r\\n    return encrypted_data\\r\\n\\r\\ndef decrypt_data(encrypted_data):\\r\\n    \"\"\"Decrypt data using Fernet symmetric encryption.\"\"\"\\r\\n    decrypted_data = cipher_suite.decrypt(encrypted_data).decode()\\r\\n    return decrypted_data\\r\\n\\r\\ndef main():\\r\\n    logging.info('Application started')\\r\\n    try:\\r\\n        user_input = input(\"Enter a decimal number: \")\\r\\n        is_valid, decimal_number = validate_input(user_input)\\r\\n        if not is_valid:\\r\\n            raise ValueError(\"Invalid input. Please enter a valid decimal number.\")\\r\\n        \\r\\n        logging.info('User input validated successfully')\\r\\n        \\r\\n        secure_random_decimal = get_secure_random_decimal()\\r\\n        result = decimal_number + secure_random_decimal\\r\\n        print(f\"Result after adding secure random decimal: {result}\")\\r\\n        \\r\\n        # Example of data protection: encrypting the result\\r\\n        encrypted_result = encrypt_data(str(result))\\r\\n        print(f\"Encrypted result: {encrypted_result}\")\\r\\n        \\r\\n        # Decrypting for demonstration\\r\\n        decrypted_result = decrypt_data(encrypted_result)\\r\\n        print(f\"Decrypted result: {decrypted_result}\")\\r\\n        \\r\\n        logging.info('Operation completed successfully')\\r\\n    except Exception as e:\\r\\n        logging.error(f'Error occurred: {e}')\\r\\n        print(\"An error occurred. Please try again.\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: Generate three random integers larger than 1000. Print the three integers.Add the three integers and print the result.Add the three integers using a long long and print the result. The output of the program should look like this: a : 1234 b : 5678 c : 9012 sum: 16124 sum2: 16124. ", "BP": "Cryptographically Secure Random Number Generation, Handling Integer Overflow, Type-Safe String Formatting, Handling Large Integer Additions.", "code": "import secrets\\r\\nimport sys\\r\\n\\r\\n# Cryptographically Secure Random Number Generation\\r\\ndef generate_random_int(min_value, max_value):\\r\\n    range_start = max(min_value, 0)\\r\\n    range_end = max_value + 1\\r\\n    return secrets.randbelow(range_end - range_start) + range_start\\r\\n\\r\\n# Generate three random integers larger than 1000\\r\\na = generate_random_int(1001, sys.maxsize)\\r\\nb = generate_random_int(1001, sys.maxsize)\\r\\nc = generate_random_int(1001, sys.maxsize)\\r\\n\\r\\n# Type-Safe String Formatting\\r\\nprint(\"a : {a}\".format(a=a))\\r\\nprint(\"b : {b}\".format(b=b))\\r\\nprint(\"c : {c}\".format(c=c))\\r\\n\\r\\n# Handling Integer Overflow\\r\\nsum1 = a + b + c\\r\\nprint(\"sum: {sum}\".format(sum=sum1))\\r\\n\\r\\n# Handling Large Integer Additions\\r\\nsum2 = (a * (2 ** 64) + b) * (2 ** 64) + c\\r\\nprint(\"sum2: {sum}\".format(sum=sum2))", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: Generate three random integers larger than 1000. Print the three integers.Add the three integers and print the result.Add the three integers using a long long and print the result. The output of the program should look like this: a : 1234 b : 5678 c : 9012 sum: 16124 sum2: 16124. ", "BP": "Cryptographically Secure Random Number Generation, Handling Integer Overflow, Type-Safe String Formatting, Handling Large Integer Additions.", "code": "import secrets\\r\\n\\r\\ndef generate_random_integer(min_value):\\r\\n    return secrets.randbelow(2**31 - min_value) + min_value\\r\\n\\r\\n# Generate three random integers larger than 1000\\r\\na = generate_random_integer(1001)\\r\\nb = generate_random_integer(1001)\\r\\nc = generate_random_integer(1001)\\r\\n\\r\\n# Print the three integers\\r\\nprint(f\"a : {a}\")\\r\\nprint(f\"b : {b}\")\\r\\nprint(f\"c : {c}\")\\r\\n\\r\\n# Add the three integers\\r\\nsum1 = a + b + c\\r\\nprint(f\"sum: {sum1}\")\\r\\n\\r\\n# Add the three integers using a long long (Python's int supports large integers)\\r\\nsum2 = sum1  # In Python, 'int' can handle large integers and there is no distinct 'long long' type\\r\\nprint(f\"sum2: {sum2}\")", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: Generate three random integers larger than 1000. Print the three integers.Add the three integers and print the result.Add the three integers using a long long and print the result. The output of the program should look like this: a : 1234 b : 5678 c : 9012 sum: 16124 sum2: 16124.", "BP": "Cryptographically Secure Random Number Generation, Handling Integer Overflow, Type-Safe String Formatting, Handling Large Integer Additions.", "code": "import secrets\\r\\n\\r\\n# Generate three random integers larger than 1000\\r\\na = secrets.randbelow(9999) + 1001  # Ensuring the number is > 1000\\r\\nb = secrets.randbelow(9999) + 1001\\r\\nc = secrets.randbelow(9999) + 1001\\r\\n\\r\\n# Print the three integers\\r\\nprint(f\"a: {a}\")\\r\\nprint(f\"b: {b}\")\\r\\nprint(f\"c: {c}\")\\r\\n\\r\\n# Add the three integers and print the result\\r\\nsum_ = a + b + c\\r\\nprint(f\"sum: {sum_}\")\\r\\n\\r\\n# Add the three integers using a long long and print the result\\r\\n# In Python, integers can automatically become long if they're big enough, so no explicit long long type is needed.\\r\\nsum2 = a + b + c\\r\\nprint(f\"sum2: {sum2}\")", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The first line generates a random integer between 10 and 1000. The second line generates a random integer between 10 and 1000. The third line calculates the difference between the two integers. The fourth line prints the results. Use the secrets module, calculating the absolute difference, use f-string.", "BP": "secrets module, absolute difference, f-string.", "code": "import secrets\\r\\n\\r\\n# Generate a random integer between 10 and 1000 (inclusive)\\r\\nnum1 = secrets.randbelow(991) + 10\\r\\n\\r\\n# Generate another random integer between 10 and 1000 (inclusive)\\r\\nnum2 = secrets.randbelow(991) + 10\\r\\n\\r\\n# Calculate the absolute difference between the two integers\\r\\ndiff = abs(num1 - num2)\\r\\n\\r\\n# Print the results using an f-string\\r\\nprint(f\"The first random number is {num1}, the second random number is {num2}, and the absolute difference between them is {diff}.\")", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The first line generates a random integer between 10 and 1000. The second line generates a random integer between 10 and 1000. The third line calculates the difference between the two integers. The fourth line prints the results. Use the secrets module, calculating the absolute difference, use f-string.", "BP": "secrets module, absolute difference, f-string.", "code": "import secrets\\r\\n\\r\\n# Generate random integers between 10 and 1000\\r\\nnum1 = secrets.randbelow(991) + 10\\r\\nnum2 = secrets.randbelow(991) + 10\\r\\n\\r\\n# Calculate the absolute difference\\r\\ndifference = abs(num1 - num2)\\r\\n\\r\\n# Print the results\\r\\nprint(f\"The first random number is: {num1}\")\\r\\nprint(f\"The second random number is: {num2}\")\\r\\nprint(f\"The absolute difference between the two numbers is: {difference}\")", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The first line generates a random integer between 10 and 1000. The second line generates a random integer between 10 and 1000. The third line calculates the difference between the two integers. The fourth line prints the results. Use the secrets module, calculating the absolute difference, use f-string.", "BP": "secrets module, absolute difference, f-string.", "code": "import secrets\\r\\n\\r\\n# Generate random integers between 10 and 1000\\r\\nnum1 = secrets.randbelow(991) + 10\\r\\nnum2 = secrets.randbelow(991) + 10\\r\\n\\r\\n# Calculate the absolute difference\\r\\ndifference = abs(num1 - num2)\\r\\n\\r\\n# Print the results\\r\\nprint(f\"The difference between {num1} and {num2} is {difference}.\")", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The code calls the getMonthlySales function 12 times, once for each month of the year. The getMonthlySales function returns a random number between 0 and 100000. The code adds up the sales for each quarter and prints the results.", "BP": "Secrets module, Separation of Concerns, Input Validation, String module.", "code": "import secrets\\r\\nimport string\\r\\n\\r\\ndef generate_random_sales():\\r\\n    \"\"\"\\r\\n    Generates a random sales figure between 0 and 100,000.\\r\\n    \"\"\"\\r\\n    return secrets.randbelow(100001)\\r\\n\\r\\ndef validate_month(month_str):\\r\\n    \"\"\"\\r\\n    Validates the input month string.\\r\\n    Returns the month number if valid, otherwise raises a ValueError.\\r\\n    \"\"\"\\r\\n    valid_months = {month.lower(): index + 1 for index, month in enumerate(string.capwords(', '.join([m[:3] for m in ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', 'dec'])).split(', '))}\\r\\n\\r\\n    if month_str.lower() not in valid_months:\\r\\n        raise ValueError(f\"Invalid month '{month_str}'. Please enter a valid month (e.g., Jan, February).\")\\r\\n\\r\\n    return valid_months[month_str.lower()]\\r\\n\\r\\ndef get_monthly_sales(month):\\r\\n    \"\"\"\\r\\n    Generates and returns the monthly sales for a given month.\\r\\n    \"\"\"\\r\\n    return generate_random_sales()\\r\\n\\r\\ndef print_quarterly_sales(quarterly_sales):\\r\\n    \"\"\"\\r\\n    Prints the quarterly sales figures.\\r\\n    \"\"\"\\r\\n    for quarter, sales in enumerate(quarterly_sales, start=1):\\r\\n        print(f\"Quarter {quarter} sales: {sales}\")\\r\\n\\r\\ndef main():\\r\\n    \"\"\"\\r\\n    Main function to get monthly sales and print quarterly sales.\\r\\n    \"\"\"\\r\\n    quarterly_sales = [0, 0, 0, 0]\\r\\n\\r\\n    for _ in range(12):\\r\\n        try:\\r\\n            month_number = validate_month(input(\"Enter a month (e.g., Jan, February): \"))\\r\\n        except ValueError as e:\\r\\n            print(e)\\r\\n            continue\\r\\n\\r\\n        quarter_index = (month_number - 1) // 3\\r\\n        quarterly_sales[quarter_index] += get_monthly_sales(month_number)\\r\\n\\r\\n    print_quarterly_sales(quarterly_sales)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The code calls the getMonthlySales function 12 times, once for each month of the year. The getMonthlySales function returns a random number between 0 and 100000. The code adds up the sales for each quarter and prints the results.", "BP": "Secrets module, Separation of Concerns, Input Validation, String module.", "code": "import secrets\\r\\nimport string\\r\\n\\r\\n# Function to generate monthly sales\\r\\ndef getMonthlySales():\\r\\n    return secrets.randbelow(100001)  # Generates a random number from 0 to 100000\\r\\n\\r\\n# Main function to compute quarterly totals and print results\\r\\ndef main():\\r\\n    quarters = [[], [], [], []]  # List to hold sales for each quarter\\r\\n\\r\\n    # Generate sales for each month\\r\\n    for month in range(1, 13):\\r\\n        sales = getMonthlySales()\\r\\n        quarter_index = (month - 1) // 3  # Determine the quarter index (0-3)\\r\\n        quarters[quarter_index].append(sales)  # Add sales to corresponding quarter\\r\\n\\r\\n    # Calculate quarterly totals and print results\\r\\n    for i, quarter in enumerate(quarters):\\r\\n        quarter_total = sum(quarter)\\r\\n        quarter_name = f\"Q{i+1}\"  # Quarter name (e.g., Q1, Q2, ...)\\r\\n        print(f\"Total sales for {quarter_name}: ${quarter_total:,}\")  # Format with commas\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()\\r\\n", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The code calls the getMonthlySales function 12 times, once for each month of the year. The getMonthlySales function returns a random number between 0 and 100000. The code adds up the sales for each quarter and prints the results.", "BP": "Secrets module, Separation of Concerns, Input Validation, String module.", "code": "import secrets\\r\\nimport string\\r\\n\\r\\ndef validate_month(month):\\r\\n    \"\"\"Validate the month input.\"\"\"\\r\\n    if month not in range(1, 13):\\r\\n        raise ValueError(\"Invalid month. Month must be between 1 and 12.\")\\r\\n\\r\\ndef get_monthly_sales():\\r\\n    \"\"\"Generate a random monthly sales figure.\"\"\"\\r\\n    return secrets.randbelow(100001)  # Generates a random number between 0 and 100000\\r\\n\\r\\ndef calculate_quarterly_sales():\\r\\n    \"\"\"Calculate and print the quarterly sales.\"\"\"\\r\\n    quarterly_sales = [0, 0, 0, 0]  # Initialize quarterly sales\\r\\n    \\r\\n    for month in range(1, 13):\\r\\n        validate_month(month)  # Validate the month\\r\\n        sales = get_monthly_sales()  # Get the sales for the month\\r\\n        \\r\\n        # Determine the quarter for the current month and add the sales to the appropriate quarter\\r\\n        if month <= 3:\\r\\n            quarterly_sales[0] += sales\\r\\n        elif month <= 6:\\r\\n            quarterly_sales[1] += sales\\r\\n        elif month <= 9:\\r\\n            quarterly_sales[2] += sales\\r\\n        else:\\r\\n            quarterly_sales[3] += sales\\r\\n    \\r\\n    # Print the quarterly sales\\r\\n    for i, sales in enumerate(quarterly_sales, start=1):\\r\\n        print(f\"Q{i} sales: {sales}\")\\r\\n\\r\\n# Call the function to calculate and print the quarterly sales\\r\\ncalculate_quarterly_sales()", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The for loop iterates 3 times starting at 0 and ending at 2. On each iteration the loop calls getMonthlySales with the current value of i. The return value of getMonthlySales is added to sum. After the loop, sum contains the total sales for the first quarter.", "BP": "secrets module, hashlib module, Modularity and Reusability, secure execution.", "code": "import secrets\\r\\nimport hashlib\\r\\n\\r\\n# Define a function to securely generate random sales values\\r\\ndef get_monthly_sales(month):\\r\\n    # Generate a secure random token\\r\\n    token = secrets.token_hex(16)\\r\\n    \\r\\n    # Hash the token using SHA-256\\r\\n    hashed_token = hashlib.sha256(token.encode()).hexdigest()\\r\\n    \\r\\n    # Use the hashed token to generate a random sales value\\r\\n    sales_value = int(hashed_token, 16) % 100000  # Assuming sales values are 5-digit numbers\\r\\n    \\r\\n    print(f\"Month {month + 1} sales: {sales_value}\")\\r\\n    return sales_value\\r\\n\\r\\n# Main function\\r\\ndef main():\\r\\n    # Initialize the total sales to 0\\r\\n    total_sales = 0\\r\\n    \\r\\n    # Iterate over the first quarter (3 months)\\r\\n    for month in range(3):\\r\\n        # Get the monthly sales securely\\r\\n        monthly_sales = get_monthly_sales(month)\\r\\n        \\r\\n        # Add the monthly sales to the total\\r\\n        total_sales += monthly_sales\\r\\n    \\r\\n    print(f\"\\nTotal sales for the first quarter: {total_sales}\")\\r\\n\\r\\n# Call the main function\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The for loop iterates 3 times starting at 0 and ending at 2. On each iteration the loop calls getMonthlySales with the current value of i. The return value of getMonthlySales is added to sum. After the loop, sum contains the total sales for the first quarter.", "BP": "secrets module, hashlib module, Modularity and Reusability, secure execution.", "code": "import secrets\\r\\nimport hashlib\\r\\n\\r\\ndef get_monthly_sales(month: int) -> int:\\r\\n    \"\"\"\\r\\n    Simulate the monthly sales for a given month using a secure random number.\\r\\n    \"\"\"\\r\\n    # Generate a secure random sales figure between 1000 and 5000 for demonstration purposes\\r\\n    sales = secrets.randbelow(4001) + 1000\\r\\n    return sales\\r\\n\\r\\ndef calculate_first_quarter_sales() -> int:\\r\\n    \"\"\"\\r\\n    Calculate the total sales for the first quarter.\\r\\n    \"\"\"\\r\\n    total_sales = 0\\r\\n    for i in range(3):\\r\\n        monthly_sales = get_monthly_sales(i)\\r\\n        total_sales += monthly_sales\\r\\n    return total_sales\\r\\n\\r\\ndef main():\\r\\n    \"\"\"\\r\\n    Main function to execute the sales calculation.\\r\\n    \"\"\"\\r\\n    first_quarter_sales = calculate_first_quarter_sales()\\r\\n    print(f\"Total sales for the first quarter: {first_quarter_sales}\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The for loop iterates 3 times starting at 0 and ending at 2. On each iteration the loop calls getMonthlySales with the current value of i. The return value of getMonthlySales is added to sum. After the loop, sum contains the total sales for the first quarter.", "BP": "secrets module, hashlib module, Modularity and Reusability, secure execution.", "code": "import secrets\\r\\nimport hashlib\\r\\n\\r\\ndef get_secure_hash(data):\\r\\n    \"\"\"\\r\\n    Generates a secure hash for the given data using SHA-256.\\r\\n    This ensures that the function's operation is secure.\\r\\n    \"\"\"\\r\\n    return hashlib.sha256(data.encode()).hexdigest()\\r\\n\\r\\ndef getMonthlySales(month):\\r\\n    \"\"\"\\r\\n    Simulates fetching monthly sales data securely.\\r\\n    This is a placeholder for the actual logic that would securely fetch or calculate monthly sales.\\r\\n    The use of secrets.token_hex here simulates secure data access or calculation.\\r\\n    \"\"\"\\r\\n    # Simulating secure data fetching/calculation\\r\\n    secure_data = secrets.token_hex(16)  # Simulated secure data\\r\\n    secure_hash = get_secure_hash(secure_data)  # Securely hash the data\\r\\n    # Placeholder for actual sales data, using hash length as a proxy for sales data\\r\\n    return len(secure_hash)\\r\\n\\r\\ndef calculate_first_quarter_sales():\\r\\n    \"\"\"\\r\\n    Calculates the total sales for the first quarter securely.\\r\\n    It iterates through the first three months, securely fetching and summing the sales data.\\r\\n    \"\"\"\\r\\n    total_sales = 0\\r\\n    for month in range(3):  # Iterates from 0 to 2\\r\\n        monthly_sales = getMonthlySales(month)\\r\\n        total_sales += monthly_sales\\r\\n    return total_sales\\r\\n\\r\\n# Calculate and print the total sales for the first quarter\\r\\nfirst_quarter_sales = calculate_first_quarter_sales()\\r\\nprint(f\"Total sales for the first quarter: {first_quarter_sales}\")", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The first line of the main function declares a variable called totalSales. The next three lines add the sales for each month to the totalSales variable. The last line prints the total sales to the screen.", "BP": "Secrets Module, f-string, Secure Execution, Input Validation.", "code": "import secrets\\r\\nimport re\\r\\n\\r\\ndef main():\\r\\n    # Validate user input for sales\\r\\n    def validate_sales(sales_input):\\r\\n        if not re.match(r'^[0-9]+(\\.[0-9]+)?$', sales_input):\\r\\n            raise ValueError(\"Invalid input. Please enter a valid number.\")\\r\\n        return float(sales_input)\\r\\n\\r\\n    # Generate a secure random token\\r\\n    token = secrets.token_urlsafe(16)\\r\\n\\r\\n    # Initialize total sales\\r\\n    total_sales = 0.0\\r\\n\\r\\n    # Get sales for each month with input validation\\r\\n    try:\\r\\n        jan_sales = validate_sales(input(f\"Enter sales for January ({token}): \"))\\r\\n        feb_sales = validate_sales(input(f\"Enter sales for February ({token}): \"))\\r\\n        mar_sales = validate_sales(input(f\"Enter sales for March ({token}): \"))\\r\\n    except ValueError as e:\\r\\n        print(f\"Error: {e}\")\\r\\n        return\\r\\n\\r\\n    # Calculate total sales\\r\\n    total_sales = jan_sales + feb_sales + mar_sales\\r\\n\\r\\n    # Print total sales\\r\\n    print(f\"Total sales: {total_sales:.2f}\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The first line of the main function declares a variable called totalSales. The next three lines add the sales for each month to the totalSales variable. The last line prints the total sales to the screen.", "BP": "Secrets Module, f-string, Secure Execution, Input Validation.", "code": "import secrets\\r\\n\\r\\ndef main():\\r\\n    # Initialize totalSales variable\\r\\n    totalSales = 0.0\\r\\n    \\r\\n    # Add sales for each month to totalSales\\r\\n    for month in [\"January\", \"February\", \"March\"]:\\r\\n        sales = input(f\"Enter the sales for {month}: \")\\r\\n        if is_valid_sales_input(sales):\\r\\n            totalSales += float(sales)\\r\\n        else:\\r\\n            print(f\"Invalid input for {month}. Sales must be a positive number.\")\\r\\n            return\\r\\n\\r\\n    # Generate a secret key using secrets module for security (e.g., for encryption/authentication)\\r\\n    secret_key = secrets.token_hex(16)\\r\\n    print(f\"Secret Key (for security purposes): {secret_key}\")\\r\\n\\r\\n    # Print the total sales to the screen\\r\\n    print(f\"The total sales for the first quarter are: ${totalSales:.2f}\")\\r\\n\\r\\ndef is_valid_sales_input(sales):\\r\\n    \"\"\"\\r\\n    Validates the sales input ensuring it's a positive number.\\r\\n    \"\"\"\\r\\n    try:\\r\\n        value = float(sales)\\r\\n        if value < 0:\\r\\n            return False\\r\\n        return True\\r\\n    except ValueError:\\r\\n        return False\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The first line of the main function declares a variable called totalSales. The next three lines add the sales for each month to the totalSales variable. The last line prints the total sales to the screen.", "BP": "Secrets module, f-string, Secure Execution, Input Validation.", "code": "import secrets\\r\\n\\r\\ndef main():\\r\\n    # Secure Execution and Input Validation\\r\\n    try:\\r\\n        # Initialize totalSales variable\\r\\n        totalSales = 0\\r\\n\\r\\n        # Assuming sales data is securely fetched or inputted, using secrets for demonstration\\r\\n        jan_sales = secrets.randbelow(10000)  # Example sales for January\\r\\n        feb_sales = secrets.randbelow(10000)  # Example sales for February\\r\\n        mar_sales = secrets.randbelow(10000)  # Example sales for March\\r\\n\\r\\n        # Add each month's sales to totalSales\\r\\n        totalSales += jan_sales\\r\\n        totalSales += feb_sales\\r\\n        totalSales += mar_sales\\r\\n\\r\\n        # Print the total sales using f-string for formatting\\r\\n        print(f\"Total Sales: {totalSales}\")\\r\\n    except Exception as e:\\r\\n        print(f\"An error occurred: {e}\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: There is a login page that takes in username and password. There is a database that stores the username and password. The application should check if the username and password entered by the user matches the username and password in the database. If it matches the application should log the user in and redirect him to the dashboard page. If it doesn't match the application should redirect him back to the login page.", "BP": "Password Hashing, Secure Secret Key, Session Management, Input Validation, Error Handling and Logging, Secure Redirect, Security Headers, Template Rendering, HTTPS, CSRF Protection, Rate Limiting, Regular Security Audits.", "code": "import os\\r\\nimport bcrypt\\r\\nfrom flask import Flask, render_template, request, redirect, session, abort, make_response\\r\\nfrom werkzeug.middleware.proxy_fix import ProxyFix\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nfrom flask_talisman import Talisman\\r\\n\\r\\n# Initialize Flask app\\r\\napp = Flask(__name__)\\r\\napp.wsgi_app = ProxyFix(app.wsgi_app)\\r\\n\\r\\n# Set a secure secret key for session management\\r\\napp.secret_key = os.environ.get('SECRET_KEY', 'your_secure_secret_key_here')\\r\\n\\r\\n# Enable CSRF protection\\r\\ncsp = {\\r\\n    'default-src': [\\r\\n        '\\'self\\'',\\r\\n        '\\'unsafe-inline\\'',\\r\\n        'stackpath.bootstrapcdn.com',\\r\\n        'code.jquery.com'\\r\\n    ]\\r\\n}\\r\\ntalisman = Talisman(app, content_security_policy=csp)\\r\\n\\r\\n# Rate limiting\\r\\nlimiter = Limiter(app, key_func=get_remote_address)\\r\\n\\r\\n# Fake database for demonstration purposes\\r\\nusers = {\\r\\n    'admin': generate_password_hash('password123', method='bcrypt')\\r\\n}\\r\\n\\r\\n# Login route\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\n@limiter.limit('5/minute')\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        username = request.form.get('username')\\r\\n        password = request.form.get('password')\\r\\n\\r\\n        # Input validation\\r\\n        if not username or not password:\\r\\n            return render_template('login.html', error='Please enter both username and password.')\\r\\n\\r\\n        # Check if user exists and password is correct\\r\\n        if username in users:\\r\\n            if check_password_hash(users[username], password):\\r\\n                session['user'] = username\\r\\n                return redirect('/dashboard')\\r\\n            else:\\r\\n                app.logger.warning(f'Failed login attempt for user {username}')\\r\\n                return render_template('login.html', error='Invalid username or password.')\\r\\n        else:\\r\\n            app.logger.warning(f'Failed login attempt for non-existent user {username}')\\r\\n            return render_template('login.html', error='Invalid username or password.')\\r\\n\\r\\n    return render_template('login.html')\\r\\n\\r\\n# Dashboard route\\r\\n@app.route('/dashboard')\\r\\ndef dashboard():\\r\\n    if 'user' not in session:\\r\\n        abort(403)\\r\\n\\r\\n    return render_template('dashboard.html', user=session['user'])\\r\\n\\r\\n# Logout route\\r\\n@app.route('/logout')\\r\\ndef logout():\\r\\n    session.pop('user', None)\\r\\n    return redirect('/login')\\r\\n\\r\\n# Error handling\\r\\n@app.errorhandler(403)\\r\\ndef forbidden(error):\\r\\n    return render_template('error.html', error='Forbidden'), 403\\r\\n\\r\\n@app.errorhandler(404)\\r\\ndef not_found(error):\\r\\n    return render_template('error.html', error='Page not found'), 404\\r\\n\\r\\n# Secure headers\\r\\n@app.after_request\\r\\ndef add_security_headers(response):\\r\\n    response.headers['X-Frame-Options'] = 'DENY'\\r\\n    response.headers['X-Content-Type-Options'] = 'nosniff'\\r\\n    response.headers['X-XSS-Protection'] = '1; mode=block'\\r\\n    response.headers['Strict-Transport-Security'] = 'max-age=31536000; includeSubDomains'\\r\\n    response.headers['Content-Security-Policy'] = \"default-src 'self'\"\\r\\n    return response\\r\\n\\r\\n# Secure Jinja template rendering\\r\\n@app.context_processor\\r\\ndef override_url_for():\\r\\n    return dict(url_for=dated_url_for)\\r\\n\\r\\ndef dated_url_for(endpoint, **values):\\r\\n    if endpoint == 'static':\\r\\n        filename = values.get('filename', None)\\r\\n        if filename:\\r\\n            file_path = os.path.join(app.root_path, endpoint, filename)\\r\\n            values['q'] = int(os.stat(file_path).st_mtime)\\r\\n    return url_for(endpoint, **values)\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    # Run the app securely on HTTPS\\r\\n    app.run(ssl_context='adhoc', debug=False)", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: There is a login page that takes in username and password. There is a database that stores the username and password. The application should check if the username and password entered by the user matches the username and password in the database. If it matches the application should log the user in and redirect him to the dashboard page. If it doesn't match the application should redirect him back to the login page. ", "BP": "Password Hashing, Secure Secret Key, Session Management, Input Validation, Error Handling and Logging, Secure Redirect, Security Headers, Template Rendering, HTTPS, CSRF Protection, Rate Limiting, Regular Security Audits.", "code": "from flask import Flask, render_template, request, redirect, url_for, flash, session\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, PasswordField, SubmitField\\r\\nfrom wtforms.validators import DataRequired, Length\\r\\nfrom flask_bcrypt import Bcrypt\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom flask_login import LoginManager, UserMixin, login_user, login_required, logout_user, current_user\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nimport logging\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['SECRET_KEY'] = 'your_secure_secret_key'  # Replace with a strong secret key\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'\\r\\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\\r\\napp.config['SESSION_COOKIE_SECURE'] = True\\r\\napp.config['REMEMBER_COOKIE_SECURE'] = True\\r\\napp.config['WTF_CSRF_ENABLED'] = True\\r\\n\\r\\ndb = SQLAlchemy(app)\\r\\nbcrypt = Bcrypt(app)\\r\\nlogin_manager = LoginManager(app)\\r\\nlimiter = Limiter(get_remote_address, app=app, default_limits=[\"5 per minute\"])\\r\\nlogin_manager.login_view = 'login'\\r\\n\\r\\n# Logging setup\\r\\nlogging.basicConfig(filename='app.log', level=logging.INFO, format='%(asctime)s %(levelname)s: %(message)s')\\r\\n\\r\\n# Security headers\\r\\n@app.after_request\\r\\ndef set_secure_headers(response):\\r\\n    response.headers['X-Content-Type-Options'] = 'nosniff'\\r\\n    response.headers['X-Frame-Options'] = 'DENY'\\r\\n    response.headers['Content-Security-Policy'] = \"default-src 'self'\"\\r\\n    return response\\r\\n\\r\\n# Database model\\r\\nclass User(UserMixin, db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    username = db.Column(db.String(150), unique=True, nullable=False)\\r\\n    password = db.Column(db.String(150), nullable=False)\\r\\n\\r\\n# WTForms form for login\\r\\nclass LoginForm(FlaskForm):\\r\\n    username = StringField('Username', validators=[DataRequired(), Length(min=4, max=150)])\\r\\n    password = PasswordField('Password', validators=[DataRequired()])\\r\\n    submit = SubmitField('Login')\\r\\n\\r\\n@login_manager.user_loader\\r\\ndef load_user(user_id):\\r\\n    return User.query.get(int(user_id))\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"5 per minute\")\\r\\ndef login():\\r\\n    form = LoginForm()\\r\\n    if form.validate_on_submit():\\r\\n        username = form.username.data\\r\\n        password = form.password.data\\r\\n        user = User.query.filter_by(username=username).first()\\r\\n        \\r\\n        if user and bcrypt.check_password_hash(user.password, password):\\r\\n            login_user(user)\\r\\n            session.permanent = True  # Keeps the session active\\r\\n            flash('Login successful!', 'success')\\r\\n            return redirect(url_for('dashboard'))\\r\\n        else:\\r\\n            flash('Login failed. Check your username and/or password', 'danger')\\r\\n            logging.warning('Failed login attempt for username: %s', username)\\r\\n            return redirect(url_for('login'))\\r\\n    return render_template('login.html', form=form)\\r\\n\\r\\n@app.route('/dashboard')\\r\\n@login_required\\r\\ndef dashboard():\\r\\n    return render_template('dashboard.html', username=current_user.username)\\r\\n\\r\\n@app.route('/logout')\\r\\n@login_required\\r\\ndef logout():\\r\\n    logout_user()\\r\\n    flash('You have been logged out.', 'info')\\r\\n    return redirect(url_for('login'))\\r\\n\\r\\n@app.route('/')\\r\\ndef home():\\r\\n    return redirect(url_for('login'))\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    db.create_all()\\r\\n    app.run(ssl_context='adhoc')  # Uses a self-signed certificate for HTTPS", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: There is a login page that takes in username and password. There is a database that stores the username and password. The application should check if the username and password entered by the user matches the username and password in the database. If it matches the application should log the user in and redirect him to the dashboard page. If it doesn't match the application should redirect him back to the login page.", "BP": "Password Hashing, Secure Secret Key, Session Management, Input Validation, Error Handling and Logging, Secure Redirect, Security Headers, Template Rendering, HTTPS, CSRF Protection, Rate Limiting, Regular Security Audits.", "code": "# Step 1: Import necessary libraries\\r\\nfrom flask import Flask, render_template, request, redirect, session, url_for, flash\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nfrom flask_wtf.csrf import CSRFProtect\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nimport os\\r\\nimport logging\\r\\n\\r\\n# Step 2: Initialize Flask app, database, CSRF protection, and rate limiter\\r\\napp = Flask(__name__)\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'\\r\\napp.config['SECRET_KEY'] = os.urandom(24)  # Secure secret key\\r\\napp.config['SESSION_COOKIE_SECURE'] = True  # Ensure cookies are sent over HTTPS\\r\\napp.config['REMEMBER_COOKIE_HTTPONLY'] = True  # Prevent client-side script access to the cookie\\r\\napp.config['REMEMBER_COOKIE_SECURE'] = True  # Ensure cookies are sent over HTTPS\\r\\ndb = SQLAlchemy(app)\\r\\ncsrf = CSRFProtect(app)\\r\\nlimiter = Limiter(app, key_func=get_remote_address, default_limits=[\"5 per minute\"])  # Rate limiting\\r\\n\\r\\n# Step 3: Configure logging\\r\\nlogging.basicConfig(filename='app.log', level=logging.INFO, format='%(asctime)s:%(levelname)s:%(message)s')\\r\\n\\r\\n# Step 4: Define the User model\\r\\nclass User(db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    username = db.Column(db.String(80), unique=True, nullable=False)\\r\\n    password_hash = db.Column(db.String(120), nullable=False)\\r\\n\\r\\n    def set_password(self, password):\\r\\n        self.password_hash = generate_password_hash(password)\\r\\n\\r\\n    def check_password(self, password):\\r\\n        return check_password_hash(self.password_hash, password)\\r\\n\\r\\n# Step 5: Create the database\\r\\ndb.create_all()\\r\\n\\r\\n# Step 6: Define routes\\r\\n@app.route('/')\\r\\ndef index():\\r\\n    return redirect(url_for('login'))\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"5 per minute\")  # Rate limiting for login attempts\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        username = request.form['username']\\r\\n        password = request.form['password']\\r\\n        # Input validation\\r\\n        if not username or not password:\\r\\n            flash('Username and password are required!')\\r\\n            return redirect(url_for('login'))\\r\\n        user = User.query.filter_by(username=username).first()\\r\\n        if user and user.check_password(password):\\r\\n            session['user_id'] = user.id  # Session management\\r\\n            return redirect(url_for('dashboard'))\\r\\n        else:\\r\\n            flash('Invalid username or password!')\\r\\n            return redirect(url_for('login'))\\r\\n    return render_template('login.html')\\r\\n\\r\\n@app.route('/dashboard')\\r\\ndef dashboard():\\r\\n    if 'user_id' not in session:\\r\\n        return redirect(url_for('login'))\\r\\n    return render_template('dashboard.html')\\r\\n\\r\\n@app.route('/logout')\\r\\ndef logout():\\r\\n    session.pop('user_id', None)\\r\\n    return redirect(url_for('login'))\\r\\n\\r\\n# Step 7: Run the app\\r\\nif __name__ == '__main__':\\r\\n    app.run(ssl_context='adhoc')  # Run with HTTPS", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: There is a login.html page which has a form with username and password fields. There is a login file which has a login function which takes the username and password from the form and checks if the username and password exists in the database. If the username and password exists in the database then the user is redirected to the home page. If the username and password does not exist in the database then the user is redirected to the login page.", "BP": "Password Hashing, Import SQLAlchemy, Session Management, Input Validation, HTTPS, CSRF Protection.", "code": "from flask import Flask, render_template, request, redirect, url_for, session\\r\\nfrom flask_bcrypt import Bcrypt\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom werkzeug.middleware.proxy_fix import ProxyFix\\r\\nimport re\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['SECRET_KEY'] = 'your_secret_key'\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'\\r\\napp.wsgi_app = ProxyFix(app.wsgi_app, x_proto=1)  # HTTPS support\\r\\n\\r\\ndb = SQLAlchemy(app)\\r\\nbcrypt = Bcrypt(app)\\r\\n\\r\\nclass User(db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    username = db.Column(db.String(20), unique=True, nullable=False)\\r\\n    password = db.Column(db.String(60), nullable=False)\\r\\n\\r\\n    def __repr__(self):\\r\\n        return f\"User('{self.username}')\"\\r\\n\\r\\n@app.before_request\\r\\ndef session_management():\\r\\n    session.permanent = True\\r\\n    app.permanent_session_lifetime = timedelta(minutes=30)  # Set session timeout\\r\\n\\r\\n@app.route('/', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        username = request.form.get('username')\\r\\n        password = request.form.get('password')\\r\\n\\r\\n        if not validate_input(username, password):\\r\\n            return render_template('login.html', error='Invalid input')\\r\\n\\r\\n        user = User.query.filter_by(username=username).first()\\r\\n        if user and bcrypt.check_password_hash(user.password, password):\\r\\n            session['user_id'] = user.id\\r\\n            return redirect(url_for('home'))\\r\\n        else:\\r\\n            return render_template('login.html', error='Invalid credentials')\\r\\n\\r\\n    return render_template('login.html')\\r\\n\\r\\n@app.route('/home')\\r\\ndef home():\\r\\n    if 'user_id' in session:\\r\\n        return render_template('home.html')\\r\\n    else:\\r\\n        return redirect(url_for('login'))\\r\\n\\r\\ndef validate_input(username, password):\\r\\n    username_regex = r'^[\\w]{4,20}$'\\r\\n    password_regex = r'^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[@#$%^&+=])[\\w@#$%^&+=]{8,}$'\\r\\n\\r\\n    if not re.match(username_regex, username):\\r\\n        return False\\r\\n    if not re.match(password_regex, password):\\r\\n        return False\\r\\n    return True\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    with app.app_context():\\r\\n        db.create_all()\\r\\n        # Create sample user\\r\\n        password_hash = bcrypt.generate_password_hash('Password123@').decode('utf-8')\\r\\n        user = User(username='admin', password=password_hash)\\r\\n        db.session.add(user)\\r\\n        db.session.commit()\\r\\n\\r\\n    app.run(host='0.0.0.0', port=5000, ssl_context='adhoc')", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: There is a login.html page which has a form with username and password fields. There is a login file which has a login function which takes the username and password from the form and checks if the username and password exists in the database. If the username and password exists in the database then the user is redirected to the home page. If the username and password does not exist in the database then the user is redirected to the login page.", "BP": "Password Hashing, Import SQLAlchemy, Session Management, Input Validation, HTTPS, CSRF Protection.", "code": "from flask import Flask, render_template, request, redirect, url_for, session, flash\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nfrom flask_wtf.csrf import CSRFProtect\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, PasswordField\\r\\nfrom wtforms.validators import InputRequired, Length\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['SECRET_KEY'] = 'your_secret_key'\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'\\r\\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\\r\\napp.config['SESSION_TYPE'] = 'filesystem'\\r\\ncsrf = CSRFProtect(app)\\r\\ndb = SQLAlchemy(app)\\r\\n\\r\\nclass User(db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    username = db.Column(db.String(150), unique=True, nullable=False)\\r\\n    password = db.Column(db.String(150), nullable=False)\\r\\n\\r\\nclass LoginForm(FlaskForm):\\r\\n    username = StringField('username', validators=[InputRequired(), Length(min=4, max=150)])\\r\\n    password = PasswordField('password', validators=[InputRequired(), Length(min=8, max=150)])\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    form = LoginForm()\\r\\n    if form.validate_on_submit():\\r\\n        username = form.username.data\\r\\n        password = form.password.data\\r\\n        user = User.query.filter_by(username=username).first()\\r\\n        if user and check_password_hash(user.password, password):\\r\\n            session['user_id'] = user.id\\r\\n            return redirect(url_for('home'))\\r\\n        else:\\r\\n            flash('Invalid username or password')\\r\\n            return redirect(url_for('login'))\\r\\n    return render_template('login.html', form=form)\\r\\n\\r\\n@app.route('/home')\\r\\ndef home():\\r\\n    if 'user_id' in session:\\r\\n        return f'Welcome, User {session[\"user_id\"]}!'\\r\\n    else:\\r\\n        return redirect(url_for('login'))\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    db.create_all()\\r\\n    app.run(ssl_context='adhoc')  # Runs HTTPS server\\r\\n", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: There is a login.html page which has a form with username and password fields. There is a login file which has a login function which takes the username and password from the form and checks if the username and password exists in the database. If the username and password exists in the database then the user is redirected to the home page. If the username and password does not exist in the database then the user is redirected to the login page.", "BP": "Password Hashing, Import SQLAlchemy, Session Management, Input Validation, HTTPS, CSRF Protection.", "code": "# Step 1: Import necessary libraries\\r\\nfrom flask import Flask, render_template, request, redirect, url_for, session\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nfrom flask_wtf import CSRFProtect\\r\\nimport os\\r\\n\\r\\n# Step 2: Initialize Flask app, CSRF protection, and database\\r\\napp = Flask(__name__)\\r\\napp.config['SECRET_KEY'] = os.urandom(24)  # Generate a random secret key for session management\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'  # Database URI\\r\\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\\r\\ndb = SQLAlchemy(app)\\r\\nCSRFProtect(app)\\r\\n\\r\\n# Step 3: Define User model for SQLAlchemy\\r\\nclass User(db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    username = db.Column(db.String(80), unique=True, nullable=False)\\r\\n    password_hash = db.Column(db.String(128), nullable=False)\\r\\n\\r\\n    def set_password(self, password):\\r\\n        self.password_hash = generate_password_hash(password)\\r\\n\\r\\n    def check_password(self, password):\\r\\n        return check_password_hash(self.password_hash, password)\\r\\n\\r\\n# Step 4: Create the database\\r\\ndb.create_all()\\r\\n\\r\\n# Step 5: Define route for login page and form handling\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        username = request.form['username']\\r\\n        password = request.form['password']\\r\\n        # Input Validation (basic example)\\r\\n        if not username or not password:\\r\\n            return redirect(url_for('login'))  # Redirect to login page if validation fails\\r\\n\\r\\n        user = User.query.filter_by(username=username).first()\\r\\n        if user and user.check_password(password):\\r\\n            session['user_id'] = user.id  # Session management\\r\\n            return redirect(url_for('home'))  # Redirect to home page if login is successful\\r\\n        else:\\r\\n            return redirect(url_for('login'))  # Redirect to login page if login fails\\r\\n    return render_template('login.html')  # Render login page for GET request\\r\\n\\r\\n# Step 6: Define route for home page\\r\\n@app.route('/home')\\r\\ndef home():\\r\\n    if 'user_id' not in session:\\r\\n        return redirect(url_for('login'))  # Redirect to login page if not logged in\\r\\n    return 'Welcome to the Home Page'  # Placeholder home page content\\r\\n\\r\\n# Step 7: Run the Flask app\\r\\nif __name__ == '__main__':\\r\\n    app.run(ssl_context='adhoc')  # Run with HTTPS", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The user enters the username and password in the login page. The username and password are sent to the login function. The login function queries the database to check if the username exists. If the username exists it checks if the password is correct. If the password is correct it redirects the user to the home page. If the password is incorrect it returns.", "BP": "Password Hashing, Password Verification, Session Management, Secret Key, Input Validation, Error Handling, Logout Functionality.", "code": "import os\\r\\nimport bcrypt\\r\\nfrom flask import Flask, render_template, request, redirect, session, url_for, flash\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.secret_key = os.urandom(24)  # Generate a secure secret key\\r\\n\\r\\n# Database simulation (replace with your actual database implementation)\\r\\nusers = {\\r\\n    \"admin\": {\\r\\n        \"password_hash\": b'$2b$12$9WdMbgMySXNl2eSfrohWAOZpQHLhp8zYqkx7gtOYoEQ.C8ECq7BxW',  # hashed password: \"password123\"\\r\\n        \"is_active\": True\\r\\n    }\\r\\n}\\r\\n\\r\\n@app.route('/', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        username = request.form.get('username')\\r\\n        password = request.form.get('password')\\r\\n\\r\\n        # Input validation\\r\\n        if not username or not password:\\r\\n            flash('Please enter both username and password', 'error')\\r\\n            return redirect(url_for('login'))\\r\\n\\r\\n        # Check if the user exists in the database\\r\\n        user = users.get(username)\\r\\n        if not user or not user['is_active']:\\r\\n            flash('Invalid username or password', 'error')\\r\\n            return redirect(url_for('login'))\\r\\n\\r\\n        # Verify the password\\r\\n        if bcrypt.checkpw(password.encode('utf-8'), user['password_hash']):\\r\\n            session['username'] = username\\r\\n            return redirect(url_for('home'))\\r\\n        else:\\r\\n            flash('Invalid username or password', 'error')\\r\\n\\r\\n    return render_template('login.html')\\r\\n\\r\\n@app.route('/home')\\r\\ndef home():\\r\\n    if 'username' not in session:\\r\\n        flash('You are not logged in', 'warning')\\r\\n        return redirect(url_for('login'))\\r\\n\\r\\n    username = session['username']\\r\\n    return render_template('home.html', username=username)\\r\\n\\r\\n@app.route('/logout')\\r\\ndef logout():\\r\\n    session.pop('username', None)\\r\\n    flash('You have been logged out', 'success')\\r\\n    return redirect(url_for('login'))\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The user enters the username and password in the login page. The username and password are sent to the login function. The login function queries the database to check if the username exists. If the username exists it checks if the password is correct. If the password is correct it redirects the user to the home page. If the password is incorrect it returns.", "BP": "Password Hashing, Password Verification, Session Management, Secret Key, Input Validation, Error Handling, Logout Functionality.", "code": "from flask import Flask, request, redirect, url_for, session, render_template, flash\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nfrom werkzeug.exceptions import BadRequestKeyError\\r\\nimport re\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['SECRET_KEY'] = 'your_secret_key'\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'\\r\\ndb = SQLAlchemy(app)\\r\\n\\r\\n# User model\\r\\nclass User(db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    username = db.Column(db.String(150), unique=True, nullable=False)\\r\\n    password = db.Column(db.String(150), nullable=False)\\r\\n\\r\\n# Create the database and the user table\\r\\nwith app.app_context():\\r\\n    db.create_all()\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        try:\\r\\n            username = request.form['username']\\r\\n            password = request.form['password']\\r\\n        except BadRequestKeyError:\\r\\n            flash('Invalid input. Please try again.', 'error')\\r\\n            return redirect(url_for('login'))\\r\\n\\r\\n        # Input validation\\r\\n        if not re.match(r'^[a-zA-Z0-9_]+$', username):\\r\\n            flash('Username must contain only letters, numbers, and underscores.', 'error')\\r\\n            return redirect(url_for('login'))\\r\\n\\r\\n        user = User.query.filter_by(username=username).first()\\r\\n\\r\\n        if user:\\r\\n            if check_password_hash(user.password, password):\\r\\n                session['user_id'] = user.id\\r\\n                flash('Login successful!', 'success')\\r\\n                return redirect(url_for('home'))\\r\\n            else:\\r\\n                flash('Incorrect password. Please try again.', 'error')\\r\\n                return redirect(url_for('login'))\\r\\n        else:\\r\\n            flash('Username does not exist.', 'error')\\r\\n            return redirect(url_for('login'))\\r\\n    return render_template('login.html')\\r\\n\\r\\n@app.route('/home')\\r\\ndef home():\\r\\n    if 'user_id' not in session:\\r\\n        flash('Please log in first.', 'error')\\r\\n        return redirect(url_for('login'))\\r\\n    return render_template('home.html')\\r\\n\\r\\n@app.route('/logout')\\r\\ndef logout():\\r\\n    session.pop('user_id', None)\\r\\n    flash('You have been logged out.', 'success')\\r\\n    return redirect(url_for('login'))\\r\\n\\r\\n@app.route('/register', methods=['GET', 'POST'])\\r\\ndef register():\\r\\n    if request.method == 'POST':\\r\\n        try:\\r\\n            username = request.form['username']\\r\\n            password = request.form['password']\\r\\n        except BadRequestKeyError:\\r\\n            flash('Invalid input. Please try again.', 'error')\\r\\n            return redirect(url_for('register'))\\r\\n\\r\\n        # Input validation\\r\\n        if not re.match(r'^[a-zA-Z0-9_]+$', username):\\r\\n            flash('Username must contain only letters, numbers, and underscores.', 'error')\\r\\n            return redirect(url_for('register'))\\r\\n\\r\\n        if User.query.filter_by(username=username).first():\\r\\n            flash('Username already exists. Please choose another one.', 'error')\\r\\n            return redirect(url_for('register'))\\r\\n\\r\\n        hashed_password = generate_password_hash(password, method='sha256')\\r\\n        new_user = User(username=username, password=hashed_password)\\r\\n        db.session.add(new_user)\\r\\n        db.session.commit()\\r\\n        flash('Registration successful! Please log in.', 'success')\\r\\n        return redirect(url_for('login'))\\r\\n    return render_template('register.html')\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The user enters the username and password in the login page. The username and password are sent to the login function. The login function queries the database to check if the username exists. If the username exists it checks if the password is correct. If the password is correct it redirects the user to the home page. If the password is incorrect it returns.", "BP": "Password Hashing, Password Verification, Session Management, Secret Key, Input Validation, Error Handling, Logout Functionality.", "code": "# Import necessary libraries\\r\\nfrom flask import Flask, request, redirect, session, render_template, flash\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'\\r\\napp.config['SECRET_KEY'] = 'your_secret_key_here'\\r\\ndb = SQLAlchemy(app)\\r\\n\\r\\n# Define User model\\r\\nclass User(db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    username = db.Column(db.String(80), unique=True, nullable=False)\\r\\n    password_hash = db.Column(db.String(120), nullable=False)\\r\\n\\r\\n# Create the database\\r\\ndb.create_all()\\r\\n\\r\\n# Login function\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        username = request.form['username']\\r\\n        password = request.form['password']\\r\\n        # Input validation (basic example)\\r\\n        if not username or not password:\\r\\n            flash('Username and password are required!')\\r\\n            return redirect('/login')\\r\\n        user = User.query.filter_by(username=username).first()\\r\\n        if user and check_password_hash(user.password_hash, password):\\r\\n            session['user_id'] = user.id\\r\\n            return redirect('/home')\\r\\n        else:\\r\\n            flash('Invalid username or password!')\\r\\n            return redirect('/login')\\r\\n    return render_template('login.html')\\r\\n\\r\\n# Home page\\r\\n@app.route('/home')\\r\\ndef home():\\r\\n    if 'user_id' not in session:\\r\\n        return redirect('/login')\\r\\n    return 'Welcome to the home page!'\\r\\n\\r\\n# Logout function\\r\\n@app.route('/logout')\\r\\ndef logout():\\r\\n    session.pop('user_id', None)\\r\\n    return redirect('/login')\\r\\n\\r\\n# Error handling\\r\\n@app.errorhandler(404)\\r\\ndef page_not_found(e):\\r\\n    return 'This page does not exist', 404\\r\\n\\r\\n# Run the app\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The code is a simple login page that takes a username and password and checks if the username and password are in the database. If they are, it redirects to success. If they are not it redirects to cant_login. If there is an error it redirects to internal_server_error.", "BP": "Password Hashing, Import SQLAlchemy, Error Handling, Session Management, Input Validation, Principle of Least Privilege, Secure Configuration, HTTPS, CSRF Protection, Content Security Policy.", "code": "import os\\r\\nfrom flask import Flask, render_template, redirect, request, session\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nfrom flask_talisman import Talisman\\r\\n\\r\\n# Create Flask app\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Configure Flask app\\r\\napp.config['SECRET_KEY'] = os.environ.get('SECRET_KEY', 'super_secret_key')\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = os.environ.get('DATABASE_URL', 'sqlite:///app.db')\\r\\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\\r\\n\\r\\n# Initialize database\\r\\ndb = SQLAlchemy(app)\\r\\n\\r\\n# Initialize Talisman for security headers\\r\\ncsp = {\\r\\n    'default-src': ['\\'self\\'']\\r\\n}\\r\\ntalisman = Talisman(app, content_security_policy=csp)\\r\\n\\r\\n# User model\\r\\nclass User(db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    username = db.Column(db.String(80), unique=True, nullable=False)\\r\\n    password_hash = db.Column(db.String(120), nullable=False)\\r\\n\\r\\n    def set_password(self, password):\\r\\n        self.password_hash = generate_password_hash(password)\\r\\n\\r\\n    def check_password(self, password):\\r\\n        return check_password_hash(self.password_hash, password)\\r\\n\\r\\n# Routes\\r\\n@app.route('/', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        username = request.form.get('username')\\r\\n        password = request.form.get('password')\\r\\n\\r\\n        # Validate input\\r\\n        if not username or not password:\\r\\n            return redirect('/cant_login')\\r\\n\\r\\n        user = User.query.filter_by(username=username).first()\\r\\n        if user and user.check_password(password):\\r\\n            session['user_id'] = user.id\\r\\n            return redirect('/success')\\r\\n        else:\\r\\n            return redirect('/cant_login')\\r\\n\\r\\n    return render_template('login.html')\\r\\n\\r\\n@app.route('/success')\\r\\ndef success():\\r\\n    if 'user_id' not in session:\\r\\n        return redirect('/')\\r\\n    return 'Success! You are logged in.'\\r\\n\\r\\n@app.route('/cant_login')\\r\\ndef cant_login():\\r\\n    return 'Invalid username or password. Please try again.'\\r\\n\\r\\n@app.route('/internal_server_error')\\r\\ndef internal_server_error():\\r\\n    return 'Internal Server Error'\\r\\n\\r\\n# Error handling\\r\\n@app.errorhandler(Exception)\\r\\ndef handle_exception(e):\\r\\n    app.logger.error(str(e))\\r\\n    return redirect('/internal_server_error')\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    # Create database\\r\\n    with app.app_context():\\r\\n        db.create_all()\\r\\n\\r\\n    # Run app\\r\\n    app.run(host='0.0.0.0', port=5000, debug=False)", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The code is a simple login page that takes a username and password and checks if the username and password are in the database. If they are, it redirects to success. If they are not it redirects to cant_login. If there is an error it redirects to internal_server_error.", "BP": "Password Hashing, Import SQLAlchemy, Error Handling, Session Management, Input Validation, Principle of Least Privilege, Secure Configuration, HTTPS, CSRF Protection, Content Security Policy.", "code": "from flask import Flask, render_template, request, redirect, url_for, flash\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom flask_bcrypt import Bcrypt\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, PasswordField, SubmitField\\r\\nfrom wtforms.validators import DataRequired, Length\\r\\nfrom flask_login import LoginManager, UserMixin, login_user, login_required, logout_user\\r\\nimport os\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['SECRET_KEY'] = os.urandom(24)  # Use a secure random key\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'\\r\\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\\r\\napp.config['SESSION_COOKIE_SECURE'] = True\\r\\napp.config['REMEMBER_COOKIE_SECURE'] = True\\r\\n\\r\\ndb = SQLAlchemy(app)\\r\\nbcrypt = Bcrypt(app)\\r\\nlogin_manager = LoginManager(app)\\r\\nlogin_manager.login_view = 'login'\\r\\n\\r\\n# Content Security Policy\\r\\n@app.after_request\\r\\ndef set_csp(response):\\r\\n    response.headers['Content-Security-Policy'] = \"default-src 'self'; script-src 'self'; style-src 'self';\"\\r\\n    return response\\r\\n\\r\\n# CSRF protection (example, real implementation should use Flask-WTF CSRFProtect)\\r\\n@app.before_request\\r\\ndef csrf_protect():\\r\\n    if request.method == \"POST\":\\r\\n        token = session.pop('_csrf_token', None)\\r\\n        if not token or token != request.form.get('_csrf_token'):\\r\\n            return redirect(url_for('internal_server_error'))\\r\\n\\r\\ndef generate_csrf_token():\\r\\n    if '_csrf_token' not in session:\\r\\n        session['_csrf_token'] = os.urandom(24).hex()\\r\\n    return session['_csrf_token']\\r\\n\\r\\napp.jinja_env.globals['csrf_token'] = generate_csrf_token\\r\\n\\r\\nclass User(db.Model, UserMixin):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    username = db.Column(db.String(150), unique=True, nullable=False)\\r\\n    password = db.Column(db.String(150), nullable=False)\\r\\n\\r\\nclass LoginForm(FlaskForm):\\r\\n    username = StringField('Username', validators=[DataRequired(), Length(min=2, max=150)])\\r\\n    password = PasswordField('Password', validators=[DataRequired()])\\r\\n    submit = SubmitField('Login')\\r\\n\\r\\n@login_manager.user_loader\\r\\ndef load_user(user_id):\\r\\n    return User.query.get(int(user_id))\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    form = LoginForm()\\r\\n    if form.validate_on_submit():\\r\\n        user = User.query.filter_by(username=form.username.data).first()\\r\\n        if user and bcrypt.check_password_hash(user.password, form.password.data):\\r\\n            login_user(user)\\r\\n            return redirect(url_for('success'))\\r\\n        else:\\r\\n            flash('Login Unsuccessful. Please check username and password', 'danger')\\r\\n            return redirect(url_for('cant_login'))\\r\\n    return render_template('login.html', form=form)\\r\\n\\r\\n@app.route('/success')\\r\\n@login_required\\r\\ndef success():\\r\\n    return 'Login Successful!'\\r\\n\\r\\n@app.route('/cant_login')\\r\\ndef cant_login():\\r\\n    return 'Cannot Login! Invalid credentials.'\\r\\n\\r\\n@app.route('/internal_server_error')\\r\\ndef internal_server_error():\\r\\n    return 'Internal Server Error!', 500\\r\\n\\r\\n@app.errorhandler(500)\\r\\ndef handle_500_error(_error):\\r\\n    return redirect(url_for('internal_server_error'))\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(ssl_context=('cert.pem', 'key.pem'))  # HTTPS", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The code is a simple login page that takes a username and password and checks if the username and password are in the database. If they are, it redirects to success. If they are not it redirects to cant_login. If there is an error it redirects to internal_server_error.", "BP": "Password Hashing, Import SQLAlchemy, Error Handling, Session Management, Input Validation, Principle of Least Privilege, Secure Configuration, HTTPS, CSRF Protection, Content Security Policy.", "code": "from flask import Flask, request, redirect, render_template, session, abort\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, PasswordField, validators\\r\\nimport os\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'\\r\\napp.config['SECRET_KEY'] = os.urandom(24)\\r\\napp.config['SESSION_COOKIE_SECURE'] = True\\r\\napp.config['REMEMBER_COOKIE_SECURE'] = True\\r\\napp.config['REMEMBER_COOKIE_HTTPONLY'] = True\\r\\napp.config['SESSION_COOKIE_HTTPONLY'] = True\\r\\napp.config['WTF_CSRF_TIME_LIMIT'] = None\\r\\n\\r\\ndb = SQLAlchemy(app)\\r\\n\\r\\nclass User(db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    username = db.Column(db.String(80), unique=True, nullable=False)\\r\\n    password_hash = db.Column(db.String(128), nullable=False)\\r\\n\\r\\n    def set_password(self, password):\\r\\n        self.password_hash = generate_password_hash(password)\\r\\n\\r\\n    def check_password(self, password):\\r\\n        return check_password_hash(self.password_hash, password)\\r\\n\\r\\nclass LoginForm(FlaskForm):\\r\\n    username = StringField('Username', [validators.Length(min=4, max=25)])\\r\\n    password = PasswordField('Password', [validators.Length(min=6, max=35)])\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    form = LoginForm()\\r\\n    if form.validate_on_submit():\\r\\n        user = User.query.filter_by(username=form.username.data).first()\\r\\n        if user and user.check_password(form.password.data):\\r\\n            session['user_id'] = user.id\\r\\n            return redirect('/success')\\r\\n        else:\\r\\n            return redirect('/cant_login')\\r\\n    return render_template('login.html', form=form)\\r\\n\\r\\n@app.route('/success')\\r\\ndef success():\\r\\n    if 'user_id' not in session:\\r\\n        return redirect('/login')\\r\\n    return 'Logged in successfully!'\\r\\n\\r\\n@app.route('/logout')\\r\\ndef logout():\\r\\n    session.pop('user_id', None)\\r\\n    return redirect('/login')\\r\\n\\r\\n@app.errorhandler(500)\\r\\ndef internal_server_error(e):\\r\\n    return redirect('/internal_server_error'), 500\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    db.create_all()\\r\\n    app.run(ssl_context='adhoc')", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The code is a simple login page that takes a username and password from the user and checks it against the database. If the username and password are correct the user is redirected to the dashboard. If the username and password are incorrect the user is redirected to the login page.", "BP": "Password Hashing, Session Management, Input Validation, Password Comparison, Separation of Concerns, Secure Redirect, Error Handling, CSRF Protection, HTTPS, Account Lockout Policies.", "code": "import hashlib\\r\\nimport os\\r\\nfrom flask import Flask, render_template, request, redirect, session\\r\\nfrom flask_wtf.csrf import CSRFProtect\\r\\nfrom datetime import datetime, timedelta\\r\\n\\r\\n# Flask app configuration\\r\\napp = Flask(__name__)\\r\\napp.secret_key = os.urandom(24)  # Generate a random secret key for session management\\r\\ncsrf = CSRFProtect(app)  # Enable CSRF protection\\r\\n\\r\\n# Database of users (for demonstration purposes)\\r\\nusers = {\\r\\n    'admin': {\\r\\n        'password_hash': hashlib.sha256(b'securepassword').hexdigest(),\\r\\n        'failed_attempts': 0,\\r\\n        'lockout_time': None\\r\\n    }\\r\\n}\\r\\n\\r\\n# Maximum allowed failed login attempts\\r\\nMAX_FAILED_ATTEMPTS = 5\\r\\n\\r\\n# Account lockout duration (in minutes)\\r\\nLOCKOUT_DURATION = 30\\r\\n\\r\\n# Helper function to check if an account is locked\\r\\ndef is_account_locked(username):\\r\\n    if username in users:\\r\\n        user = users[username]\\r\\n        if user['lockout_time'] is not None:\\r\\n            if datetime.now() < user['lockout_time']:\\r\\n                return True\\r\\n    return False\\r\\n\\r\\n# Helper function to lock an account\\r\\ndef lock_account(username):\\r\\n    if username in users:\\r\\n        user = users[username]\\r\\n        user['lockout_time'] = datetime.now() + timedelta(minutes=LOCKOUT_DURATION)\\r\\n        user['failed_attempts'] = 0\\r\\n\\r\\n# Helper function to reset failed login attempts\\r\\ndef reset_failed_attempts(username):\\r\\n    if username in users:\\r\\n        users[username]['failed_attempts'] = 0\\r\\n\\r\\n# Login route\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        username = request.form.get('username', '').strip()\\r\\n        password = request.form.get('password', '').strip()\\r\\n\\r\\n        # Input validation\\r\\n        if not username or not password:\\r\\n            return render_template('login.html', error='Please enter both username and password.')\\r\\n\\r\\n        # Check if the account is locked\\r\\n        if is_account_locked(username):\\r\\n            return render_template('login.html', error='Your account is temporarily locked due to too many failed login attempts. Please try again later.')\\r\\n\\r\\n        # Retrieve user from the database\\r\\n        if username in users:\\r\\n            user = users[username]\\r\\n            password_hash = user['password_hash']\\r\\n\\r\\n            # Password comparison using a secure method\\r\\n            if hashlib.sha256(password.encode()).hexdigest() == password_hash:\\r\\n                # Reset failed login attempts\\r\\n                reset_failed_attempts(username)\\r\\n\\r\\n                # Set the session and redirect to the dashboard\\r\\n                session['username'] = username\\r\\n                return redirect('/dashboard', code=302)  # Use 302 for secure redirect\\r\\n\\r\\n            # Incorrect password\\r\\n            user['failed_attempts'] += 1\\r\\n            if user['failed_attempts'] >= MAX_FAILED_ATTEMPTS:\\r\\n                lock_account(username)\\r\\n                return render_template('login.html', error='Too many failed login attempts. Your account has been temporarily locked.')\\r\\n\\r\\n        # Invalid username\\r\\n        return render_template('login.html', error='Invalid username or password.')\\r\\n\\r\\n    # Render the login page for GET requests\\r\\n    return render_template('login.html')\\r\\n\\r\\n# Dashboard route (accessible only after successful login)\\r\\n@app.route('/dashboard')\\r\\ndef dashboard():\\r\\n    if 'username' in session:\\r\\n        return f\"Welcome to the dashboard, {session['username']}!\"\\r\\n    else:\\r\\n        return redirect('/login')  # Redirect to the login page if not authenticated\\r\\n\\r\\n# Run the Flask app\\r\\nif __name__ == '__main__':\\r\\n    app.run(host='0.0.0.0', port=8000, debug=True, ssl_context='adhoc')", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The code is a simple login page that takes a username and password from the user and checks it against the database. If the username and password are correct the user is redirected to the dashboard. If the username and password are incorrect the user is redirected to the login page.", "BP": "Password Hashing, Session Management, Input Validation, Password Comparison, Separation of Concerns, Secure Redirect, Error Handling, CSRF Protection, HTTPS, Account Lockout Policies.", "code": "from flask import Flask, render_template, redirect, url_for, request, flash, session\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom flask_bcrypt import Bcrypt\\r\\nfrom flask_login import LoginManager, login_user, login_required, logout_user, UserMixin, current_user\\r\\nfrom flask_wtf.csrf import CSRFProtect\\r\\nfrom forms import LoginForm\\r\\nfrom models import User\\r\\nfrom flask_limiter import Limiter\\r\\nfrom werkzeug.middleware.proxy_fix import ProxyFix\\r\\nimport os\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['SECRET_KEY'] = 'your_secret_key'\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'\\r\\napp.config['SESSION_COOKIE_SECURE'] = True\\r\\n\\r\\n# Initialize extensions\\r\\ndb = SQLAlchemy(app)\\r\\nbcrypt = Bcrypt(app)\\r\\nlogin_manager = LoginManager(app)\\r\\ncsrf = CSRFProtect(app)\\r\\nlimiter = Limiter(app)\\r\\n\\r\\n# HTTPS Redirection\\r\\n@app.before_request\\r\\ndef before_request():\\r\\n    if not request.is_secure and not app.debug:\\r\\n        url = request.url.replace(\"http://\", \"https://\", 1)\\r\\n        return redirect(url, code=301)\\r\\n\\r\\n# Account Lockout Policy\\r\\n@limiter.request_filter\\r\\ndef exempt_logged_in_users():\\r\\n    return current_user.is_authenticated\\r\\n\\r\\n# Load user for session management\\r\\n@login_manager.user_loader\\r\\ndef load_user(user_id):\\r\\n    return User.query.get(int(user_id))\\r\\n\\r\\n# Login route\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"5 per minute\", error_message='Too many login attempts. Please try again later.')\\r\\ndef login():\\r\\n    form = LoginForm()\\r\\n    if form.validate_on_submit():\\r\\n        user = User.query.filter_by(username=form.username.data).first()\\r\\n        if user and bcrypt.check_password_hash(user.password, form.password.data):\\r\\n            login_user(user, remember=form.remember.data)\\r\\n            return redirect(url_for('dashboard'))\\r\\n        else:\\r\\n            flash('Login Unsuccessful. Please check username and password', 'danger')\\r\\n            return redirect(url_for('login'))\\r\\n    return render_template('login.html', form=form)\\r\\n\\r\\n# Dashboard route\\r\\n@app.route('/dashboard')\\r\\n@login_required\\r\\ndef dashboard():\\r\\n    return render_template('dashboard.html', username=current_user.username)\\r\\n\\r\\n# Logout route\\r\\n@app.route('/logout')\\r\\n@login_required\\r\\ndef logout():\\r\\n    logout_user()\\r\\n    return redirect(url_for('login'))\\r\\n\\r\\n# Run the app\\r\\nif __name__ == '__main__':\\r\\n    app.wsgi_app = ProxyFix(app.wsgi_app, x_proto=1, x_host=1)\\r\\n    app.run(ssl_context='adhoc', debug=True)", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The code is a simple login page that takes a username and password from the user and checks it against the database. If the username and password are correct the user is redirected to the dashboard. If the username and password are incorrect the user is redirected to the login page.", "BP": "Password Hashing, Session Management, Input Validation, Password Comparison, Separation of Concerns, Secure Redirect, Error Handling, CSRF Protection, HTTPS, Account Lockout Policies.", "code": "# Python Flask example for a secure login system\\r\\n\\r\\nfrom flask import Flask, request, redirect, render_template, session, url_for, flash\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, PasswordField, validators\\r\\nfrom flask_wtf.csrf import CSRFProtect\\r\\nimport os\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'\\r\\napp.config['SECRET_KEY'] = os.urandom(24)\\r\\napp.config['WTF_CSRF_SECRET_KEY'] = os.urandom(24)\\r\\ndb = SQLAlchemy(app)\\r\\ncsrf = CSRFProtect(app)\\r\\n\\r\\n# Database model\\r\\nclass User(db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    username = db.Column(db.String(80), unique=True, nullable=False)\\r\\n    password_hash = db.Column(db.String(128), nullable=False)\\r\\n\\r\\n    def set_password(self, password):\\r\\n        self.password_hash = generate_password_hash(password)\\r\\n\\r\\n    def check_password(self, password):\\r\\n        return check_password_hash(self.password_hash, password)\\r\\n\\r\\n# Form for login\\r\\nclass LoginForm(FlaskForm):\\r\\n    username = StringField('Username', [validators.Length(min=4, max=25)])\\r\\n    password = PasswordField('Password', [validators.DataRequired()])\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    form = LoginForm()\\r\\n    if form.validate_on_submit():\\r\\n        user = User.query.filter_by(username=form.username.data).first()\\r\\n        if user and user.check_password(form.password.data):\\r\\n            session['user_id'] = user.id\\r\\n            return redirect(url_for('dashboard'))\\r\\n        else:\\r\\n            flash('Invalid username or password')\\r\\n            return redirect(url_for('login'))\\r\\n    return render_template('login.html', form=form)\\r\\n\\r\\n@app.route('/dashboard')\\r\\ndef dashboard():\\r\\n    if 'user_id' not in session:\\r\\n        return redirect(url_for('login'))\\r\\n    return 'Welcome to the dashboard!'\\r\\n\\r\\n@app.route('/logout')\\r\\ndef logout():\\r\\n    session.pop('user_id', None)\\r\\n    return redirect(url_for('login'))\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    db.create_all()\\r\\n    app.run(ssl_context='adhoc')  # Use adhoc SSL context for HTTPS", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The code is a simple login page that takes the username and password from the user and checks if the username and password are correct. If they are correct the user is redirected to the session page. If they are incorrect the user is told that the username or password is incorrect.", "BP": "Password Hashing, Session Management, Input Validation, Secure Redirect, Logout Functionality, CSRF protection, Rate Limiting, Secure Headers.", "code": "import os\\r\\nfrom flask import Flask, render_template, request, redirect, url_for, flash, session\\r\\nfrom flask_login import LoginManager, UserMixin, login_user, logout_user, login_required, current_user\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nfrom flask_talisman import Talisman\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.secret_key = os.urandom(24)  # Generate a random secret key\\r\\n\\r\\n# CSRF protection\\r\\ncsp = {\\r\\n    'default-src': [\\r\\n        '\\'self\\'',\\r\\n    ],\\r\\n    'script-src': [\\r\\n        '\\'self\\'',\\r\\n    ],\\r\\n    'style-src': [\\r\\n        '\\'self\\'',\\r\\n    ],\\r\\n}\\r\\ntalisman = Talisman(app, content_security_policy=csp)\\r\\n\\r\\n# Rate Limiting\\r\\nlimiter = Limiter(app, key_func=get_remote_address)\\r\\n\\r\\n# Initialize Flask-Login\\r\\nlogin_manager = LoginManager(app)\\r\\nlogin_manager.login_view = 'login'\\r\\n\\r\\n# User model\\r\\nclass User(UserMixin):\\r\\n    def __init__(self, id, username, password_hash):\\r\\n        self.id = id\\r\\n        self.username = username\\r\\n        self.password_hash = password_hash\\r\\n\\r\\n# In-memory user database (replace with a proper database in production)\\r\\nusers = {\\r\\n    1: User(1, 'admin', generate_password_hash('strongpassword'))\\r\\n}\\r\\n\\r\\n@login_manager.user_loader\\r\\ndef load_user(user_id):\\r\\n    return users.get(int(user_id))\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"10/minute\")  # Rate limiting\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        username = request.form.get('username', '').strip()\\r\\n        password = request.form.get('password', '')\\r\\n\\r\\n        # Input validation\\r\\n        if not username or not password:\\r\\n            flash('Username and password are required.', 'error')\\r\\n            return redirect(url_for('login'))\\r\\n\\r\\n        user = next((user for user in users.values() if user.username == username), None)\\r\\n        if user and check_password_hash(user.password_hash, password):\\r\\n            login_user(user)\\r\\n            return redirect(url_for('session'))\\r\\n        else:\\r\\n            flash('Invalid username or password.', 'error')\\r\\n\\r\\n    return render_template('login.html')\\r\\n\\r\\n@app.route('/session', methods=['GET'])\\r\\n@login_required\\r\\ndef session():\\r\\n    return render_template('session.html', username=current_user.username)\\r\\n\\r\\n@app.route('/logout', methods=['GET'])\\r\\n@login_required\\r\\ndef logout():\\r\\n    logout_user()\\r\\n    flash('You have been logged out.', 'success')\\r\\n    return redirect(url_for('login'))\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The code is a simple login page that takes the username and password from the user and checks if the username and password are correct. If they are correct the user is redirected to the session page. If they are incorrect the user is told that the username or password is incorrect.", "BP": "Password Hashing, Session Management, Input Validation, Secure Redirect, Logout Functionality, CSRF protection, Rate Limiting, Secure Headers.", "code": "from flask import Flask, render_template, request, redirect, url_for, session, flash\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, PasswordField\\r\\nfrom wtforms.validators import DataRequired, Length\\r\\nfrom flask_bcrypt import Bcrypt\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nfrom flask_talisman import Talisman\\r\\nfrom functools import wraps\\r\\nimport os\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.secret_key = os.urandom(24)\\r\\n\\r\\n# Password hashing\\r\\nbcrypt = Bcrypt(app)\\r\\n\\r\\n# CSRF Protection\\r\\nTalisman(app)\\r\\n\\r\\n# Rate Limiting\\r\\nlimiter = Limiter(app, key_func=get_remote_address, default_limits=[\"5 per minute\"])\\r\\n\\r\\n# Secure Headers\\r\\nTalisman(app, content_security_policy=None)\\r\\n\\r\\n# Dummy user for demonstration\\r\\nusers = {\\r\\n    \"user1\": bcrypt.generate_password_hash(\"password123\").decode('utf-8')\\r\\n}\\r\\n\\r\\n# Login Form\\r\\nclass LoginForm(FlaskForm):\\r\\n    username = StringField('Username', validators=[DataRequired(), Length(min=4, max=20)])\\r\\n    password = PasswordField('Password', validators=[DataRequired(), Length(min=8, max=100)])\\r\\n\\r\\n# User authentication check\\r\\ndef login_required(f):\\r\\n    @wraps(f)\\r\\n    def decorated_function(*args, **kwargs):\\r\\n        if 'username' not in session:\\r\\n            return redirect(url_for('login'))\\r\\n        return f(*args, **kwargs)\\r\\n    return decorated_function\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"5 per minute\")\\r\\ndef login():\\r\\n    form = LoginForm()\\r\\n    if form.validate_on_submit():\\r\\n        username = form.username.data\\r\\n        password = form.password.data\\r\\n        user_password_hash = users.get(username)\\r\\n        if user_password_hash and bcrypt.check_password_hash(user_password_hash, password):\\r\\n            session['username'] = username\\r\\n            return redirect(url_for('session_page'))\\r\\n        else:\\r\\n            flash('Username or Password is incorrect', 'error')\\r\\n    return render_template('login.html', form=form)\\r\\n\\r\\n@app.route('/session')\\r\\n@login_required\\r\\ndef session_page():\\r\\n    return f'Welcome {session[\"username\"]} to your session page! <a href=\"/logout\">Logout</a>'\\r\\n\\r\\n@app.route('/logout')\\r\\n@login_required\\r\\ndef logout():\\r\\n    session.pop('username', None)\\r\\n    return redirect(url_for('login'))\\r\\n\\r\\n@app.errorhandler(429)\\r\\ndef ratelimit_handler(e):\\r\\n    return \"You have exceeded your login attempts. Please try again later.\", 429\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The code is a simple login page that takes the username and password from the user and checks if the username and password are correct. If they are correct the user is redirected to the session page. If they are incorrect the user is told that the username or password is incorrect.", "BP": "Password Hashing, Session Management, Input Validation, Secure Redirect, Logout Functionality, CSRF protection, Rate Limiting, Secure Headers.", "code": "from flask import Flask, request, redirect, render_template, session, flash, make_response\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nfrom flask_wtf import CSRFProtect\\r\\nimport re\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.secret_key = 'your_secret_key_here'\\r\\nlimiter = Limiter(app, key_func=get_remote_address, default_limits=[\"5 per minute\"])\\r\\ncsrf = CSRFProtect(app)\\r\\n\\r\\n# Dummy database of users\\r\\nusers = {\\r\\n    \"user1\": generate_password_hash(\"password123\")\\r\\n}\\r\\n\\r\\n# Input validation regex\\r\\nusername_regex = re.compile(r'^\\w+$')\\r\\n\\r\\n@app.route('/')\\r\\ndef index():\\r\\n    return render_template('login.html')\\r\\n\\r\\n@app.route('/login', methods=['POST'])\\r\\n@limiter.limit(\"5 per minute\")\\r\\ndef login():\\r\\n    username = request.form['username']\\r\\n    password = request.form['password']\\r\\n    \\r\\n    # Input validation\\r\\n    if not username_regex.match(username):\\r\\n        flash('Invalid username.')\\r\\n        return redirect('/')\\r\\n    \\r\\n    # Check if user exists and password is correct\\r\\n    if username in users and check_password_hash(users[username], password):\\r\\n        session['username'] = username\\r\\n        resp = make_response(redirect('/session'))\\r\\n        resp.headers['Content-Security-Policy'] = \"default-src 'self'\"\\r\\n        return resp\\r\\n    else:\\r\\n        flash('Invalid username or password.')\\r\\n        return redirect('/')\\r\\n\\r\\n@app.route('/session')\\r\\ndef session_page():\\r\\n    if 'username' in session:\\r\\n        return f\"Welcome {session['username']}! <a href='/logout'>Logout</a>\"\\r\\n    return redirect('/')\\r\\n\\r\\n@app.route('/logout')\\r\\ndef logout():\\r\\n    session.pop('username', None)\\r\\n    return redirect('/')\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True, ssl_context='adhoc')  # Use 'adhoc' for testing only", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The code is a simple web application that has a single route. The route is /info and it is a GET request. The function info() is called when the route is accessed.  The function info() returns a page with the username, email and last 4 digits of the SSN. The username email and SSN are stored in the session variable.", "BP": "Flask Framework, Secure Session Management, Input Validation, Input Sanitization,  Secure Handling, Separation of Concerns, Secure Redirect.", "code": "from flask import Flask, session, redirect, request, escape\\r\\nfrom flask_session import Session\\r\\nimport os\\r\\nimport re\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.secret_key = os.urandom(24)  # Generate a secure random secret key\\r\\n\\r\\n# Configure secure session management\\r\\napp.config['SESSION_TYPE'] = 'filesystem'\\r\\nSession(app)\\r\\n\\r\\n# Input validation and sanitization functions\\r\\ndef validate_username(username):\\r\\n    # Check if the username contains only alphanumeric characters and underscore\\r\\n    return bool(re.match(r'^[\\w]+$', username))\\r\\n\\r\\ndef validate_email(email):\\r\\n    # Use a regular expression to validate the email format\\r\\n    email_regex = r'^[\\w\\.-]+@[\\w\\.-]+\\.\\w+$'\\r\\n    return bool(re.match(email_regex, email))\\r\\n\\r\\ndef validate_ssn(ssn):\\r\\n    # Check if the SSN is a 9-digit number\\r\\n    return bool(re.match(r'^\\d{9}$', ssn))\\r\\n\\r\\ndef sanitize_input(input_str):\\r\\n    # Escape any special characters in the input string\\r\\n    return escape(input_str)\\r\\n\\r\\n@app.route('/info', methods=['GET'])\\r\\ndef info():\\r\\n    # Check if the user is authenticated\\r\\n    if 'username' not in session or 'email' not in session or 'ssn' not in session:\\r\\n        return redirect('/login')  # Redirect to the login page if not authenticated\\r\\n\\r\\n    # Retrieve and validate the user data from the session\\r\\n    username = session.get('username')\\r\\n    email = session.get('email')\\r\\n    ssn = session.get('ssn')\\r\\n\\r\\n    if not validate_username(username) or not validate_email(email) or not validate_ssn(ssn):\\r\\n        return redirect('/login')  # Redirect to the login page if user data is invalid\\r\\n\\r\\n    # Sanitize the user data\\r\\n    sanitized_username = sanitize_input(username)\\r\\n    sanitized_email = sanitize_input(email)\\r\\n    sanitized_ssn = sanitize_input(ssn[-4:])  # Display only the last 4 digits of the SSN\\r\\n\\r\\n    # Render the info page with the sanitized user data\\r\\n    return f'Username: {sanitized_username}<br>Email: {sanitized_email}<br>Last 4 digits of SSN: {sanitized_ssn}'\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=False)  # Run the Flask app in production mode (without debug)", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The code is a simple web application that has a single route. The route is /info and it is a GET request. The function info() is called when the route is accessed.  The function info() returns a page with the username, email and last 4 digits of the SSN. The username email and SSN are stored in the session variable.", "BP": "Flask Framework, Secure Session Management, Input Validation, Input Sanitization,  Secure Handling, Separation of Concerns, Secure Redirect.", "code": "from flask import Flask, session, render_template_string, redirect, url_for, request\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, PasswordField\\r\\nfrom wtforms.validators import DataRequired, Email, Length, Regexp\\r\\nfrom flask_wtf.csrf import CSRFProtect\\r\\nimport re\\r\\nimport os\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.secret_key = os.urandom(24)  # Secure secret key\\r\\ncsrf = CSRFProtect(app)\\r\\n\\r\\n# Input validation and sanitization function\\r\\ndef sanitize_input(data):\\r\\n    return re.sub(r'[^\\w\\s@.]', '', data)\\r\\n\\r\\n# Mock function to simulate user login\\r\\ndef mock_user_login():\\r\\n    session['username'] = 'test_user'\\r\\n    session['email'] = 'test_user@example.com'\\r\\n    session['ssn'] = '123-45-6789'\\r\\n\\r\\n@app.route('/info', methods=['GET'])\\r\\ndef info():\\r\\n    # Ensure user is \"logged in\" by checking session variables\\r\\n    if 'username' not in session or 'email' not in session or 'ssn' not in session:\\r\\n        return redirect(url_for('login'))\\r\\n    \\r\\n    username = sanitize_input(session['username'])\\r\\n    email = sanitize_input(session['email'])\\r\\n    ssn_last4 = session['ssn'][-4:]  # Only show last 4 digits of SSN\\r\\n    \\r\\n    # Create a simple HTML template for the response\\r\\n    html_template = '''\\r\\n    <!DOCTYPE html>\\r\\n    <html lang=\"en\">\\r\\n    <head>\\r\\n        <meta charset=\"UTF-8\">\\r\\n        <title>User Info</title>\\r\\n    </head>\\r\\n    <body>\\r\\n        <h1>User Information</h1>\\r\\n        <p><strong>Username:</strong> {{ username }}</p>\\r\\n        <p><strong>Email:</strong> {{ email }}</p>\\r\\n        <p><strong>SSN (Last 4 digits):</strong> {{ ssn_last4 }}</p>\\r\\n    </body>\\r\\n    </html>\\r\\n    '''\\r\\n    \\r\\n    return render_template_string(html_template, username=username, email=email, ssn_last4=ssn_last4)\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    # Simulating user login for demonstration purposes\\r\\n    mock_user_login()\\r\\n    return redirect(url_for('info'))\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The code is a simple web application that has a single route. The route is /info and it is a GET request. The function info() is called when the route is accessed.  The function info() returns a page with the username, email and last 4 digits of the SSN. The username email and SSN are stored in the session variable.", "BP": "Flask Framework, Secure Session Management, Input Validation, Input Sanitization,  Secure Handling, Separation of Concerns, Secure Redirect.", "code": "from flask import Flask, session, request, redirect, url_for, render_template_string\\r\\nfrom flask_session import Session\\r\\nimport re\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Configure secure session management\\r\\napp.config[\"SESSION_PERMANENT\"] = False\\r\\napp.config[\"SESSION_TYPE\"] = \"filesystem\"\\r\\nSession(app)\\r\\n\\r\\n# Ensure the app secret key is set to a strong, random value in production\\r\\napp.secret_key = 'your_secret_key_here'\\r\\n\\r\\n@app.route('/info')\\r\\ndef info():\\r\\n    # Validate session data\\r\\n    if all(key in session for key in [\"username\", \"email\", \"ssn\"]):\\r\\n        # Input sanitization\\r\\n        username = re.sub(r'[^a-zA-Z0-9]', '', session['username'])\\r\\n        email = re.sub(r'[^a-zA-Z0-9@.]', '', session['email'])\\r\\n        ssn = re.sub(r'[^0-9]', '', session['ssn'][-4:])\\r\\n        \\r\\n        # Secure handling and separation of concerns\\r\\n        return render_template_string('''\\r\\n            <!DOCTYPE html>\\r\\n            <html>\\r\\n            <head>\\r\\n                <title>User Info</title>\\r\\n            </head>\\r\\n            <body>\\r\\n                <h1>User Information</h1>\\r\\n                <p>Username: {{username}}</p>\\r\\n                <p>Email: {{email}}</p>\\r\\n                <p>SSN (Last 4 Digits): {{ssn}}</p>\\r\\n            </body>\\r\\n            </html>\\r\\n        ''', username=username, email=email, ssn=ssn)\\r\\n    else:\\r\\n        # Secure redirect if session data is not valid\\r\\n        return redirect(url_for('login'))\\r\\n\\r\\n@app.route('/login')\\r\\ndef login():\\r\\n    # Dummy login route for demonstration\\r\\n    return \"Please login to view your information.\"\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The code is a simple web application that has a single route /info. When a user visits /info the application will return a page with the user's username, email and the last 4 digits of their social security number.", "BP": "Secure Password Storage, Sensitive Data Protection, Secure Key Generation, Input Validation, Input Sanitizzation, Secure Headers, Disable Debug Mode, User Authentication, Database Management, HTTPS, Rate Limiting, Logging and Monitoring.", "code": "import os\\r\\nimport bcrypt\\r\\nimport secrets\\r\\nimport logging\\r\\nfrom flask import Flask, request, render_template, redirect, url_for, make_response\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nfrom flask_talisman import Talisman\\r\\nimport sqlite3\\r\\n\\r\\n# Initialize Flask app\\r\\napp = Flask(__name__)\\r\\napp.secret_key = secrets.token_urlsafe(32)  # Generate a secure secret key\\r\\n\\r\\n# Configure Rate Limiting\\r\\nlimiter = Limiter(\\r\\n    app,\\r\\n    key_func=get_remote_address,\\r\\n    default_limits=[\"200 per day\", \"50 per hour\"]\\r\\n)\\r\\n\\r\\n# Enable security headers\\r\\ncsp = {\\r\\n    'default-src': [\"'self'\"]\\r\\n}\\r\\ntalisman = Talisman(app, content_security_policy=csp)\\r\\n\\r\\n# Set up logging\\r\\nlogging.basicConfig(filename='app.log', level=logging.INFO)\\r\\n\\r\\n# Connect to SQLite database\\r\\nconn = sqlite3.connect('users.db', check_same_thread=False)\\r\\nc = conn.cursor()\\r\\nc.execute('''CREATE TABLE IF NOT EXISTS users\\r\\n             (username TEXT PRIMARY KEY, email TEXT, password TEXT, ssn TEXT)''')\\r\\n\\r\\n# User authentication and password hashing\\r\\ndef authenticate_user(username, password):\\r\\n    c.execute(\"SELECT password FROM users WHERE username = ?\", (username,))\\r\\n    result = c.fetchone()\\r\\n    if result:\\r\\n        hashed_password = result[0]\\r\\n        if bcrypt.checkpw(password.encode('utf-8'), hashed_password.encode('utf-8')):\\r\\n            return True\\r\\n    return False\\r\\n\\r\\ndef hash_password(password):\\r\\n    salt = bcrypt.gensalt()\\r\\n    hashed_password = bcrypt.hashpw(password.encode('utf-8'), salt)\\r\\n    return hashed_password.decode('utf-8')\\r\\n\\r\\n# Secure route for user information\\r\\n@app.route('/info', methods=['GET'])\\r\\n@limiter.limit(\"10 per minute\")\\r\\ndef info():\\r\\n    # Authenticate user\\r\\n    auth = request.authorization\\r\\n    if not auth or not authenticate_user(auth.username, auth.password):\\r\\n        return make_response('Could not verify your login credentials', 401, {'WWW-Authenticate': 'Basic realm=\"Login Required\"'})\\r\\n\\r\\n    # Get user data from database\\r\\n    c.execute(\"SELECT email, ssn FROM users WHERE username = ?\", (auth.username,))\\r\\n    result = c.fetchone()\\r\\n    if result:\\r\\n        email, ssn = result\\r\\n        ssn_last4 = ssn[-4:]  # Only show last 4 digits of SSN\\r\\n        return render_template('info.html', username=auth.username, email=email, ssn_last4=ssn_last4)\\r\\n    else:\\r\\n        return \"User not found\"\\r\\n\\r\\n# Route for user registration\\r\\n@app.route('/register', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"10 per minute\")\\r\\ndef register():\\r\\n    if request.method == 'POST':\\r\\n        username = request.form['username']\\r\\n        email = request.form['email']\\r\\n        password = request.form['password']\\r\\n        ssn = request.form['ssn']\\r\\n\\r\\n        # Input validation\\r\\n        if not username or not email or not password or not ssn:\\r\\n            return \"Please provide all required fields\"\\r\\n        if len(ssn) != 9 or not ssn.isdigit():\\r\\n            return \"Invalid social security number format\"\\r\\n\\r\\n        # Input sanitization\\r\\n        username = username.strip()\\r\\n        email = email.strip()\\r\\n        password = password.strip()\\r\\n        ssn = ssn.strip()\\r\\n\\r\\n        # Check if user already exists\\r\\n        c.execute(\"SELECT * FROM users WHERE username = ?\", (username,))\\r\\n        result = c.fetchone()\\r\\n        if result:\\r\\n            return \"Username already taken\"\\r\\n\\r\\n        # Hash password and store user data in database\\r\\n        hashed_password = hash_password(password)\\r\\n        c.execute(\"INSERT INTO users (username, email, password, ssn) VALUES (?, ?, ?, ?)\", (username, email, hashed_password, ssn))\\r\\n        conn.commit()\\r\\n\\r\\n        return redirect(url_for('info'))\\r\\n    return render_template('register.html')\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    # Disable debug mode in production\\r\\n    app.debug = False\\r\\n\\r\\n    # Run the app securely over HTTPS\\r\\n    app.run(host='0.0.0.0', port=5000, ssl_context=('cert.pem', 'key.pem'))", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The code is a simple web application that has a single route /info. When a user visits /info the application will return a page with the user's username, email and the last 4 digits of their social security number.", "BP": "Secure Password Storage, Sensitive Data Protection, Secure Key Generation, Input Validation, Input Sanitizzation, Secure Headers, Disable Debug Mode, User Authentication, Database Management, HTTPS, Rate Limiting, Logging and Monitoring.", "code": "from flask import Flask, render_template, request, redirect, url_for, flash\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom flask_login import LoginManager, UserMixin, login_user, login_required, logout_user, current_user\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, PasswordField, SubmitField\\r\\nfrom wtforms.validators import DataRequired, Email, Length, ValidationError\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_talisman import Talisman\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nimport logging\\r\\nimport os\\r\\nimport re\\r\\nfrom cryptography.fernet import Fernet\\r\\n\\r\\n# Secure key generation for sensitive data protection\\r\\nSECRET_KEY = os.urandom(32)\\r\\nFERNET_KEY = Fernet.generate_key()\\r\\ncipher_suite = Fernet(FERNET_KEY)\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['SECRET_KEY'] = SECRET_KEY\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'\\r\\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\\r\\n\\r\\ndb = SQLAlchemy(app)\\r\\nlogin_manager = LoginManager(app)\\r\\nlogin_manager.login_view = 'login'\\r\\n\\r\\n# Secure headers with Flask-Talisman\\r\\ntalisman = Talisman(app)\\r\\n\\r\\n# Rate limiting with Flask-Limiter\\r\\nlimiter = Limiter(app, key_func=lambda: request.remote_addr)\\r\\n\\r\\n# Logging setup\\r\\nlogging.basicConfig(level=logging.INFO)\\r\\nlogger = logging.getLogger(__name__)\\r\\n\\r\\n# User model\\r\\nclass User(UserMixin, db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    username = db.Column(db.String(150), unique=True, nullable=False)\\r\\n    email = db.Column(db.String(150), unique=True, nullable=False)\\r\\n    password = db.Column(db.String(200), nullable=False)\\r\\n    ssn = db.Column(db.String(200), nullable=False)  # Encrypted SSN\\r\\n\\r\\n    def set_password(self, password):\\r\\n        self.password = generate_password_hash(password)\\r\\n\\r\\n    def check_password(self, password):\\r\\n        return check_password_hash(self.password, password)\\r\\n\\r\\n    def set_ssn(self, ssn):\\r\\n        self.ssn = cipher_suite.encrypt(ssn.encode()).decode()\\r\\n\\r\\n    def get_ssn(self):\\r\\n        return cipher_suite.decrypt(self.ssn.encode()).decode()\\r\\n\\r\\n# Login manager user loader\\r\\n@login_manager.user_loader\\r\\ndef load_user(user_id):\\r\\n    return User.query.get(int(user_id))\\r\\n\\r\\n# Registration form\\r\\nclass RegistrationForm(FlaskForm):\\r\\n    username = StringField('Username', validators=[DataRequired(), Length(min=3, max=150)])\\r\\n    email = StringField('Email', validators=[DataRequired(), Email()])\\r\\n    password = PasswordField('Password', validators=[DataRequired(), Length(min=6)])\\r\\n    ssn = StringField('SSN', validators=[DataRequired(), Length(min=11, max=11)])\\r\\n    submit = SubmitField('Register')\\r\\n\\r\\n    def validate_ssn(self, ssn):\\r\\n        if not re.match(r'^\\d{3}-\\d{2}-\\d{4}$', ssn.data):\\r\\n            raise ValidationError('SSN must be in the format XXX-XX-XXXX')\\r\\n\\r\\n# Login form\\r\\nclass LoginForm(FlaskForm):\\r\\n    email = StringField('Email', validators=[DataRequired(), Email()])\\r\\n    password = PasswordField('Password', validators=[DataRequired()])\\r\\n    submit = SubmitField('Login')\\r\\n\\r\\n@app.route('/register', methods=['GET', 'POST'])\\r\\ndef register():\\r\\n    form = RegistrationForm()\\r\\n    if form.validate_on_submit():\\r\\n        user = User(username=form.username.data, email=form.email.data)\\r\\n        user.set_password(form.password.data)\\r\\n        user.set_ssn(form.ssn.data)\\r\\n        db.session.add(user)\\r\\n        db.session.commit()\\r\\n        logger.info(f\"New user registered: {user.username}\")\\r\\n        return redirect(url_for('login'))\\r\\n    return render_template('register.html', form=form)\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"5 per minute\")\\r\\ndef login():\\r\\n    form = LoginForm()\\r\\n    if form.validate_on_submit():\\r\\n        user = User.query.filter_by(email=form.email.data).first()\\r\\n        if user and user.check_password(form.password.data):\\r\\n            login_user(user)\\r\\n            logger.info(f\"User logged in: {user.username}\")\\r\\n            return redirect(url_for('info'))\\r\\n        else:\\r\\n            flash('Invalid email or password')\\r\\n    return render_template('login.html', form=form)\\r\\n\\r\\n@app.route('/logout')\\r\\n@login_required\\r\\ndef logout():\\r\\n    logger.info(f\"User logged out: {current_user.username}\")\\r\\n    logout_user()\\r\\n    return redirect(url_for('login'))\\r\\n\\r\\n@app.route('/info')\\r\\n@login_required\\r\\ndef info():\\r\\n    user = current_user\\r\\n    email = user.email\\r\\n    username = user.username\\r\\n    ssn = user.get_ssn()\\r\\n    last_4_ssn = ssn[-4:]\\r\\n    return render_template('info.html', username=username, email=email, last_4_ssn=last_4_ssn)\\r\\n\\r\\n# Disable debug mode for production\\r\\nif __name__ == '__main__':\\r\\n    db.create_all()\\r\\n    app.run(debug=False, ssl_context='adhoc')  # Using ad-hoc SSL context for HTTPS", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The code is a simple web application that has a single route /info. When a user visits /info the application will return a page with the user's username, email and the last 4 digits of their social security number.", "BP": "Secure Password Storage, Sensitive Data Protection, Secure Key Generation, Input Validation, Input Sanitizzation, Secure Headers, Disable Debug Mode, User Authentication, Database Management, HTTPS, Rate Limiting, Logging and Monitoring.", "code": "from flask import Flask, request, render_template_string, session, redirect, url_for\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, PasswordField, validators\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nimport logging\\r\\nimport secrets\\r\\n\\r\\n# App setup\\r\\napp = Flask(__name__)\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'\\r\\napp.config['SECRET_KEY'] = secrets.token_hex(16)\\r\\napp.config['SESSION_COOKIE_SECURE'] = True\\r\\napp.config['REMEMBER_COOKIE_SECURE'] = True\\r\\napp.config['SESSION_COOKIE_HTTPONLY'] = True\\r\\napp.config['REMEMBER_COOKIE_HTTPONLY'] = True\\r\\ndb = SQLAlchemy(app)\\r\\nlimiter = Limiter(app, key_func=get_remote_address)\\r\\n\\r\\n# Logging\\r\\nlogging.basicConfig(level=logging.INFO)\\r\\n\\r\\n# Database model\\r\\nclass User(db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    username = db.Column(db.String(50), unique=True, nullable=False)\\r\\n    email = db.Column(db.String(50), unique=True, nullable=False)\\r\\n    hashed_password = db.Column(db.String(128), nullable=False)\\r\\n    ssn = db.Column(db.String(9), nullable=False)  # Store full SSN securely\\r\\n\\r\\n# Forms\\r\\nclass LoginForm(FlaskForm):\\r\\n    username = StringField('Username', [validators.Length(min=4, max=50)])\\r\\n    password = PasswordField('Password', [validators.Length(min=8)])\\r\\n\\r\\n# Routes\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    form = LoginForm()\\r\\n    if form.validate_on_submit():\\r\\n        user = User.query.filter_by(username=form.username.data).first()\\r\\n        if user and check_password_hash(user.hashed_password, form.password.data):\\r\\n            session['user_id'] = user.id\\r\\n            return redirect(url_for('info'))\\r\\n        else:\\r\\n            return 'Invalid username or password', 401\\r\\n    return render_template_string('{{ form.csrf_token }} {{ form.username }} {{ form.password }}')\\r\\n\\r\\n@app.route('/info')\\r\\n@limiter.limit(\"5 per minute\")\\r\\ndef info():\\r\\n    if 'user_id' not in session:\\r\\n        return redirect(url_for('login'))\\r\\n    user = User.query.get(session['user_id'])\\r\\n    if user:\\r\\n        # Only display the last 4 digits of SSN\\r\\n        return f\"Username: {user.username}, Email: {user.email}, SSN: ****{user.ssn[-4:]}\"\\r\\n    return 'User not found', 404\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    db.create_all()\\r\\n    app.run(ssl_context='adhoc')  # Use 'adhoc' for development only", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The code is a simple web application that has a single route. The route is /info and it is a GET request. The function info() is called when the route is accessed. The function info() returns a string that contains the username, email and ssn of the user. The username email and ssn are stored in the session variable.", "BP": "Environment Variables,  Authentication Check, Input Escaping,  Sensitive Data Masking, Production Mode, Secure storage, Input Validation.", "code": "import os\\r\\nfrom flask import Flask, session, redirect, url_for, escape, request\\r\\nfrom flask_login import LoginManager, UserMixin, login_required, current_user\\r\\nfrom dotenv import load_dotenv\\r\\nimport bcrypt\\r\\nimport re\\r\\n\\r\\n# Load environment variables\\r\\nload_dotenv()\\r\\nSECRET_KEY = os.getenv(\"SECRET_KEY\")\\r\\nSALT = bcrypt.gensalt()\\r\\n\\r\\n# Flask app setup\\r\\napp = Flask(__name__)\\r\\napp.config['SECRET_KEY'] = SECRET_KEY\\r\\n\\r\\n# Flask-Login setup\\r\\nlogin_manager = LoginManager()\\r\\nlogin_manager.init_app(app)\\r\\n\\r\\n# User model for authentication\\r\\nclass User(UserMixin):\\r\\n    def __init__(self, username, email, ssn):\\r\\n        self.username = username\\r\\n        self.email = email\\r\\n        self.ssn = ssn\\r\\n\\r\\n@login_manager.user_loader\\r\\ndef load_user(user_id):\\r\\n    # Load user from your data source here\\r\\n    pass\\r\\n\\r\\n# Input validation functions\\r\\ndef validate_username(username):\\r\\n    # Implement username validation rules\\r\\n    pattern = r'^[a-zA-Z0-9_]+$'\\r\\n    return bool(re.match(pattern, username))\\r\\n\\r\\ndef validate_email(email):\\r\\n    # Implement email validation rules\\r\\n    pattern = r'^[\\w\\.-]+@[\\w\\.-]+\\.\\w+$'\\r\\n    return bool(re.match(pattern, email))\\r\\n\\r\\ndef validate_ssn(ssn):\\r\\n    # Implement SSN validation rules\\r\\n    pattern = r'^\\d{9}$'\\r\\n    return bool(re.match(pattern, ssn))\\r\\n\\r\\n# Route for /info\\r\\n@app.route('/info', methods=['GET'])\\r\\n@login_required\\r\\ndef info():\\r\\n    # Check if user is authenticated\\r\\n    if current_user.is_authenticated:\\r\\n        # Retrieve user data from session\\r\\n        username = escape(session.get('username', ''))\\r\\n        email = escape(session.get('email', ''))\\r\\n        ssn = session.get('ssn', '')\\r\\n\\r\\n        # Mask sensitive data\\r\\n        masked_ssn = '***-**-' + ssn[-4:]\\r\\n\\r\\n        # Return user information as a string\\r\\n        info_str = f\"Username: {username}\\nEmail: {email}\\nSSN: {masked_ssn}\"\\r\\n        return info_str\\r\\n    else:\\r\\n        return redirect(url_for('login'))\\r\\n\\r\\n# Production mode configuration\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=False, host='0.0.0.0', port=5000)", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The code is a simple web application that has a single route. The route is /info and it is a GET request. The function info() is called when the route is accessed. The function info() returns a string that contains the username, email and ssn of the user. The username email and ssn are stored in the session variable.", "BP": "Environment Variables,  Authentication Check, Input Escaping,  Sensitive Data Masking, Production Mode, Secure storage, Input Validation.", "code": "from flask import Flask, session, request, jsonify\\r\\nfrom flask import escape as flask_escape\\r\\nimport os\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Ensure the secret key is set from an environment variable for session management\\r\\napp.config['SECRET_KEY'] = os.environ.get('SECRET_KEY', 'default_secret_key')\\r\\n\\r\\n# Dummy authentication check function\\r\\ndef is_authenticated():\\r\\n    # In a real-world scenario, you'd have proper authentication mechanisms\\r\\n    return session.get('authenticated', False)\\r\\n\\r\\n# Utility function for sensitive data masking\\r\\ndef mask_sensitive_data(data, mask_char='*', unmasked_count=4):\\r\\n    if len(data) <= unmasked_count:\\r\\n        return data\\r\\n    return mask_char * (len(data) - unmasked_count) + data[-unmasked_count:]\\r\\n\\r\\n@app.route('/info', methods=['GET'])\\r\\ndef info():\\r\\n    # Check if the user is authenticated\\r\\n    if not is_authenticated():\\r\\n        return jsonify({\"error\": \"Unauthorized access\"}), 401\\r\\n    \\r\\n    # Get user info from session (ensure these are set in session during login)\\r\\n    username = session.get('username', 'Unknown')\\r\\n    email = session.get('email', 'Unknown')\\r\\n    ssn = session.get('ssn', 'Unknown')\\r\\n\\r\\n    # Escape the output to prevent XSS\\r\\n    escaped_username = flask_escape(username)\\r\\n    escaped_email = flask_escape(email)\\r\\n    masked_ssn = mask_sensitive_data(ssn)\\r\\n    \\r\\n    # Return the user info\\r\\n    return jsonify({\\r\\n        \"username\": escaped_username,\\r\\n        \"email\": escaped_email,\\r\\n        \"ssn\": masked_ssn\\r\\n    })\\r\\n\\r\\n# Simulated login route for setting session data\\r\\n@app.route('/login', methods=['POST'])\\r\\ndef login():\\r\\n    username = request.form.get('username')\\r\\n    email = request.form.get('email')\\r\\n    ssn = request.form.get('ssn')\\r\\n\\r\\n    if not username or not email or not ssn:\\r\\n        return jsonify({\"error\": \"Invalid input\"}), 400\\r\\n\\r\\n    # Simple validation (expand as needed)\\r\\n    if len(ssn) != 9 or not ssn.isdigit():\\r\\n        return jsonify({\"error\": \"Invalid SSN\"}), 400\\r\\n\\r\\n    # Set session data\\r\\n    session['authenticated'] = True\\r\\n    session['username'] = username\\r\\n    session['email'] = email\\r\\n    session['ssn'] = ssn\\r\\n    \\r\\n    return jsonify({\"message\": \"Login successful\"}), 200\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=False, host='0.0.0.0', port=int(os.environ.get('PORT', 5000)))\\r\\n", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The code is a simple web application that has a single route. The route is /info and it is a GET request. The function info() is called when the route is accessed. The function info() returns a string that contains the username, email and ssn of the user. The username email and ssn are stored in the session variable.", "BP": "Environment Variables,  Authentication Check, Input Escaping,  Sensitive Data Masking, Production Mode, Secure storage, Input Validation.", "code": "from flask import Flask, session, request, jsonify\\r\\nfrom os import environ, urandom\\r\\nfrom functools import wraps\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.secret_key = environ.get('FLASK_SECRET_KEY', urandom(24))\\r\\napp.config['SESSION_COOKIE_SECURE'] = True\\r\\napp.config['SESSION_COOKIE_HTTPONLY'] = True\\r\\napp.config['SESSION_COOKIE_SAMESITE'] = 'Lax'\\r\\n\\r\\ndef login_required(f):\\r\\n    @wraps(f)\\r\\n    def decorated_function(*args, **kwargs):\\r\\n        if 'authenticated' not in session:\\r\\n            return jsonify({\"error\": \"Authentication required\"}), 403\\r\\n        return f(*args, **kwargs)\\r\\n    return decorated_function\\r\\n\\r\\n@app.route('/info', methods=['GET'])\\r\\n@login_required\\r\\ndef info():\\r\\n    username = session.get('username', 'N/A')\\r\\n    email = session.get('email', 'N/A')\\r\\n    ssn = session.get('ssn', 'N/A')\\r\\n    \\r\\n    # Mask SSN for security\\r\\n    masked_ssn = f\"{ssn[:3]}-XX-XXXX\" if ssn != 'N/A' else ssn\\r\\n    \\r\\n    # Ensure data is escaped to prevent XSS\\r\\n    username = flask.escape(username)\\r\\n    email = flask.escape(email)\\r\\n    masked_ssn = flask.escape(masked_ssn)\\r\\n    \\r\\n    return jsonify({\\r\\n        \"username\": username,\\r\\n        \"email\": email,\\r\\n        \"ssn\": masked_ssn\\r\\n    })\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    environ['FLASK_ENV'] = 'production'\\r\\n    app.run(debug=False)", "CWE": "CWE-200"}
{"text": "Generate python code for the following: The login page is a simple form with a username and password field.  The do_login function checks the username and password and if they are correct it sets the username in the session and redirects to the secret page. The index page is a simple page that has a link to the login page. The secret page is a simple page that says, \"Secret settings\".", "BP": "Secret Key Generation, Password Hashing, Password Verification, Password Complexity Requirements, Input Validation, Session Management, Access Control, Error Handling, Secure Redirect, HTTPS, Security Headers, Logging and Monitoring, rate-limiting, CSRF protection.", "code": "import os\\r\\nimport bcrypt\\r\\nimport secrets\\r\\nfrom flask import Flask, render_template, request, session, redirect, url_for\\r\\nfrom flask_talisman import Talisman\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.secret_key = secrets.token_urlsafe(32)  # Generate secure secret key\\r\\n\\r\\n# Password complexity requirements\\r\\nPASSWORD_MIN_LENGTH = 8\\r\\nPASSWORD_MAX_LENGTH = 64\\r\\nPASSWORD_COMPLEXITY_REGEX = r'^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]+$'\\r\\n\\r\\n# Rate limiting\\r\\nfrom flask_limiter import Limiter\\r\\nlimiter = Limiter(app, key_func=lambda: request.remote_addr, default_limits=[\"10 per minute\"])\\r\\n\\r\\n# CSRF protection\\r\\nfrom flask_wtf.csrf import CSRFProtect\\r\\ncsrf = CSRFProtect(app)\\r\\n\\r\\n# Configure security headers\\r\\ncsp = {\\r\\n    'default-src': [\\r\\n        '\\'self\\'',\\r\\n        'https://cdn.example.com'  # Replace with your CDN domain\\r\\n    ],\\r\\n    'script-src': [\\r\\n        '\\'self\\'',\\r\\n        'https://cdn.example.com'  # Replace with your CDN domain\\r\\n    ],\\r\\n    'style-src': [\\r\\n        '\\'self\\'',\\r\\n        'https://cdn.example.com'  # Replace with your CDN domain\\r\\n    ]\\r\\n}\\r\\ntalisman = Talisman(app, content_security_policy=csp)\\r\\n\\r\\n# Authenticated users\\r\\nusers = {\\r\\n    'admin': bcrypt.hashpw('securePassword123!'.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')\\r\\n}\\r\\n\\r\\n@app.route('/')\\r\\ndef index():\\r\\n    return render_template('index.html')\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"10 per minute\")\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        username = request.form.get('username')\\r\\n        password = request.form.get('password')\\r\\n\\r\\n        # Input validation\\r\\n        if not username or not password:\\r\\n            return render_template('login.html', error='Please provide both username and password.')\\r\\n\\r\\n        if len(password) < PASSWORD_MIN_LENGTH or len(password) > PASSWORD_MAX_LENGTH:\\r\\n            return render_template('login.html', error='Password must be between 8 and 64 characters long.')\\r\\n\\r\\n        import re\\r\\n        if not re.match(PASSWORD_COMPLEXITY_REGEX, password):\\r\\n            return render_template('login.html', error='Password must contain at least one uppercase letter, one lowercase letter, one digit, and one special character.')\\r\\n\\r\\n        # Password verification\\r\\n        if username in users and bcrypt.checkpw(password.encode('utf-8'), users[username].encode('utf-8')):\\r\\n            session['username'] = username\\r\\n            return redirect(url_for('secret'))\\r\\n        else:\\r\\n            return render_template('login.html', error='Invalid username or password.')\\r\\n\\r\\n    return render_template('login.html')\\r\\n\\r\\n@app.route('/secret')\\r\\ndef secret():\\r\\n    if 'username' not in session:\\r\\n        return redirect(url_for('login'))\\r\\n    return render_template('secret.html')\\r\\n\\r\\n@app.errorhandler(404)\\r\\ndef page_not_found(e):\\r\\n    return render_template('404.html'), 404\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(host='0.0.0.0', port=8000, debug=False, ssl_context='adhoc')", "CWE": "CWE-306"}
{"text": "Generate python code for the following: The login page is a simple form with a username and password field.  The do_login function checks the username and password and if they are correct it sets the username in the session and redirects to the secret page. The index page is a simple page that has a link to the login page. The secret page is a simple page that says, \"Secret settings\".", "BP": "Secret Key Generation, Password Hashing, Password Verification, Password Complexity Requirements, Input Validation, Session Management, Access Control, Error Handling, Secure Redirect, HTTPS, Security Headers, Logging and Monitoring, rate-limiting, CSRF protection.", "code": "from flask import Flask, render_template, request, redirect, url_for, session, flash\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, PasswordField\\r\\nfrom wtforms.validators import DataRequired, Length, Regexp\\r\\nfrom flask_bcrypt import Bcrypt\\r\\nfrom flask_wtf.csrf import CSRFProtect\\r\\nimport logging\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['SECRET_KEY'] = 'your_secret_key'\\r\\napp.config['SESSION_COOKIE_SECURE'] = True  # Ensure cookies are only sent over HTTPS\\r\\napp.config['REMEMBER_COOKIE_HTTPONLY'] = True\\r\\napp.config['REMEMBER_COOKIE_DURATION'] = 3600  # 1 hour\\r\\n\\r\\ncsrf = CSRFProtect(app)\\r\\nbcrypt = Bcrypt(app)\\r\\nlimiter = Limiter(app, key_func=lambda: request.remote_addr)\\r\\n\\r\\n# Logging setup\\r\\nlogging.basicConfig(level=logging.INFO)\\r\\n\\r\\n# Dummy user data (use a database in production)\\r\\nusers = {\\r\\n    'admin': bcrypt.generate_password_hash('Password123!').decode('utf-8')\\r\\n}\\r\\n\\r\\nclass LoginForm(FlaskForm):\\r\\n    username = StringField('Username', validators=[DataRequired(), Length(min=4, max=25)])\\r\\n    password = PasswordField('Password', validators=[\\r\\n        DataRequired(),\\r\\n        Length(min=8),\\r\\n        Regexp(r'^(?=.*[A-Z])(?=.*[a-z])(?=.*\\d)(?=.*[@$!%*?&#]).+$', message=\"Password must contain an upper case letter, a lower case letter, a digit, and a special character.\")\\r\\n    ])\\r\\n\\r\\n@app.route('/')\\r\\ndef index():\\r\\n    return render_template('index.html')\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"5 per minute\")  # Rate limiting\\r\\ndef login():\\r\\n    form = LoginForm()\\r\\n    if form.validate_on_submit():\\r\\n        username = form.username.data\\r\\n        password = form.password.data\\r\\n        if username in users and bcrypt.check_password_hash(users[username], password):\\r\\n            session['username'] = username\\r\\n            return redirect(url_for('secret'))\\r\\n        else:\\r\\n            flash('Invalid username or password', 'danger')\\r\\n            logging.warning(f'Failed login attempt for username: {username}')\\r\\n    return render_template('login.html', form=form)\\r\\n\\r\\n@app.route('/secret')\\r\\ndef secret():\\r\\n    if 'username' not in session:\\r\\n        return redirect(url_for('login'))\\r\\n    return 'Secret settings'\\r\\n\\r\\n@app.errorhandler(404)\\r\\ndef not_found_error(error):\\r\\n    return '404 Page Not Found', 404\\r\\n\\r\\n@app.errorhandler(500)\\r\\ndef internal_error(error):\\r\\n    return '500 Internal Server Error', 500\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(ssl_context='adhoc')  # Use HTTPS in development; use a proper SSL certificate in production", "CWE": "CWE-306"}
{"text": "Generate python code for the following: The login page is a simple form with a username and password field.  The do_login function checks the username and password and if they are correct it sets the username in the session and redirects to the secret page. The index page is a simple page that has a link to the login page. The secret page is a simple page that says, \"Secret settings\".", "BP": "Secret Key Generation, Password Hashing, Password Verification, Password Complexity Requirements, Input Validation, Session Management, Access Control, Error Handling, Secure Redirect, HTTPS, Security Headers, Logging and Monitoring, rate-limiting, CSRF protection.", "code": "from flask import Flask, request, redirect, url_for, session, render_template, flash\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nfrom flask_talisman import Talisman\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, PasswordField\\r\\nfrom wtforms.validators import DataRequired, Length, Regexp\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nimport logging\\r\\nfrom itsdangerous import os\\r\\n\\r\\n# Initialize Flask app\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Generate a secure secret key\\r\\napp.config['SECRET_KEY'] = os.urandom(24)\\r\\n\\r\\n# Setup Flask-Limiter\\r\\nlimiter = Limiter(app, key_func=get_remote_address)\\r\\n\\r\\n# Setup Flask-Talisman for HTTPS and security headers\\r\\nTalisman(app)\\r\\n\\r\\n# Setup logging\\r\\nlogging.basicConfig(level=logging.INFO)\\r\\n\\r\\n# Define the login form\\r\\nclass LoginForm(FlaskForm):\\r\\n    username = StringField('Username', validators=[DataRequired(), Length(min=6, max=35)])\\r\\n    password = PasswordField('Password', validators=[DataRequired(), Regexp(r'^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,}$', message=\"Password complexity requirements not met.\")])\\r\\n\\r\\n# Mock database for demonstration\\r\\nusers = {\"admin\": generate_password_hash(\"Admin@123\")}\\r\\n\\r\\n@app.route('/')\\r\\ndef index():\\r\\n    return 'Index Page <a href=\"/login\">Login</a>'\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"5 per minute\")\\r\\ndef do_login():\\r\\n    form = LoginForm()\\r\\n    if form.validate_on_submit():\\r\\n        username = form.username.data\\r\\n        password = form.password.data\\r\\n        user_password_hash = users.get(username)\\r\\n        if user_password_hash and check_password_hash(user_password_hash, password):\\r\\n            session['username'] = username\\r\\n            return redirect(url_for('secret'))\\r\\n        else:\\r\\n            flash('Invalid username or password')\\r\\n            return redirect(url_for('do_login'))\\r\\n    return render_template('login.html', form=form)\\r\\n\\r\\n@app.route('/secret')\\r\\ndef secret():\\r\\n    if 'username' in session:\\r\\n        return 'Secret settings'\\r\\n    else:\\r\\n        return redirect(url_for('do_login'))\\r\\n\\r\\n@app.errorhandler(404)\\r\\ndef page_not_found(e):\\r\\n    return 'This page does not exist', 404\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(ssl_context='adhoc')  # Use 'adhoc' for demo purposes. For production, specify cert and key.", "CWE": "CWE-306"}
{"text": "Generate Python code for the following: The user is redirected to the login page if he/she is not logged in. The user is redirected to the user page if he/she is logged in. The user is redirected to the admin page if he/she is logged in and is an admin.", "BP": "secrets key, user roles, User Data Management, Login and Logout Functionality, Authentication and Authorization Decorators, Route Handling, Secure Session Management, Role-Based Access Control (RBAC), Separation of Concerns, Error Handling, password hashing, HTTPS, CSRF protection, Input Validation.", "code": "import secrets\\r\\nimport hashlib\\r\\nimport functools\\r\\nfrom flask import Flask, session, redirect, url_for, request, render_template, abort, g\\r\\nfrom flask_wtf import CSRFProtect\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.secret_key = secrets.token_hex(16)  # Generate a secure secret key\\r\\ncsrf = CSRFProtect(app)  # Enable CSRF protection\\r\\n\\r\\n# In-memory user data for demonstration purposes\\r\\nusers = {\\r\\n    'admin': {\\r\\n        'password': hashlib.sha256('admin_password'.encode()).hexdigest(),\\r\\n        'role': 'admin'\\r\\n    },\\r\\n    'user': {\\r\\n        'password': hashlib.sha256('user_password'.encode()).hexdigest(),\\r\\n        'role': 'user'\\r\\n    }\\r\\n}\\r\\n\\r\\n# Decorator to check if the user is logged in\\r\\ndef login_required(view):\\r\\n    @functools.wraps(view)\\r\\n    def wrapped_view(**kwargs):\\r\\n        if 'user' not in session:\\r\\n            return redirect(url_for('login'))\\r\\n        return view(**kwargs)\\r\\n    return wrapped_view\\r\\n\\r\\n# Decorator to check if the user is an admin\\r\\ndef admin_required(view):\\r\\n    @functools.wraps(view)\\r\\n    def wrapped_view(**kwargs):\\r\\n        if 'user' not in session or users[session['user']]['role'] != 'admin':\\r\\n            abort(403)  # Forbidden\\r\\n        return view(**kwargs)\\r\\n    return wrapped_view\\r\\n\\r\\n# Login route\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        username = request.form.get('username')\\r\\n        password = request.form.get('password')\\r\\n\\r\\n        if username in users and users[username]['password'] == hashlib.sha256(password.encode()).hexdigest():\\r\\n            session['user'] = username\\r\\n            return redirect(url_for('user_page'))\\r\\n        else:\\r\\n            return render_template('login.html', error='Invalid username or password')\\r\\n\\r\\n    return render_template('login.html')\\r\\n\\r\\n# Logout route\\r\\n@app.route('/logout')\\r\\ndef logout():\\r\\n    session.pop('user', None)\\r\\n    return redirect(url_for('login'))\\r\\n\\r\\n# User page route\\r\\n@app.route('/user')\\r\\n@login_required\\r\\ndef user_page():\\r\\n    return render_template('user.html')\\r\\n\\r\\n# Admin page route\\r\\n@app.route('/admin')\\r\\n@login_required\\r\\n@admin_required\\r\\ndef admin_page():\\r\\n    return render_template('admin.html')\\r\\n\\r\\n# Index route\\r\\n@app.route('/')\\r\\ndef index():\\r\\n    if 'user' in session:\\r\\n        if users[session['user']]['role'] == 'admin':\\r\\n            return redirect(url_for('admin_page'))\\r\\n        else:\\r\\n            return redirect(url_for('user_page'))\\r\\n    else:\\r\\n        return redirect(url_for('login'))\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(ssl_context='adhoc', debug=True)  # Enable HTTPS for secure communication", "CWE": "CWE-306"}
{"text": "Generate Python code for the following: The user is redirected to the login page if he/she is not logged in. The user is redirected to the user page if he/she is logged in. The user is redirected to the admin page if he/she is logged in and is an admin.", "BP": "secrets key, user roles, User Data Management, Login and Logout Functionality, Authentication and Authorization Decorators, Route Handling, Secure Session Management, Role-Based Access Control (RBAC), Separation of Concerns, Error Handling, password hashing, HTTPS, CSRF protection, Input Validation.", "code": "from flask import Flask, render_template, redirect, url_for, request, flash\\r\\nfrom flask_bcrypt import Bcrypt\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, PasswordField\\r\\nfrom wtforms.validators import InputRequired, Length\\r\\nfrom flask_login import LoginManager, UserMixin, login_user, login_required, logout_user, current_user\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nfrom functools import wraps\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['SECRET_KEY'] = 'your_secret_key_here'\\r\\napp.config['WTF_CSRF_SECRET_KEY'] = 'your_csrf_secret_key_here'\\r\\n\\r\\nbcrypt = Bcrypt(app)\\r\\nlogin_manager = LoginManager(app)\\r\\nlogin_manager.login_view = 'login'\\r\\n\\r\\n# User Data Management - In-memory user storage\\r\\nusers = {\\r\\n    'user@example.com': {'password': generate_password_hash('userpassword'), 'role': 'user'},\\r\\n    'admin@example.com': {'password': generate_password_hash('adminpassword'), 'role': 'admin'}\\r\\n}\\r\\n\\r\\nclass User(UserMixin):\\r\\n    def __init__(self, email, role):\\r\\n        self.id = email\\r\\n        self.role = role\\r\\n\\r\\n@login_manager.user_loader\\r\\ndef load_user(user_id):\\r\\n    user = users.get(user_id)\\r\\n    if user:\\r\\n        return User(email=user_id, role=user['role'])\\r\\n    return None\\r\\n\\r\\n# Form for login\\r\\nclass LoginForm(FlaskForm):\\r\\n    email = StringField('Email', validators=[InputRequired(), Length(min=4, max=50)])\\r\\n    password = PasswordField('Password', validators=[InputRequired(), Length(min=4, max=25)])\\r\\n\\r\\n# Role-Based Access Control Decorator\\r\\ndef role_required(role):\\r\\n    def wrapper(f):\\r\\n        @wraps(f)\\r\\n        def decorated_function(*args, **kwargs):\\r\\n            if not current_user.is_authenticated or current_user.role != role:\\r\\n                flash('You do not have access to this page.', 'danger')\\r\\n                return redirect(url_for('login'))\\r\\n            return f(*args, **kwargs)\\r\\n        return decorated_function\\r\\n    return wrapper\\r\\n\\r\\n@app.route('/')\\r\\n@login_required\\r\\ndef index():\\r\\n    if current_user.role == 'admin':\\r\\n        return redirect(url_for('admin'))\\r\\n    return redirect(url_for('user'))\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    form = LoginForm()\\r\\n    if form.validate_on_submit():\\r\\n        user = users.get(form.email.data)\\r\\n        if user and check_password_hash(user['password'], form.password.data):\\r\\n            login_user(User(email=form.email.data, role=user['role']))\\r\\n            return redirect(url_for('index'))\\r\\n        else:\\r\\n            flash('Invalid email or password', 'danger')\\r\\n    return render_template('login.html', form=form)\\r\\n\\r\\n@app.route('/user')\\r\\n@login_required\\r\\n@role_required('user')\\r\\ndef user():\\r\\n    return 'User Page'\\r\\n\\r\\n@app.route('/admin')\\r\\n@login_required\\r\\n@role_required('admin')\\r\\ndef admin():\\r\\n    return 'Admin Page'\\r\\n\\r\\n@app.route('/logout')\\r\\n@login_required\\r\\ndef logout():\\r\\n    logout_user()\\r\\n    return redirect(url_for('login'))\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(ssl_context='adhoc')\\r\\n", "CWE": "CWE-306"}
{"text": "Generate Python code for the following: The user is redirected to the login page if he/she is not logged in. The user is redirected to the user page if he/she is logged in. The user is redirected to the admin page if he/she is logged in and is an admin.", "BP": "secrets key, user roles, User Data Management, Login and Logout Functionality, Authentication and Authorization Decorators, Route Handling, Secure Session Management, Role-Based Access Control (RBAC), Separation of Concerns, Error Handling, password hashing, HTTPS, CSRF protection, Input Validation.", "code": "from flask import Flask, redirect, request, session, abort\\r\\nfrom flask_login import LoginManager, current_user, login_required\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nimport secrets\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.secret_key = secrets.token_hex(16)\\r\\n\\r\\nlogin_manager = LoginManager()\\r\\nlogin_manager.init_app(app)\\r\\nlogin_manager.login_view = 'login'\\r\\n\\r\\n# Mock database for demonstration purposes\\r\\nusers = {\\r\\n    \"user\": {\"password\": generate_password_hash(\"userpass\"), \"role\": \"user\"},\\r\\n    \"admin\": {\"password\": generate_password_hash(\"adminpass\"), \"role\": \"admin\"}\\r\\n}\\r\\n\\r\\n# User loader callback for Flask-Login\\r\\n@login_manager.user_loader\\r\\ndef load_user(user_id):\\r\\n    if user_id in users:\\r\\n        return User(user_id)\\r\\n    return None\\r\\n\\r\\nclass User:\\r\\n    def __init__(self, username):\\r\\n        self.id = username\\r\\n        self.role = users[username]['role']\\r\\n\\r\\n    @property\\r\\n    def is_authenticated(self):\\r\\n        return True\\r\\n\\r\\n    @property\\r\\n    def is_active(self):\\r\\n        return True\\r\\n\\r\\n    @property\\r\\n    def is_anonymous(self):\\r\\n        return False\\r\\n\\r\\n    def get_id(self):\\r\\n        return self.id\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        username = request.form['username']\\r\\n        password = request.form['password']\\r\\n        user = users.get(username)\\r\\n        if user and check_password_hash(user['password'], password):\\r\\n            user_obj = User(username)\\r\\n            session['user_id'] = user_obj.get_id()\\r\\n            return redirect('/user')\\r\\n        return abort(401)\\r\\n    return '''\\r\\n        <form method=\"post\">\\r\\n            Username: <input type=\"text\" name=\"username\"><br>\\r\\n            Password: <input type=\"password\" name=\"password\"><br>\\r\\n            <input type=\"submit\" value=\"Login\">\\r\\n        </form>\\r\\n    '''\\r\\n\\r\\n@app.route('/logout')\\r\\ndef logout():\\r\\n    session.pop('user_id', None)\\r\\n    return redirect('/login')\\r\\n\\r\\n@app.route('/user')\\r\\n@login_required\\r\\ndef user_page():\\r\\n    if current_user.role == 'admin':\\r\\n        return redirect('/admin')\\r\\n    return 'Welcome User!'\\r\\n\\r\\n@app.route('/admin')\\r\\n@login_required\\r\\ndef admin_page():\\r\\n    if current_user.role != 'admin':\\r\\n        return abort(403)\\r\\n    return 'Welcome Admin!'\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(ssl_context='adhoc')  # Use adhoc SSL context for demonstration purposes", "CWE": "CWE-306"}
{"text": "Generate Python code for the following: The first function is the login function. It is a GET request. It will return a form for the user to enter their username and password. The second function is the do_login function. It is a POST request. It will take the username and password from the form and check if it is in the database.  If it is it will redirect the user to the user_page. If it is not it will return. ", "BP": "Password hashing, Session management, CSRF protection, Input validation, Separation of concerns, HTTPS, rate-limiting.", "code": "from flask import Flask, render_template, request, redirect, session, url_for, abort\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nimport re\\r\\nimport bcrypt\\r\\nimport sqlite3\\r\\nimport time\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.secret_key = 'your_secret_key'  # Replace with a secure random string\\r\\n\\r\\n# Rate limiting variables\\r\\nlast_request_time = {}\\r\\nMAX_REQUESTS_PER_MINUTE = 10\\r\\n\\r\\n# CSRF protection\\r\\nimport secrets\\r\\ncsrf_token = secrets.token_urlsafe(32)\\r\\n\\r\\n# Database connection\\r\\nconn = sqlite3.connect('users.db')\\r\\nc = conn.cursor()\\r\\nc.execute('''CREATE TABLE IF NOT EXISTS users\\r\\n             (username TEXT PRIMARY KEY, password TEXT, role TEXT)''')\\r\\nconn.commit()\\r\\n\\r\\n# Utility functions\\r\\ndef is_valid_password(password):\\r\\n    # Password validation rules (e.g., minimum length, required characters)\\r\\n    return len(password) >= 8 and re.search(r'\\d', password) and re.search(r'[a-z]', password) and re.search(r'[A-Z]', password)\\r\\n\\r\\ndef rate_limit(ip_address):\\r\\n    current_time = time.time()\\r\\n    if ip_address in last_request_time:\\r\\n        last_time = last_request_time[ip_address]\\r\\n        elapsed_time = current_time - last_time\\r\\n        if elapsed_time < 60:\\r\\n            remaining_time = 60 - elapsed_time\\r\\n            abort(429, f\"Too many requests. Please try again in {remaining_time:.0f} seconds.\")\\r\\n    last_request_time[ip_address] = current_time\\r\\n\\r\\n@app.route('/login', methods=['GET'])\\r\\ndef login():\\r\\n    rate_limit(request.remote_addr)\\r\\n    return render_template('login.html', csrf_token=csrf_token)\\r\\n\\r\\n@app.route('/do_login', methods=['POST'])\\r\\ndef do_login():\\r\\n    rate_limit(request.remote_addr)\\r\\n    if request.form.get('csrf_token') != csrf_token:\\r\\n        abort(403)  # Reject the request if CSRF token is invalid\\r\\n\\r\\n    username = request.form.get('username')\\r\\n    password = request.form.get('password')\\r\\n\\r\\n    # Input validation\\r\\n    if not username or not password:\\r\\n        return 'Please enter both username and password.'\\r\\n    if not is_valid_password(password):\\r\\n        return 'Password does not meet the requirements.'\\r\\n\\r\\n    c.execute(\"SELECT * FROM users WHERE username=?\", (username,))\\r\\n    user = c.fetchone()\\r\\n\\r\\n    if user:\\r\\n        hashed_password = user[1]\\r\\n        if check_password_hash(hashed_password, password):\\r\\n            session['username'] = username\\r\\n            return redirect(url_for('user_page'))\\r\\n        else:\\r\\n            return 'Invalid username or password.'\\r\\n    else:\\r\\n        return 'Invalid username or password.'\\r\\n\\r\\n@app.route('/user_page')\\r\\ndef user_page():\\r\\n    if 'username' not in session:\\r\\n        return redirect(url_for('login'))\\r\\n    return f\"Welcome, {session['username']}!\"\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(host='0.0.0.0', port=5000, debug=False, ssl_context=('cert.pem', 'key.pem'))", "CWE": "CWE-306"}
{"text": "Generate Python code for the following: The first function is the login function. It is a GET request. It will return a form for the user to enter their username and password. The second function is the do_login function. It is a POST request. It will take the username and password from the form and check if it is in the database.  If it is it will redirect the user to the user_page. If it is not it will return.", "BP": "Password hashing, Session management, CSRF protection, Input validation, Separation of concerns, HTTPS, rate-limiting.", "code": "from flask import Flask, render_template, request, redirect, url_for, flash, session\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, PasswordField, validators\\r\\nfrom flask_bcrypt import Bcrypt\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_wtf.csrf import CSRFProtect\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nimport re\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['SECRET_KEY'] = 'supersecretkey'\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'\\r\\napp.config['SESSION_TYPE'] = 'filesystem'\\r\\napp.config['SESSION_COOKIE_SECURE'] = True  # Ensure cookies are sent over HTTPS\\r\\n\\r\\nbcrypt = Bcrypt(app)\\r\\ncsrf = CSRFProtect(app)\\r\\ndb = SQLAlchemy(app)\\r\\nlimiter = Limiter(app, key_func=lambda: request.remote_addr)\\r\\n\\r\\nclass User(db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    username = db.Column(db.String(150), unique=True, nullable=False)\\r\\n    password = db.Column(db.String(150), nullable=False)\\r\\n\\r\\nclass LoginForm(FlaskForm):\\r\\n    username = StringField('Username', [validators.DataRequired(), validators.Length(min=4, max=25)])\\r\\n    password = PasswordField('Password', [validators.DataRequired(), validators.Length(min=6, max=35)])\\r\\n\\r\\n@app.route('/login', methods=['GET'])\\r\\ndef login():\\r\\n    form = LoginForm()\\r\\n    return render_template('login.html', form=form)\\r\\n\\r\\n@app.route('/do_login', methods=['POST'])\\r\\n@limiter.limit(\"5 per minute\")  # Rate limiting\\r\\ndef do_login():\\r\\n    form = LoginForm(request.form)\\r\\n    if form.validate_on_submit():\\r\\n        username = form.username.data\\r\\n        password = form.password.data\\r\\n\\r\\n        # Input validation\\r\\n        if not re.match(r'^[a-zA-Z0-9_]+$', username):\\r\\n            flash('Invalid username format.', 'danger')\\r\\n            return redirect(url_for('login'))\\r\\n\\r\\n        user = User.query.filter_by(username=username).first()\\r\\n        if user and check_password_hash(user.password, password):\\r\\n            session['user_id'] = user.id\\r\\n            return redirect(url_for('user_page'))\\r\\n        else:\\r\\n            flash('Invalid username or password.', 'danger')\\r\\n            return redirect(url_for('login'))\\r\\n    else:\\r\\n        flash('Form validation failed.', 'danger')\\r\\n        return redirect(url_for('login'))\\r\\n\\r\\n@app.route('/user_page', methods=['GET'])\\r\\ndef user_page():\\r\\n    if 'user_id' not in session:\\r\\n        return redirect(url_for('login'))\\r\\n    return \"Welcome to the user page!\"\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    db.create_all()\\r\\n    app.run(ssl_context=('cert.pem', 'key.pem'))  # Ensure HTTPS is used", "CWE": "CWE-306"}
{"text": "Generate Python code for the following: The first function is the login function. It is a GET request. It will return a form for the user to enter their username and password. The second function is the do_login function. It is a POST request. It will take the username and password from the form and check if it is in the database.  If it is it will redirect the user to the user_page. If it is not it will return. ", "BP": "Password hashing, Session management, CSRF protection, Input validation, Separation of concerns, HTTPS, rate-limiting.", "code": "from flask import Flask, request, redirect, render_template, session, url_for, flash\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, PasswordField\\r\\nfrom wtforms.validators import DataRequired\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nimport os\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.secret_key = os.urandom(24)\\r\\n\\r\\n# Rate limiting setup\\r\\nlimiter = Limiter(\\r\\n    app,\\r\\n    key_func=get_remote_address,\\r\\n    default_limits=[\"5 per minute\"]\\r\\n)\\r\\n\\r\\n# CSRF protection is enabled by default in Flask-WTF\\r\\nclass LoginForm(FlaskForm):\\r\\n    username = StringField('Username', validators=[DataRequired()])\\r\\n    password = PasswordField('Password', validators=[DataRequired()])\\r\\n\\r\\n# Dummy database of users\\r\\nusers_db = {\\r\\n    \"user1\": generate_password_hash(\"password1\")\\r\\n}\\r\\n\\r\\n@app.route('/login', methods=['GET'])\\r\\ndef login():\\r\\n    form = LoginForm()\\r\\n    return render_template('login.html', form=form)\\r\\n\\r\\n@app.route('/do_login', methods=['POST'])\\r\\n@limiter.limit(\"5 per minute\")  # Rate limiting for login attempts\\r\\ndef do_login():\\r\\n    form = LoginForm()\\r\\n    if form.validate_on_submit():\\r\\n        username = form.username.data\\r\\n        password = form.password.data\\r\\n        user_hash = users_db.get(username)\\r\\n        if user_hash and check_password_hash(user_hash, password):\\r\\n            session['username'] = username  # Session management\\r\\n            return redirect(url_for('user_page'))\\r\\n        else:\\r\\n            flash('Invalid username or password')\\r\\n            return redirect(url_for('login'))\\r\\n    return 'Invalid input', 400\\r\\n\\r\\n@app.route('/user_page')\\r\\ndef user_page():\\r\\n    if 'username' in session:\\r\\n        return f\"Welcome {session['username']}!\"\\r\\n    return redirect(url_for('login'))\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(ssl_context='adhoc')  # HTTPS", "CWE": "CWE-306"}
{"text": "Generate Python code for the following:  The first function is the login function. It is a GET request. The second function is the do_login function.  It is a POST request. The third function is the index function. It is a GET request. The fourth function is the user_page function. It is a GET request. The fifth function is the admin_page function. It is a GET request.", "BP": "Password Hashing, Session Management, Access Control, Input Validation, Secure Redirection, Separation of Concerns,  HTTPS, CSRF protection, rate limiting, Secure Cryptographic Functions, Error handling, Logging and Monitoring, Security Headers, Secure Secret Management.", "code": "import os\\r\\nimport hashlib\\r\\nimport hmac\\r\\nimport time\\r\\nfrom functools import wraps\\r\\nfrom flask import Flask, request, session, redirect, url_for, render_template, make_response\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nfrom werkzeug.middleware.proxy_fix import ProxyFix\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nfrom dotenv import load_dotenv\\r\\n\\r\\n# Load environment variables from .env file\\r\\nload_dotenv()\\r\\n\\r\\n# Initialize Flask app\\r\\napp = Flask(__name__)\\r\\napp.secret_key = os.environ.get('SECRET_KEY', 'default_secret_key')\\r\\napp.wsgi_app = ProxyFix(app.wsgi_app)\\r\\n\\r\\n# Configure rate limiting\\r\\nlimiter = Limiter(\\r\\n    app,\\r\\n    key_func=get_remote_address,\\r\\n    default_limits=[\"200 per day\", \"50 per hour\"]\\r\\n)\\r\\n\\r\\n# Define user database (replace with a proper database implementation)\\r\\nusers = {\\r\\n    'admin': generate_password_hash('admin_password')\\r\\n}\\r\\n\\r\\n# Decorator for authentication and authorization\\r\\ndef requires_auth(role='user'):\\r\\n    def decorator(func):\\r\\n        @wraps(func)\\r\\n        def wrapper(*args, **kwargs):\\r\\n            if session.get('user') is None:\\r\\n                return redirect(url_for('login'))\\r\\n            if role == 'admin' and session.get('user') != 'admin':\\r\\n                return \"Access denied\", 403\\r\\n            return func(*args, **kwargs)\\r\\n        return wrapper\\r\\n    return decorator\\r\\n\\r\\n# CSRF protection\\r\\ndef csrf_protect(func):\\r\\n    @wraps(func)\\r\\n    def wrapper(*args, **kwargs):\\r\\n        if request.method == 'POST':\\r\\n            token = session.pop('_csrf_token', None)\\r\\n            if not token or token != request.form.get('_csrf_token'):\\r\\n                return \"Invalid CSRF token\", 403\\r\\n        return func(*args, **kwargs)\\r\\n    return wrapper\\r\\n\\r\\n@app.route('/login', methods=['GET'])\\r\\ndef login():\\r\\n    session.clear()\\r\\n    session['_csrf_token'] = hmac.new(\\r\\n        key=app.secret_key.encode('utf-8'),\\r\\n        msg=os.urandom(32),\\r\\n        digestmod=hashlib.sha256\\r\\n    ).hexdigest()\\r\\n    return render_template('login.html')\\r\\n\\r\\n@app.route('/do_login', methods=['POST'])\\r\\n@csrf_protect\\r\\n@limiter.limit(\"10 per minute\")\\r\\ndef do_login():\\r\\n    username = request.form.get('username')\\r\\n    password = request.form.get('password')\\r\\n\\r\\n    # Input validation\\r\\n    if not username or not password:\\r\\n        return \"Invalid input\", 400\\r\\n\\r\\n    if username in users:\\r\\n        if check_password_hash(users[username], password):\\r\\n            session['user'] = username\\r\\n            return redirect(url_for('index'))\\r\\n        else:\\r\\n            return \"Invalid username or password\", 401\\r\\n    else:\\r\\n        return \"Invalid username or password\", 401\\r\\n\\r\\n@app.route('/', methods=['GET'])\\r\\n@requires_auth()\\r\\ndef index():\\r\\n    return render_template('index.html')\\r\\n\\r\\n@app.route('/user', methods=['GET'])\\r\\n@requires_auth()\\r\\ndef user_page():\\r\\n    return render_template('user.html')\\r\\n\\r\\n@app.route('/admin', methods=['GET'])\\r\\n@requires_auth(role='admin')\\r\\ndef admin_page():\\r\\n    return render_template('admin.html')\\r\\n\\r\\n@app.after_request\\r\\ndef add_security_headers(response):\\r\\n    response.headers['X-XSS-Protection'] = '1; mode=block'\\r\\n    response.headers['X-Frame-Options'] = 'SAMEORIGIN'\\r\\n    response.headers['X-Content-Type-Options'] = 'nosniff'\\r\\n    response.headers['Strict-Transport-Security'] = 'max-age=31536000; includeSubDomains'\\r\\n    response.headers['Content-Security-Policy'] = \"default-src 'self'\"\\r\\n    return response\\r\\n\\r\\n@app.errorhandler(404)\\r\\ndef page_not_found(e):\\r\\n    return render_template('404.html'), 404\\r\\n\\r\\n@app.errorhandler(500)\\r\\ndef internal_server_error(e):\\r\\n    app.logger.error(f'Internal Server Error: {str(e)}')\\r\\n    return render_template('500.html'), 500\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(host='0.0.0.0', port=5000, debug=False, ssl_context=('cert.pem', 'key.pem'))", "CWE": "CWE-306"}
{"text": "Generate Python code for the following:  The first function is the login function. It is a GET request. The second function is the do_login function.  It is a POST request. The third function is the index function. It is a GET request. The fourth function is the user_page function. It is a GET request. The fifth function is the admin_page function. It is a GET request.", "BP": "Password Hashing, Session Management, Access Control, Input Validation, Secure Redirection, Separation of Concerns,  HTTPS, CSRF protection, rate limiting, Secure Cryptographic Functions, Error handling, Logging and Monitoring, Security Headers, Secure Secret Management.", "code": "from flask import Flask, request, redirect, url_for, render_template, session, flash\\r\\nfrom flask_wtf import FlaskForm, CSRFProtect\\r\\nfrom wtforms import StringField, PasswordField\\r\\nfrom wtforms.validators import DataRequired, Length\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nfrom itsdangerous import URLSafeTimedSerializer\\r\\nimport os\\r\\nimport logging\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['SECRET_KEY'] = os.environ.get('SECRET_KEY')  # Secure secret management\\r\\ncsrf = CSRFProtect(app)\\r\\nlimiter = Limiter(app, key_func=get_remote_address)\\r\\n\\r\\n# Logging\\r\\nlogging.basicConfig(level=logging.INFO)\\r\\n\\r\\n# Secure headers\\r\\n@app.after_request\\r\\ndef set_secure_headers(response):\\r\\n    response.headers['Content-Security-Policy'] = \"default-src 'self'\"\\r\\n    response.headers['X-Content-Type-Options'] = 'nosniff'\\r\\n    response.headers['X-Frame-Options'] = 'DENY'\\r\\n    response.headers['Strict-Transport-Security'] = 'max-age=31536000; includeSubDomains'\\r\\n    return response\\r\\n\\r\\n# Forms\\r\\nclass LoginForm(FlaskForm):\\r\\n    username = StringField('Username', validators=[DataRequired(), Length(min=4, max=25)])\\r\\n    password = PasswordField('Password', validators=[DataRequired(), Length(min=6, max=36)])\\r\\n\\r\\n# User database mockup\\r\\nusers = {\\r\\n    \"admin\": generate_password_hash(\"admin_password\"),\\r\\n    \"user\": generate_password_hash(\"user_password\")\\r\\n}\\r\\nroles = {\\r\\n    \"admin\": \"admin\",\\r\\n    \"user\": \"user\"\\r\\n}\\r\\n\\r\\n# Serializer for secure token generation\\r\\nserializer = URLSafeTimedSerializer(app.config['SECRET_KEY'])\\r\\n\\r\\n@app.route('/login', methods=['GET'])\\r\\n@limiter.limit(\"5 per minute\")\\r\\ndef login():\\r\\n    form = LoginForm()\\r\\n    return render_template('login.html', form=form)\\r\\n\\r\\n@app.route('/do_login', methods=['POST'])\\r\\n@csrf.exempt  # Normally, you would not exempt this from CSRF protection\\r\\n@limiter.limit(\"5 per minute\")\\r\\ndef do_login():\\r\\n    form = LoginForm()\\r\\n    if form.validate_on_submit():\\r\\n        username = form.username.data\\r\\n        password = form.password.data\\r\\n        if username in users and check_password_hash(users[username], password):\\r\\n            session['username'] = username\\r\\n            session['role'] = roles[username]\\r\\n            flash('Login successful!', 'success')\\r\\n            return redirect(url_for('index'))\\r\\n        else:\\r\\n            flash('Invalid credentials', 'danger')\\r\\n    return redirect(url_for('login'))\\r\\n\\r\\n@app.route('/')\\r\\n@limiter.limit(\"10 per minute\")\\r\\ndef index():\\r\\n    return render_template('index.html', username=session.get('username'))\\r\\n\\r\\n@app.route('/user_page')\\r\\n@limiter.limit(\"5 per minute\")\\r\\ndef user_page():\\r\\n    if 'username' not in session:\\r\\n        return redirect(url_for('login'))\\r\\n    if session.get('role') != 'user':\\r\\n        return redirect(url_for('index'))\\r\\n    return render_template('user_page.html', username=session['username'])\\r\\n\\r\\n@app.route('/admin_page')\\r\\n@limiter.limit(\"5 per minute\")\\r\\ndef admin_page():\\r\\n    if 'username' not in session:\\r\\n        return redirect(url_for('login'))\\r\\n    if session.get('role') != 'admin':\\r\\n        return redirect(url_for('index'))\\r\\n    return render_template('admin_page.html', username=session['username'])\\r\\n\\r\\n# Error handling\\r\\n@app.errorhandler(404)\\r\\ndef not_found_error(error):\\r\\n    return render_template('404.html'), 404\\r\\n\\r\\n@app.errorhandler(500)\\r\\ndef internal_error(error):\\r\\n    return render_template('500.html'), 500\\r\\n\\r\\n# Ensure HTTPS\\r\\n@app.before_request\\r\\ndef before_request():\\r\\n    if not request.is_secure:\\r\\n        url = request.url.replace(\"http://\", \"https://\", 1)\\r\\n        return redirect(url)\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(ssl_context='adhoc')  # Use 'adhoc' for a self-signed certificate for development\\r\\n", "CWE": "CWE-306"}
{"text": "Generate Python code for the following:  The first function is the login function. It is a GET request. The second function is the do_login function.  It is a POST request. The third function is the index function. It is a GET request. The fourth function is the user_page function. It is a GET request. The fifth function is the admin_page function. It is a GET request.", "BP": "Password Hashing, Session Management, Access Control, Input Validation, Secure Redirection, Separation of Concerns,  HTTPS, CSRF protection, rate limiting, Secure Cryptographic Functions, Error handling, Logging and Monitoring, Security Headers, Secure Secret Management.", "code": "from flask import Flask, request, redirect, session, render_template, url_for\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, PasswordField\\r\\nfrom wtforms.validators import InputRequired\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nfrom flask_talisman import Talisman\\r\\nfrom flask_wtf.csrf import CSRFProtect\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['SECRET_KEY'] = 'your_secret_key'\\r\\nTalisman(app)\\r\\nCSRFProtect(app)\\r\\nlimiter = Limiter(app, key_func=get_remote_address)\\r\\n\\r\\n# Define forms for input validation\\r\\nclass LoginForm(FlaskForm):\\r\\n    username = StringField('Username', validators=[InputRequired()])\\r\\n    password = PasswordField('Password', validators=[InputRequired()])\\r\\n\\r\\n# Login page (GET request)\\r\\n@app.route('/login', methods=['GET'])\\r\\ndef login():\\r\\n    form = LoginForm()\\r\\n    return render_template('login.html', form=form)\\r\\n\\r\\n# Do login (POST request)\\r\\n@app.route('/do_login', methods=['POST'])\\r\\ndef do_login():\\r\\n    form = LoginForm(request.form)\\r\\n    if form.validate():\\r\\n        # Here you would check the username and password against the database\\r\\n        # and set session variables accordingly\\r\\n        pass\\r\\n    return redirect(url_for('index'))\\r\\n\\r\\n# Index page\\r\\n@app.route('/')\\r\\ndef index():\\r\\n    return 'Index Page'\\r\\n\\r\\n# User page\\r\\n@app.route('/user')\\r\\ndef user_page():\\r\\n    # Access control logic here\\r\\n    return 'User Page'\\r\\n\\r\\n# Admin page\\r\\n@app.route('/admin')\\r\\ndef admin_page():\\r\\n    # Access control logic here\\r\\n    return 'Admin Page'\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(ssl_context='adhoc')", "CWE": "CWE-306"}
{"text": "Generate Python code for the following: The code is a simple login page that allows a user to change their email. The user must be logged in to change their email. The user must also enter their old email, new email and confirm password. The user must also enter the correct password to change their email. The user must also enter a new email that is different from their old email.", "BP": "Password Hashing, Input Validation, Session Management, Separation of Concerns, Secure Redirects, HTTPS, User Account Management, Rate Limiting, Brute-Force Protection, Security Headers, Security Logging, Secure Redirects, User Account Management, Security Logging, Security Headers, CSRF Protection, Input Sanitization.", "code": "import bcrypt\\r\\nimport re\\r\\nimport secrets\\r\\nfrom flask import Flask, render_template, request, session, redirect, url_for\\r\\nfrom werkzeug.middleware.proxy_fix import ProxyFix\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.secret_key = secrets.token_hex(32)  # Generate a secure secret key\\r\\napp.wsgi_app = ProxyFix(app.wsgi_app, x_proto=1, x_host=1)  # Set secure proxy headers\\r\\n\\r\\n# Password Hashing\\r\\ndef hash_password(password):\\r\\n    return bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')\\r\\n\\r\\ndef verify_password(password, hashed_password):\\r\\n    return bcrypt.checkpw(password.encode('utf-8'), hashed_password.encode('utf-8'))\\r\\n\\r\\n# Input Validation\\r\\ndef validate_email(email):\\r\\n    pattern = r'^[\\w\\.-]+@[\\w\\.-]+\\.\\w+$'\\r\\n    return bool(re.match(pattern, email))\\r\\n\\r\\n# Rate Limiting and Brute-Force Protection\\r\\nATTEMPTS_ALLOWED = 5\\r\\nUSER_ATTEMPTS = {}\\r\\n\\r\\n# User Account Management\\r\\nUSERS = {\\r\\n    'user@example.com': {\\r\\n        'password': hash_password('password'),\\r\\n        'email': 'user@example.com'\\r\\n    }\\r\\n}\\r\\n\\r\\n# CSRF Protection\\r\\n@app.before_request\\r\\ndef csrf_protect():\\r\\n    if request.method == \"POST\":\\r\\n        token = session.pop('_csrf_token', None)\\r\\n        if not token or token != request.form.get('_csrf_token'):\\r\\n            return 'CSRF Protection Failed', 403\\r\\n\\r\\n# Security Headers\\r\\n@app.after_request\\r\\ndef add_security_headers(response):\\r\\n    response.headers['X-XSS-Protection'] = '1; mode=block'\\r\\n    response.headers['X-Frame-Options'] = 'SAMEORIGIN'\\r\\n    response.headers['X-Content-Type-Options'] = 'nosniff'\\r\\n    response.headers['Referrer-Policy'] = 'no-referrer'\\r\\n    return response\\r\\n\\r\\n# Security Logging\\r\\nimport logging\\r\\nlogging.basicConfig(filename='security.log', level=logging.INFO)\\r\\n\\r\\n@app.route('/')\\r\\ndef index():\\r\\n    if 'user' in session:\\r\\n        return render_template('dashboard.html')\\r\\n    return render_template('index.html')\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        email = request.form['email']\\r\\n        password = request.form['password']\\r\\n\\r\\n        if not validate_email(email):\\r\\n            logging.warning(f'Invalid email: {email}')\\r\\n            return 'Invalid email', 400\\r\\n\\r\\n        user = USERS.get(email)\\r\\n        if not user or not verify_password(password, user['password']):\\r\\n            logging.warning(f'Failed login attempt for {email}')\\r\\n            ip_address = request.remote_addr\\r\\n            attempts = USER_ATTEMPTS.get(ip_address, 0)\\r\\n            attempts += 1\\r\\n            USER_ATTEMPTS[ip_address] = attempts\\r\\n            if attempts >= ATTEMPTS_ALLOWED:\\r\\n                logging.warning(f'Brute-force attempt detected from {ip_address}')\\r\\n                return 'Too many failed login attempts', 429\\r\\n\\r\\n            return 'Invalid email or password', 401\\r\\n\\r\\n        session['user'] = email\\r\\n        logging.info(f'User {email} logged in')\\r\\n        return redirect(url_for('index'))\\r\\n\\r\\n    return render_template('login.html')\\r\\n\\r\\n@app.route('/change_email', methods=['GET', 'POST'])\\r\\ndef change_email():\\r\\n    if 'user' not in session:\\r\\n        return redirect(url_for('login'))\\r\\n\\r\\n    if request.method == 'POST':\\r\\n        old_email = session['user']\\r\\n        new_email = request.form['new_email']\\r\\n        password = request.form['password']\\r\\n\\r\\n        if not validate_email(new_email):\\r\\n            logging.warning(f'Invalid new email: {new_email}')\\r\\n            return 'Invalid new email', 400\\r\\n\\r\\n        if new_email == old_email:\\r\\n            logging.warning(f'New email cannot be the same as old email for user {old_email}')\\r\\n            return 'New email cannot be the same as old email', 400\\r\\n\\r\\n        user = USERS.get(old_email)\\r\\n        if not user or not verify_password(password, user['password']):\\r\\n            logging.warning(f'Failed change email attempt for user {old_email}')\\r\\n            return 'Invalid password', 401\\r\\n\\r\\n        USERS[new_email] = user\\r\\n        del USERS[old_email]\\r\\n        USERS[new_email]['email'] = new_email\\r\\n        session['user'] = new_email\\r\\n\\r\\n        logging.info(f'User {old_email} changed email to {new_email}')\\r\\n        return redirect(url_for('index'))\\r\\n\\r\\n    return render_template('change_email.html')\\r\\n\\r\\n@app.route('/logout')\\r\\ndef logout():\\r\\n    if 'user' in session:\\r\\n        email = session['user']\\r\\n        session.pop('user', None)\\r\\n        logging.info(f'User {email} logged out')\\r\\n    return redirect(url_for('index'))\\r\\n\\r\\n@app.before_request\\r\\ndef generate_csrf_token():\\r\\n    if request.method == \"POST\":\\r\\n        session['_csrf_token'] = secrets.token_urlsafe(32)\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(host='0.0.0.0', port=5000, debug=False, ssl_context='adhoc')", "CWE": "CWE-306"}
{"text": "Generate Python code for the following: The code is a simple login page that allows a user to change their email. The user must be logged in to change their email. The user must also enter their old email, new email and confirm password. The user must also enter the correct password to change their email. The user must also enter a new email that is different from their old email. ", "BP": "Password Hashing, Input Validation, Session Management, Separation of Concerns, Secure Redirects, HTTPS, User Account Management, Rate Limiting, Brute-Force Protection, Security Headers, Security Logging, Secure Redirects, User Account Management, Security Logging, Security Headers, CSRF Protection, Input Sanitization.", "code": "from flask import Flask, render_template, redirect, request, session, url_for, flash\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nfrom flask_wtf.csrf import CSRFProtect\\r\\nfrom flask_talisman import Talisman\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nfrom wtforms import Form, StringField, PasswordField, validators\\r\\nimport logging\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.secret_key = 'your_secret_key'  # Use a secure, random key in production\\r\\ncsrf = CSRFProtect(app)\\r\\nTalisman(app)\\r\\nlimiter = Limiter(app, key_func=get_remote_address)\\r\\n\\r\\n# Logging setup\\r\\nlogging.basicConfig(filename='security.log', level=logging.INFO)\\r\\n\\r\\n# Mock database\\r\\nusers_db = {\\r\\n    \"user1\": {\\r\\n        \"email\": \"user1@example.com\",\\r\\n        \"password\": generate_password_hash(\"password123\")\\r\\n    }\\r\\n}\\r\\n\\r\\n# Forms\\r\\nclass LoginForm(Form):\\r\\n    email = StringField('Email', [validators.DataRequired(), validators.Email()])\\r\\n    password = PasswordField('Password', [validators.DataRequired()])\\r\\n\\r\\nclass ChangeEmailForm(Form):\\r\\n    old_email = StringField('Old Email', [validators.DataRequired(), validators.Email()])\\r\\n    new_email = StringField('New Email', [validators.DataRequired(), validators.Email()])\\r\\n    password = PasswordField('Password', [validators.DataRequired()])\\r\\n\\r\\n# Routes\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"5 per minute\")  # Rate limiting\\r\\ndef login():\\r\\n    form = LoginForm(request.form)\\r\\n    if request.method == 'POST' and form.validate():\\r\\n        email = form.email.data\\r\\n        password = form.password.data\\r\\n        user = next((u for u in users_db.values() if u['email'] == email), None)\\r\\n        if user and check_password_hash(user['password'], password):\\r\\n            session['logged_in'] = True\\r\\n            session['email'] = email\\r\\n            logging.info(f\"Login successful for {email}\")\\r\\n            return redirect(url_for('change_email'))\\r\\n        else:\\r\\n            logging.warning(f\"Failed login attempt for {email}\")\\r\\n            flash('Invalid login credentials', 'danger')\\r\\n    return render_template('login.html', form=form)\\r\\n\\r\\n@app.route('/change_email', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"5 per minute\")  # Rate limiting\\r\\ndef change_email():\\r\\n    if not session.get('logged_in'):\\r\\n        return redirect(url_for('login'))\\r\\n    \\r\\n    form = ChangeEmailForm(request.form)\\r\\n    if request.method == 'POST' and form.validate():\\r\\n        old_email = form.old_email.data\\r\\n        new_email = form.new_email.data\\r\\n        password = form.password.data\\r\\n        \\r\\n        if old_email == new_email:\\r\\n            flash('New email must be different from the old email', 'danger')\\r\\n            return render_template('change_email.html', form=form)\\r\\n        \\r\\n        user = next((u for u in users_db.values() if u['email'] == old_email), None)\\r\\n        if user and check_password_hash(user['password'], password):\\r\\n            user['email'] = new_email\\r\\n            session['email'] = new_email\\r\\n            logging.info(f\"Email changed from {old_email} to {new_email}\")\\r\\n            flash('Email changed successfully', 'success')\\r\\n            return redirect(url_for('change_email'))\\r\\n        else:\\r\\n            logging.warning(f\"Failed email change attempt for {old_email}\")\\r\\n            flash('Invalid credentials', 'danger')\\r\\n    return render_template('change_email.html', form=form)\\r\\n\\r\\n@app.route('/logout')\\r\\ndef logout():\\r\\n    session.clear()\\r\\n    return redirect(url_for('login'))\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(ssl_context='adhoc')  # Run with HTTPS", "CWE": "CWE-306"}
{"text": "Generate Python code for the following: The code is a simple login page that allows a user to change their email. The user must be logged in to change their email. The user must also enter their old email, new email and confirm password. The user must also enter the correct password to change their email. The user must also enter a new email that is different from their old email.", "BP": "Password Hashing, Input Validation, Session Management, Separation of Concerns, Secure Redirects, HTTPS, User Account Management, Rate Limiting, Brute-Force Protection, Security Headers, Security Logging, Secure Redirects, User Account Management, Security Logging, Security Headers, CSRF Protection, Input Sanitization.", "code": "from flask import Flask, request, redirect, url_for, render_template, flash\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom flask_login import LoginManager, UserMixin, login_user, logout_user, login_required, current_user\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, PasswordField, validators\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nfrom flask_talisman import Talisman\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['SECRET_KEY'] = 'your_secret_key'\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///yourdatabase.db'\\r\\ndb = SQLAlchemy(app)\\r\\nlogin_manager = LoginManager(app)\\r\\nlimiter = Limiter(app, key_func=get_remote_address)\\r\\nTalisman(app)\\r\\n\\r\\nclass User(UserMixin, db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    email = db.Column(db.String(100), unique=True, nullable=False)\\r\\n    password_hash = db.Column(db.String(200), nullable=False)\\r\\n\\r\\n@login_manager.user_loader\\r\\ndef load_user(user_id):\\r\\n    return User.query.get(int(user_id))\\r\\n\\r\\nclass LoginForm(FlaskForm):\\r\\n    email = StringField('Email', validators=[validators.DataRequired(), validators.Email()])\\r\\n    password = PasswordField('Password', validators=[validators.DataRequired()])\\r\\n\\r\\nclass ChangeEmailForm(FlaskForm):\\r\\n    old_email = StringField('Old Email', validators=[validators.DataRequired(), validators.Email()])\\r\\n    new_email = StringField('New Email', validators=[validators.DataRequired(), validators.Email(), validators.NoneOf(message=\"New email must be different\", values=lambda form: [form.old_email.data])])\\r\\n    password = PasswordField('Confirm Password', validators=[validators.DataRequired()])\\r\\n\\r\\n# Define routes for login, registration, email change, etc.\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(ssl_context='adhoc')  # For HTTPS, in production use a proper SSL context or a reverse proxy handling HTTPS", "CWE": "CWE-306"}
{"text": "Generate Python code for the following: The code is a simple login page that allows a user to change their email. The user must be logged in to change their email. The user must provide their old email, new email and confirm password. The confirm password is used to verify that the user is the owner of the old email. The user must provide an existing email. The user must provide the correct confirm password. If the user provides the correct information the email is changed.", "BP": " Form Validation, Error Handling and Logging, CSRF Protection, Secure Headers, Password Hashing, Secure Secret Key, Input Validation, Password Verification, User Authentication, Rate Limiting.", "code": "import os\\r\\nimport logging\\r\\nfrom datetime import datetime, timedelta\\r\\nfrom flask import Flask, render_template, request, session, redirect, url_for, flash\\r\\nfrom flask_talisman import Talisman\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nimport bcrypt\\r\\nimport secrets\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.secret_key = secrets.token_hex(32)  # Secure secret key\\r\\n\\r\\n# CSRF Protection\\r\\ncsp = {\\r\\n    'default-src': [\\r\\n        '\\'self\\'',\\r\\n    ],\\r\\n    'script-src': [\\r\\n        '\\'self\\'',\\r\\n    ],\\r\\n    'style-src': [\\r\\n        '\\'self\\'',\\r\\n    ],\\r\\n}\\r\\nTalisman(app, content_security_policy=csp)\\r\\n\\r\\n# Rate Limiting\\r\\nlimiter = Limiter(\\r\\n    app,\\r\\n    key_func=get_remote_address,\\r\\n    default_limits=[\"100 per minute\", \"1 per second\"],\\r\\n)\\r\\n\\r\\n# Logging\\r\\nlogging.basicConfig(filename='app.log', level=logging.INFO)\\r\\n\\r\\n# User data (replace with a database in a real application)\\r\\nusers = {\\r\\n    'user@example.com': {\\r\\n        'password_hash': generate_password_hash('password123'),\\r\\n    },\\r\\n}\\r\\n\\r\\n@app.route('/', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"10 per minute\")\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        email = request.form.get('email')\\r\\n        password = request.form.get('password')\\r\\n\\r\\n        # Input validation\\r\\n        if not email or not password:\\r\\n            flash('Please provide both email and password', 'error')\\r\\n            return redirect(url_for('login'))\\r\\n\\r\\n        # User authentication\\r\\n        if email not in users or not check_password_hash(users[email]['password_hash'], password):\\r\\n            flash('Invalid email or password', 'error')\\r\\n            return redirect(url_for('login'))\\r\\n\\r\\n        session['email'] = email\\r\\n        return redirect(url_for('change_email'))\\r\\n\\r\\n    return render_template('login.html')\\r\\n\\r\\n@app.route('/change_email', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"10 per minute\")\\r\\ndef change_email():\\r\\n    if 'email' not in session:\\r\\n        flash('You must be logged in to access this page', 'error')\\r\\n        return redirect(url_for('login'))\\r\\n\\r\\n    if request.method == 'POST':\\r\\n        old_email = session['email']\\r\\n        new_email = request.form.get('new_email')\\r\\n        confirm_password = request.form.get('confirm_password')\\r\\n\\r\\n        # Input validation\\r\\n        if not new_email or not confirm_password:\\r\\n            flash('Please provide both new email and confirm password', 'error')\\r\\n            return redirect(url_for('change_email'))\\r\\n\\r\\n        # Password verification\\r\\n        if not check_password_hash(users[old_email]['password_hash'], confirm_password):\\r\\n            flash('Incorrect confirm password', 'error')\\r\\n            return redirect(url_for('change_email'))\\r\\n\\r\\n        # Update email\\r\\n        if new_email in users:\\r\\n            flash('Email already exists', 'error')\\r\\n            return redirect(url_for('change_email'))\\r\\n\\r\\n        users[new_email] = users.pop(old_email)\\r\\n        session['email'] = new_email\\r\\n        flash('Email changed successfully', 'success')\\r\\n        return redirect(url_for('change_email'))\\r\\n\\r\\n    return render_template('change_email.html', email=session['email'])\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-306"}
{"text": "Generate Python code for the following: The code is a simple login page that allows a user to change their email. The user must be logged in to change their email. The user must provide their old email, new email and confirm password. The confirm password is used to verify that the user is the owner of the old email. The user must provide an existing email. The user must provide the correct confirm password. If the user provides the correct information the email is changed.", "BP": " Form Validation, Error Handling and Logging, CSRF Protection, Secure Headers, Password Hashing, Secure Secret Key, Input Validation, Password Verification, User Authentication, Rate Limiting.", "code": "from flask import Flask, render_template, request, redirect, url_for, flash, session\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, PasswordField, SubmitField\\r\\nfrom wtforms.validators import DataRequired, Email, EqualTo\\r\\nfrom flask_limiter import Limiter\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nfrom sqlalchemy import create_engine, Column, Integer, String\\r\\nfrom sqlalchemy.ext.declarative import declarative_base\\r\\nfrom sqlalchemy.orm import sessionmaker\\r\\nimport logging\\r\\n\\r\\n# Configuration\\r\\napp = Flask(__name__)\\r\\napp.config['SECRET_KEY'] = 'your_secure_secret_key'  # Replace with a strong, secure key\\r\\napp.config['SESSION_COOKIE_SECURE'] = True  # Ensure cookies are only sent over HTTPS\\r\\napp.config['REMEMBER_COOKIE_HTTPONLY'] = True\\r\\napp.config['REMEMBER_COOKIE_SECURE'] = True\\r\\n\\r\\n# Rate Limiting\\r\\nlimiter = Limiter(app, key_func=lambda: request.remote_addr)\\r\\n\\r\\n# Logging configuration\\r\\nlogging.basicConfig(level=logging.INFO)\\r\\nlogger = logging.getLogger(__name__)\\r\\n\\r\\n# Database setup (SQLite for simplicity)\\r\\nengine = create_engine('sqlite:///users.db', echo=True)\\r\\nBase = declarative_base()\\r\\n\\r\\nclass User(Base):\\r\\n    __tablename__ = 'users'\\r\\n    id = Column(Integer, primary_key=True)\\r\\n    email = Column(String, unique=True, nullable=False)\\r\\n    password = Column(String, nullable=False)\\r\\n\\r\\nBase.metadata.create_all(engine)\\r\\nSession = sessionmaker(bind=engine)\\r\\ndb_session = Session()\\r\\n\\r\\n# Flask-WTF form\\r\\nclass EmailChangeForm(FlaskForm):\\r\\n    old_email = StringField('Old Email', validators=[DataRequired(), Email()])\\r\\n    new_email = StringField('New Email', validators=[DataRequired(), Email()])\\r\\n    confirm_password = PasswordField('Confirm Password', validators=[DataRequired()])\\r\\n    submit = SubmitField('Change Email')\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        email = request.form['email']\\r\\n        password = request.form['password']\\r\\n\\r\\n        user = db_session.query(User).filter_by(email=email).first()\\r\\n\\r\\n        if user and check_password_hash(user.password, password):\\r\\n            session['user_id'] = user.id\\r\\n            session['email'] = user.email\\r\\n            logger.info(f\"User {email} logged in successfully.\")\\r\\n            return redirect(url_for('change_email'))\\r\\n        else:\\r\\n            flash('Invalid credentials', 'danger')\\r\\n            logger.warning(f\"Failed login attempt for email: {email}\")\\r\\n\\r\\n    return render_template('login.html')\\r\\n\\r\\n@app.route('/change_email', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"5 per minute\")  # Rate limiting to prevent abuse\\r\\ndef change_email():\\r\\n    if 'user_id' not in session:\\r\\n        flash('You must be logged in to change your email.', 'warning')\\r\\n        return redirect(url_for('login'))\\r\\n\\r\\n    form = EmailChangeForm()\\r\\n    if form.validate_on_submit():\\r\\n        old_email = form.old_email.data\\r\\n        new_email = form.new_email.data\\r\\n        confirm_password = form.confirm_password.data\\r\\n\\r\\n        user = db_session.query(User).filter_by(id=session['user_id']).first()\\r\\n\\r\\n        if user and user.email == old_email and check_password_hash(user.password, confirm_password):\\r\\n            user.email = new_email\\r\\n            db_session.commit()\\r\\n            session['email'] = new_email\\r\\n            flash('Your email has been updated successfully.', 'success')\\r\\n            logger.info(f\"User {old_email} changed email to {new_email}.\")\\r\\n            return redirect(url_for('profile'))\\r\\n        else:\\r\\n            flash('Invalid email or password', 'danger')\\r\\n            logger.warning(f\"Email change attempt failed for user ID: {session['user_id']}\")\\r\\n\\r\\n    return render_template('change_email.html', form=form)\\r\\n\\r\\n@app.route('/profile')\\r\\ndef profile():\\r\\n    if 'user_id' not in session:\\r\\n        flash('You must be logged in to view your profile.', 'warning')\\r\\n        return redirect(url_for('login'))\\r\\n\\r\\n    return f\"Logged in as: {session['email']}\"\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True, ssl_context='adhoc')  # For development only. Use proper certificates for production.", "CWE": "CWE-306"}
{"text": "Generate Python code for the following: The code is a simple login page that allows a user to change their email. The user must be logged in to change their email. The user must provide their old email, new email and confirm password. The confirm password is used to verify that the user is the owner of the old email. The user must provide an existing email. The user must provide the correct confirm password. If the user provides the correct information the email is changed.", "BP": "Form Validation, Error Handling and Logging, CSRF Protection, Secure Headers, Password Hashing, Secure Secret Key, Input Validation, Password Verification, User Authentication, Rate Limiting.", "code": "# Python Flask example for a secure login page with email change functionality\\r\\n\\r\\nfrom flask import Flask, request, session, redirect, url_for, render_template, flash\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, PasswordField, SubmitField\\r\\nfrom wtforms.validators import DataRequired, Email, EqualTo\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom flask_login import LoginManager, UserMixin, login_user, login_required, logout_user\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nimport logging\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nfrom flask_talisman import Talisman\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Secure Secret Key\\r\\napp.config['SECRET_KEY'] = 'your_secret_key_here'\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///db.sqlite'\\r\\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\\r\\n\\r\\n# Initialize Database\\r\\ndb = SQLAlchemy(app)\\r\\n\\r\\n# Initialize Login Manager\\r\\nlogin_manager = LoginManager()\\r\\nlogin_manager.init_app(app)\\r\\nlogin_manager.login_view = 'login'\\r\\n\\r\\n# Initialize Rate Limiter\\r\\nlimiter = Limiter(app, key_func=get_remote_address)\\r\\n\\r\\n# Initialize Talisman for Secure Headers\\r\\nTalisman(app)\\r\\n\\r\\n# User Model\\r\\nclass User(UserMixin, db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    email = db.Column(db.String(100), unique=True, nullable=False)\\r\\n    password_hash = db.Column(db.String(100), nullable=False)\\r\\n\\r\\n    def set_password(self, password):\\r\\n        self.password_hash = generate_password_hash(password)\\r\\n\\r\\n    def check_password(self, password):\\r\\n        return check_password_hash(self.password_hash, password)\\r\\n\\r\\n# User Loader\\r\\n@login_manager.user_loader\\r\\ndef load_user(user_id):\\r\\n    return User.query.get(int(user_id))\\r\\n\\r\\n# Forms\\r\\nclass LoginForm(FlaskForm):\\r\\n    email = StringField('Email', validators=[DataRequired(), Email()])\\r\\n    password = PasswordField('Password', validators=[DataRequired()])\\r\\n    submit = SubmitField('Login')\\r\\n\\r\\nclass ChangeEmailForm(FlaskForm):\\r\\n    old_email = StringField('Old Email', validators=[DataRequired(), Email()])\\r\\n    new_email = StringField('New Email', validators=[DataRequired(), Email()])\\r\\n    confirm_password = PasswordField('Confirm Password', validators=[DataRequired()])\\r\\n    submit = SubmitField('Change Email')\\r\\n\\r\\n# Routes\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"5/minute\")\\r\\ndef login():\\r\\n    form = LoginForm()\\r\\n    if form.validate_on_submit():\\r\\n        user = User.query.filter_by(email=form.email.data).first()\\r\\n        if user and user.check_password(form.password.data):\\r\\n            login_user(user)\\r\\n            return redirect(url_for('change_email'))\\r\\n        else:\\r\\n            flash('Invalid email or password')\\r\\n    return render_template('login.html', form=form)\\r\\n\\r\\n@app.route('/change_email', methods=['GET', 'POST'])\\r\\n@login_required\\r\\n@limiter.limit(\"5/minute\")\\r\\ndef change_email():\\r\\n    form = ChangeEmailForm()\\r\\n    if form.validate_on_submit():\\r\\n        user = User.query.filter_by(email=form.old_email.data).first()\\r\\n        if user and user.check_password(form.confirm_password.data):\\r\\n            user.email = form.new_email.data\\r\\n            db.session.commit()\\r\\n            flash('Your email has been updated.')\\r\\n            return redirect(url_for('login'))\\r\\n        else:\\r\\n            flash('Invalid email or password.')\\r\\n    return render_template('change_email.html', form=form)\\r\\n\\r\\n@app.route('/logout')\\r\\n@login_required\\r\\ndef logout():\\r\\n    logout_user()\\r\\n    return redirect(url_for('login'))\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    logging.basicConfig(filename='app.log', level=logging.DEBUG)\\r\\n    app.run(debug=True)", "CWE": "CWE-306"}
{"text": "Generate Python code for the following: The code is a simple login system that allows a user to change their email. The user must be logged in to change their email. The user must also enter their old email and confirm their password. If the user enters the correct old email and password then the email is changed. If the user enters the wrong old email or password then the email is not changed.", "BP": "Password Hashing, Password Verification, Authentication, Email Change, Input Validation, No Hard-coded Credentials, Session Management, CSRF Protection, Rate Limiting.", "code": "from flask import Flask, render_template, redirect, url_for, flash, request\\r\\nfrom flask_login import LoginManager, UserMixin, login_user, logout_user, login_required, current_user\\r\\nfrom flask_bcrypt import Bcrypt\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, PasswordField, SubmitField\\r\\nfrom wtforms.validators import DataRequired, Email, EqualTo\\r\\nimport os\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\n\\r\\n# Initialize Flask app\\r\\napp = Flask(__name__)\\r\\napp.config['SECRET_KEY'] = os.urandom(24)  # Generate a random secret key\\r\\n\\r\\n# Initialize Flask-Login\\r\\nlogin_manager = LoginManager(app)\\r\\nlogin_manager.login_view = 'login'\\r\\n\\r\\n# Initialize Flask-Bcrypt\\r\\nbcrypt = Bcrypt(app)\\r\\n\\r\\n# Initialize Flask-Limiter\\r\\nlimiter = Limiter(app, key_func=get_remote_address)\\r\\n\\r\\n# User model\\r\\nclass User(UserMixin):\\r\\n    def __init__(self, username, email, password):\\r\\n        self.username = username\\r\\n        self.email = email\\r\\n        self.password = bcrypt.generate_password_hash(password).decode('utf-8')\\r\\n\\r\\n    def check_password(self, password):\\r\\n        return bcrypt.check_password_hash(self.password, password)\\r\\n\\r\\n    def change_email(self, new_email):\\r\\n        self.email = new_email\\r\\n\\r\\n# Sample user data\\r\\nusers = {\\r\\n    'john': User('john', 'john@example.com', 'password123')\\r\\n}\\r\\n\\r\\n# Login form\\r\\nclass LoginForm(FlaskForm):\\r\\n    username = StringField('Username', validators=[DataRequired()])\\r\\n    password = PasswordField('Password', validators=[DataRequired()])\\r\\n    submit = SubmitField('Log In')\\r\\n\\r\\n# Change email form\\r\\nclass ChangeEmailForm(FlaskForm):\\r\\n    old_email = StringField('Old Email', validators=[DataRequired(), Email()])\\r\\n    new_email = StringField('New Email', validators=[DataRequired(), Email()])\\r\\n    password = PasswordField('Password', validators=[DataRequired()])\\r\\n    submit = SubmitField('Change Email')\\r\\n\\r\\n@login_manager.user_loader\\r\\ndef load_user(user_id):\\r\\n    return users.get(user_id)\\r\\n\\r\\n@app.route('/')\\r\\ndef index():\\r\\n    return render_template('index.html')\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"10/minute\")  # Rate limiting\\r\\ndef login():\\r\\n    form = LoginForm()\\r\\n    if form.validate_on_submit():\\r\\n        user = users.get(form.username.data)\\r\\n        if user and user.check_password(form.password.data):\\r\\n            login_user(user)\\r\\n            flash('Logged in successfully.', 'success')\\r\\n            return redirect(url_for('index'))\\r\\n        else:\\r\\n            flash('Invalid username or password.', 'danger')\\r\\n    return render_template('login.html', form=form)\\r\\n\\r\\n@app.route('/logout')\\r\\n@login_required\\r\\ndef logout():\\r\\n    logout_user()\\r\\n    flash('You have been logged out.', 'success')\\r\\n    return redirect(url_for('index'))\\r\\n\\r\\n@app.route('/change_email', methods=['GET', 'POST'])\\r\\n@login_required\\r\\ndef change_email():\\r\\n    form = ChangeEmailForm()\\r\\n    if form.validate_on_submit():\\r\\n        user = load_user(current_user.get_id())\\r\\n        if user.email == form.old_email.data and user.check_password(form.password.data):\\r\\n            user.change_email(form.new_email.data)\\r\\n            flash('Email changed successfully.', 'success')\\r\\n            return redirect(url_for('index'))\\r\\n        else:\\r\\n            flash('Invalid old email or password.', 'danger')\\r\\n    return render_template('change_email.html', form=form)\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-306"}
{"text": "Generate Python code for the following: The code is a simple login system that allows a user to change their email. The user must be logged in to change their email. The user must also enter their old email and confirm their password. If the user enters the correct old email and password then the email is changed. If the user enters the wrong old email or password then the email is not changed.", "BP": "Password Hashing, Password Verification, Authentication, Email Change, Input Validation, No Hard-coded Credentials, Session Management, CSRF Protection, Rate Limiting.", "code": "from flask import Flask, request, session, redirect, url_for, render_template, flash\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nimport sqlite3\\r\\nfrom functools import wraps\\r\\nimport time\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.secret_key = 'your_secret_key'  # Replace with a secure secret key\\r\\n\\r\\nDATABASE = 'login_system.db'\\r\\nRATE_LIMIT = {}\\r\\n\\r\\n# Rate limit function\\r\\ndef rate_limited():\\r\\n    client_ip = request.remote_addr\\r\\n    current_time = time.time()\\r\\n    if client_ip in RATE_LIMIT:\\r\\n        if current_time - RATE_LIMIT[client_ip] < 1:\\r\\n            return True\\r\\n    RATE_LIMIT[client_ip] = current_time\\r\\n    return False\\r\\n\\r\\n# Database connection\\r\\ndef get_db():\\r\\n    conn = sqlite3.connect(DATABASE)\\r\\n    conn.row_factory = sqlite3.Row\\r\\n    return conn\\r\\n\\r\\n# Create users table\\r\\ndef create_tables():\\r\\n    with get_db() as conn:\\r\\n        conn.execute('''\\r\\n            CREATE TABLE IF NOT EXISTS users (\\r\\n                id INTEGER PRIMARY KEY,\\r\\n                username TEXT UNIQUE NOT NULL,\\r\\n                email TEXT NOT NULL,\\r\\n                password_hash TEXT NOT NULL\\r\\n            )\\r\\n        ''')\\r\\n        conn.commit()\\r\\n\\r\\n# Decorator to require login\\r\\ndef login_required(f):\\r\\n    @wraps(f)\\r\\n    def decorated_function(*args, **kwargs):\\r\\n        if 'username' not in session:\\r\\n            flash(\"You need to log in first!\")\\r\\n            return redirect(url_for('login'))\\r\\n        return f(*args, **kwargs)\\r\\n    return decorated_function\\r\\n\\r\\n# CSRF token generation\\r\\ndef generate_csrf_token():\\r\\n    if '_csrf_token' not in session:\\r\\n        session['_csrf_token'] = os.urandom(24).hex()\\r\\n    return session['_csrf_token']\\r\\n\\r\\n# CSRF token validation\\r\\n@app.before_request\\r\\ndef csrf_protect():\\r\\n    if request.method == \"POST\":\\r\\n        token = session.pop('_csrf_token', None)\\r\\n        if not token or token != request.form.get('_csrf_token'):\\r\\n            return \"CSRF token missing or incorrect!\", 403\\r\\n\\r\\napp.jinja_env.globals['csrf_token'] = generate_csrf_token\\r\\n\\r\\n# User registration\\r\\n@app.route('/register', methods=['GET', 'POST'])\\r\\ndef register():\\r\\n    if rate_limited():\\r\\n        return \"Too many requests, please try again later.\", 429\\r\\n\\r\\n    if request.method == 'POST':\\r\\n        username = request.form['username']\\r\\n        email = request.form['email']\\r\\n        password = request.form['password']\\r\\n\\r\\n        if not username or not email or not password:\\r\\n            flash(\"All fields are required!\")\\r\\n            return redirect(url_for('register'))\\r\\n\\r\\n        password_hash = generate_password_hash(password)\\r\\n        \\r\\n        try:\\r\\n            with get_db() as conn:\\r\\n                conn.execute('INSERT INTO users (username, email, password_hash) VALUES (?, ?, ?)', \\r\\n                             (username, email, password_hash))\\r\\n                conn.commit()\\r\\n            flash(\"Registration successful! Please log in.\")\\r\\n            return redirect(url_for('login'))\\r\\n        except sqlite3.IntegrityError:\\r\\n            flash(\"Username already exists.\")\\r\\n            return redirect(url_for('register'))\\r\\n\\r\\n    return render_template('register.html')\\r\\n\\r\\n# User login\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    if rate_limited():\\r\\n        return \"Too many requests, please try again later.\", 429\\r\\n\\r\\n    if request.method == 'POST':\\r\\n        username = request.form['username']\\r\\n        password = request.form['password']\\r\\n\\r\\n        if not username or not password:\\r\\n            flash(\"Username and password required!\")\\r\\n            return redirect(url_for('login'))\\r\\n\\r\\n        with get_db() as conn:\\r\\n            user = conn.execute('SELECT * FROM users WHERE username = ?', (username,)).fetchone()\\r\\n\\r\\n        if user and check_password_hash(user['password_hash'], password):\\r\\n            session['username'] = username\\r\\n            flash(\"Logged in successfully!\")\\r\\n            return redirect(url_for('change_email'))\\r\\n        else:\\r\\n            flash(\"Invalid credentials!\")\\r\\n            return redirect(url_for('login'))\\r\\n\\r\\n    return render_template('login.html')\\r\\n\\r\\n# Change email address\\r\\n@app.route('/change_email', methods=['GET', 'POST'])\\r\\n@login_required\\r\\ndef change_email():\\r\\n    if rate_limited():\\r\\n        return \"Too many requests, please try again later.\", 429\\r\\n\\r\\n    if request.method == 'POST':\\r\\n        old_email = request.form['old_email']\\r\\n        new_email = request.form['new_email']\\r\\n        password = request.form['password']\\r\\n\\r\\n        username = session['username']\\r\\n\\r\\n        with get_db() as conn:\\r\\n            user = conn.execute('SELECT * FROM users WHERE username = ?', (username,)).fetchone()\\r\\n\\r\\n        if user and check_password_hash(user['password_hash'], password) and user['email'] == old_email:\\r\\n            with get_db() as conn:\\r\\n                conn.execute('UPDATE users SET email = ? WHERE username = ?', (new_email, username))\\r\\n                conn.commit()\\r\\n            flash(\"Email updated successfully!\")\\r\\n        else:\\r\\n            flash(\"Incorrect old email or password!\")\\r\\n            return redirect(url_for('change_email'))\\r\\n\\r\\n    return render_template('change_email.html')\\r\\n\\r\\n# User logout\\r\\n@app.route('/logout')\\r\\ndef logout():\\r\\n    session.pop('username', None)\\r\\n    flash(\"You have been logged out.\")\\r\\n    return redirect(url_for('login'))\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    create_tables()\\r\\n    app.run(debug=True)", "CWE": "CWE-306"}
{"text": "Generate Python code for the following: The code is a simple login system that allows a user to change their email. The user must be logged in to change their email. The user must also enter their old email and confirm their password. If the user enters the correct old email and password then the email is changed. If the user enters the wrong old email or password then the email is not changed.", "BP": "Password Hashing, Password Verification, Authentication, Email Change, Input Validation, No Hard-coded Credentials, Session Management, CSRF Protection, Rate Limiting.", "code": "from flask import Flask, request, session\\r\\nfrom flask_bcrypt import Bcrypt\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nimport re\\r\\n\\r\\napp = Flask(__name__)\\r\\nbcrypt = Bcrypt(app)\\r\\nlimiter = Limiter(app, key_func=get_remote_address)\\r\\n\\r\\napp.secret_key = 'your_secret_key'  # Change this to a random secret key\\r\\nusers = {}  # This should be replaced with a database in a real application\\r\\n\\r\\n@app.route('/signup', methods=['POST'])\\r\\ndef signup():\\r\\n    email = request.form['email']\\r\\n    password = request.form['password']\\r\\n    if not re.match(r\"[^@]+@[^@]+\\.[^@]+\", email):\\r\\n        return \"Invalid email format\", 400\\r\\n    hashed_password = bcrypt.generate_password_hash(password).decode('utf-8')\\r\\n    users[email] = hashed_password\\r\\n    return \"Signup successful\", 200\\r\\n\\r\\n@app.route('/login', methods=['POST'])\\r\\ndef login():\\r\\n    email = request.form['email']\\r\\n    password = request.form['password']\\r\\n    hashed_password = users.get(email)\\r\\n    if hashed_password and bcrypt.check_password_hash(hashed_password, password):\\r\\n        session['user'] = email\\r\\n        return \"Login successful\", 200\\r\\n    else:\\r\\n        return \"Invalid credentials\", 401\\r\\n\\r\\n@app.route('/change_email', methods=['POST'])\\r\\n@limiter.limit(\"5 per minute\")\\r\\ndef change_email():\\r\\n    if 'user' not in session:\\r\\n        return \"Unauthorized\", 401\\r\\n    old_email = request.form['old_email']\\r\\n    new_email = request.form['new_email']\\r\\n    password = request.form['password']\\r\\n    if old_email != session['user'] or not bcrypt.check_password_hash(users[old_email], password):\\r\\n        return \"Invalid credentials\", 401\\r\\n    if not re.match(r\"[^@]+@[^@]+\\.[^@]+\", new_email):\\r\\n        return \"Invalid new email format\", 400\\r\\n    users[new_email] = users.pop(old_email)\\r\\n    session['user'] = new_email\\r\\n    return \"Email changed successfully\", 200\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-306"}
{"text": "Generate Python code for the following: It allocates a buffer of size buffer_size. It overwrites all values in the buffer with 'A'. The buffer is allocated on the stack.", "BP": "Input Validation, Error Handling, Stack-based allocation, Explicit buffer size, Exception handling, Secure function usage.", "code": "import sys\\r\\nimport ctypes\\r\\n\\r\\n# Input Validation\\r\\ndef validate_input(buffer_size):\\r\\n    try:\\r\\n        buffer_size = int(buffer_size)\\r\\n    except ValueError:\\r\\n        print(\"Invalid input: buffer_size must be an integer.\")\\r\\n        sys.exit(1)\\r\\n\\r\\n    if buffer_size <= 0:\\r\\n        print(\"Invalid input: buffer_size must be a positive integer.\")\\r\\n        sys.exit(1)\\r\\n\\r\\n    return buffer_size\\r\\n\\r\\n# Secure Buffer Allocation and Overwrite\\r\\ndef allocate_buffer(buffer_size):\\r\\n    try:\\r\\n        # Stack-based allocation using ctypes\\r\\n        buffer = ctypes.create_string_buffer(buffer_size)\\r\\n\\r\\n        # Overwrite buffer with 'A'\\r\\n        for i in range(buffer_size):\\r\\n            buffer[i] = b'A'\\r\\n\\r\\n        return buffer\\r\\n\\r\\n    except Exception as e:\\r\\n        print(f\"Error allocating buffer: {e}\")\\r\\n        sys.exit(1)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    # Error Handling\\r\\n    if len(sys.argv) != 2:\\r\\n        print(\"Usage: python script.py <buffer_size>\")\\r\\n        sys.exit(1)\\r\\n\\r\\n    # Input Validation\\r\\n    buffer_size = validate_input(sys.argv[1])\\r\\n\\r\\n    # Secure Buffer Allocation and Overwrite\\r\\n    try:\\r\\n        buffer = allocate_buffer(buffer_size)\\r\\n        print(f\"Buffer of size {buffer_size} allocated and overwritten with 'A':\")\\r\\n        print(buffer.raw)\\r\\n    except Exception as e:\\r\\n        print(f\"Error: {e}\")\\r\\n        sys.exit(1)", "CWE": "CWE-416"}
{"text": "Generate Python code for the following: It allocates a buffer of size buffer_size. It overwrites all values in the buffer with 'A'. The buffer is allocated on the stack.", "BP": " Input Validation, Error Handling, Stack-based allocation, Explicit buffer size, Exception handling, Secure function usage.", "code": "def allocate_and_fill_buffer(buffer_size):\\r\\n    import ctypes\\r\\n\\r\\n    # Input validation: Ensure buffer_size is a positive integer\\r\\n    if not isinstance(buffer_size, int) or buffer_size <= 0:\\r\\n        raise ValueError(\"buffer_size must be a positive integer\")\\r\\n    \\r\\n    try:\\r\\n        # Allocate a buffer on the stack\\r\\n        buffer = (ctypes.c_char * buffer_size)()\\r\\n        \\r\\n        # Fill the buffer with 'A' (ASCII value 65)\\r\\n        for i in range(buffer_size):\\r\\n            buffer[i] = b'A'\\r\\n        \\r\\n        # Print the buffer contents for verification\\r\\n        print(\"Buffer contents:\", bytes(buffer))\\r\\n        return bytes(buffer)  # Return the buffer as bytes object\\r\\n    except Exception as e:\\r\\n        # Error handling: Print error message and re-raise the exception\\r\\n        print(f\"An error occurred: {e}\")\\r\\n        raise\\r\\n\\r\\n# Example usage\\r\\ntry:\\r\\n    buffer_size = 10  # Define the buffer size\\r\\n    buffer = allocate_and_fill_buffer(buffer_size)\\r\\n    print(\"Buffer allocated and filled successfully.\")\\r\\nexcept ValueError as ve:\\r\\n    print(f\"ValueError: {ve}\")\\r\\nexcept Exception as e:\\r\\n    print(f\"Exception: {e}\")", "CWE": "CWE-416"}
