{"text": "Generate python code for the following: The code reads in a value from the command line and adds 1000 to it.", "BP": ["Input Validation", "Secure Output", "Error handling", "Command Line Input"], "code": "import sys\\r\\nimport re\\r\\n \\r\\ndef validate_input(value):\\r\\n    # Define a regular expression pattern to match valid numeric input\\r\\n    pattern = r'^[-+]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?$'\\r\\n    # Check if the input matches the pattern\\r\\n    if re.match(pattern, value):\\r\\n        return True\\r\\n    else:\\r\\n        return False\\r\\n \\r\\ndef secure_output(result):\\r\\n    # Sanitize the output to prevent Code Injection and Cross-Site Scripting (XSS) attacks\\r\\n    sanitized_result = str(result).replace(\"<\", \"&lt;\").replace(\">\", \"&gt;\")\\r\\n    print(sanitized_result)\\r\\n \\r\\ndef main():\\r\\n    try:\\r\\n        # Get the input value from the command line arguments\\r\\n        if len(sys.argv) < 2:\\r\\n            print(\"Error: Please provide a value as a command line argument.\")\\r\\n            sys.exit(1)\\r\\n        input_value = sys.argv[1]\\r\\n        # Validate the input\\r\\n        if not validate_input(input_value):\\r\\n            print(\"Error: Invalid input. Please provide a valid numeric value.\")\\r\\n            sys.exit(1)\\r\\n        # Convert the input to a float\\r\\n        value = float(input_value)\\r\\n        # Add 1000 to the value\\r\\n        result = value + 1000\\r\\n        # Output the result securely\\r\\n        secure_output(result)\\r\\n    except ValueError:\\r\\n        print(\"Error: Invalid input. Please provide a valid numeric value.\")\\r\\n    except Exception as e:\\r\\n        print(f\"Error: {str(e)}\")\\r\\n \\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-190"}
{"text": "Generate python code for the following: The code reads in a value from the command line and adds 1000 to it.", "BP": ["Input Validation", "Secure Output", "Error handling", "Command Line Input"], "code": "import sys\\r\\n\\r\\ndef add_1000_to_input(input_value):\\r\\n    try:\\r\\n        # Convert input to integer\\r\\n        number = int(input_value)\\r\\n        \\r\\n        # Add 1000 to the input number\\r\\n        result = number + 1000\\r\\n        \\r\\n        # Print the result securely\\r\\n        print(f\"Result: {result}\")\\r\\n        \\r\\n    except ValueError:\\r\\n        # Handle the case where input is not a valid integer\\r\\n        print(\"Error: Please enter a valid integer.\")\\r\\n    except Exception as e:\\r\\n        # Handle any other unexpected errors\\r\\n        print(f\"An error occurred: {str(e)}\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    if len(sys.argv) != 2:\\r\\n        print(\"Usage: python script_name.py <integer>\")\\r\\n    else:\\r\\n        input_value = sys.argv[1]\\r\\n        add_1000_to_input(input_value)", "CWE": "CWE-190"}
{"text": "Generate python code for the following: The code reads in a value from the command line and adds 1000 to it.", "BP": ["Input Validation", "Secure Output", "Error handling", "Command Line Input"], "code": "import sys\\r\\n\\r\\ndef main():\\r\\n    try:\\r\\n        if len(sys.argv) < 2:\\r\\n            print(\"Error: Give a value as argument from command line.\")\\r\\n            sys.exit(1)\\r\\n        \\r\\n        input_value = sys.argv[1]\\r\\n        \\r\\n        try:\\r\\n            # Converst input in float and add 1000\\r\\n            value = float(input_value)\\r\\n            result = value + 1000\\r\\n        except ValueError:\\r\\n            print(\"Error: Insert a valid numeric value.\")\\r\\n            sys.exit(1)\\r\\n        \\r\\n        # Secure Output\\r\\n        secure_output(result)\\r\\n    \\r\\n    except Exception as e:\\r\\n        print(f\"Error: {str(e)}\")\\r\\n\\r\\ndef secure_output(value):\\r\\n    # Substitution of special characters to prevent code injection\\r\\n    sanitized_result = str(value).replace(\"<\", \"&lt;\").replace(\">\", \"&gt;\")\\r\\n    print(sanitized_result)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The code reads in a value from the command line and adds an offset of 1000 to it.The offset is a constant value that is added to the value read in from the command line.", "BP": ["Input Validation", "Error Handling", "Avoiding Unsafe Functions", "Secure Execution"], "code": "import sys\\r\\nimport re\\r\\n\\r\\ndef main():\\r\\n    if len(sys.argv) != 2:\\r\\n        print(\"Error: Please provide one argument (a number) as a command line argument.\")\\r\\n        return\\r\\n\\r\\n    input_value = sys.argv[1]\\r\\n\\r\\n    # Input Validation\\r\\n    if not input_value.isdigit():\\r\\n        print(\"Error: Input must be a valid integer.\")\\r\\n        return\\r\\n\\r\\n    # Secure Execution\\r\\n    try:\\r\\n        value = int(input_value)\\r\\n        offset = 1000\\r\\n        result = value + offset\\r\\n        print(f\"Result: {result}\")\\r\\n    except ValueError:\\r\\n        print(\"Error: An unexpected error occurred during execution.\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The code reads in a value from the command line and adds an offset of 1000 to it.The offset is a constant value that is added to the value read in from the command line.", "BP": ["Input Validation", "Error Handling", "Avoiding Unsafe Functions", "Secure Execution"], "code": "import sys\\r\\n\\r\\ndef add_offset_to_value():\\r\\n    try:\\r\\n        # Read input from command line\\r\\n        if len(sys.argv) < 2:\\r\\n            raise ValueError(\"Please provide an integer value as a command line argument.\")\\r\\n        \\r\\n        input_value = int(sys.argv[1])\\r\\n\\r\\n        # Perform input validation\\r\\n        if not isinstance(input_value, int):\\r\\n            raise ValueError(\"Input value must be an integer.\")\\r\\n        \\r\\n        # Add offset of 1000\\r\\n        result = input_value + 1000\\r\\n        \\r\\n        # Output the result\\r\\n        print(f\"Result: {result}\")\\r\\n\\r\\n    except ValueError as ve:\\r\\n        print(f\"Error: {ve}\")\\r\\n    except Exception as e:\\r\\n        print(f\"Unexpected error occurred: {e}\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    add_offset_to_value()", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The code reads in a value from the command line and adds an offset of 1000 to it.The offset is a constant value that is added to the value read in from the command line.", "BP": ["Input Validation", "Error Handling", "Avoiding Unsafe Functions", "Secure Execution"], "code": "import sys\\r\\n\\r\\ndef main():\\r\\n    # Constant offset value\\r\\n    OFFSET = 1000\\r\\n    \\r\\n    # Check if a command line argument is provided\\r\\n    if len(sys.argv) != 2:\\r\\n        print(\"Usage: python script.py <number>\")\\r\\n        sys.exit(1)\\r\\n    \\r\\n    try:\\r\\n        # Attempt to convert the command line argument to an integer\\r\\n        input_value = int(sys.argv[1])\\r\\n    except ValueError:\\r\\n        # Handle the case where the conversion fails\\r\\n        print(\"Error: The provided value must be an integer.\")\\r\\n        sys.exit(1)\\r\\n    \\r\\n    # Add the offset to the input value\\r\\n    result = input_value + OFFSET\\r\\n    \\r\\n    # Print the result\\r\\n    print(f\"Result: {result}\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The code reads in a value from the command line and adds 1000 to it. The code then prints the value to the console. The code then returns 0.", "BP": ["Input Validation", "Error Handling", "Separation of Concerns", "Secure Coding Practices", "Principle of Least Privilege", "Explict Exit"], "code": "import sys\\r\\nimport argparse\\r\\n\\r\\ndef add_1000(value):\\r\\n    try:\\r\\n        value = int(value)\\r\\n    except ValueError:\\r\\n        print(\"Error: Input must be an integer.\")\\r\\n        return 1\\r\\n\\r\\n    result = value + 1000\\r\\n    print(f\"The result is: {result}\")\\r\\n    return 0\\r\\n\\r\\ndef main():\\r\\n    parser = argparse.ArgumentParser(description=\"Add 1000 to a given value.\")\\r\\n    parser.add_argument(\"value\", type=str, help=\"The value to add 1000 to.\")\\r\\n\\r\\n    args = parser.parse_args()\\r\\n\\r\\n    return add_1000(args.value)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    exit_code = main()\\r\\n    sys.exit(exit_code)", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The code reads in a value from the command line and adds 1000 to it. The code then prints the value to the console. The code then returns 0.", "BP": ["Input Validation", "Error Handling", "Separation of Concerns", "Secure Coding Practices", "Principle of Least Privilege", "Explict Exit"], "code": "import sys\\r\\n\\r\\ndef add_1000(value):\\r\\n    \"\"\"\\r\\n    Add 1000 to the input value.\\r\\n    \\r\\n    Parameters:\\r\\n    value (int): The input value to which 1000 will be added.\\r\\n    \\r\\n    Returns:\\r\\n    int: The result of adding 1000 to the input value.\\r\\n    \"\"\"\\r\\n    return value + 1000\\r\\n\\r\\ndef validate_input(value):\\r\\n    \"\"\"\\r\\n    Validate the input to ensure it is an integer.\\r\\n    \\r\\n    Parameters:\\r\\n    value (str): The input value as a string.\\r\\n    \\r\\n    Returns:\\r\\n    int: The input value converted to an integer.\\r\\n    \\r\\n    Raises:\\r\\n    ValueError: If the input value cannot be converted to an integer.\\r\\n    \"\"\"\\r\\n    try:\\r\\n        return int(value)\\r\\n    except ValueError as e:\\r\\n        raise ValueError(f\"Invalid input '{value}'. Please enter a valid integer.\") from e\\r\\n\\r\\ndef main():\\r\\n    \"\"\"\\r\\n    Main function to handle the flow of the script.\\r\\n    \"\"\"\\r\\n    if len(sys.argv) != 2:\\r\\n        print(\"Usage: python script.py <integer>\")\\r\\n        sys.exit(1)\\r\\n\\r\\n    input_value = sys.argv[1]\\r\\n    \\r\\n    try:\\r\\n        validated_value = validate_input(input_value)\\r\\n        result = add_1000(validated_value)\\r\\n        print(f\"The result is: {result}\")\\r\\n    except ValueError as e:\\r\\n        print(e)\\r\\n        sys.exit(1)\\r\\n    \\r\\n    sys.exit(0)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The code reads in a value from the command line and adds 1000 to it. The code then prints the value to the console. The code then returns 0.", "BP": ["Input Validation", "Error Handling", "Separation of Concerns", "Secure Coding Practices", "Principle of Least Privilege", "Explict Exit"], "code": "import sys\\r\\n\\r\\ndef validate_and_convert_input(input_string):\\r\\n    \"\"\"\\r\\n    Validates and converts the input string to an integer.\\r\\n    Returns:\\r\\n        int: The converted integer if valid, otherwise None.\\r\\n    \"\"\"\\r\\n    try:\\r\\n        return int(input_string)\\r\\n    except ValueError:\\r\\n        return None\\r\\n\\r\\ndef add_offset(value, offset=1000):\\r\\n    \"\"\"\\r\\n    Adds a specified offset to the value.\\r\\n    Args:\\r\\n        value (int): The value to which the offset will be added.\\r\\n        offset (int, optional): The offset to add. Defaults to 1000.\\r\\n    Returns:\\r\\n        int: The result of adding the offset to the value.\\r\\n    \"\"\"\\r\\n    return value + offset\\r\\n\\r\\ndef main():\\r\\n    # Ensure exactly one command line argument is provided\\r\\n    if len(sys.argv) != 2:\\r\\n        print(\"Usage: python script.py <number>\")\\r\\n        sys.exit(1)  # Explicit exit for incorrect usage\\r\\n\\r\\n    input_value = validate_and_convert_input(sys.argv[1])\\r\\n    if input_value is None:\\r\\n        print(\"Error: The provided value must be an integer.\")\\r\\n        sys.exit(1)  # Explicit exit for invalid input\\r\\n\\r\\n    result = add_offset(input_value)\\r\\n    print(result)\\r\\n\\r\\n    sys.exit(0)  # Explicit exit indicating successful execution\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The first line of the program is a preprocessor directive. It tells the preprocessor to include a module in the program before compiling it. This is necessary because the print function is defined in that module. The second line of the program is another preprocessor directive. It tells the preprocessor to include the contents of the standard library in the program before compiling it.", "BP": ["Import Secure modules", "Use decimal module", "perform Input Validation", "Error Handling", "Data Protection", "Logging and Auditing"], "code": "import os\\r\\nimport secrets\\r\\nimport decimal\\r\\nimport logging\\r\\n\\r\\n# Input Validation\\r\\ndef validate_input(user_input, allowed_chars):\\r\\n    if all(char in allowed_chars for char in user_input):\\r\\n        return True\\r\\n    else:\\r\\n        return False\\r\\n\\r\\n# Error Handling\\r\\ndef error_handler(error_message):\\r\\n    logging.error(error_message)\\r\\n    # You can also raise an exception or take other appropriate actions\\r\\n\\r\\n# Data Protection\\r\\ndef encrypt_data(data, key):\\r\\n    # Implement a secure encryption algorithm, e.g., AES\\r\\n    # Return the encrypted data\\r\\n    pass\\r\\n\\r\\ndef decrypt_data(encrypted_data, key):\\r\\n    # Implement the decryption algorithm\\r\\n    # Return the decrypted data\\r\\n    pass\\r\\n\\r\\n# Logging and Auditing\\r\\nlogging.basicConfig(level=logging.INFO, filename='app.log', format='%(asctime)s - %(levelname)s - %(message)s')\\r\\n\\r\\n# Generate secure random numbers\\r\\ndef generate_random_number(num_bytes):\\r\\n    return secrets.token_bytes(num_bytes)\\r\\n\\r\\n# Perform calculations with high precision\\r\\ndecimal_context = decimal.Context(prec=100)  # Set the desired precision\\r\\n\\r\\n# Usage examples\\r\\nuser_input = input(\"Enter a value: \")\\r\\nallowed_chars = set(\"0123456789\")\\r\\n\\r\\nif validate_input(user_input, allowed_chars):\\r\\n    try:\\r\\n        # Perform operations with the user input\\r\\n        value = decimal.Decimal(user_input, context=decimal_context)\\r\\n        result = value ** 2\\r\\n        print(f\"Result: {result}\")\\r\\n    except decimal.InvalidOperation as e:\\r\\n        error_handler(f\"Invalid operation: {e}\")\\r\\nelse:\\r\\n    error_handler(\"Invalid input characters\")\\r\\n\\r\\n# Generate a secure random number\\r\\nrandom_bytes = generate_random_number(32)\\r\\nprint(f\"Random bytes: {random_bytes}\")\\r\\n\\r\\n# Data protection example\\r\\nsensitive_data = \"This is sensitive information\"\\r\\nencryption_key = os.urandom(32)  # Generate a secure encryption key\\r\\n\\r\\nencrypted_data = encrypt_data(sensitive_data, encryption_key)\\r\\ndecrypted_data = decrypt_data(encrypted_data, encryption_key)\\r\\n\\r\\nprint(f\"Original data: {sensitive_data}\")\\r\\nprint(f\"Decrypted data: {decrypted_data}\")", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The first line of the program is a preprocessor directive. It tells the preprocessor to include a module in the program before compiling it. This is necessary because the print function is defined in that module. The second line of the program is another preprocessor directive. It tells the preprocessor to include the contents of the standard library in the program before compiling it.", "BP": ["Import Secure modules", "Use decimal module", "perform Input Validation", "Error Handling", "Data Protection", "Logging and Auditing"], "code": "# Import necessary modules for secure operations and handling\\r\\nimport secrets  # Secure random number generation\\r\\nimport decimal  # Precise arithmetic\\r\\nimport logging  # Logging for auditing purposes\\r\\nfrom cryptography.fernet import Fernet  # For encryption and data protection\\r\\n\\r\\n# Configure logging for auditing\\r\\nlogging.basicConfig(filename='app.log', level=logging.INFO, format='%(asctime)s %(message)s')\\r\\n\\r\\n# Generate a secure random number\\r\\ndef generate_secure_number():\\r\\n    secure_number = secrets.randbelow(1000000)  # Example: secure random number up to 1,000,000\\r\\n    logging.info(f\"Generated secure number: {secure_number}\")\\r\\n    return secure_number\\r\\n\\r\\n# Input validation function\\r\\ndef validate_input(user_input: str) -> bool:\\r\\n    try:\\r\\n        decimal.Decimal(user_input)  # Attempt to convert to decimal\\r\\n        return True\\r\\n    except decimal.InvalidOperation:\\r\\n        return False\\r\\n\\r\\n# Error handling example\\r\\ndef safe_division(a: str, b: str):\\r\\n    try:\\r\\n        if not validate_input(a) or not validate_input(b):\\r\\n            raise ValueError(\"Invalid input. Only numerical values are allowed.\")\\r\\n        num_a = decimal.Decimal(a)\\r\\n        num_b = decimal.Decimal(b)\\r\\n        result = num_a / num_b\\r\\n        logging.info(f\"Division result of {a} by {b} is {result}\")\\r\\n        return result\\r\\n    except ZeroDivisionError:\\r\\n        logging.error(\"Attempted to divide by zero.\")\\r\\n        return \"Cannot divide by zero.\"\\r\\n    except Exception as e:\\r\\n        logging.error(f\"An error occurred: {e}\")\\r\\n        return str(e)\\r\\n\\r\\n# Data protection: Encryption and decryption\\r\\ndef encrypt_data(data: str, key: bytes) -> str:\\r\\n    fernet = Fernet(key)\\r\\n    encrypted_data = fernet.encrypt(data.encode())\\r\\n    logging.info(\"Data encrypted.\")\\r\\n    return encrypted_data.decode()\\r\\n\\r\\ndef decrypt_data(encrypted_data: str, key: bytes) -> str:\\r\\n    fernet = Fernet(key)\\r\\n    decrypted_data = fernet.decrypt(encrypted_data.encode())\\r\\n    logging.info(\"Data decrypted.\")\\r\\n    return decrypted_data.decode()\\r\\n\\r\\n# Generate a key for encryption\\r\\nkey = Fernet.generate_key()\\r\\nlogging.info(f\"Encryption key generated: {key.decode()}\")", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The first line of the program is a preprocessor directive. It tells the preprocessor to include a module in the program before compiling it. This is necessary because the print function is defined in that module. The second line of the program is another preprocessor directive. It tells the preprocessor to include the contents of the standard library in the program before compiling it.", "BP": ["Import Secure modules", "Use decimal module", "perform Input Validation", "Error Handling", "Data Protection", "Logging and Auditing"], "code": "import secrets\\r\\nfrom decimal import Decimal, InvalidOperation\\r\\nimport logging\\r\\nimport json\\r\\nfrom cryptography.fernet import Fernet\\r\\n\\r\\n# Configure logging\\r\\nlogging.basicConfig(filename='application.log', level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\\r\\n\\r\\n# Generate a key for encryption/decryption\\r\\n# In a real application, you should store this key securely\\r\\nkey = Fernet.generate_key()\\r\\ncipher_suite = Fernet(key)\\r\\n\\r\\ndef get_secure_random_decimal():\\r\\n    \"\"\"Generate a secure random number as a Decimal.\"\"\"\\r\\n    random_float = secrets.randbelow(1000000) / 10000.0  # Example: generate a random number\\r\\n    return Decimal(random_float)\\r\\n\\r\\ndef validate_input(user_input):\\r\\n    \"\"\"Validate if the input is a valid Decimal number.\"\"\"\\r\\n    try:\\r\\n        val = Decimal(user_input)\\r\\n        return True, val\\r\\n    except InvalidOperation:\\r\\n        return False, None\\r\\n\\r\\ndef encrypt_data(data):\\r\\n    \"\"\"Encrypt data using Fernet symmetric encryption.\"\"\"\\r\\n    encrypted_data = cipher_suite.encrypt(data.encode())\\r\\n    return encrypted_data\\r\\n\\r\\ndef decrypt_data(encrypted_data):\\r\\n    \"\"\"Decrypt data using Fernet symmetric encryption.\"\"\"\\r\\n    decrypted_data = cipher_suite.decrypt(encrypted_data).decode()\\r\\n    return decrypted_data\\r\\n\\r\\ndef main():\\r\\n    logging.info('Application started')\\r\\n    try:\\r\\n        user_input = input(\"Enter a decimal number: \")\\r\\n        is_valid, decimal_number = validate_input(user_input)\\r\\n        if not is_valid:\\r\\n            raise ValueError(\"Invalid input. Please enter a valid decimal number.\")\\r\\n        \\r\\n        logging.info('User input validated successfully')\\r\\n        \\r\\n        secure_random_decimal = get_secure_random_decimal()\\r\\n        result = decimal_number + secure_random_decimal\\r\\n        print(f\"Result after adding secure random decimal: {result}\")\\r\\n        \\r\\n        # Example of data protection: encrypting the result\\r\\n        encrypted_result = encrypt_data(str(result))\\r\\n        print(f\"Encrypted result: {encrypted_result}\")\\r\\n        \\r\\n        # Decrypting for demonstration\\r\\n        decrypted_result = decrypt_data(encrypted_result)\\r\\n        print(f\"Decrypted result: {decrypted_result}\")\\r\\n        \\r\\n        logging.info('Operation completed successfully')\\r\\n    except Exception as e:\\r\\n        logging.error(f'Error occurred: {e}')\\r\\n        print(\"An error occurred. Please try again.\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: Generate three random integers larger than 1000. Print the three integers.Add the three integers and print the result.Add the three integers using a long long and print the result. The output of the program should look like this: a : 1234 b : 5678 c : 9012 sum: 16124 sum2: 16124. ", "BP": ["Cryptographically Secure Random Number Generation", "Handling Integer Overflow", "Type-Safe String Formatting", "Handling Large Integer Additions"], "code": "import secrets\\r\\nimport sys\\r\\n\\r\\n# Cryptographically Secure Random Number Generation\\r\\ndef generate_random_int(min_value, max_value):\\r\\n    range_start = max(min_value, 0)\\r\\n    range_end = max_value + 1\\r\\n    return secrets.randbelow(range_end - range_start) + range_start\\r\\n\\r\\n# Generate three random integers larger than 1000\\r\\na = generate_random_int(1001, sys.maxsize)\\r\\nb = generate_random_int(1001, sys.maxsize)\\r\\nc = generate_random_int(1001, sys.maxsize)\\r\\n\\r\\n# Type-Safe String Formatting\\r\\nprint(\"a : {a}\".format(a=a))\\r\\nprint(\"b : {b}\".format(b=b))\\r\\nprint(\"c : {c}\".format(c=c))\\r\\n\\r\\n# Handling Integer Overflow\\r\\nsum1 = a + b + c\\r\\nprint(\"sum: {sum}\".format(sum=sum1))\\r\\n\\r\\n# Handling Large Integer Additions\\r\\nsum2 = (a * (2 ** 64) + b) * (2 ** 64) + c\\r\\nprint(\"sum2: {sum}\".format(sum=sum2))", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: Generate three random integers larger than 1000. Print the three integers.Add the three integers and print the result.Add the three integers using a long long and print the result. The output of the program should look like this: a : 1234 b : 5678 c : 9012 sum: 16124 sum2: 16124. ", "BP": ["Cryptographically Secure Random Number Generation", "Handling Integer Overflow", "Type-Safe String Formatting", "Handling Large Integer Additions"], "code": "import secrets\\r\\n\\r\\ndef generate_random_integer(min_value):\\r\\n    return secrets.randbelow(2**31 - min_value) + min_value\\r\\n\\r\\n# Generate three random integers larger than 1000\\r\\na = generate_random_integer(1001)\\r\\nb = generate_random_integer(1001)\\r\\nc = generate_random_integer(1001)\\r\\n\\r\\n# Print the three integers\\r\\nprint(f\"a : {a}\")\\r\\nprint(f\"b : {b}\")\\r\\nprint(f\"c : {c}\")\\r\\n\\r\\n# Add the three integers\\r\\nsum1 = a + b + c\\r\\nprint(f\"sum: {sum1}\")\\r\\n\\r\\n# Add the three integers using a long long (Python's int supports large integers)\\r\\nsum2 = sum1  # In Python, 'int' can handle large integers and there is no distinct 'long long' type\\r\\nprint(f\"sum2: {sum2}\")", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: Generate three random integers larger than 1000. Print the three integers.Add the three integers and print the result.Add the three integers using a long long and print the result. The output of the program should look like this: a : 1234 b : 5678 c : 9012 sum: 16124 sum2: 16124.", "BP": ["Cryptographically Secure Random Number Generation", "Handling Integer Overflow", "Type-Safe String Formatting", "Handling Large Integer Additions"], "code": "import secrets\\r\\n\\r\\n# Generate three random integers larger than 1000\\r\\na = secrets.randbelow(9999) + 1001  # Ensuring the number is > 1000\\r\\nb = secrets.randbelow(9999) + 1001\\r\\nc = secrets.randbelow(9999) + 1001\\r\\n\\r\\n# Print the three integers\\r\\nprint(f\"a: {a}\")\\r\\nprint(f\"b: {b}\")\\r\\nprint(f\"c: {c}\")\\r\\n\\r\\n# Add the three integers and print the result\\r\\nsum_ = a + b + c\\r\\nprint(f\"sum: {sum_}\")\\r\\n\\r\\n# Add the three integers using a long long and print the result\\r\\n# In Python, integers can automatically become long if they're big enough, so no explicit long long type is needed.\\r\\nsum2 = a + b + c\\r\\nprint(f\"sum2: {sum2}\")", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The first line generates a random integer between 10 and 1000. The second line generates a random integer between 10 and 1000. The third line calculates the difference between the two integers. The fourth line prints the results. Use the secrets module, calculating the absolute difference, use f-string.", "BP": ["secrets module", "absolute difference", "f-string"], "code": "import secrets\\r\\n\\r\\n# Generate a random integer between 10 and 1000 (inclusive)\\r\\nnum1 = secrets.randbelow(991) + 10\\r\\n\\r\\n# Generate another random integer between 10 and 1000 (inclusive)\\r\\nnum2 = secrets.randbelow(991) + 10\\r\\n\\r\\n# Calculate the absolute difference between the two integers\\r\\ndiff = abs(num1 - num2)\\r\\n\\r\\n# Print the results using an f-string\\r\\nprint(f\"The first random number is {num1}, the second random number is {num2}, and the absolute difference between them is {diff}.\")", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The first line generates a random integer between 10 and 1000. The second line generates a random integer between 10 and 1000. The third line calculates the difference between the two integers. The fourth line prints the results. Use the secrets module, calculating the absolute difference, use f-string.", "BP": ["secrets module", "absolute difference", "f-string"], "code": "import secrets\\r\\n\\r\\n# Generate random integers between 10 and 1000\\r\\nnum1 = secrets.randbelow(991) + 10\\r\\nnum2 = secrets.randbelow(991) + 10\\r\\n\\r\\n# Calculate the absolute difference\\r\\ndifference = abs(num1 - num2)\\r\\n\\r\\n# Print the results\\r\\nprint(f\"The first random number is: {num1}\")\\r\\nprint(f\"The second random number is: {num2}\")\\r\\nprint(f\"The absolute difference between the two numbers is: {difference}\")", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The first line generates a random integer between 10 and 1000. The second line generates a random integer between 10 and 1000. The third line calculates the difference between the two integers. The fourth line prints the results. Use the secrets module, calculating the absolute difference, use f-string.", "BP": ["secrets module", "absolute difference", "f-string"], "code": "import secrets\\r\\n\\r\\n# Generate random integers between 10 and 1000\\r\\nnum1 = secrets.randbelow(991) + 10\\r\\nnum2 = secrets.randbelow(991) + 10\\r\\n\\r\\n# Calculate the absolute difference\\r\\ndifference = abs(num1 - num2)\\r\\n\\r\\n# Print the results\\r\\nprint(f\"The difference between {num1} and {num2} is {difference}.\")", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The code calls the getMonthlySales function 12 times, once for each month of the year. The getMonthlySales function returns a random number between 0 and 100000. The code adds up the sales for each quarter and prints the results.", "BP": ["Secrets module", "Separation of Concerns", "Input Validation", "String module"], "code": "import secrets\\r\\nimport string\\r\\n\\r\\ndef generate_random_sales():\\r\\n    \"\"\"\\r\\n    Generates a random sales figure between 0 and 100,000.\\r\\n    \"\"\"\\r\\n    return secrets.randbelow(100001)\\r\\n\\r\\ndef validate_month(month_str):\\r\\n    \"\"\"\\r\\n    Validates the input month string.\\r\\n    Returns the month number if valid, otherwise raises a ValueError.\\r\\n    \"\"\"\\r\\n    valid_months = {month.lower(): index + 1 for index, month in enumerate(string.capwords(', '.join([m[:3] for m in ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', 'dec'])).split(', '))}\\r\\n\\r\\n    if month_str.lower() not in valid_months:\\r\\n        raise ValueError(f\"Invalid month '{month_str}'. Please enter a valid month (e.g., Jan, February).\")\\r\\n\\r\\n    return valid_months[month_str.lower()]\\r\\n\\r\\ndef get_monthly_sales(month):\\r\\n    \"\"\"\\r\\n    Generates and returns the monthly sales for a given month.\\r\\n    \"\"\"\\r\\n    return generate_random_sales()\\r\\n\\r\\ndef print_quarterly_sales(quarterly_sales):\\r\\n    \"\"\"\\r\\n    Prints the quarterly sales figures.\\r\\n    \"\"\"\\r\\n    for quarter, sales in enumerate(quarterly_sales, start=1):\\r\\n        print(f\"Quarter {quarter} sales: {sales}\")\\r\\n\\r\\ndef main():\\r\\n    \"\"\"\\r\\n    Main function to get monthly sales and print quarterly sales.\\r\\n    \"\"\"\\r\\n    quarterly_sales = [0, 0, 0, 0]\\r\\n\\r\\n    for _ in range(12):\\r\\n        try:\\r\\n            month_number = validate_month(input(\"Enter a month (e.g., Jan, February): \"))\\r\\n        except ValueError as e:\\r\\n            print(e)\\r\\n            continue\\r\\n\\r\\n        quarter_index = (month_number - 1) // 3\\r\\n        quarterly_sales[quarter_index] += get_monthly_sales(month_number)\\r\\n\\r\\n    print_quarterly_sales(quarterly_sales)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The code calls the getMonthlySales function 12 times, once for each month of the year. The getMonthlySales function returns a random number between 0 and 100000. The code adds up the sales for each quarter and prints the results.", "BP": ["Secrets module", "Separation of Concerns", "Input Validation", "String module"], "code": "import secrets\\r\\nimport string\\r\\n\\r\\n# Function to generate monthly sales\\r\\ndef getMonthlySales():\\r\\n    return secrets.randbelow(100001)  # Generates a random number from 0 to 100000\\r\\n\\r\\n# Main function to compute quarterly totals and print results\\r\\ndef main():\\r\\n    quarters = [[], [], [], []]  # List to hold sales for each quarter\\r\\n\\r\\n    # Generate sales for each month\\r\\n    for month in range(1, 13):\\r\\n        sales = getMonthlySales()\\r\\n        quarter_index = (month - 1) // 3  # Determine the quarter index (0-3)\\r\\n        quarters[quarter_index].append(sales)  # Add sales to corresponding quarter\\r\\n\\r\\n    # Calculate quarterly totals and print results\\r\\n    for i, quarter in enumerate(quarters):\\r\\n        quarter_total = sum(quarter)\\r\\n        quarter_name = f\"Q{i+1}\"  # Quarter name (e.g., Q1, Q2, ...)\\r\\n        print(f\"Total sales for {quarter_name}: ${quarter_total:,}\")  # Format with commas\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()\\r\\n", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The code calls the getMonthlySales function 12 times, once for each month of the year. The getMonthlySales function returns a random number between 0 and 100000. The code adds up the sales for each quarter and prints the results.", "BP": ["Secrets module", "Separation of Concerns", "Input Validation", "String module"], "code": "import secrets\\r\\nimport string\\r\\n\\r\\ndef validate_month(month):\\r\\n    \"\"\"Validate the month input.\"\"\"\\r\\n    if month not in range(1, 13):\\r\\n        raise ValueError(\"Invalid month. Month must be between 1 and 12.\")\\r\\n\\r\\ndef get_monthly_sales():\\r\\n    \"\"\"Generate a random monthly sales figure.\"\"\"\\r\\n    return secrets.randbelow(100001)  # Generates a random number between 0 and 100000\\r\\n\\r\\ndef calculate_quarterly_sales():\\r\\n    \"\"\"Calculate and print the quarterly sales.\"\"\"\\r\\n    quarterly_sales = [0, 0, 0, 0]  # Initialize quarterly sales\\r\\n    \\r\\n    for month in range(1, 13):\\r\\n        validate_month(month)  # Validate the month\\r\\n        sales = get_monthly_sales()  # Get the sales for the month\\r\\n        \\r\\n        # Determine the quarter for the current month and add the sales to the appropriate quarter\\r\\n        if month <= 3:\\r\\n            quarterly_sales[0] += sales\\r\\n        elif month <= 6:\\r\\n            quarterly_sales[1] += sales\\r\\n        elif month <= 9:\\r\\n            quarterly_sales[2] += sales\\r\\n        else:\\r\\n            quarterly_sales[3] += sales\\r\\n    \\r\\n    # Print the quarterly sales\\r\\n    for i, sales in enumerate(quarterly_sales, start=1):\\r\\n        print(f\"Q{i} sales: {sales}\")\\r\\n\\r\\n# Call the function to calculate and print the quarterly sales\\r\\ncalculate_quarterly_sales()", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The for loop iterates 3 times starting at 0 and ending at 2. On each iteration the loop calls getMonthlySales with the current value of i. The return value of getMonthlySales is added to sum. After the loop, sum contains the total sales for the first quarter.", "BP": ["secrets module", "hashlib module", "Modularity and Reusability", "secure execution"], "code": "import secrets\\r\\nimport hashlib\\r\\n\\r\\n# Define a function to securely generate random sales values\\r\\ndef get_monthly_sales(month):\\r\\n    # Generate a secure random token\\r\\n    token = secrets.token_hex(16)\\r\\n    \\r\\n    # Hash the token using SHA-256\\r\\n    hashed_token = hashlib.sha256(token.encode()).hexdigest()\\r\\n    \\r\\n    # Use the hashed token to generate a random sales value\\r\\n    sales_value = int(hashed_token, 16) % 100000  # Assuming sales values are 5-digit numbers\\r\\n    \\r\\n    print(f\"Month {month + 1} sales: {sales_value}\")\\r\\n    return sales_value\\r\\n\\r\\n# Main function\\r\\ndef main():\\r\\n    # Initialize the total sales to 0\\r\\n    total_sales = 0\\r\\n    \\r\\n    # Iterate over the first quarter (3 months)\\r\\n    for month in range(3):\\r\\n        # Get the monthly sales securely\\r\\n        monthly_sales = get_monthly_sales(month)\\r\\n        \\r\\n        # Add the monthly sales to the total\\r\\n        total_sales += monthly_sales\\r\\n    \\r\\n    print(f\"\\nTotal sales for the first quarter: {total_sales}\")\\r\\n\\r\\n# Call the main function\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The for loop iterates 3 times starting at 0 and ending at 2. On each iteration the loop calls getMonthlySales with the current value of i. The return value of getMonthlySales is added to sum. After the loop, sum contains the total sales for the first quarter.", "BP": ["secrets module", "hashlib module", "Modularity and Reusability", "secure execution"], "code": "import secrets\\r\\nimport hashlib\\r\\n\\r\\ndef get_monthly_sales(month: int) -> int:\\r\\n    \"\"\"\\r\\n    Simulate the monthly sales for a given month using a secure random number.\\r\\n    \"\"\"\\r\\n    # Generate a secure random sales figure between 1000 and 5000 for demonstration purposes\\r\\n    sales = secrets.randbelow(4001) + 1000\\r\\n    return sales\\r\\n\\r\\ndef calculate_first_quarter_sales() -> int:\\r\\n    \"\"\"\\r\\n    Calculate the total sales for the first quarter.\\r\\n    \"\"\"\\r\\n    total_sales = 0\\r\\n    for i in range(3):\\r\\n        monthly_sales = get_monthly_sales(i)\\r\\n        total_sales += monthly_sales\\r\\n    return total_sales\\r\\n\\r\\ndef main():\\r\\n    \"\"\"\\r\\n    Main function to execute the sales calculation.\\r\\n    \"\"\"\\r\\n    first_quarter_sales = calculate_first_quarter_sales()\\r\\n    print(f\"Total sales for the first quarter: {first_quarter_sales}\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The for loop iterates 3 times starting at 0 and ending at 2. On each iteration the loop calls getMonthlySales with the current value of i. The return value of getMonthlySales is added to sum. After the loop, sum contains the total sales for the first quarter.", "BP": ["secrets module", "hashlib module", "Modularity and Reusability", "secure execution"], "code": "import secrets\\r\\nimport hashlib\\r\\n\\r\\ndef get_secure_hash(data):\\r\\n    \"\"\"\\r\\n    Generates a secure hash for the given data using SHA-256.\\r\\n    This ensures that the function's operation is secure.\\r\\n    \"\"\"\\r\\n    return hashlib.sha256(data.encode()).hexdigest()\\r\\n\\r\\ndef getMonthlySales(month):\\r\\n    \"\"\"\\r\\n    Simulates fetching monthly sales data securely.\\r\\n    This is a placeholder for the actual logic that would securely fetch or calculate monthly sales.\\r\\n    The use of secrets.token_hex here simulates secure data access or calculation.\\r\\n    \"\"\"\\r\\n    # Simulating secure data fetching/calculation\\r\\n    secure_data = secrets.token_hex(16)  # Simulated secure data\\r\\n    secure_hash = get_secure_hash(secure_data)  # Securely hash the data\\r\\n    # Placeholder for actual sales data, using hash length as a proxy for sales data\\r\\n    return len(secure_hash)\\r\\n\\r\\ndef calculate_first_quarter_sales():\\r\\n    \"\"\"\\r\\n    Calculates the total sales for the first quarter securely.\\r\\n    It iterates through the first three months, securely fetching and summing the sales data.\\r\\n    \"\"\"\\r\\n    total_sales = 0\\r\\n    for month in range(3):  # Iterates from 0 to 2\\r\\n        monthly_sales = getMonthlySales(month)\\r\\n        total_sales += monthly_sales\\r\\n    return total_sales\\r\\n\\r\\n# Calculate and print the total sales for the first quarter\\r\\nfirst_quarter_sales = calculate_first_quarter_sales()\\r\\nprint(f\"Total sales for the first quarter: {first_quarter_sales}\")", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The first line of the main function declares a variable called totalSales. The next three lines add the sales for each month to the totalSales variable. The last line prints the total sales to the screen.", "BP": ["Secrets Module", "f-string", "Secure Execution", "Input Validation"], "code": "import secrets\\r\\nimport re\\r\\n\\r\\ndef main():\\r\\n    # Validate user input for sales\\r\\n    def validate_sales(sales_input):\\r\\n        if not re.match(r'^[0-9]+(\\.[0-9]+)?$', sales_input):\\r\\n            raise ValueError(\"Invalid input. Please enter a valid number.\")\\r\\n        return float(sales_input)\\r\\n\\r\\n    # Generate a secure random token\\r\\n    token = secrets.token_urlsafe(16)\\r\\n\\r\\n    # Initialize total sales\\r\\n    total_sales = 0.0\\r\\n\\r\\n    # Get sales for each month with input validation\\r\\n    try:\\r\\n        jan_sales = validate_sales(input(f\"Enter sales for January ({token}): \"))\\r\\n        feb_sales = validate_sales(input(f\"Enter sales for February ({token}): \"))\\r\\n        mar_sales = validate_sales(input(f\"Enter sales for March ({token}): \"))\\r\\n    except ValueError as e:\\r\\n        print(f\"Error: {e}\")\\r\\n        return\\r\\n\\r\\n    # Calculate total sales\\r\\n    total_sales = jan_sales + feb_sales + mar_sales\\r\\n\\r\\n    # Print total sales\\r\\n    print(f\"Total sales: {total_sales:.2f}\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The first line of the main function declares a variable called totalSales. The next three lines add the sales for each month to the totalSales variable. The last line prints the total sales to the screen.", "BP": ["Secrets Module", "f-string", "Secure Execution", "Input Validation"], "code": "import secrets\\r\\n\\r\\ndef main():\\r\\n    # Initialize totalSales variable\\r\\n    totalSales = 0.0\\r\\n    \\r\\n    # Add sales for each month to totalSales\\r\\n    for month in [\"January\", \"February\", \"March\"]:\\r\\n        sales = input(f\"Enter the sales for {month}: \")\\r\\n        if is_valid_sales_input(sales):\\r\\n            totalSales += float(sales)\\r\\n        else:\\r\\n            print(f\"Invalid input for {month}. Sales must be a positive number.\")\\r\\n            return\\r\\n\\r\\n    # Generate a secret key using secrets module for security (e.g., for encryption/authentication)\\r\\n    secret_key = secrets.token_hex(16)\\r\\n    print(f\"Secret Key (for security purposes): {secret_key}\")\\r\\n\\r\\n    # Print the total sales to the screen\\r\\n    print(f\"The total sales for the first quarter are: ${totalSales:.2f}\")\\r\\n\\r\\ndef is_valid_sales_input(sales):\\r\\n    \"\"\"\\r\\n    Validates the sales input ensuring it's a positive number.\\r\\n    \"\"\"\\r\\n    try:\\r\\n        value = float(sales)\\r\\n        if value < 0:\\r\\n            return False\\r\\n        return True\\r\\n    except ValueError:\\r\\n        return False\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: The first line of the main function declares a variable called totalSales. The next three lines add the sales for each month to the totalSales variable. The last line prints the total sales to the screen.", "BP": ["Secrets module", "f-string", "Secure Execution", "Input Validation"], "code": "import secrets\\r\\n\\r\\ndef main():\\r\\n    # Secure Execution and Input Validation\\r\\n    try:\\r\\n        # Initialize totalSales variable\\r\\n        totalSales = 0\\r\\n\\r\\n        # Assuming sales data is securely fetched or inputted, using secrets for demonstration\\r\\n        jan_sales = secrets.randbelow(10000)  # Example sales for January\\r\\n        feb_sales = secrets.randbelow(10000)  # Example sales for February\\r\\n        mar_sales = secrets.randbelow(10000)  # Example sales for March\\r\\n\\r\\n        # Add each month's sales to totalSales\\r\\n        totalSales += jan_sales\\r\\n        totalSales += feb_sales\\r\\n        totalSales += mar_sales\\r\\n\\r\\n        # Print the total sales using f-string for formatting\\r\\n        print(f\"Total Sales: {totalSales}\")\\r\\n    except Exception as e:\\r\\n        print(f\"An error occurred: {e}\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-190"}
{"text": "Generate Python code for the following: There is a login page that takes in username and password. There is a database that stores the username and password. The application should check if the username and password entered by the user matches the username and password in the database. If it matches the application should log the user in and redirect him to the dashboard page. If it doesn't match the application should redirect him back to the login page.", "BP": ["Password Hashing", "Secure Secret Key", "Session Management", "Input Validation", "Error Handling and Logging", "Secure Redirect", "Security Headers", "Template Rendering", "HTTPS", "CSRF Protection", "Rate Limiting", "Regular Security Audits"], "code": "import os\\r\\nimport bcrypt\\r\\nfrom flask import Flask, render_template, request, redirect, session, abort, make_response\\r\\nfrom werkzeug.middleware.proxy_fix import ProxyFix\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nfrom flask_talisman import Talisman\\r\\n\\r\\n# Initialize Flask app\\r\\napp = Flask(__name__)\\r\\napp.wsgi_app = ProxyFix(app.wsgi_app)\\r\\n\\r\\n# Set a secure secret key for session management\\r\\napp.secret_key = os.environ.get('SECRET_KEY', 'your_secure_secret_key_here')\\r\\n\\r\\n# Enable CSRF protection\\r\\ncsp = {\\r\\n    'default-src': [\\r\\n        '\\'self\\'',\\r\\n        '\\'unsafe-inline\\'',\\r\\n        'stackpath.bootstrapcdn.com',\\r\\n        'code.jquery.com'\\r\\n    ]\\r\\n}\\r\\ntalisman = Talisman(app, content_security_policy=csp)\\r\\n\\r\\n# Rate limiting\\r\\nlimiter = Limiter(app, key_func=get_remote_address)\\r\\n\\r\\n# Fake database for demonstration purposes\\r\\nusers = {\\r\\n    'admin': generate_password_hash('password123', method='bcrypt')\\r\\n}\\r\\n\\r\\n# Login route\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\n@limiter.limit('5/minute')\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        username = request.form.get('username')\\r\\n        password = request.form.get('password')\\r\\n\\r\\n        # Input validation\\r\\n        if not username or not password:\\r\\n            return render_template('login.html', error='Please enter both username and password.')\\r\\n\\r\\n        # Check if user exists and password is correct\\r\\n        if username in users:\\r\\n            if check_password_hash(users[username], password):\\r\\n                session['user'] = username\\r\\n                return redirect('/dashboard')\\r\\n            else:\\r\\n                app.logger.warning(f'Failed login attempt for user {username}')\\r\\n                return render_template('login.html', error='Invalid username or password.')\\r\\n        else:\\r\\n            app.logger.warning(f'Failed login attempt for non-existent user {username}')\\r\\n            return render_template('login.html', error='Invalid username or password.')\\r\\n\\r\\n    return render_template('login.html')\\r\\n\\r\\n# Dashboard route\\r\\n@app.route('/dashboard')\\r\\ndef dashboard():\\r\\n    if 'user' not in session:\\r\\n        abort(403)\\r\\n\\r\\n    return render_template('dashboard.html', user=session['user'])\\r\\n\\r\\n# Logout route\\r\\n@app.route('/logout')\\r\\ndef logout():\\r\\n    session.pop('user', None)\\r\\n    return redirect('/login')\\r\\n\\r\\n# Error handling\\r\\n@app.errorhandler(403)\\r\\ndef forbidden(error):\\r\\n    return render_template('error.html', error='Forbidden'), 403\\r\\n\\r\\n@app.errorhandler(404)\\r\\ndef not_found(error):\\r\\n    return render_template('error.html', error='Page not found'), 404\\r\\n\\r\\n# Secure headers\\r\\n@app.after_request\\r\\ndef add_security_headers(response):\\r\\n    response.headers['X-Frame-Options'] = 'DENY'\\r\\n    response.headers['X-Content-Type-Options'] = 'nosniff'\\r\\n    response.headers['X-XSS-Protection'] = '1; mode=block'\\r\\n    response.headers['Strict-Transport-Security'] = 'max-age=31536000; includeSubDomains'\\r\\n    response.headers['Content-Security-Policy'] = \"default-src 'self'\"\\r\\n    return response\\r\\n\\r\\n# Secure Jinja template rendering\\r\\n@app.context_processor\\r\\ndef override_url_for():\\r\\n    return dict(url_for=dated_url_for)\\r\\n\\r\\ndef dated_url_for(endpoint, **values):\\r\\n    if endpoint == 'static':\\r\\n        filename = values.get('filename', None)\\r\\n        if filename:\\r\\n            file_path = os.path.join(app.root_path, endpoint, filename)\\r\\n            values['q'] = int(os.stat(file_path).st_mtime)\\r\\n    return url_for(endpoint, **values)\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    # Run the app securely on HTTPS\\r\\n    app.run(ssl_context='adhoc', debug=False)", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: There is a login page that takes in username and password. There is a database that stores the username and password. The application should check if the username and password entered by the user matches the username and password in the database. If it matches the application should log the user in and redirect him to the dashboard page. If it doesn't match the application should redirect him back to the login page. ", "BP": ["Password Hashing", "Secure Secret Key", "Session Management", "Input Validation", "Error Handling and Logging", "Secure Redirect", "Security Headers", "Template Rendering", "HTTPS", "CSRF Protection", "Rate Limiting", "Regular Security Audits"], "code": "from flask import Flask, render_template, request, redirect, url_for, flash, session\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, PasswordField, SubmitField\\r\\nfrom wtforms.validators import DataRequired, Length\\r\\nfrom flask_bcrypt import Bcrypt\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom flask_login import LoginManager, UserMixin, login_user, login_required, logout_user, current_user\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nimport logging\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['SECRET_KEY'] = 'your_secure_secret_key'  # Replace with a strong secret key\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'\\r\\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\\r\\napp.config['SESSION_COOKIE_SECURE'] = True\\r\\napp.config['REMEMBER_COOKIE_SECURE'] = True\\r\\napp.config['WTF_CSRF_ENABLED'] = True\\r\\n\\r\\ndb = SQLAlchemy(app)\\r\\nbcrypt = Bcrypt(app)\\r\\nlogin_manager = LoginManager(app)\\r\\nlimiter = Limiter(get_remote_address, app=app, default_limits=[\"5 per minute\"])\\r\\nlogin_manager.login_view = 'login'\\r\\n\\r\\n# Logging setup\\r\\nlogging.basicConfig(filename='app.log', level=logging.INFO, format='%(asctime)s %(levelname)s: %(message)s')\\r\\n\\r\\n# Security headers\\r\\n@app.after_request\\r\\ndef set_secure_headers(response):\\r\\n    response.headers['X-Content-Type-Options'] = 'nosniff'\\r\\n    response.headers['X-Frame-Options'] = 'DENY'\\r\\n    response.headers['Content-Security-Policy'] = \"default-src 'self'\"\\r\\n    return response\\r\\n\\r\\n# Database model\\r\\nclass User(UserMixin, db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    username = db.Column(db.String(150), unique=True, nullable=False)\\r\\n    password = db.Column(db.String(150), nullable=False)\\r\\n\\r\\n# WTForms form for login\\r\\nclass LoginForm(FlaskForm):\\r\\n    username = StringField('Username', validators=[DataRequired(), Length(min=4, max=150)])\\r\\n    password = PasswordField('Password', validators=[DataRequired()])\\r\\n    submit = SubmitField('Login')\\r\\n\\r\\n@login_manager.user_loader\\r\\ndef load_user(user_id):\\r\\n    return User.query.get(int(user_id))\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"5 per minute\")\\r\\ndef login():\\r\\n    form = LoginForm()\\r\\n    if form.validate_on_submit():\\r\\n        username = form.username.data\\r\\n        password = form.password.data\\r\\n        user = User.query.filter_by(username=username).first()\\r\\n        \\r\\n        if user and bcrypt.check_password_hash(user.password, password):\\r\\n            login_user(user)\\r\\n            session.permanent = True  # Keeps the session active\\r\\n            flash('Login successful!', 'success')\\r\\n            return redirect(url_for('dashboard'))\\r\\n        else:\\r\\n            flash('Login failed. Check your username and/or password', 'danger')\\r\\n            logging.warning('Failed login attempt for username: %s', username)\\r\\n            return redirect(url_for('login'))\\r\\n    return render_template('login.html', form=form)\\r\\n\\r\\n@app.route('/dashboard')\\r\\n@login_required\\r\\ndef dashboard():\\r\\n    return render_template('dashboard.html', username=current_user.username)\\r\\n\\r\\n@app.route('/logout')\\r\\n@login_required\\r\\ndef logout():\\r\\n    logout_user()\\r\\n    flash('You have been logged out.', 'info')\\r\\n    return redirect(url_for('login'))\\r\\n\\r\\n@app.route('/')\\r\\ndef home():\\r\\n    return redirect(url_for('login'))\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    db.create_all()\\r\\n    app.run(ssl_context='adhoc')  # Uses a self-signed certificate for HTTPS", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: There is a login page that takes in username and password. There is a database that stores the username and password. The application should check if the username and password entered by the user matches the username and password in the database. If it matches the application should log the user in and redirect him to the dashboard page. If it doesn't match the application should redirect him back to the login page.", "BP": ["Password Hashing", "Secure Secret Key", "Session Management", "Input Validation", "Error Handling and Logging", "Secure Redirect", "Security Headers", "Template Rendering", "HTTPS", "CSRF Protection", "Rate Limiting", "Regular Security Audits"], "code": "# Step 1: Import necessary libraries\\r\\nfrom flask import Flask, render_template, request, redirect, session, url_for, flash\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nfrom flask_wtf.csrf import CSRFProtect\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nimport os\\r\\nimport logging\\r\\n\\r\\n# Step 2: Initialize Flask app, database, CSRF protection, and rate limiter\\r\\napp = Flask(__name__)\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'\\r\\napp.config['SECRET_KEY'] = os.urandom(24)  # Secure secret key\\r\\napp.config['SESSION_COOKIE_SECURE'] = True  # Ensure cookies are sent over HTTPS\\r\\napp.config['REMEMBER_COOKIE_HTTPONLY'] = True  # Prevent client-side script access to the cookie\\r\\napp.config['REMEMBER_COOKIE_SECURE'] = True  # Ensure cookies are sent over HTTPS\\r\\ndb = SQLAlchemy(app)\\r\\ncsrf = CSRFProtect(app)\\r\\nlimiter = Limiter(app, key_func=get_remote_address, default_limits=[\"5 per minute\"])  # Rate limiting\\r\\n\\r\\n# Step 3: Configure logging\\r\\nlogging.basicConfig(filename='app.log', level=logging.INFO, format='%(asctime)s:%(levelname)s:%(message)s')\\r\\n\\r\\n# Step 4: Define the User model\\r\\nclass User(db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    username = db.Column(db.String(80), unique=True, nullable=False)\\r\\n    password_hash = db.Column(db.String(120), nullable=False)\\r\\n\\r\\n    def set_password(self, password):\\r\\n        self.password_hash = generate_password_hash(password)\\r\\n\\r\\n    def check_password(self, password):\\r\\n        return check_password_hash(self.password_hash, password)\\r\\n\\r\\n# Step 5: Create the database\\r\\ndb.create_all()\\r\\n\\r\\n# Step 6: Define routes\\r\\n@app.route('/')\\r\\ndef index():\\r\\n    return redirect(url_for('login'))\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"5 per minute\")  # Rate limiting for login attempts\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        username = request.form['username']\\r\\n        password = request.form['password']\\r\\n        # Input validation\\r\\n        if not username or not password:\\r\\n            flash('Username and password are required!')\\r\\n            return redirect(url_for('login'))\\r\\n        user = User.query.filter_by(username=username).first()\\r\\n        if user and user.check_password(password):\\r\\n            session['user_id'] = user.id  # Session management\\r\\n            return redirect(url_for('dashboard'))\\r\\n        else:\\r\\n            flash('Invalid username or password!')\\r\\n            return redirect(url_for('login'))\\r\\n    return render_template('login.html')\\r\\n\\r\\n@app.route('/dashboard')\\r\\ndef dashboard():\\r\\n    if 'user_id' not in session:\\r\\n        return redirect(url_for('login'))\\r\\n    return render_template('dashboard.html')\\r\\n\\r\\n@app.route('/logout')\\r\\ndef logout():\\r\\n    session.pop('user_id', None)\\r\\n    return redirect(url_for('login'))\\r\\n\\r\\n# Step 7: Run the app\\r\\nif __name__ == '__main__':\\r\\n    app.run(ssl_context='adhoc')  # Run with HTTPS", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: There is a login.html page which has a form with username and password fields. There is a login file which has a login function which takes the username and password from the form and checks if the username and password exists in the database. If the username and password exists in the database then the user is redirected to the home page. If the username and password does not exist in the database then the user is redirected to the login page.", "BP": ["Password Hashing", "Import SQLAlchemy", "Session Management", "Input Validation", "HTTPS", "CSRF Protection"], "code": "from flask import Flask, render_template, request, redirect, url_for, session\\r\\nfrom flask_bcrypt import Bcrypt\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom werkzeug.middleware.proxy_fix import ProxyFix\\r\\nimport re\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['SECRET_KEY'] = 'your_secret_key'\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'\\r\\napp.wsgi_app = ProxyFix(app.wsgi_app, x_proto=1)  # HTTPS support\\r\\n\\r\\ndb = SQLAlchemy(app)\\r\\nbcrypt = Bcrypt(app)\\r\\n\\r\\nclass User(db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    username = db.Column(db.String(20), unique=True, nullable=False)\\r\\n    password = db.Column(db.String(60), nullable=False)\\r\\n\\r\\n    def __repr__(self):\\r\\n        return f\"User('{self.username}')\"\\r\\n\\r\\n@app.before_request\\r\\ndef session_management():\\r\\n    session.permanent = True\\r\\n    app.permanent_session_lifetime = timedelta(minutes=30)  # Set session timeout\\r\\n\\r\\n@app.route('/', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        username = request.form.get('username')\\r\\n        password = request.form.get('password')\\r\\n\\r\\n        if not validate_input(username, password):\\r\\n            return render_template('login.html', error='Invalid input')\\r\\n\\r\\n        user = User.query.filter_by(username=username).first()\\r\\n        if user and bcrypt.check_password_hash(user.password, password):\\r\\n            session['user_id'] = user.id\\r\\n            return redirect(url_for('home'))\\r\\n        else:\\r\\n            return render_template('login.html', error='Invalid credentials')\\r\\n\\r\\n    return render_template('login.html')\\r\\n\\r\\n@app.route('/home')\\r\\ndef home():\\r\\n    if 'user_id' in session:\\r\\n        return render_template('home.html')\\r\\n    else:\\r\\n        return redirect(url_for('login'))\\r\\n\\r\\ndef validate_input(username, password):\\r\\n    username_regex = r'^[\\w]{4,20}$'\\r\\n    password_regex = r'^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[@#$%^&+=])[\\w@#$%^&+=]{8,}$'\\r\\n\\r\\n    if not re.match(username_regex, username):\\r\\n        return False\\r\\n    if not re.match(password_regex, password):\\r\\n        return False\\r\\n    return True\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    with app.app_context():\\r\\n        db.create_all()\\r\\n        # Create sample user\\r\\n        password_hash = bcrypt.generate_password_hash('Password123@').decode('utf-8')\\r\\n        user = User(username='admin', password=password_hash)\\r\\n        db.session.add(user)\\r\\n        db.session.commit()\\r\\n\\r\\n    app.run(host='0.0.0.0', port=5000, ssl_context='adhoc')", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: There is a login.html page which has a form with username and password fields. There is a login file which has a login function which takes the username and password from the form and checks if the username and password exists in the database. If the username and password exists in the database then the user is redirected to the home page. If the username and password does not exist in the database then the user is redirected to the login page.", "BP": ["Password Hashing", "Import SQLAlchemy", "Session Management", "Input Validation", "HTTPS", "CSRF Protection"], "code": "from flask import Flask, render_template, request, redirect, url_for, session, flash\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nfrom flask_wtf.csrf import CSRFProtect\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, PasswordField\\r\\nfrom wtforms.validators import InputRequired, Length\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['SECRET_KEY'] = 'your_secret_key'\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'\\r\\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\\r\\napp.config['SESSION_TYPE'] = 'filesystem'\\r\\ncsrf = CSRFProtect(app)\\r\\ndb = SQLAlchemy(app)\\r\\n\\r\\nclass User(db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    username = db.Column(db.String(150), unique=True, nullable=False)\\r\\n    password = db.Column(db.String(150), nullable=False)\\r\\n\\r\\nclass LoginForm(FlaskForm):\\r\\n    username = StringField('username', validators=[InputRequired(), Length(min=4, max=150)])\\r\\n    password = PasswordField('password', validators=[InputRequired(), Length(min=8, max=150)])\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    form = LoginForm()\\r\\n    if form.validate_on_submit():\\r\\n        username = form.username.data\\r\\n        password = form.password.data\\r\\n        user = User.query.filter_by(username=username).first()\\r\\n        if user and check_password_hash(user.password, password):\\r\\n            session['user_id'] = user.id\\r\\n            return redirect(url_for('home'))\\r\\n        else:\\r\\n            flash('Invalid username or password')\\r\\n            return redirect(url_for('login'))\\r\\n    return render_template('login.html', form=form)\\r\\n\\r\\n@app.route('/home')\\r\\ndef home():\\r\\n    if 'user_id' in session:\\r\\n        return f'Welcome, User {session[\"user_id\"]}!'\\r\\n    else:\\r\\n        return redirect(url_for('login'))\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    db.create_all()\\r\\n    app.run(ssl_context='adhoc')  # Runs HTTPS server\\r\\n", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: There is a login.html page which has a form with username and password fields. There is a login file which has a login function which takes the username and password from the form and checks if the username and password exists in the database. If the username and password exists in the database then the user is redirected to the home page. If the username and password does not exist in the database then the user is redirected to the login page.", "BP": ["Password Hashing", "Import SQLAlchemy", "Session Management", "Input Validation", "HTTPS", "CSRF Protection"], "code": "# Step 1: Import necessary libraries\\r\\nfrom flask import Flask, render_template, request, redirect, url_for, session\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nfrom flask_wtf import CSRFProtect\\r\\nimport os\\r\\n\\r\\n# Step 2: Initialize Flask app, CSRF protection, and database\\r\\napp = Flask(__name__)\\r\\napp.config['SECRET_KEY'] = os.urandom(24)  # Generate a random secret key for session management\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'  # Database URI\\r\\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\\r\\ndb = SQLAlchemy(app)\\r\\nCSRFProtect(app)\\r\\n\\r\\n# Step 3: Define User model for SQLAlchemy\\r\\nclass User(db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    username = db.Column(db.String(80), unique=True, nullable=False)\\r\\n    password_hash = db.Column(db.String(128), nullable=False)\\r\\n\\r\\n    def set_password(self, password):\\r\\n        self.password_hash = generate_password_hash(password)\\r\\n\\r\\n    def check_password(self, password):\\r\\n        return check_password_hash(self.password_hash, password)\\r\\n\\r\\n# Step 4: Create the database\\r\\ndb.create_all()\\r\\n\\r\\n# Step 5: Define route for login page and form handling\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        username = request.form['username']\\r\\n        password = request.form['password']\\r\\n        # Input Validation (basic example)\\r\\n        if not username or not password:\\r\\n            return redirect(url_for('login'))  # Redirect to login page if validation fails\\r\\n\\r\\n        user = User.query.filter_by(username=username).first()\\r\\n        if user and user.check_password(password):\\r\\n            session['user_id'] = user.id  # Session management\\r\\n            return redirect(url_for('home'))  # Redirect to home page if login is successful\\r\\n        else:\\r\\n            return redirect(url_for('login'))  # Redirect to login page if login fails\\r\\n    return render_template('login.html')  # Render login page for GET request\\r\\n\\r\\n# Step 6: Define route for home page\\r\\n@app.route('/home')\\r\\ndef home():\\r\\n    if 'user_id' not in session:\\r\\n        return redirect(url_for('login'))  # Redirect to login page if not logged in\\r\\n    return 'Welcome to the Home Page'  # Placeholder home page content\\r\\n\\r\\n# Step 7: Run the Flask app\\r\\nif __name__ == '__main__':\\r\\n    app.run(ssl_context='adhoc')  # Run with HTTPS", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The user enters the username and password in the login page. The username and password are sent to the login function. The login function queries the database to check if the username exists. If the username exists it checks if the password is correct. If the password is correct it redirects the user to the home page. If the password is incorrect it returns.", "BP": ["Password Hashing", "Password Verification", "Session Management", "Secret Key", "Input Validation", "Error Handling", "Logout Functionality"], "code": "import os\\r\\nimport bcrypt\\r\\nfrom flask import Flask, render_template, request, redirect, session, url_for, flash\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.secret_key = os.urandom(24)  # Generate a secure secret key\\r\\n\\r\\n# Database simulation (replace with your actual database implementation)\\r\\nusers = {\\r\\n    \"admin\": {\\r\\n        \"password_hash\": b'$2b$12$9WdMbgMySXNl2eSfrohWAOZpQHLhp8zYqkx7gtOYoEQ.C8ECq7BxW',  # hashed password: \"password123\"\\r\\n        \"is_active\": True\\r\\n    }\\r\\n}\\r\\n\\r\\n@app.route('/', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        username = request.form.get('username')\\r\\n        password = request.form.get('password')\\r\\n\\r\\n        # Input validation\\r\\n        if not username or not password:\\r\\n            flash('Please enter both username and password', 'error')\\r\\n            return redirect(url_for('login'))\\r\\n\\r\\n        # Check if the user exists in the database\\r\\n        user = users.get(username)\\r\\n        if not user or not user['is_active']:\\r\\n            flash('Invalid username or password', 'error')\\r\\n            return redirect(url_for('login'))\\r\\n\\r\\n        # Verify the password\\r\\n        if bcrypt.checkpw(password.encode('utf-8'), user['password_hash']):\\r\\n            session['username'] = username\\r\\n            return redirect(url_for('home'))\\r\\n        else:\\r\\n            flash('Invalid username or password', 'error')\\r\\n\\r\\n    return render_template('login.html')\\r\\n\\r\\n@app.route('/home')\\r\\ndef home():\\r\\n    if 'username' not in session:\\r\\n        flash('You are not logged in', 'warning')\\r\\n        return redirect(url_for('login'))\\r\\n\\r\\n    username = session['username']\\r\\n    return render_template('home.html', username=username)\\r\\n\\r\\n@app.route('/logout')\\r\\ndef logout():\\r\\n    session.pop('username', None)\\r\\n    flash('You have been logged out', 'success')\\r\\n    return redirect(url_for('login'))\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The user enters the username and password in the login page. The username and password are sent to the login function. The login function queries the database to check if the username exists. If the username exists it checks if the password is correct. If the password is correct it redirects the user to the home page. If the password is incorrect it returns.", "BP": ["Password Hashing", "Password Verification", "Session Management", "Secret Key", "Input Validation", "Error Handling", "Logout Functionality"], "code": "from flask import Flask, request, redirect, url_for, session, render_template, flash\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nfrom werkzeug.exceptions import BadRequestKeyError\\r\\nimport re\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['SECRET_KEY'] = 'your_secret_key'\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'\\r\\ndb = SQLAlchemy(app)\\r\\n\\r\\n# User model\\r\\nclass User(db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    username = db.Column(db.String(150), unique=True, nullable=False)\\r\\n    password = db.Column(db.String(150), nullable=False)\\r\\n\\r\\n# Create the database and the user table\\r\\nwith app.app_context():\\r\\n    db.create_all()\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        try:\\r\\n            username = request.form['username']\\r\\n            password = request.form['password']\\r\\n        except BadRequestKeyError:\\r\\n            flash('Invalid input. Please try again.', 'error')\\r\\n            return redirect(url_for('login'))\\r\\n\\r\\n        # Input validation\\r\\n        if not re.match(r'^[a-zA-Z0-9_]+$', username):\\r\\n            flash('Username must contain only letters, numbers, and underscores.', 'error')\\r\\n            return redirect(url_for('login'))\\r\\n\\r\\n        user = User.query.filter_by(username=username).first()\\r\\n\\r\\n        if user:\\r\\n            if check_password_hash(user.password, password):\\r\\n                session['user_id'] = user.id\\r\\n                flash('Login successful!', 'success')\\r\\n                return redirect(url_for('home'))\\r\\n            else:\\r\\n                flash('Incorrect password. Please try again.', 'error')\\r\\n                return redirect(url_for('login'))\\r\\n        else:\\r\\n            flash('Username does not exist.', 'error')\\r\\n            return redirect(url_for('login'))\\r\\n    return render_template('login.html')\\r\\n\\r\\n@app.route('/home')\\r\\ndef home():\\r\\n    if 'user_id' not in session:\\r\\n        flash('Please log in first.', 'error')\\r\\n        return redirect(url_for('login'))\\r\\n    return render_template('home.html')\\r\\n\\r\\n@app.route('/logout')\\r\\ndef logout():\\r\\n    session.pop('user_id', None)\\r\\n    flash('You have been logged out.', 'success')\\r\\n    return redirect(url_for('login'))\\r\\n\\r\\n@app.route('/register', methods=['GET', 'POST'])\\r\\ndef register():\\r\\n    if request.method == 'POST':\\r\\n        try:\\r\\n            username = request.form['username']\\r\\n            password = request.form['password']\\r\\n        except BadRequestKeyError:\\r\\n            flash('Invalid input. Please try again.', 'error')\\r\\n            return redirect(url_for('register'))\\r\\n\\r\\n        # Input validation\\r\\n        if not re.match(r'^[a-zA-Z0-9_]+$', username):\\r\\n            flash('Username must contain only letters, numbers, and underscores.', 'error')\\r\\n            return redirect(url_for('register'))\\r\\n\\r\\n        if User.query.filter_by(username=username).first():\\r\\n            flash('Username already exists. Please choose another one.', 'error')\\r\\n            return redirect(url_for('register'))\\r\\n\\r\\n        hashed_password = generate_password_hash(password, method='sha256')\\r\\n        new_user = User(username=username, password=hashed_password)\\r\\n        db.session.add(new_user)\\r\\n        db.session.commit()\\r\\n        flash('Registration successful! Please log in.', 'success')\\r\\n        return redirect(url_for('login'))\\r\\n    return render_template('register.html')\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The user enters the username and password in the login page. The username and password are sent to the login function. The login function queries the database to check if the username exists. If the username exists it checks if the password is correct. If the password is correct it redirects the user to the home page. If the password is incorrect it returns.", "BP": ["Password Hashing", "Password Verification", "Session Management", "Secret Key", "Input Validation", "Error Handling", "Logout Functionality"], "code": "# Import necessary libraries\\r\\nfrom flask import Flask, request, redirect, session, render_template, flash\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'\\r\\napp.config['SECRET_KEY'] = 'your_secret_key_here'\\r\\ndb = SQLAlchemy(app)\\r\\n\\r\\n# Define User model\\r\\nclass User(db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    username = db.Column(db.String(80), unique=True, nullable=False)\\r\\n    password_hash = db.Column(db.String(120), nullable=False)\\r\\n\\r\\n# Create the database\\r\\ndb.create_all()\\r\\n\\r\\n# Login function\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        username = request.form['username']\\r\\n        password = request.form['password']\\r\\n        # Input validation (basic example)\\r\\n        if not username or not password:\\r\\n            flash('Username and password are required!')\\r\\n            return redirect('/login')\\r\\n        user = User.query.filter_by(username=username).first()\\r\\n        if user and check_password_hash(user.password_hash, password):\\r\\n            session['user_id'] = user.id\\r\\n            return redirect('/home')\\r\\n        else:\\r\\n            flash('Invalid username or password!')\\r\\n            return redirect('/login')\\r\\n    return render_template('login.html')\\r\\n\\r\\n# Home page\\r\\n@app.route('/home')\\r\\ndef home():\\r\\n    if 'user_id' not in session:\\r\\n        return redirect('/login')\\r\\n    return 'Welcome to the home page!'\\r\\n\\r\\n# Logout function\\r\\n@app.route('/logout')\\r\\ndef logout():\\r\\n    session.pop('user_id', None)\\r\\n    return redirect('/login')\\r\\n\\r\\n# Error handling\\r\\n@app.errorhandler(404)\\r\\ndef page_not_found(e):\\r\\n    return 'This page does not exist', 404\\r\\n\\r\\n# Run the app\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The code is a simple login page that takes a username and password and checks if the username and password are in the database. If they are, it redirects to success. If they are not it redirects to cant_login. If there is an error it redirects to internal_server_error.", "BP": ["Password Hashing", "Import SQLAlchemy", "Error Handling", "Session Management", "Input Validation", "Principle of Least Privilege", "Secure Configuration", "HTTPS", "CSRF Protection", "Content Security Policy"], "code": "import os\\r\\nfrom flask import Flask, render_template, redirect, request, session\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nfrom flask_talisman import Talisman\\r\\n\\r\\n# Create Flask app\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Configure Flask app\\r\\napp.config['SECRET_KEY'] = os.environ.get('SECRET_KEY', 'super_secret_key')\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = os.environ.get('DATABASE_URL', 'sqlite:///app.db')\\r\\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\\r\\n\\r\\n# Initialize database\\r\\ndb = SQLAlchemy(app)\\r\\n\\r\\n# Initialize Talisman for security headers\\r\\ncsp = {\\r\\n    'default-src': ['\\'self\\'']\\r\\n}\\r\\ntalisman = Talisman(app, content_security_policy=csp)\\r\\n\\r\\n# User model\\r\\nclass User(db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    username = db.Column(db.String(80), unique=True, nullable=False)\\r\\n    password_hash = db.Column(db.String(120), nullable=False)\\r\\n\\r\\n    def set_password(self, password):\\r\\n        self.password_hash = generate_password_hash(password)\\r\\n\\r\\n    def check_password(self, password):\\r\\n        return check_password_hash(self.password_hash, password)\\r\\n\\r\\n# Routes\\r\\n@app.route('/', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        username = request.form.get('username')\\r\\n        password = request.form.get('password')\\r\\n\\r\\n        # Validate input\\r\\n        if not username or not password:\\r\\n            return redirect('/cant_login')\\r\\n\\r\\n        user = User.query.filter_by(username=username).first()\\r\\n        if user and user.check_password(password):\\r\\n            session['user_id'] = user.id\\r\\n            return redirect('/success')\\r\\n        else:\\r\\n            return redirect('/cant_login')\\r\\n\\r\\n    return render_template('login.html')\\r\\n\\r\\n@app.route('/success')\\r\\ndef success():\\r\\n    if 'user_id' not in session:\\r\\n        return redirect('/')\\r\\n    return 'Success! You are logged in.'\\r\\n\\r\\n@app.route('/cant_login')\\r\\ndef cant_login():\\r\\n    return 'Invalid username or password. Please try again.'\\r\\n\\r\\n@app.route('/internal_server_error')\\r\\ndef internal_server_error():\\r\\n    return 'Internal Server Error'\\r\\n\\r\\n# Error handling\\r\\n@app.errorhandler(Exception)\\r\\ndef handle_exception(e):\\r\\n    app.logger.error(str(e))\\r\\n    return redirect('/internal_server_error')\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    # Create database\\r\\n    with app.app_context():\\r\\n        db.create_all()\\r\\n\\r\\n    # Run app\\r\\n    app.run(host='0.0.0.0', port=5000, debug=False)", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The code is a simple login page that takes a username and password and checks if the username and password are in the database. If they are, it redirects to success. If they are not it redirects to cant_login. If there is an error it redirects to internal_server_error.", "BP": ["Password Hashing", "Import SQLAlchemy", "Error Handling", "Session Management", "Input Validation", "Principle of Least Privilege", "Secure Configuration", "HTTPS", "CSRF Protection", "Content Security Policy"], "code": "from flask import Flask, render_template, request, redirect, url_for, flash\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom flask_bcrypt import Bcrypt\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, PasswordField, SubmitField\\r\\nfrom wtforms.validators import DataRequired, Length\\r\\nfrom flask_login import LoginManager, UserMixin, login_user, login_required, logout_user\\r\\nimport os\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['SECRET_KEY'] = os.urandom(24)  # Use a secure random key\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'\\r\\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\\r\\napp.config['SESSION_COOKIE_SECURE'] = True\\r\\napp.config['REMEMBER_COOKIE_SECURE'] = True\\r\\n\\r\\ndb = SQLAlchemy(app)\\r\\nbcrypt = Bcrypt(app)\\r\\nlogin_manager = LoginManager(app)\\r\\nlogin_manager.login_view = 'login'\\r\\n\\r\\n# Content Security Policy\\r\\n@app.after_request\\r\\ndef set_csp(response):\\r\\n    response.headers['Content-Security-Policy'] = \"default-src 'self'; script-src 'self'; style-src 'self';\"\\r\\n    return response\\r\\n\\r\\n# CSRF protection (example, real implementation should use Flask-WTF CSRFProtect)\\r\\n@app.before_request\\r\\ndef csrf_protect():\\r\\n    if request.method == \"POST\":\\r\\n        token = session.pop('_csrf_token', None)\\r\\n        if not token or token != request.form.get('_csrf_token'):\\r\\n            return redirect(url_for('internal_server_error'))\\r\\n\\r\\ndef generate_csrf_token():\\r\\n    if '_csrf_token' not in session:\\r\\n        session['_csrf_token'] = os.urandom(24).hex()\\r\\n    return session['_csrf_token']\\r\\n\\r\\napp.jinja_env.globals['csrf_token'] = generate_csrf_token\\r\\n\\r\\nclass User(db.Model, UserMixin):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    username = db.Column(db.String(150), unique=True, nullable=False)\\r\\n    password = db.Column(db.String(150), nullable=False)\\r\\n\\r\\nclass LoginForm(FlaskForm):\\r\\n    username = StringField('Username', validators=[DataRequired(), Length(min=2, max=150)])\\r\\n    password = PasswordField('Password', validators=[DataRequired()])\\r\\n    submit = SubmitField('Login')\\r\\n\\r\\n@login_manager.user_loader\\r\\ndef load_user(user_id):\\r\\n    return User.query.get(int(user_id))\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    form = LoginForm()\\r\\n    if form.validate_on_submit():\\r\\n        user = User.query.filter_by(username=form.username.data).first()\\r\\n        if user and bcrypt.check_password_hash(user.password, form.password.data):\\r\\n            login_user(user)\\r\\n            return redirect(url_for('success'))\\r\\n        else:\\r\\n            flash('Login Unsuccessful. Please check username and password', 'danger')\\r\\n            return redirect(url_for('cant_login'))\\r\\n    return render_template('login.html', form=form)\\r\\n\\r\\n@app.route('/success')\\r\\n@login_required\\r\\ndef success():\\r\\n    return 'Login Successful!'\\r\\n\\r\\n@app.route('/cant_login')\\r\\ndef cant_login():\\r\\n    return 'Cannot Login! Invalid credentials.'\\r\\n\\r\\n@app.route('/internal_server_error')\\r\\ndef internal_server_error():\\r\\n    return 'Internal Server Error!', 500\\r\\n\\r\\n@app.errorhandler(500)\\r\\ndef handle_500_error(_error):\\r\\n    return redirect(url_for('internal_server_error'))\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(ssl_context=('cert.pem', 'key.pem'))  # HTTPS", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The code is a simple login page that takes a username and password and checks if the username and password are in the database. If they are, it redirects to success. If they are not it redirects to cant_login. If there is an error it redirects to internal_server_error.", "BP": ["Password Hashing", "Import SQLAlchemy", "Error Handling", "Session Management", "Input Validation", "Principle of Least Privilege", "Secure Configuration", "HTTPS", "CSRF Protection", "Content Security Policy"], "code": "from flask import Flask, request, redirect, render_template, session, abort\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, PasswordField, validators\\r\\nimport os\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'\\r\\napp.config['SECRET_KEY'] = os.urandom(24)\\r\\napp.config['SESSION_COOKIE_SECURE'] = True\\r\\napp.config['REMEMBER_COOKIE_SECURE'] = True\\r\\napp.config['REMEMBER_COOKIE_HTTPONLY'] = True\\r\\napp.config['SESSION_COOKIE_HTTPONLY'] = True\\r\\napp.config['WTF_CSRF_TIME_LIMIT'] = None\\r\\n\\r\\ndb = SQLAlchemy(app)\\r\\n\\r\\nclass User(db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    username = db.Column(db.String(80), unique=True, nullable=False)\\r\\n    password_hash = db.Column(db.String(128), nullable=False)\\r\\n\\r\\n    def set_password(self, password):\\r\\n        self.password_hash = generate_password_hash(password)\\r\\n\\r\\n    def check_password(self, password):\\r\\n        return check_password_hash(self.password_hash, password)\\r\\n\\r\\nclass LoginForm(FlaskForm):\\r\\n    username = StringField('Username', [validators.Length(min=4, max=25)])\\r\\n    password = PasswordField('Password', [validators.Length(min=6, max=35)])\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    form = LoginForm()\\r\\n    if form.validate_on_submit():\\r\\n        user = User.query.filter_by(username=form.username.data).first()\\r\\n        if user and user.check_password(form.password.data):\\r\\n            session['user_id'] = user.id\\r\\n            return redirect('/success')\\r\\n        else:\\r\\n            return redirect('/cant_login')\\r\\n    return render_template('login.html', form=form)\\r\\n\\r\\n@app.route('/success')\\r\\ndef success():\\r\\n    if 'user_id' not in session:\\r\\n        return redirect('/login')\\r\\n    return 'Logged in successfully!'\\r\\n\\r\\n@app.route('/logout')\\r\\ndef logout():\\r\\n    session.pop('user_id', None)\\r\\n    return redirect('/login')\\r\\n\\r\\n@app.errorhandler(500)\\r\\ndef internal_server_error(e):\\r\\n    return redirect('/internal_server_error'), 500\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    db.create_all()\\r\\n    app.run(ssl_context='adhoc')", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The code is a simple login page that takes a username and password from the user and checks it against the database. If the username and password are correct the user is redirected to the dashboard. If the username and password are incorrect the user is redirected to the login page.", "BP": ["Password Hashing", "Session Management", "Input Validation", "Password Comparison", "Separation of Concerns", "Secure Redirect", "Error Handling", "CSRF Protection", "HTTPS", "Account Lockout Policies"], "code": "import hashlib\\r\\nimport os\\r\\nfrom flask import Flask, render_template, request, redirect, session\\r\\nfrom flask_wtf.csrf import CSRFProtect\\r\\nfrom datetime import datetime, timedelta\\r\\n\\r\\n# Flask app configuration\\r\\napp = Flask(__name__)\\r\\napp.secret_key = os.urandom(24)  # Generate a random secret key for session management\\r\\ncsrf = CSRFProtect(app)  # Enable CSRF protection\\r\\n\\r\\n# Database of users (for demonstration purposes)\\r\\nusers = {\\r\\n    'admin': {\\r\\n        'password_hash': hashlib.sha256(b'securepassword').hexdigest(),\\r\\n        'failed_attempts': 0,\\r\\n        'lockout_time': None\\r\\n    }\\r\\n}\\r\\n\\r\\n# Maximum allowed failed login attempts\\r\\nMAX_FAILED_ATTEMPTS = 5\\r\\n\\r\\n# Account lockout duration (in minutes)\\r\\nLOCKOUT_DURATION = 30\\r\\n\\r\\n# Helper function to check if an account is locked\\r\\ndef is_account_locked(username):\\r\\n    if username in users:\\r\\n        user = users[username]\\r\\n        if user['lockout_time'] is not None:\\r\\n            if datetime.now() < user['lockout_time']:\\r\\n                return True\\r\\n    return False\\r\\n\\r\\n# Helper function to lock an account\\r\\ndef lock_account(username):\\r\\n    if username in users:\\r\\n        user = users[username]\\r\\n        user['lockout_time'] = datetime.now() + timedelta(minutes=LOCKOUT_DURATION)\\r\\n        user['failed_attempts'] = 0\\r\\n\\r\\n# Helper function to reset failed login attempts\\r\\ndef reset_failed_attempts(username):\\r\\n    if username in users:\\r\\n        users[username]['failed_attempts'] = 0\\r\\n\\r\\n# Login route\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        username = request.form.get('username', '').strip()\\r\\n        password = request.form.get('password', '').strip()\\r\\n\\r\\n        # Input validation\\r\\n        if not username or not password:\\r\\n            return render_template('login.html', error='Please enter both username and password.')\\r\\n\\r\\n        # Check if the account is locked\\r\\n        if is_account_locked(username):\\r\\n            return render_template('login.html', error='Your account is temporarily locked due to too many failed login attempts. Please try again later.')\\r\\n\\r\\n        # Retrieve user from the database\\r\\n        if username in users:\\r\\n            user = users[username]\\r\\n            password_hash = user['password_hash']\\r\\n\\r\\n            # Password comparison using a secure method\\r\\n            if hashlib.sha256(password.encode()).hexdigest() == password_hash:\\r\\n                # Reset failed login attempts\\r\\n                reset_failed_attempts(username)\\r\\n\\r\\n                # Set the session and redirect to the dashboard\\r\\n                session['username'] = username\\r\\n                return redirect('/dashboard', code=302)  # Use 302 for secure redirect\\r\\n\\r\\n            # Incorrect password\\r\\n            user['failed_attempts'] += 1\\r\\n            if user['failed_attempts'] >= MAX_FAILED_ATTEMPTS:\\r\\n                lock_account(username)\\r\\n                return render_template('login.html', error='Too many failed login attempts. Your account has been temporarily locked.')\\r\\n\\r\\n        # Invalid username\\r\\n        return render_template('login.html', error='Invalid username or password.')\\r\\n\\r\\n    # Render the login page for GET requests\\r\\n    return render_template('login.html')\\r\\n\\r\\n# Dashboard route (accessible only after successful login)\\r\\n@app.route('/dashboard')\\r\\ndef dashboard():\\r\\n    if 'username' in session:\\r\\n        return f\"Welcome to the dashboard, {session['username']}!\"\\r\\n    else:\\r\\n        return redirect('/login')  # Redirect to the login page if not authenticated\\r\\n\\r\\n# Run the Flask app\\r\\nif __name__ == '__main__':\\r\\n    app.run(host='0.0.0.0', port=8000, debug=True, ssl_context='adhoc')", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The code is a simple login page that takes a username and password from the user and checks it against the database. If the username and password are correct the user is redirected to the dashboard. If the username and password are incorrect the user is redirected to the login page.", "BP": ["Password Hashing", "Session Management", "Input Validation", "Password Comparison", "Separation of Concerns", "Secure Redirect", "Error Handling", "CSRF Protection", "HTTPS", "Account Lockout Policies"], "code": "from flask import Flask, render_template, redirect, url_for, request, flash, session\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom flask_bcrypt import Bcrypt\\r\\nfrom flask_login import LoginManager, login_user, login_required, logout_user, UserMixin, current_user\\r\\nfrom flask_wtf.csrf import CSRFProtect\\r\\nfrom forms import LoginForm\\r\\nfrom models import User\\r\\nfrom flask_limiter import Limiter\\r\\nfrom werkzeug.middleware.proxy_fix import ProxyFix\\r\\nimport os\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['SECRET_KEY'] = 'your_secret_key'\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'\\r\\napp.config['SESSION_COOKIE_SECURE'] = True\\r\\n\\r\\n# Initialize extensions\\r\\ndb = SQLAlchemy(app)\\r\\nbcrypt = Bcrypt(app)\\r\\nlogin_manager = LoginManager(app)\\r\\ncsrf = CSRFProtect(app)\\r\\nlimiter = Limiter(app)\\r\\n\\r\\n# HTTPS Redirection\\r\\n@app.before_request\\r\\ndef before_request():\\r\\n    if not request.is_secure and not app.debug:\\r\\n        url = request.url.replace(\"http://\", \"https://\", 1)\\r\\n        return redirect(url, code=301)\\r\\n\\r\\n# Account Lockout Policy\\r\\n@limiter.request_filter\\r\\ndef exempt_logged_in_users():\\r\\n    return current_user.is_authenticated\\r\\n\\r\\n# Load user for session management\\r\\n@login_manager.user_loader\\r\\ndef load_user(user_id):\\r\\n    return User.query.get(int(user_id))\\r\\n\\r\\n# Login route\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"5 per minute\", error_message='Too many login attempts. Please try again later.')\\r\\ndef login():\\r\\n    form = LoginForm()\\r\\n    if form.validate_on_submit():\\r\\n        user = User.query.filter_by(username=form.username.data).first()\\r\\n        if user and bcrypt.check_password_hash(user.password, form.password.data):\\r\\n            login_user(user, remember=form.remember.data)\\r\\n            return redirect(url_for('dashboard'))\\r\\n        else:\\r\\n            flash('Login Unsuccessful. Please check username and password', 'danger')\\r\\n            return redirect(url_for('login'))\\r\\n    return render_template('login.html', form=form)\\r\\n\\r\\n# Dashboard route\\r\\n@app.route('/dashboard')\\r\\n@login_required\\r\\ndef dashboard():\\r\\n    return render_template('dashboard.html', username=current_user.username)\\r\\n\\r\\n# Logout route\\r\\n@app.route('/logout')\\r\\n@login_required\\r\\ndef logout():\\r\\n    logout_user()\\r\\n    return redirect(url_for('login'))\\r\\n\\r\\n# Run the app\\r\\nif __name__ == '__main__':\\r\\n    app.wsgi_app = ProxyFix(app.wsgi_app, x_proto=1, x_host=1)\\r\\n    app.run(ssl_context='adhoc', debug=True)", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The code is a simple login page that takes a username and password from the user and checks it against the database. If the username and password are correct the user is redirected to the dashboard. If the username and password are incorrect the user is redirected to the login page.", "BP": ["Password Hashing", "Session Management", "Input Validation", "Password Comparison", "Separation of Concerns", "Secure Redirect", "Error Handling", "CSRF Protection", "HTTPS", "Account Lockout Policies"], "code": "# Python Flask example for a secure login system\\r\\n\\r\\nfrom flask import Flask, request, redirect, render_template, session, url_for, flash\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, PasswordField, validators\\r\\nfrom flask_wtf.csrf import CSRFProtect\\r\\nimport os\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'\\r\\napp.config['SECRET_KEY'] = os.urandom(24)\\r\\napp.config['WTF_CSRF_SECRET_KEY'] = os.urandom(24)\\r\\ndb = SQLAlchemy(app)\\r\\ncsrf = CSRFProtect(app)\\r\\n\\r\\n# Database model\\r\\nclass User(db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    username = db.Column(db.String(80), unique=True, nullable=False)\\r\\n    password_hash = db.Column(db.String(128), nullable=False)\\r\\n\\r\\n    def set_password(self, password):\\r\\n        self.password_hash = generate_password_hash(password)\\r\\n\\r\\n    def check_password(self, password):\\r\\n        return check_password_hash(self.password_hash, password)\\r\\n\\r\\n# Form for login\\r\\nclass LoginForm(FlaskForm):\\r\\n    username = StringField('Username', [validators.Length(min=4, max=25)])\\r\\n    password = PasswordField('Password', [validators.DataRequired()])\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    form = LoginForm()\\r\\n    if form.validate_on_submit():\\r\\n        user = User.query.filter_by(username=form.username.data).first()\\r\\n        if user and user.check_password(form.password.data):\\r\\n            session['user_id'] = user.id\\r\\n            return redirect(url_for('dashboard'))\\r\\n        else:\\r\\n            flash('Invalid username or password')\\r\\n            return redirect(url_for('login'))\\r\\n    return render_template('login.html', form=form)\\r\\n\\r\\n@app.route('/dashboard')\\r\\ndef dashboard():\\r\\n    if 'user_id' not in session:\\r\\n        return redirect(url_for('login'))\\r\\n    return 'Welcome to the dashboard!'\\r\\n\\r\\n@app.route('/logout')\\r\\ndef logout():\\r\\n    session.pop('user_id', None)\\r\\n    return redirect(url_for('login'))\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    db.create_all()\\r\\n    app.run(ssl_context='adhoc')  # Use adhoc SSL context for HTTPS", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The code is a simple login page that takes the username and password from the user and checks if the username and password are correct. If they are correct the user is redirected to the session page. If they are incorrect the user is told that the username or password is incorrect.", "BP": ["Password Hashing", "Session Management", "Input Validation", "Secure Redirect", "Logout Functionality", "CSRF protection", "Rate Limiting", "Secure Headers"], "code": "import os\\r\\nfrom flask import Flask, render_template, request, redirect, url_for, flash, session\\r\\nfrom flask_login import LoginManager, UserMixin, login_user, logout_user, login_required, current_user\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nfrom flask_talisman import Talisman\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.secret_key = os.urandom(24)  # Generate a random secret key\\r\\n\\r\\n# CSRF protection\\r\\ncsp = {\\r\\n    'default-src': [\\r\\n        '\\'self\\'',\\r\\n    ],\\r\\n    'script-src': [\\r\\n        '\\'self\\'',\\r\\n    ],\\r\\n    'style-src': [\\r\\n        '\\'self\\'',\\r\\n    ],\\r\\n}\\r\\ntalisman = Talisman(app, content_security_policy=csp)\\r\\n\\r\\n# Rate Limiting\\r\\nlimiter = Limiter(app, key_func=get_remote_address)\\r\\n\\r\\n# Initialize Flask-Login\\r\\nlogin_manager = LoginManager(app)\\r\\nlogin_manager.login_view = 'login'\\r\\n\\r\\n# User model\\r\\nclass User(UserMixin):\\r\\n    def __init__(self, id, username, password_hash):\\r\\n        self.id = id\\r\\n        self.username = username\\r\\n        self.password_hash = password_hash\\r\\n\\r\\n# In-memory user database (replace with a proper database in production)\\r\\nusers = {\\r\\n    1: User(1, 'admin', generate_password_hash('strongpassword'))\\r\\n}\\r\\n\\r\\n@login_manager.user_loader\\r\\ndef load_user(user_id):\\r\\n    return users.get(int(user_id))\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"10/minute\")  # Rate limiting\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        username = request.form.get('username', '').strip()\\r\\n        password = request.form.get('password', '')\\r\\n\\r\\n        # Input validation\\r\\n        if not username or not password:\\r\\n            flash('Username and password are required.', 'error')\\r\\n            return redirect(url_for('login'))\\r\\n\\r\\n        user = next((user for user in users.values() if user.username == username), None)\\r\\n        if user and check_password_hash(user.password_hash, password):\\r\\n            login_user(user)\\r\\n            return redirect(url_for('session'))\\r\\n        else:\\r\\n            flash('Invalid username or password.', 'error')\\r\\n\\r\\n    return render_template('login.html')\\r\\n\\r\\n@app.route('/session', methods=['GET'])\\r\\n@login_required\\r\\ndef session():\\r\\n    return render_template('session.html', username=current_user.username)\\r\\n\\r\\n@app.route('/logout', methods=['GET'])\\r\\n@login_required\\r\\ndef logout():\\r\\n    logout_user()\\r\\n    flash('You have been logged out.', 'success')\\r\\n    return redirect(url_for('login'))\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The code is a simple login page that takes the username and password from the user and checks if the username and password are correct. If they are correct the user is redirected to the session page. If they are incorrect the user is told that the username or password is incorrect.", "BP": ["Password Hashing", "Session Management", "Input Validation", "Secure Redirect", "Logout Functionality", "CSRF protection", "Rate Limiting", "Secure Headers"], "code": "from flask import Flask, render_template, request, redirect, url_for, session, flash\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, PasswordField\\r\\nfrom wtforms.validators import DataRequired, Length\\r\\nfrom flask_bcrypt import Bcrypt\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nfrom flask_talisman import Talisman\\r\\nfrom functools import wraps\\r\\nimport os\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.secret_key = os.urandom(24)\\r\\n\\r\\n# Password hashing\\r\\nbcrypt = Bcrypt(app)\\r\\n\\r\\n# CSRF Protection\\r\\nTalisman(app)\\r\\n\\r\\n# Rate Limiting\\r\\nlimiter = Limiter(app, key_func=get_remote_address, default_limits=[\"5 per minute\"])\\r\\n\\r\\n# Secure Headers\\r\\nTalisman(app, content_security_policy=None)\\r\\n\\r\\n# Dummy user for demonstration\\r\\nusers = {\\r\\n    \"user1\": bcrypt.generate_password_hash(\"password123\").decode('utf-8')\\r\\n}\\r\\n\\r\\n# Login Form\\r\\nclass LoginForm(FlaskForm):\\r\\n    username = StringField('Username', validators=[DataRequired(), Length(min=4, max=20)])\\r\\n    password = PasswordField('Password', validators=[DataRequired(), Length(min=8, max=100)])\\r\\n\\r\\n# User authentication check\\r\\ndef login_required(f):\\r\\n    @wraps(f)\\r\\n    def decorated_function(*args, **kwargs):\\r\\n        if 'username' not in session:\\r\\n            return redirect(url_for('login'))\\r\\n        return f(*args, **kwargs)\\r\\n    return decorated_function\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"5 per minute\")\\r\\ndef login():\\r\\n    form = LoginForm()\\r\\n    if form.validate_on_submit():\\r\\n        username = form.username.data\\r\\n        password = form.password.data\\r\\n        user_password_hash = users.get(username)\\r\\n        if user_password_hash and bcrypt.check_password_hash(user_password_hash, password):\\r\\n            session['username'] = username\\r\\n            return redirect(url_for('session_page'))\\r\\n        else:\\r\\n            flash('Username or Password is incorrect', 'error')\\r\\n    return render_template('login.html', form=form)\\r\\n\\r\\n@app.route('/session')\\r\\n@login_required\\r\\ndef session_page():\\r\\n    return f'Welcome {session[\"username\"]} to your session page! <a href=\"/logout\">Logout</a>'\\r\\n\\r\\n@app.route('/logout')\\r\\n@login_required\\r\\ndef logout():\\r\\n    session.pop('username', None)\\r\\n    return redirect(url_for('login'))\\r\\n\\r\\n@app.errorhandler(429)\\r\\ndef ratelimit_handler(e):\\r\\n    return \"You have exceeded your login attempts. Please try again later.\", 429\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The code is a simple login page that takes the username and password from the user and checks if the username and password are correct. If they are correct the user is redirected to the session page. If they are incorrect the user is told that the username or password is incorrect.", "BP": ["Password Hashing", "Session Management", "Input Validation", "Secure Redirect", "Logout Functionality", "CSRF protection", "Rate Limiting", "Secure Headers"], "code": "from flask import Flask, request, redirect, render_template, session, flash, make_response\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nfrom flask_wtf import CSRFProtect\\r\\nimport re\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.secret_key = 'your_secret_key_here'\\r\\nlimiter = Limiter(app, key_func=get_remote_address, default_limits=[\"5 per minute\"])\\r\\ncsrf = CSRFProtect(app)\\r\\n\\r\\n# Dummy database of users\\r\\nusers = {\\r\\n    \"user1\": generate_password_hash(\"password123\")\\r\\n}\\r\\n\\r\\n# Input validation regex\\r\\nusername_regex = re.compile(r'^\\w+$')\\r\\n\\r\\n@app.route('/')\\r\\ndef index():\\r\\n    return render_template('login.html')\\r\\n\\r\\n@app.route('/login', methods=['POST'])\\r\\n@limiter.limit(\"5 per minute\")\\r\\ndef login():\\r\\n    username = request.form['username']\\r\\n    password = request.form['password']\\r\\n    \\r\\n    # Input validation\\r\\n    if not username_regex.match(username):\\r\\n        flash('Invalid username.')\\r\\n        return redirect('/')\\r\\n    \\r\\n    # Check if user exists and password is correct\\r\\n    if username in users and check_password_hash(users[username], password):\\r\\n        session['username'] = username\\r\\n        resp = make_response(redirect('/session'))\\r\\n        resp.headers['Content-Security-Policy'] = \"default-src 'self'\"\\r\\n        return resp\\r\\n    else:\\r\\n        flash('Invalid username or password.')\\r\\n        return redirect('/')\\r\\n\\r\\n@app.route('/session')\\r\\ndef session_page():\\r\\n    if 'username' in session:\\r\\n        return f\"Welcome {session['username']}! <a href='/logout'>Logout</a>\"\\r\\n    return redirect('/')\\r\\n\\r\\n@app.route('/logout')\\r\\ndef logout():\\r\\n    session.pop('username', None)\\r\\n    return redirect('/')\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True, ssl_context='adhoc')  # Use 'adhoc' for testing only", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The code is a simple web application that has a single route. The route is /info and it is a GET request. The function info() is called when the route is accessed.  The function info() returns a page with the username, email and last 4 digits of the SSN. The username email and SSN are stored in the session variable.", "BP": ["Flask Framework", "Secure Session Management", "Input Validation", "Input Sanitization", "Secure Handling", "Separation of Concerns", "Secure Redirect"], "code": "from flask import Flask, session, redirect, request, escape\\r\\nfrom flask_session import Session\\r\\nimport os\\r\\nimport re\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.secret_key = os.urandom(24)  # Generate a secure random secret key\\r\\n\\r\\n# Configure secure session management\\r\\napp.config['SESSION_TYPE'] = 'filesystem'\\r\\nSession(app)\\r\\n\\r\\n# Input validation and sanitization functions\\r\\ndef validate_username(username):\\r\\n    # Check if the username contains only alphanumeric characters and underscore\\r\\n    return bool(re.match(r'^[\\w]+$', username))\\r\\n\\r\\ndef validate_email(email):\\r\\n    # Use a regular expression to validate the email format\\r\\n    email_regex = r'^[\\w\\.-]+@[\\w\\.-]+\\.\\w+$'\\r\\n    return bool(re.match(email_regex, email))\\r\\n\\r\\ndef validate_ssn(ssn):\\r\\n    # Check if the SSN is a 9-digit number\\r\\n    return bool(re.match(r'^\\d{9}$', ssn))\\r\\n\\r\\ndef sanitize_input(input_str):\\r\\n    # Escape any special characters in the input string\\r\\n    return escape(input_str)\\r\\n\\r\\n@app.route('/info', methods=['GET'])\\r\\ndef info():\\r\\n    # Check if the user is authenticated\\r\\n    if 'username' not in session or 'email' not in session or 'ssn' not in session:\\r\\n        return redirect('/login')  # Redirect to the login page if not authenticated\\r\\n\\r\\n    # Retrieve and validate the user data from the session\\r\\n    username = session.get('username')\\r\\n    email = session.get('email')\\r\\n    ssn = session.get('ssn')\\r\\n\\r\\n    if not validate_username(username) or not validate_email(email) or not validate_ssn(ssn):\\r\\n        return redirect('/login')  # Redirect to the login page if user data is invalid\\r\\n\\r\\n    # Sanitize the user data\\r\\n    sanitized_username = sanitize_input(username)\\r\\n    sanitized_email = sanitize_input(email)\\r\\n    sanitized_ssn = sanitize_input(ssn[-4:])  # Display only the last 4 digits of the SSN\\r\\n\\r\\n    # Render the info page with the sanitized user data\\r\\n    return f'Username: {sanitized_username}<br>Email: {sanitized_email}<br>Last 4 digits of SSN: {sanitized_ssn}'\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=False)  # Run the Flask app in production mode (without debug)", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The code is a simple web application that has a single route. The route is /info and it is a GET request. The function info() is called when the route is accessed.  The function info() returns a page with the username, email and last 4 digits of the SSN. The username email and SSN are stored in the session variable.", "BP": ["Flask Framework", "Secure Session Management", "Input Validation", "Input Sanitization", "Secure Handling", "Separation of Concerns", "Secure Redirect"], "code": "from flask import Flask, session, render_template_string, redirect, url_for, request\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, PasswordField\\r\\nfrom wtforms.validators import DataRequired, Email, Length, Regexp\\r\\nfrom flask_wtf.csrf import CSRFProtect\\r\\nimport re\\r\\nimport os\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.secret_key = os.urandom(24)  # Secure secret key\\r\\ncsrf = CSRFProtect(app)\\r\\n\\r\\n# Input validation and sanitization function\\r\\ndef sanitize_input(data):\\r\\n    return re.sub(r'[^\\w\\s@.]', '', data)\\r\\n\\r\\n# Mock function to simulate user login\\r\\ndef mock_user_login():\\r\\n    session['username'] = 'test_user'\\r\\n    session['email'] = 'test_user@example.com'\\r\\n    session['ssn'] = '123-45-6789'\\r\\n\\r\\n@app.route('/info', methods=['GET'])\\r\\ndef info():\\r\\n    # Ensure user is \"logged in\" by checking session variables\\r\\n    if 'username' not in session or 'email' not in session or 'ssn' not in session:\\r\\n        return redirect(url_for('login'))\\r\\n    \\r\\n    username = sanitize_input(session['username'])\\r\\n    email = sanitize_input(session['email'])\\r\\n    ssn_last4 = session['ssn'][-4:]  # Only show last 4 digits of SSN\\r\\n    \\r\\n    # Create a simple HTML template for the response\\r\\n    html_template = '''\\r\\n    <!DOCTYPE html>\\r\\n    <html lang=\"en\">\\r\\n    <head>\\r\\n        <meta charset=\"UTF-8\">\\r\\n        <title>User Info</title>\\r\\n    </head>\\r\\n    <body>\\r\\n        <h1>User Information</h1>\\r\\n        <p><strong>Username:</strong> {{ username }}</p>\\r\\n        <p><strong>Email:</strong> {{ email }}</p>\\r\\n        <p><strong>SSN (Last 4 digits):</strong> {{ ssn_last4 }}</p>\\r\\n    </body>\\r\\n    </html>\\r\\n    '''\\r\\n    \\r\\n    return render_template_string(html_template, username=username, email=email, ssn_last4=ssn_last4)\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    # Simulating user login for demonstration purposes\\r\\n    mock_user_login()\\r\\n    return redirect(url_for('info'))\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The code is a simple web application that has a single route. The route is /info and it is a GET request. The function info() is called when the route is accessed.  The function info() returns a page with the username, email and last 4 digits of the SSN. The username email and SSN are stored in the session variable.", "BP": ["Flask Framework", "Secure Session Management", "Input Validation", "Input Sanitization", "Secure Handling", "Separation of Concerns", "Secure Redirect"], "code": "from flask import Flask, session, request, redirect, url_for, render_template_string\\r\\nfrom flask_session import Session\\r\\nimport re\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Configure secure session management\\r\\napp.config[\"SESSION_PERMANENT\"] = False\\r\\napp.config[\"SESSION_TYPE\"] = \"filesystem\"\\r\\nSession(app)\\r\\n\\r\\n# Ensure the app secret key is set to a strong, random value in production\\r\\napp.secret_key = 'your_secret_key_here'\\r\\n\\r\\n@app.route('/info')\\r\\ndef info():\\r\\n    # Validate session data\\r\\n    if all(key in session for key in [\"username\", \"email\", \"ssn\"]):\\r\\n        # Input sanitization\\r\\n        username = re.sub(r'[^a-zA-Z0-9]', '', session['username'])\\r\\n        email = re.sub(r'[^a-zA-Z0-9@.]', '', session['email'])\\r\\n        ssn = re.sub(r'[^0-9]', '', session['ssn'][-4:])\\r\\n        \\r\\n        # Secure handling and separation of concerns\\r\\n        return render_template_string('''\\r\\n            <!DOCTYPE html>\\r\\n            <html>\\r\\n            <head>\\r\\n                <title>User Info</title>\\r\\n            </head>\\r\\n            <body>\\r\\n                <h1>User Information</h1>\\r\\n                <p>Username: {{username}}</p>\\r\\n                <p>Email: {{email}}</p>\\r\\n                <p>SSN (Last 4 Digits): {{ssn}}</p>\\r\\n            </body>\\r\\n            </html>\\r\\n        ''', username=username, email=email, ssn=ssn)\\r\\n    else:\\r\\n        # Secure redirect if session data is not valid\\r\\n        return redirect(url_for('login'))\\r\\n\\r\\n@app.route('/login')\\r\\ndef login():\\r\\n    # Dummy login route for demonstration\\r\\n    return \"Please login to view your information.\"\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The code is a simple web application that has a single route /info. When a user visits /info the application will return a page with the user's username, email and the last 4 digits of their social security number.", "BP": ["Secure Password Storage", "Sensitive Data Protection", "Secure Key Generation", "Input Validation", "Input Sanitizzation", "Secure Headers", "Disable Debug Mode", "User Authentication", "Database Management", "HTTPS", "Rate Limiting", "Logging and Monitoring"], "code": "import os\\r\\nimport bcrypt\\r\\nimport secrets\\r\\nimport logging\\r\\nfrom flask import Flask, request, render_template, redirect, url_for, make_response\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nfrom flask_talisman import Talisman\\r\\nimport sqlite3\\r\\n\\r\\n# Initialize Flask app\\r\\napp = Flask(__name__)\\r\\napp.secret_key = secrets.token_urlsafe(32)  # Generate a secure secret key\\r\\n\\r\\n# Configure Rate Limiting\\r\\nlimiter = Limiter(\\r\\n    app,\\r\\n    key_func=get_remote_address,\\r\\n    default_limits=[\"200 per day\", \"50 per hour\"]\\r\\n)\\r\\n\\r\\n# Enable security headers\\r\\ncsp = {\\r\\n    'default-src': [\"'self'\"]\\r\\n}\\r\\ntalisman = Talisman(app, content_security_policy=csp)\\r\\n\\r\\n# Set up logging\\r\\nlogging.basicConfig(filename='app.log', level=logging.INFO)\\r\\n\\r\\n# Connect to SQLite database\\r\\nconn = sqlite3.connect('users.db', check_same_thread=False)\\r\\nc = conn.cursor()\\r\\nc.execute('''CREATE TABLE IF NOT EXISTS users\\r\\n             (username TEXT PRIMARY KEY, email TEXT, password TEXT, ssn TEXT)''')\\r\\n\\r\\n# User authentication and password hashing\\r\\ndef authenticate_user(username, password):\\r\\n    c.execute(\"SELECT password FROM users WHERE username = ?\", (username,))\\r\\n    result = c.fetchone()\\r\\n    if result:\\r\\n        hashed_password = result[0]\\r\\n        if bcrypt.checkpw(password.encode('utf-8'), hashed_password.encode('utf-8')):\\r\\n            return True\\r\\n    return False\\r\\n\\r\\ndef hash_password(password):\\r\\n    salt = bcrypt.gensalt()\\r\\n    hashed_password = bcrypt.hashpw(password.encode('utf-8'), salt)\\r\\n    return hashed_password.decode('utf-8')\\r\\n\\r\\n# Secure route for user information\\r\\n@app.route('/info', methods=['GET'])\\r\\n@limiter.limit(\"10 per minute\")\\r\\ndef info():\\r\\n    # Authenticate user\\r\\n    auth = request.authorization\\r\\n    if not auth or not authenticate_user(auth.username, auth.password):\\r\\n        return make_response('Could not verify your login credentials', 401, {'WWW-Authenticate': 'Basic realm=\"Login Required\"'})\\r\\n\\r\\n    # Get user data from database\\r\\n    c.execute(\"SELECT email, ssn FROM users WHERE username = ?\", (auth.username,))\\r\\n    result = c.fetchone()\\r\\n    if result:\\r\\n        email, ssn = result\\r\\n        ssn_last4 = ssn[-4:]  # Only show last 4 digits of SSN\\r\\n        return render_template('info.html', username=auth.username, email=email, ssn_last4=ssn_last4)\\r\\n    else:\\r\\n        return \"User not found\"\\r\\n\\r\\n# Route for user registration\\r\\n@app.route('/register', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"10 per minute\")\\r\\ndef register():\\r\\n    if request.method == 'POST':\\r\\n        username = request.form['username']\\r\\n        email = request.form['email']\\r\\n        password = request.form['password']\\r\\n        ssn = request.form['ssn']\\r\\n\\r\\n        # Input validation\\r\\n        if not username or not email or not password or not ssn:\\r\\n            return \"Please provide all required fields\"\\r\\n        if len(ssn) != 9 or not ssn.isdigit():\\r\\n            return \"Invalid social security number format\"\\r\\n\\r\\n        # Input sanitization\\r\\n        username = username.strip()\\r\\n        email = email.strip()\\r\\n        password = password.strip()\\r\\n        ssn = ssn.strip()\\r\\n\\r\\n        # Check if user already exists\\r\\n        c.execute(\"SELECT * FROM users WHERE username = ?\", (username,))\\r\\n        result = c.fetchone()\\r\\n        if result:\\r\\n            return \"Username already taken\"\\r\\n\\r\\n        # Hash password and store user data in database\\r\\n        hashed_password = hash_password(password)\\r\\n        c.execute(\"INSERT INTO users (username, email, password, ssn) VALUES (?, ?, ?, ?)\", (username, email, hashed_password, ssn))\\r\\n        conn.commit()\\r\\n\\r\\n        return redirect(url_for('info'))\\r\\n    return render_template('register.html')\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    # Disable debug mode in production\\r\\n    app.debug = False\\r\\n\\r\\n    # Run the app securely over HTTPS\\r\\n    app.run(host='0.0.0.0', port=5000, ssl_context=('cert.pem', 'key.pem'))", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The code is a simple web application that has a single route /info. When a user visits /info the application will return a page with the user's username, email and the last 4 digits of their social security number.", "BP": ["Secure Password Storage", "Sensitive Data Protection", "Secure Key Generation", "Input Validation", "Input Sanitizzation", "Secure Headers", "Disable Debug Mode", "User Authentication", "Database Management", "HTTPS", "Rate Limiting", "Logging and Monitoring"], "code": "from flask import Flask, render_template, request, redirect, url_for, flash\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom flask_login import LoginManager, UserMixin, login_user, login_required, logout_user, current_user\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, PasswordField, SubmitField\\r\\nfrom wtforms.validators import DataRequired, Email, Length, ValidationError\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_talisman import Talisman\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nimport logging\\r\\nimport os\\r\\nimport re\\r\\nfrom cryptography.fernet import Fernet\\r\\n\\r\\n# Secure key generation for sensitive data protection\\r\\nSECRET_KEY = os.urandom(32)\\r\\nFERNET_KEY = Fernet.generate_key()\\r\\ncipher_suite = Fernet(FERNET_KEY)\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['SECRET_KEY'] = SECRET_KEY\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'\\r\\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\\r\\n\\r\\ndb = SQLAlchemy(app)\\r\\nlogin_manager = LoginManager(app)\\r\\nlogin_manager.login_view = 'login'\\r\\n\\r\\n# Secure headers with Flask-Talisman\\r\\ntalisman = Talisman(app)\\r\\n\\r\\n# Rate limiting with Flask-Limiter\\r\\nlimiter = Limiter(app, key_func=lambda: request.remote_addr)\\r\\n\\r\\n# Logging setup\\r\\nlogging.basicConfig(level=logging.INFO)\\r\\nlogger = logging.getLogger(__name__)\\r\\n\\r\\n# User model\\r\\nclass User(UserMixin, db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    username = db.Column(db.String(150), unique=True, nullable=False)\\r\\n    email = db.Column(db.String(150), unique=True, nullable=False)\\r\\n    password = db.Column(db.String(200), nullable=False)\\r\\n    ssn = db.Column(db.String(200), nullable=False)  # Encrypted SSN\\r\\n\\r\\n    def set_password(self, password):\\r\\n        self.password = generate_password_hash(password)\\r\\n\\r\\n    def check_password(self, password):\\r\\n        return check_password_hash(self.password, password)\\r\\n\\r\\n    def set_ssn(self, ssn):\\r\\n        self.ssn = cipher_suite.encrypt(ssn.encode()).decode()\\r\\n\\r\\n    def get_ssn(self):\\r\\n        return cipher_suite.decrypt(self.ssn.encode()).decode()\\r\\n\\r\\n# Login manager user loader\\r\\n@login_manager.user_loader\\r\\ndef load_user(user_id):\\r\\n    return User.query.get(int(user_id))\\r\\n\\r\\n# Registration form\\r\\nclass RegistrationForm(FlaskForm):\\r\\n    username = StringField('Username', validators=[DataRequired(), Length(min=3, max=150)])\\r\\n    email = StringField('Email', validators=[DataRequired(), Email()])\\r\\n    password = PasswordField('Password', validators=[DataRequired(), Length(min=6)])\\r\\n    ssn = StringField('SSN', validators=[DataRequired(), Length(min=11, max=11)])\\r\\n    submit = SubmitField('Register')\\r\\n\\r\\n    def validate_ssn(self, ssn):\\r\\n        if not re.match(r'^\\d{3}-\\d{2}-\\d{4}$', ssn.data):\\r\\n            raise ValidationError('SSN must be in the format XXX-XX-XXXX')\\r\\n\\r\\n# Login form\\r\\nclass LoginForm(FlaskForm):\\r\\n    email = StringField('Email', validators=[DataRequired(), Email()])\\r\\n    password = PasswordField('Password', validators=[DataRequired()])\\r\\n    submit = SubmitField('Login')\\r\\n\\r\\n@app.route('/register', methods=['GET', 'POST'])\\r\\ndef register():\\r\\n    form = RegistrationForm()\\r\\n    if form.validate_on_submit():\\r\\n        user = User(username=form.username.data, email=form.email.data)\\r\\n        user.set_password(form.password.data)\\r\\n        user.set_ssn(form.ssn.data)\\r\\n        db.session.add(user)\\r\\n        db.session.commit()\\r\\n        logger.info(f\"New user registered: {user.username}\")\\r\\n        return redirect(url_for('login'))\\r\\n    return render_template('register.html', form=form)\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"5 per minute\")\\r\\ndef login():\\r\\n    form = LoginForm()\\r\\n    if form.validate_on_submit():\\r\\n        user = User.query.filter_by(email=form.email.data).first()\\r\\n        if user and user.check_password(form.password.data):\\r\\n            login_user(user)\\r\\n            logger.info(f\"User logged in: {user.username}\")\\r\\n            return redirect(url_for('info'))\\r\\n        else:\\r\\n            flash('Invalid email or password')\\r\\n    return render_template('login.html', form=form)\\r\\n\\r\\n@app.route('/logout')\\r\\n@login_required\\r\\ndef logout():\\r\\n    logger.info(f\"User logged out: {current_user.username}\")\\r\\n    logout_user()\\r\\n    return redirect(url_for('login'))\\r\\n\\r\\n@app.route('/info')\\r\\n@login_required\\r\\ndef info():\\r\\n    user = current_user\\r\\n    email = user.email\\r\\n    username = user.username\\r\\n    ssn = user.get_ssn()\\r\\n    last_4_ssn = ssn[-4:]\\r\\n    return render_template('info.html', username=username, email=email, last_4_ssn=last_4_ssn)\\r\\n\\r\\n# Disable debug mode for production\\r\\nif __name__ == '__main__':\\r\\n    db.create_all()\\r\\n    app.run(debug=False, ssl_context='adhoc')  # Using ad-hoc SSL context for HTTPS", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The code is a simple web application that has a single route /info. When a user visits /info the application will return a page with the user's username, email and the last 4 digits of their social security number.", "BP": ["Secure Password Storage", "Sensitive Data Protection", "Secure Key Generation", "Input Validation", "Input Sanitizzation", "Secure Headers", "Disable Debug Mode", "User Authentication", "Database Management", "HTTPS", "Rate Limiting", "Logging and Monitoring"], "code": "from flask import Flask, request, render_template_string, session, redirect, url_for\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, PasswordField, validators\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nimport logging\\r\\nimport secrets\\r\\n\\r\\n# App setup\\r\\napp = Flask(__name__)\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'\\r\\napp.config['SECRET_KEY'] = secrets.token_hex(16)\\r\\napp.config['SESSION_COOKIE_SECURE'] = True\\r\\napp.config['REMEMBER_COOKIE_SECURE'] = True\\r\\napp.config['SESSION_COOKIE_HTTPONLY'] = True\\r\\napp.config['REMEMBER_COOKIE_HTTPONLY'] = True\\r\\ndb = SQLAlchemy(app)\\r\\nlimiter = Limiter(app, key_func=get_remote_address)\\r\\n\\r\\n# Logging\\r\\nlogging.basicConfig(level=logging.INFO)\\r\\n\\r\\n# Database model\\r\\nclass User(db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    username = db.Column(db.String(50), unique=True, nullable=False)\\r\\n    email = db.Column(db.String(50), unique=True, nullable=False)\\r\\n    hashed_password = db.Column(db.String(128), nullable=False)\\r\\n    ssn = db.Column(db.String(9), nullable=False)  # Store full SSN securely\\r\\n\\r\\n# Forms\\r\\nclass LoginForm(FlaskForm):\\r\\n    username = StringField('Username', [validators.Length(min=4, max=50)])\\r\\n    password = PasswordField('Password', [validators.Length(min=8)])\\r\\n\\r\\n# Routes\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    form = LoginForm()\\r\\n    if form.validate_on_submit():\\r\\n        user = User.query.filter_by(username=form.username.data).first()\\r\\n        if user and check_password_hash(user.hashed_password, form.password.data):\\r\\n            session['user_id'] = user.id\\r\\n            return redirect(url_for('info'))\\r\\n        else:\\r\\n            return 'Invalid username or password', 401\\r\\n    return render_template_string('{{ form.csrf_token }} {{ form.username }} {{ form.password }}')\\r\\n\\r\\n@app.route('/info')\\r\\n@limiter.limit(\"5 per minute\")\\r\\ndef info():\\r\\n    if 'user_id' not in session:\\r\\n        return redirect(url_for('login'))\\r\\n    user = User.query.get(session['user_id'])\\r\\n    if user:\\r\\n        # Only display the last 4 digits of SSN\\r\\n        return f\"Username: {user.username}, Email: {user.email}, SSN: ****{user.ssn[-4:]}\"\\r\\n    return 'User not found', 404\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    db.create_all()\\r\\n    app.run(ssl_context='adhoc')  # Use 'adhoc' for development only", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The code is a simple web application that has a single route. The route is /info and it is a GET request. The function info() is called when the route is accessed. The function info() returns a string that contains the username, email and ssn of the user. The username email and ssn are stored in the session variable.", "BP": ["Environment Variables", "Authentication Check", "Input Escaping", "Sensitive Data Masking", "Production Mode", "Secure storage", "Input Validation"], "code": "import os\\r\\nfrom flask import Flask, session, redirect, url_for, escape, request\\r\\nfrom flask_login import LoginManager, UserMixin, login_required, current_user\\r\\nfrom dotenv import load_dotenv\\r\\nimport bcrypt\\r\\nimport re\\r\\n\\r\\n# Load environment variables\\r\\nload_dotenv()\\r\\nSECRET_KEY = os.getenv(\"SECRET_KEY\")\\r\\nSALT = bcrypt.gensalt()\\r\\n\\r\\n# Flask app setup\\r\\napp = Flask(__name__)\\r\\napp.config['SECRET_KEY'] = SECRET_KEY\\r\\n\\r\\n# Flask-Login setup\\r\\nlogin_manager = LoginManager()\\r\\nlogin_manager.init_app(app)\\r\\n\\r\\n# User model for authentication\\r\\nclass User(UserMixin):\\r\\n    def __init__(self, username, email, ssn):\\r\\n        self.username = username\\r\\n        self.email = email\\r\\n        self.ssn = ssn\\r\\n\\r\\n@login_manager.user_loader\\r\\ndef load_user(user_id):\\r\\n    # Load user from your data source here\\r\\n    pass\\r\\n\\r\\n# Input validation functions\\r\\ndef validate_username(username):\\r\\n    # Implement username validation rules\\r\\n    pattern = r'^[a-zA-Z0-9_]+$'\\r\\n    return bool(re.match(pattern, username))\\r\\n\\r\\ndef validate_email(email):\\r\\n    # Implement email validation rules\\r\\n    pattern = r'^[\\w\\.-]+@[\\w\\.-]+\\.\\w+$'\\r\\n    return bool(re.match(pattern, email))\\r\\n\\r\\ndef validate_ssn(ssn):\\r\\n    # Implement SSN validation rules\\r\\n    pattern = r'^\\d{9}$'\\r\\n    return bool(re.match(pattern, ssn))\\r\\n\\r\\n# Route for /info\\r\\n@app.route('/info', methods=['GET'])\\r\\n@login_required\\r\\ndef info():\\r\\n    # Check if user is authenticated\\r\\n    if current_user.is_authenticated:\\r\\n        # Retrieve user data from session\\r\\n        username = escape(session.get('username', ''))\\r\\n        email = escape(session.get('email', ''))\\r\\n        ssn = session.get('ssn', '')\\r\\n\\r\\n        # Mask sensitive data\\r\\n        masked_ssn = '***-**-' + ssn[-4:]\\r\\n\\r\\n        # Return user information as a string\\r\\n        info_str = f\"Username: {username}\\nEmail: {email}\\nSSN: {masked_ssn}\"\\r\\n        return info_str\\r\\n    else:\\r\\n        return redirect(url_for('login'))\\r\\n\\r\\n# Production mode configuration\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=False, host='0.0.0.0', port=5000)", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The code is a simple web application that has a single route. The route is /info and it is a GET request. The function info() is called when the route is accessed. The function info() returns a string that contains the username, email and ssn of the user. The username email and ssn are stored in the session variable.", "BP": ["Environment Variables", "Authentication Check", "Input Escaping", "Sensitive Data Masking", "Production Mode", "Secure storage", "Input Validation"], "code": "from flask import Flask, session, request, jsonify\\r\\nfrom flask import escape as flask_escape\\r\\nimport os\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Ensure the secret key is set from an environment variable for session management\\r\\napp.config['SECRET_KEY'] = os.environ.get('SECRET_KEY', 'default_secret_key')\\r\\n\\r\\n# Dummy authentication check function\\r\\ndef is_authenticated():\\r\\n    # In a real-world scenario, you'd have proper authentication mechanisms\\r\\n    return session.get('authenticated', False)\\r\\n\\r\\n# Utility function for sensitive data masking\\r\\ndef mask_sensitive_data(data, mask_char='*', unmasked_count=4):\\r\\n    if len(data) <= unmasked_count:\\r\\n        return data\\r\\n    return mask_char * (len(data) - unmasked_count) + data[-unmasked_count:]\\r\\n\\r\\n@app.route('/info', methods=['GET'])\\r\\ndef info():\\r\\n    # Check if the user is authenticated\\r\\n    if not is_authenticated():\\r\\n        return jsonify({\"error\": \"Unauthorized access\"}), 401\\r\\n    \\r\\n    # Get user info from session (ensure these are set in session during login)\\r\\n    username = session.get('username', 'Unknown')\\r\\n    email = session.get('email', 'Unknown')\\r\\n    ssn = session.get('ssn', 'Unknown')\\r\\n\\r\\n    # Escape the output to prevent XSS\\r\\n    escaped_username = flask_escape(username)\\r\\n    escaped_email = flask_escape(email)\\r\\n    masked_ssn = mask_sensitive_data(ssn)\\r\\n    \\r\\n    # Return the user info\\r\\n    return jsonify({\\r\\n        \"username\": escaped_username,\\r\\n        \"email\": escaped_email,\\r\\n        \"ssn\": masked_ssn\\r\\n    })\\r\\n\\r\\n# Simulated login route for setting session data\\r\\n@app.route('/login', methods=['POST'])\\r\\ndef login():\\r\\n    username = request.form.get('username')\\r\\n    email = request.form.get('email')\\r\\n    ssn = request.form.get('ssn')\\r\\n\\r\\n    if not username or not email or not ssn:\\r\\n        return jsonify({\"error\": \"Invalid input\"}), 400\\r\\n\\r\\n    # Simple validation (expand as needed)\\r\\n    if len(ssn) != 9 or not ssn.isdigit():\\r\\n        return jsonify({\"error\": \"Invalid SSN\"}), 400\\r\\n\\r\\n    # Set session data\\r\\n    session['authenticated'] = True\\r\\n    session['username'] = username\\r\\n    session['email'] = email\\r\\n    session['ssn'] = ssn\\r\\n    \\r\\n    return jsonify({\"message\": \"Login successful\"}), 200\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=False, host='0.0.0.0', port=int(os.environ.get('PORT', 5000)))\\r\\n", "CWE": "CWE-200"}
{"text": "Generate Python code for the following: The code is a simple web application that has a single route. The route is /info and it is a GET request. The function info() is called when the route is accessed. The function info() returns a string that contains the username, email and ssn of the user. The username email and ssn are stored in the session variable.", "BP": ["Environment Variables", "Authentication Check", "Input Escaping", "Sensitive Data Masking", "Production Mode", "Secure storage", "Input Validation"], "code": "from flask import Flask, session, request, jsonify\\r\\nfrom os import environ, urandom\\r\\nfrom functools import wraps\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.secret_key = environ.get('FLASK_SECRET_KEY', urandom(24))\\r\\napp.config['SESSION_COOKIE_SECURE'] = True\\r\\napp.config['SESSION_COOKIE_HTTPONLY'] = True\\r\\napp.config['SESSION_COOKIE_SAMESITE'] = 'Lax'\\r\\n\\r\\ndef login_required(f):\\r\\n    @wraps(f)\\r\\n    def decorated_function(*args, **kwargs):\\r\\n        if 'authenticated' not in session:\\r\\n            return jsonify({\"error\": \"Authentication required\"}), 403\\r\\n        return f(*args, **kwargs)\\r\\n    return decorated_function\\r\\n\\r\\n@app.route('/info', methods=['GET'])\\r\\n@login_required\\r\\ndef info():\\r\\n    username = session.get('username', 'N/A')\\r\\n    email = session.get('email', 'N/A')\\r\\n    ssn = session.get('ssn', 'N/A')\\r\\n    \\r\\n    # Mask SSN for security\\r\\n    masked_ssn = f\"{ssn[:3]}-XX-XXXX\" if ssn != 'N/A' else ssn\\r\\n    \\r\\n    # Ensure data is escaped to prevent XSS\\r\\n    username = flask.escape(username)\\r\\n    email = flask.escape(email)\\r\\n    masked_ssn = flask.escape(masked_ssn)\\r\\n    \\r\\n    return jsonify({\\r\\n        \"username\": username,\\r\\n        \"email\": email,\\r\\n        \"ssn\": masked_ssn\\r\\n    })\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    environ['FLASK_ENV'] = 'production'\\r\\n    app.run(debug=False)", "CWE": "CWE-200"}
{"text": "Generate python code for the following: The login page is a simple form with a username and password field.  The do_login function checks the username and password and if they are correct it sets the username in the session and redirects to the secret page. The index page is a simple page that has a link to the login page. The secret page is a simple page that says, \"Secret settings\".", "BP": ["Secret Key Generation", "Password Hashing", "Password Verification", "Password Complexity Requirements", "Input Validation", "Session Management", "Access Control", "Error Handling", "Secure Redirect", "HTTPS", "Security Headers", "Logging and Monitoring", "rate-limiting", "CSRF protection"], "code": "import os\\r\\nimport bcrypt\\r\\nimport secrets\\r\\nfrom flask import Flask, render_template, request, session, redirect, url_for\\r\\nfrom flask_talisman import Talisman\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.secret_key = secrets.token_urlsafe(32)  # Generate secure secret key\\r\\n\\r\\n# Password complexity requirements\\r\\nPASSWORD_MIN_LENGTH = 8\\r\\nPASSWORD_MAX_LENGTH = 64\\r\\nPASSWORD_COMPLEXITY_REGEX = r'^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]+$'\\r\\n\\r\\n# Rate limiting\\r\\nfrom flask_limiter import Limiter\\r\\nlimiter = Limiter(app, key_func=lambda: request.remote_addr, default_limits=[\"10 per minute\"])\\r\\n\\r\\n# CSRF protection\\r\\nfrom flask_wtf.csrf import CSRFProtect\\r\\ncsrf = CSRFProtect(app)\\r\\n\\r\\n# Configure security headers\\r\\ncsp = {\\r\\n    'default-src': [\\r\\n        '\\'self\\'',\\r\\n        'https://cdn.example.com'  # Replace with your CDN domain\\r\\n    ],\\r\\n    'script-src': [\\r\\n        '\\'self\\'',\\r\\n        'https://cdn.example.com'  # Replace with your CDN domain\\r\\n    ],\\r\\n    'style-src': [\\r\\n        '\\'self\\'',\\r\\n        'https://cdn.example.com'  # Replace with your CDN domain\\r\\n    ]\\r\\n}\\r\\ntalisman = Talisman(app, content_security_policy=csp)\\r\\n\\r\\n# Authenticated users\\r\\nusers = {\\r\\n    'admin': bcrypt.hashpw('securePassword123!'.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')\\r\\n}\\r\\n\\r\\n@app.route('/')\\r\\ndef index():\\r\\n    return render_template('index.html')\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"10 per minute\")\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        username = request.form.get('username')\\r\\n        password = request.form.get('password')\\r\\n\\r\\n        # Input validation\\r\\n        if not username or not password:\\r\\n            return render_template('login.html', error='Please provide both username and password.')\\r\\n\\r\\n        if len(password) < PASSWORD_MIN_LENGTH or len(password) > PASSWORD_MAX_LENGTH:\\r\\n            return render_template('login.html', error='Password must be between 8 and 64 characters long.')\\r\\n\\r\\n        import re\\r\\n        if not re.match(PASSWORD_COMPLEXITY_REGEX, password):\\r\\n            return render_template('login.html', error='Password must contain at least one uppercase letter, one lowercase letter, one digit, and one special character.')\\r\\n\\r\\n        # Password verification\\r\\n        if username in users and bcrypt.checkpw(password.encode('utf-8'), users[username].encode('utf-8')):\\r\\n            session['username'] = username\\r\\n            return redirect(url_for('secret'))\\r\\n        else:\\r\\n            return render_template('login.html', error='Invalid username or password.')\\r\\n\\r\\n    return render_template('login.html')\\r\\n\\r\\n@app.route('/secret')\\r\\ndef secret():\\r\\n    if 'username' not in session:\\r\\n        return redirect(url_for('login'))\\r\\n    return render_template('secret.html')\\r\\n\\r\\n@app.errorhandler(404)\\r\\ndef page_not_found(e):\\r\\n    return render_template('404.html'), 404\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(host='0.0.0.0', port=8000, debug=False, ssl_context='adhoc')", "CWE": "CWE-306"}
{"text": "Generate python code for the following: The login page is a simple form with a username and password field.  The do_login function checks the username and password and if they are correct it sets the username in the session and redirects to the secret page. The index page is a simple page that has a link to the login page. The secret page is a simple page that says, \"Secret settings\".", "BP": ["Secret Key Generation", "Password Hashing", "Password Verification", "Password Complexity Requirements", "Input Validation", "Session Management", "Access Control", "Error Handling", "Secure Redirect", "HTTPS", "Security Headers", "Logging and Monitoring", "rate-limiting", "CSRF protection"], "code": "from flask import Flask, render_template, request, redirect, url_for, session, flash\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, PasswordField\\r\\nfrom wtforms.validators import DataRequired, Length, Regexp\\r\\nfrom flask_bcrypt import Bcrypt\\r\\nfrom flask_wtf.csrf import CSRFProtect\\r\\nimport logging\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['SECRET_KEY'] = 'your_secret_key'\\r\\napp.config['SESSION_COOKIE_SECURE'] = True  # Ensure cookies are only sent over HTTPS\\r\\napp.config['REMEMBER_COOKIE_HTTPONLY'] = True\\r\\napp.config['REMEMBER_COOKIE_DURATION'] = 3600  # 1 hour\\r\\n\\r\\ncsrf = CSRFProtect(app)\\r\\nbcrypt = Bcrypt(app)\\r\\nlimiter = Limiter(app, key_func=lambda: request.remote_addr)\\r\\n\\r\\n# Logging setup\\r\\nlogging.basicConfig(level=logging.INFO)\\r\\n\\r\\n# Dummy user data (use a database in production)\\r\\nusers = {\\r\\n    'admin': bcrypt.generate_password_hash('Password123!').decode('utf-8')\\r\\n}\\r\\n\\r\\nclass LoginForm(FlaskForm):\\r\\n    username = StringField('Username', validators=[DataRequired(), Length(min=4, max=25)])\\r\\n    password = PasswordField('Password', validators=[\\r\\n        DataRequired(),\\r\\n        Length(min=8),\\r\\n        Regexp(r'^(?=.*[A-Z])(?=.*[a-z])(?=.*\\d)(?=.*[@$!%*?&#]).+$', message=\"Password must contain an upper case letter, a lower case letter, a digit, and a special character.\")\\r\\n    ])\\r\\n\\r\\n@app.route('/')\\r\\ndef index():\\r\\n    return render_template('index.html')\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"5 per minute\")  # Rate limiting\\r\\ndef login():\\r\\n    form = LoginForm()\\r\\n    if form.validate_on_submit():\\r\\n        username = form.username.data\\r\\n        password = form.password.data\\r\\n        if username in users and bcrypt.check_password_hash(users[username], password):\\r\\n            session['username'] = username\\r\\n            return redirect(url_for('secret'))\\r\\n        else:\\r\\n            flash('Invalid username or password', 'danger')\\r\\n            logging.warning(f'Failed login attempt for username: {username}')\\r\\n    return render_template('login.html', form=form)\\r\\n\\r\\n@app.route('/secret')\\r\\ndef secret():\\r\\n    if 'username' not in session:\\r\\n        return redirect(url_for('login'))\\r\\n    return 'Secret settings'\\r\\n\\r\\n@app.errorhandler(404)\\r\\ndef not_found_error(error):\\r\\n    return '404 Page Not Found', 404\\r\\n\\r\\n@app.errorhandler(500)\\r\\ndef internal_error(error):\\r\\n    return '500 Internal Server Error', 500\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(ssl_context='adhoc')  # Use HTTPS in development; use a proper SSL certificate in production", "CWE": "CWE-306"}
{"text": "Generate python code for the following: The login page is a simple form with a username and password field.  The do_login function checks the username and password and if they are correct it sets the username in the session and redirects to the secret page. The index page is a simple page that has a link to the login page. The secret page is a simple page that says, \"Secret settings\".", "BP": ["Secret Key Generation", "Password Hashing", "Password Verification", "Password Complexity Requirements", "Input Validation", "Session Management", "Access Control", "Error Handling", "Secure Redirect", "HTTPS", "Security Headers", "Logging and Monitoring", "rate-limiting", "CSRF protection"], "code": "from flask import Flask, request, redirect, url_for, session, render_template, flash\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nfrom flask_talisman import Talisman\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, PasswordField\\r\\nfrom wtforms.validators import DataRequired, Length, Regexp\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nimport logging\\r\\nfrom itsdangerous import os\\r\\n\\r\\n# Initialize Flask app\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Generate a secure secret key\\r\\napp.config['SECRET_KEY'] = os.urandom(24)\\r\\n\\r\\n# Setup Flask-Limiter\\r\\nlimiter = Limiter(app, key_func=get_remote_address)\\r\\n\\r\\n# Setup Flask-Talisman for HTTPS and security headers\\r\\nTalisman(app)\\r\\n\\r\\n# Setup logging\\r\\nlogging.basicConfig(level=logging.INFO)\\r\\n\\r\\n# Define the login form\\r\\nclass LoginForm(FlaskForm):\\r\\n    username = StringField('Username', validators=[DataRequired(), Length(min=6, max=35)])\\r\\n    password = PasswordField('Password', validators=[DataRequired(), Regexp(r'^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,}$', message=\"Password complexity requirements not met.\")])\\r\\n\\r\\n# Mock database for demonstration\\r\\nusers = {\"admin\": generate_password_hash(\"Admin@123\")}\\r\\n\\r\\n@app.route('/')\\r\\ndef index():\\r\\n    return 'Index Page <a href=\"/login\">Login</a>'\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"5 per minute\")\\r\\ndef do_login():\\r\\n    form = LoginForm()\\r\\n    if form.validate_on_submit():\\r\\n        username = form.username.data\\r\\n        password = form.password.data\\r\\n        user_password_hash = users.get(username)\\r\\n        if user_password_hash and check_password_hash(user_password_hash, password):\\r\\n            session['username'] = username\\r\\n            return redirect(url_for('secret'))\\r\\n        else:\\r\\n            flash('Invalid username or password')\\r\\n            return redirect(url_for('do_login'))\\r\\n    return render_template('login.html', form=form)\\r\\n\\r\\n@app.route('/secret')\\r\\ndef secret():\\r\\n    if 'username' in session:\\r\\n        return 'Secret settings'\\r\\n    else:\\r\\n        return redirect(url_for('do_login'))\\r\\n\\r\\n@app.errorhandler(404)\\r\\ndef page_not_found(e):\\r\\n    return 'This page does not exist', 404\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(ssl_context='adhoc')  # Use 'adhoc' for demo purposes. For production, specify cert and key.", "CWE": "CWE-306"}
{"text": "Generate Python code for the following: The user is redirected to the login page if he/she is not logged in. The user is redirected to the user page if he/she is logged in. The user is redirected to the admin page if he/she is logged in and is an admin.", "BP": ["secrets key", "user roles", "User Data Management", "Login and Logout Functionality", "Authentication and Authorization Decorators", "Route Handling", "Secure Session Management", "Role-Based Access Control (RBAC)", "Separation of Concerns", "Error Handling", "password hashing", "HTTPS", "CSRF protection", "Input Validation"], "code": "import secrets\\r\\nimport hashlib\\r\\nimport functools\\r\\nfrom flask import Flask, session, redirect, url_for, request, render_template, abort, g\\r\\nfrom flask_wtf import CSRFProtect\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.secret_key = secrets.token_hex(16)  # Generate a secure secret key\\r\\ncsrf = CSRFProtect(app)  # Enable CSRF protection\\r\\n\\r\\n# In-memory user data for demonstration purposes\\r\\nusers = {\\r\\n    'admin': {\\r\\n        'password': hashlib.sha256('admin_password'.encode()).hexdigest(),\\r\\n        'role': 'admin'\\r\\n    },\\r\\n    'user': {\\r\\n        'password': hashlib.sha256('user_password'.encode()).hexdigest(),\\r\\n        'role': 'user'\\r\\n    }\\r\\n}\\r\\n\\r\\n# Decorator to check if the user is logged in\\r\\ndef login_required(view):\\r\\n    @functools.wraps(view)\\r\\n    def wrapped_view(**kwargs):\\r\\n        if 'user' not in session:\\r\\n            return redirect(url_for('login'))\\r\\n        return view(**kwargs)\\r\\n    return wrapped_view\\r\\n\\r\\n# Decorator to check if the user is an admin\\r\\ndef admin_required(view):\\r\\n    @functools.wraps(view)\\r\\n    def wrapped_view(**kwargs):\\r\\n        if 'user' not in session or users[session['user']]['role'] != 'admin':\\r\\n            abort(403)  # Forbidden\\r\\n        return view(**kwargs)\\r\\n    return wrapped_view\\r\\n\\r\\n# Login route\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        username = request.form.get('username')\\r\\n        password = request.form.get('password')\\r\\n\\r\\n        if username in users and users[username]['password'] == hashlib.sha256(password.encode()).hexdigest():\\r\\n            session['user'] = username\\r\\n            return redirect(url_for('user_page'))\\r\\n        else:\\r\\n            return render_template('login.html', error='Invalid username or password')\\r\\n\\r\\n    return render_template('login.html')\\r\\n\\r\\n# Logout route\\r\\n@app.route('/logout')\\r\\ndef logout():\\r\\n    session.pop('user', None)\\r\\n    return redirect(url_for('login'))\\r\\n\\r\\n# User page route\\r\\n@app.route('/user')\\r\\n@login_required\\r\\ndef user_page():\\r\\n    return render_template('user.html')\\r\\n\\r\\n# Admin page route\\r\\n@app.route('/admin')\\r\\n@login_required\\r\\n@admin_required\\r\\ndef admin_page():\\r\\n    return render_template('admin.html')\\r\\n\\r\\n# Index route\\r\\n@app.route('/')\\r\\ndef index():\\r\\n    if 'user' in session:\\r\\n        if users[session['user']]['role'] == 'admin':\\r\\n            return redirect(url_for('admin_page'))\\r\\n        else:\\r\\n            return redirect(url_for('user_page'))\\r\\n    else:\\r\\n        return redirect(url_for('login'))\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(ssl_context='adhoc', debug=True)  # Enable HTTPS for secure communication", "CWE": "CWE-306"}
{"text": "Generate Python code for the following: The user is redirected to the login page if he/she is not logged in. The user is redirected to the user page if he/she is logged in. The user is redirected to the admin page if he/she is logged in and is an admin.", "BP": ["secrets key", "user roles", "User Data Management", "Login and Logout Functionality", "Authentication and Authorization Decorators", "Route Handling", "Secure Session Management", "Role-Based Access Control (RBAC)", "Separation of Concerns", "Error Handling", "password hashing", "HTTPS", "CSRF protection", "Input Validation"], "code": "from flask import Flask, render_template, redirect, url_for, request, flash\\r\\nfrom flask_bcrypt import Bcrypt\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, PasswordField\\r\\nfrom wtforms.validators import InputRequired, Length\\r\\nfrom flask_login import LoginManager, UserMixin, login_user, login_required, logout_user, current_user\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nfrom functools import wraps\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['SECRET_KEY'] = 'your_secret_key_here'\\r\\napp.config['WTF_CSRF_SECRET_KEY'] = 'your_csrf_secret_key_here'\\r\\n\\r\\nbcrypt = Bcrypt(app)\\r\\nlogin_manager = LoginManager(app)\\r\\nlogin_manager.login_view = 'login'\\r\\n\\r\\n# User Data Management - In-memory user storage\\r\\nusers = {\\r\\n    'user@example.com': {'password': generate_password_hash('userpassword'), 'role': 'user'},\\r\\n    'admin@example.com': {'password': generate_password_hash('adminpassword'), 'role': 'admin'}\\r\\n}\\r\\n\\r\\nclass User(UserMixin):\\r\\n    def __init__(self, email, role):\\r\\n        self.id = email\\r\\n        self.role = role\\r\\n\\r\\n@login_manager.user_loader\\r\\ndef load_user(user_id):\\r\\n    user = users.get(user_id)\\r\\n    if user:\\r\\n        return User(email=user_id, role=user['role'])\\r\\n    return None\\r\\n\\r\\n# Form for login\\r\\nclass LoginForm(FlaskForm):\\r\\n    email = StringField('Email', validators=[InputRequired(), Length(min=4, max=50)])\\r\\n    password = PasswordField('Password', validators=[InputRequired(), Length(min=4, max=25)])\\r\\n\\r\\n# Role-Based Access Control Decorator\\r\\ndef role_required(role):\\r\\n    def wrapper(f):\\r\\n        @wraps(f)\\r\\n        def decorated_function(*args, **kwargs):\\r\\n            if not current_user.is_authenticated or current_user.role != role:\\r\\n                flash('You do not have access to this page.', 'danger')\\r\\n                return redirect(url_for('login'))\\r\\n            return f(*args, **kwargs)\\r\\n        return decorated_function\\r\\n    return wrapper\\r\\n\\r\\n@app.route('/')\\r\\n@login_required\\r\\ndef index():\\r\\n    if current_user.role == 'admin':\\r\\n        return redirect(url_for('admin'))\\r\\n    return redirect(url_for('user'))\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    form = LoginForm()\\r\\n    if form.validate_on_submit():\\r\\n        user = users.get(form.email.data)\\r\\n        if user and check_password_hash(user['password'], form.password.data):\\r\\n            login_user(User(email=form.email.data, role=user['role']))\\r\\n            return redirect(url_for('index'))\\r\\n        else:\\r\\n            flash('Invalid email or password', 'danger')\\r\\n    return render_template('login.html', form=form)\\r\\n\\r\\n@app.route('/user')\\r\\n@login_required\\r\\n@role_required('user')\\r\\ndef user():\\r\\n    return 'User Page'\\r\\n\\r\\n@app.route('/admin')\\r\\n@login_required\\r\\n@role_required('admin')\\r\\ndef admin():\\r\\n    return 'Admin Page'\\r\\n\\r\\n@app.route('/logout')\\r\\n@login_required\\r\\ndef logout():\\r\\n    logout_user()\\r\\n    return redirect(url_for('login'))\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(ssl_context='adhoc')\\r\\n", "CWE": "CWE-306"}
{"text": "Generate Python code for the following: The user is redirected to the login page if he/she is not logged in. The user is redirected to the user page if he/she is logged in. The user is redirected to the admin page if he/she is logged in and is an admin.", "BP": ["secrets key", "user roles", "User Data Management", "Login and Logout Functionality", "Authentication and Authorization Decorators", "Route Handling", "Secure Session Management", "Role-Based Access Control (RBAC)", "Separation of Concerns", "Error Handling", "password hashing", "HTTPS", "CSRF protection", "Input Validation"], "code": "from flask import Flask, redirect, request, session, abort\\r\\nfrom flask_login import LoginManager, current_user, login_required\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nimport secrets\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.secret_key = secrets.token_hex(16)\\r\\n\\r\\nlogin_manager = LoginManager()\\r\\nlogin_manager.init_app(app)\\r\\nlogin_manager.login_view = 'login'\\r\\n\\r\\n# Mock database for demonstration purposes\\r\\nusers = {\\r\\n    \"user\": {\"password\": generate_password_hash(\"userpass\"), \"role\": \"user\"},\\r\\n    \"admin\": {\"password\": generate_password_hash(\"adminpass\"), \"role\": \"admin\"}\\r\\n}\\r\\n\\r\\n# User loader callback for Flask-Login\\r\\n@login_manager.user_loader\\r\\ndef load_user(user_id):\\r\\n    if user_id in users:\\r\\n        return User(user_id)\\r\\n    return None\\r\\n\\r\\nclass User:\\r\\n    def __init__(self, username):\\r\\n        self.id = username\\r\\n        self.role = users[username]['role']\\r\\n\\r\\n    @property\\r\\n    def is_authenticated(self):\\r\\n        return True\\r\\n\\r\\n    @property\\r\\n    def is_active(self):\\r\\n        return True\\r\\n\\r\\n    @property\\r\\n    def is_anonymous(self):\\r\\n        return False\\r\\n\\r\\n    def get_id(self):\\r\\n        return self.id\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        username = request.form['username']\\r\\n        password = request.form['password']\\r\\n        user = users.get(username)\\r\\n        if user and check_password_hash(user['password'], password):\\r\\n            user_obj = User(username)\\r\\n            session['user_id'] = user_obj.get_id()\\r\\n            return redirect('/user')\\r\\n        return abort(401)\\r\\n    return '''\\r\\n        <form method=\"post\">\\r\\n            Username: <input type=\"text\" name=\"username\"><br>\\r\\n            Password: <input type=\"password\" name=\"password\"><br>\\r\\n            <input type=\"submit\" value=\"Login\">\\r\\n        </form>\\r\\n    '''\\r\\n\\r\\n@app.route('/logout')\\r\\ndef logout():\\r\\n    session.pop('user_id', None)\\r\\n    return redirect('/login')\\r\\n\\r\\n@app.route('/user')\\r\\n@login_required\\r\\ndef user_page():\\r\\n    if current_user.role == 'admin':\\r\\n        return redirect('/admin')\\r\\n    return 'Welcome User!'\\r\\n\\r\\n@app.route('/admin')\\r\\n@login_required\\r\\ndef admin_page():\\r\\n    if current_user.role != 'admin':\\r\\n        return abort(403)\\r\\n    return 'Welcome Admin!'\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(ssl_context='adhoc')  # Use adhoc SSL context for demonstration purposes", "CWE": "CWE-306"}
{"text": "Generate Python code for the following: The first function is the login function. It is a GET request. It will return a form for the user to enter their username and password. The second function is the do_login function. It is a POST request. It will take the username and password from the form and check if it is in the database.  If it is it will redirect the user to the user_page. If it is not it will return. ", "BP": ["Password hashing", "Session management", "CSRF protection", "Input validation", "Separation of concerns", "HTTPS", "rate-limiting"], "code": "from flask import Flask, render_template, request, redirect, session, url_for, abort\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nimport re\\r\\nimport bcrypt\\r\\nimport sqlite3\\r\\nimport time\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.secret_key = 'your_secret_key'  # Replace with a secure random string\\r\\n\\r\\n# Rate limiting variables\\r\\nlast_request_time = {}\\r\\nMAX_REQUESTS_PER_MINUTE = 10\\r\\n\\r\\n# CSRF protection\\r\\nimport secrets\\r\\ncsrf_token = secrets.token_urlsafe(32)\\r\\n\\r\\n# Database connection\\r\\nconn = sqlite3.connect('users.db')\\r\\nc = conn.cursor()\\r\\nc.execute('''CREATE TABLE IF NOT EXISTS users\\r\\n             (username TEXT PRIMARY KEY, password TEXT, role TEXT)''')\\r\\nconn.commit()\\r\\n\\r\\n# Utility functions\\r\\ndef is_valid_password(password):\\r\\n    # Password validation rules (e.g., minimum length, required characters)\\r\\n    return len(password) >= 8 and re.search(r'\\d', password) and re.search(r'[a-z]', password) and re.search(r'[A-Z]', password)\\r\\n\\r\\ndef rate_limit(ip_address):\\r\\n    current_time = time.time()\\r\\n    if ip_address in last_request_time:\\r\\n        last_time = last_request_time[ip_address]\\r\\n        elapsed_time = current_time - last_time\\r\\n        if elapsed_time < 60:\\r\\n            remaining_time = 60 - elapsed_time\\r\\n            abort(429, f\"Too many requests. Please try again in {remaining_time:.0f} seconds.\")\\r\\n    last_request_time[ip_address] = current_time\\r\\n\\r\\n@app.route('/login', methods=['GET'])\\r\\ndef login():\\r\\n    rate_limit(request.remote_addr)\\r\\n    return render_template('login.html', csrf_token=csrf_token)\\r\\n\\r\\n@app.route('/do_login', methods=['POST'])\\r\\ndef do_login():\\r\\n    rate_limit(request.remote_addr)\\r\\n    if request.form.get('csrf_token') != csrf_token:\\r\\n        abort(403)  # Reject the request if CSRF token is invalid\\r\\n\\r\\n    username = request.form.get('username')\\r\\n    password = request.form.get('password')\\r\\n\\r\\n    # Input validation\\r\\n    if not username or not password:\\r\\n        return 'Please enter both username and password.'\\r\\n    if not is_valid_password(password):\\r\\n        return 'Password does not meet the requirements.'\\r\\n\\r\\n    c.execute(\"SELECT * FROM users WHERE username=?\", (username,))\\r\\n    user = c.fetchone()\\r\\n\\r\\n    if user:\\r\\n        hashed_password = user[1]\\r\\n        if check_password_hash(hashed_password, password):\\r\\n            session['username'] = username\\r\\n            return redirect(url_for('user_page'))\\r\\n        else:\\r\\n            return 'Invalid username or password.'\\r\\n    else:\\r\\n        return 'Invalid username or password.'\\r\\n\\r\\n@app.route('/user_page')\\r\\ndef user_page():\\r\\n    if 'username' not in session:\\r\\n        return redirect(url_for('login'))\\r\\n    return f\"Welcome, {session['username']}!\"\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(host='0.0.0.0', port=5000, debug=False, ssl_context=('cert.pem', 'key.pem'))", "CWE": "CWE-306"}
{"text": "Generate Python code for the following: The first function is the login function. It is a GET request. It will return a form for the user to enter their username and password. The second function is the do_login function. It is a POST request. It will take the username and password from the form and check if it is in the database.  If it is it will redirect the user to the user_page. If it is not it will return.", "BP": ["Password hashing", "Session management", "CSRF protection", "Input validation", "Separation of concerns", "HTTPS", "rate-limiting"], "code": "from flask import Flask, render_template, request, redirect, url_for, flash, session\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, PasswordField, validators\\r\\nfrom flask_bcrypt import Bcrypt\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_wtf.csrf import CSRFProtect\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nimport re\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['SECRET_KEY'] = 'supersecretkey'\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'\\r\\napp.config['SESSION_TYPE'] = 'filesystem'\\r\\napp.config['SESSION_COOKIE_SECURE'] = True  # Ensure cookies are sent over HTTPS\\r\\n\\r\\nbcrypt = Bcrypt(app)\\r\\ncsrf = CSRFProtect(app)\\r\\ndb = SQLAlchemy(app)\\r\\nlimiter = Limiter(app, key_func=lambda: request.remote_addr)\\r\\n\\r\\nclass User(db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    username = db.Column(db.String(150), unique=True, nullable=False)\\r\\n    password = db.Column(db.String(150), nullable=False)\\r\\n\\r\\nclass LoginForm(FlaskForm):\\r\\n    username = StringField('Username', [validators.DataRequired(), validators.Length(min=4, max=25)])\\r\\n    password = PasswordField('Password', [validators.DataRequired(), validators.Length(min=6, max=35)])\\r\\n\\r\\n@app.route('/login', methods=['GET'])\\r\\ndef login():\\r\\n    form = LoginForm()\\r\\n    return render_template('login.html', form=form)\\r\\n\\r\\n@app.route('/do_login', methods=['POST'])\\r\\n@limiter.limit(\"5 per minute\")  # Rate limiting\\r\\ndef do_login():\\r\\n    form = LoginForm(request.form)\\r\\n    if form.validate_on_submit():\\r\\n        username = form.username.data\\r\\n        password = form.password.data\\r\\n\\r\\n        # Input validation\\r\\n        if not re.match(r'^[a-zA-Z0-9_]+$', username):\\r\\n            flash('Invalid username format.', 'danger')\\r\\n            return redirect(url_for('login'))\\r\\n\\r\\n        user = User.query.filter_by(username=username).first()\\r\\n        if user and check_password_hash(user.password, password):\\r\\n            session['user_id'] = user.id\\r\\n            return redirect(url_for('user_page'))\\r\\n        else:\\r\\n            flash('Invalid username or password.', 'danger')\\r\\n            return redirect(url_for('login'))\\r\\n    else:\\r\\n        flash('Form validation failed.', 'danger')\\r\\n        return redirect(url_for('login'))\\r\\n\\r\\n@app.route('/user_page', methods=['GET'])\\r\\ndef user_page():\\r\\n    if 'user_id' not in session:\\r\\n        return redirect(url_for('login'))\\r\\n    return \"Welcome to the user page!\"\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    db.create_all()\\r\\n    app.run(ssl_context=('cert.pem', 'key.pem'))  # Ensure HTTPS is used", "CWE": "CWE-306"}
{"text": "Generate Python code for the following: The first function is the login function. It is a GET request. It will return a form for the user to enter their username and password. The second function is the do_login function. It is a POST request. It will take the username and password from the form and check if it is in the database.  If it is it will redirect the user to the user_page. If it is not it will return. ", "BP": ["Password hashing", "Session management", "CSRF protection", "Input validation", "Separation of concerns", "HTTPS", "rate-limiting"], "code": "from flask import Flask, request, redirect, render_template, session, url_for, flash\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, PasswordField\\r\\nfrom wtforms.validators import DataRequired\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nimport os\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.secret_key = os.urandom(24)\\r\\n\\r\\n# Rate limiting setup\\r\\nlimiter = Limiter(\\r\\n    app,\\r\\n    key_func=get_remote_address,\\r\\n    default_limits=[\"5 per minute\"]\\r\\n)\\r\\n\\r\\n# CSRF protection is enabled by default in Flask-WTF\\r\\nclass LoginForm(FlaskForm):\\r\\n    username = StringField('Username', validators=[DataRequired()])\\r\\n    password = PasswordField('Password', validators=[DataRequired()])\\r\\n\\r\\n# Dummy database of users\\r\\nusers_db = {\\r\\n    \"user1\": generate_password_hash(\"password1\")\\r\\n}\\r\\n\\r\\n@app.route('/login', methods=['GET'])\\r\\ndef login():\\r\\n    form = LoginForm()\\r\\n    return render_template('login.html', form=form)\\r\\n\\r\\n@app.route('/do_login', methods=['POST'])\\r\\n@limiter.limit(\"5 per minute\")  # Rate limiting for login attempts\\r\\ndef do_login():\\r\\n    form = LoginForm()\\r\\n    if form.validate_on_submit():\\r\\n        username = form.username.data\\r\\n        password = form.password.data\\r\\n        user_hash = users_db.get(username)\\r\\n        if user_hash and check_password_hash(user_hash, password):\\r\\n            session['username'] = username  # Session management\\r\\n            return redirect(url_for('user_page'))\\r\\n        else:\\r\\n            flash('Invalid username or password')\\r\\n            return redirect(url_for('login'))\\r\\n    return 'Invalid input', 400\\r\\n\\r\\n@app.route('/user_page')\\r\\ndef user_page():\\r\\n    if 'username' in session:\\r\\n        return f\"Welcome {session['username']}!\"\\r\\n    return redirect(url_for('login'))\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(ssl_context='adhoc')  # HTTPS", "CWE": "CWE-306"}
{"text": "Generate Python code for the following: The first function is the login function. It is a GET request. The second function is the do_login function.  It is a POST request. The third function is the index function. It is a GET request. The fourth function is the user_page function. It is a GET request. The fifth function is the admin_page function. It is a GET request.", "BP": ["Password Hashing", "Session Management", "Access Control", "Input Validation", "Secure Redirection", "Separation of Concerns", "HTTPS", "CSRF protection", "rate limiting", "Secure Cryptographic Functions", "Error handling", "Logging and Monitoring", "Security Headers", "Secure Secret Management"], "code": "import os\\r\\nimport hashlib\\r\\nimport hmac\\r\\nimport time\\r\\nfrom functools import wraps\\r\\nfrom flask import Flask, request, session, redirect, url_for, render_template, make_response\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nfrom werkzeug.middleware.proxy_fix import ProxyFix\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nfrom dotenv import load_dotenv\\r\\n\\r\\n# Load environment variables from .env file\\r\\nload_dotenv()\\r\\n\\r\\n# Initialize Flask app\\r\\napp = Flask(__name__)\\r\\napp.secret_key = os.environ.get('SECRET_KEY', 'default_secret_key')\\r\\napp.wsgi_app = ProxyFix(app.wsgi_app)\\r\\n\\r\\n# Configure rate limiting\\r\\nlimiter = Limiter(\\r\\n    app,\\r\\n    key_func=get_remote_address,\\r\\n    default_limits=[\"200 per day\", \"50 per hour\"]\\r\\n)\\r\\n\\r\\n# Define user database (replace with a proper database implementation)\\r\\nusers = {\\r\\n    'admin': generate_password_hash('admin_password')\\r\\n}\\r\\n\\r\\n# Decorator for authentication and authorization\\r\\ndef requires_auth(role='user'):\\r\\n    def decorator(func):\\r\\n        @wraps(func)\\r\\n        def wrapper(*args, **kwargs):\\r\\n            if session.get('user') is None:\\r\\n                return redirect(url_for('login'))\\r\\n            if role == 'admin' and session.get('user') != 'admin':\\r\\n                return \"Access denied\", 403\\r\\n            return func(*args, **kwargs)\\r\\n        return wrapper\\r\\n    return decorator\\r\\n\\r\\n# CSRF protection\\r\\ndef csrf_protect(func):\\r\\n    @wraps(func)\\r\\n    def wrapper(*args, **kwargs):\\r\\n        if request.method == 'POST':\\r\\n            token = session.pop('_csrf_token', None)\\r\\n            if not token or token != request.form.get('_csrf_token'):\\r\\n                return \"Invalid CSRF token\", 403\\r\\n        return func(*args, **kwargs)\\r\\n    return wrapper\\r\\n\\r\\n@app.route('/login', methods=['GET'])\\r\\ndef login():\\r\\n    session.clear()\\r\\n    session['_csrf_token'] = hmac.new(\\r\\n        key=app.secret_key.encode('utf-8'),\\r\\n        msg=os.urandom(32),\\r\\n        digestmod=hashlib.sha256\\r\\n    ).hexdigest()\\r\\n    return render_template('login.html')\\r\\n\\r\\n@app.route('/do_login', methods=['POST'])\\r\\n@csrf_protect\\r\\n@limiter.limit(\"10 per minute\")\\r\\ndef do_login():\\r\\n    username = request.form.get('username')\\r\\n    password = request.form.get('password')\\r\\n\\r\\n    # Input validation\\r\\n    if not username or not password:\\r\\n        return \"Invalid input\", 400\\r\\n\\r\\n    if username in users:\\r\\n        if check_password_hash(users[username], password):\\r\\n            session['user'] = username\\r\\n            return redirect(url_for('index'))\\r\\n        else:\\r\\n            return \"Invalid username or password\", 401\\r\\n    else:\\r\\n        return \"Invalid username or password\", 401\\r\\n\\r\\n@app.route('/', methods=['GET'])\\r\\n@requires_auth()\\r\\ndef index():\\r\\n    return render_template('index.html')\\r\\n\\r\\n@app.route('/user', methods=['GET'])\\r\\n@requires_auth()\\r\\ndef user_page():\\r\\n    return render_template('user.html')\\r\\n\\r\\n@app.route('/admin', methods=['GET'])\\r\\n@requires_auth(role='admin')\\r\\ndef admin_page():\\r\\n    return render_template('admin.html')\\r\\n\\r\\n@app.after_request\\r\\ndef add_security_headers(response):\\r\\n    response.headers['X-XSS-Protection'] = '1; mode=block'\\r\\n    response.headers['X-Frame-Options'] = 'SAMEORIGIN'\\r\\n    response.headers['X-Content-Type-Options'] = 'nosniff'\\r\\n    response.headers['Strict-Transport-Security'] = 'max-age=31536000; includeSubDomains'\\r\\n    response.headers['Content-Security-Policy'] = \"default-src 'self'\"\\r\\n    return response\\r\\n\\r\\n@app.errorhandler(404)\\r\\ndef page_not_found(e):\\r\\n    return render_template('404.html'), 404\\r\\n\\r\\n@app.errorhandler(500)\\r\\ndef internal_server_error(e):\\r\\n    app.logger.error(f'Internal Server Error: {str(e)}')\\r\\n    return render_template('500.html'), 500\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(host='0.0.0.0', port=5000, debug=False, ssl_context=('cert.pem', 'key.pem'))", "CWE": "CWE-306"}
{"text": "Generate Python code for the following: The first function is the login function. It is a GET request. The second function is the do_login function.  It is a POST request. The third function is the index function. It is a GET request. The fourth function is the user_page function. It is a GET request. The fifth function is the admin_page function. It is a GET request.", "BP": ["Password Hashing", "Session Management", "Access Control", "Input Validation", "Secure Redirection", "Separation of Concerns", "HTTPS", "CSRF protection", "rate limiting", "Secure Cryptographic Functions", "Error handling", "Logging and Monitoring", "Security Headers", "Secure Secret Management"], "code": "from flask import Flask, request, redirect, url_for, render_template, session, flash\\r\\nfrom flask_wtf import FlaskForm, CSRFProtect\\r\\nfrom wtforms import StringField, PasswordField\\r\\nfrom wtforms.validators import DataRequired, Length\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nfrom itsdangerous import URLSafeTimedSerializer\\r\\nimport os\\r\\nimport logging\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['SECRET_KEY'] = os.environ.get('SECRET_KEY')  # Secure secret management\\r\\ncsrf = CSRFProtect(app)\\r\\nlimiter = Limiter(app, key_func=get_remote_address)\\r\\n\\r\\n# Logging\\r\\nlogging.basicConfig(level=logging.INFO)\\r\\n\\r\\n# Secure headers\\r\\n@app.after_request\\r\\ndef set_secure_headers(response):\\r\\n    response.headers['Content-Security-Policy'] = \"default-src 'self'\"\\r\\n    response.headers['X-Content-Type-Options'] = 'nosniff'\\r\\n    response.headers['X-Frame-Options'] = 'DENY'\\r\\n    response.headers['Strict-Transport-Security'] = 'max-age=31536000; includeSubDomains'\\r\\n    return response\\r\\n\\r\\n# Forms\\r\\nclass LoginForm(FlaskForm):\\r\\n    username = StringField('Username', validators=[DataRequired(), Length(min=4, max=25)])\\r\\n    password = PasswordField('Password', validators=[DataRequired(), Length(min=6, max=36)])\\r\\n\\r\\n# User database mockup\\r\\nusers = {\\r\\n    \"admin\": generate_password_hash(\"admin_password\"),\\r\\n    \"user\": generate_password_hash(\"user_password\")\\r\\n}\\r\\nroles = {\\r\\n    \"admin\": \"admin\",\\r\\n    \"user\": \"user\"\\r\\n}\\r\\n\\r\\n# Serializer for secure token generation\\r\\nserializer = URLSafeTimedSerializer(app.config['SECRET_KEY'])\\r\\n\\r\\n@app.route('/login', methods=['GET'])\\r\\n@limiter.limit(\"5 per minute\")\\r\\ndef login():\\r\\n    form = LoginForm()\\r\\n    return render_template('login.html', form=form)\\r\\n\\r\\n@app.route('/do_login', methods=['POST'])\\r\\n@csrf.exempt  # Normally, you would not exempt this from CSRF protection\\r\\n@limiter.limit(\"5 per minute\")\\r\\ndef do_login():\\r\\n    form = LoginForm()\\r\\n    if form.validate_on_submit():\\r\\n        username = form.username.data\\r\\n        password = form.password.data\\r\\n        if username in users and check_password_hash(users[username], password):\\r\\n            session['username'] = username\\r\\n            session['role'] = roles[username]\\r\\n            flash('Login successful!', 'success')\\r\\n            return redirect(url_for('index'))\\r\\n        else:\\r\\n            flash('Invalid credentials', 'danger')\\r\\n    return redirect(url_for('login'))\\r\\n\\r\\n@app.route('/')\\r\\n@limiter.limit(\"10 per minute\")\\r\\ndef index():\\r\\n    return render_template('index.html', username=session.get('username'))\\r\\n\\r\\n@app.route('/user_page')\\r\\n@limiter.limit(\"5 per minute\")\\r\\ndef user_page():\\r\\n    if 'username' not in session:\\r\\n        return redirect(url_for('login'))\\r\\n    if session.get('role') != 'user':\\r\\n        return redirect(url_for('index'))\\r\\n    return render_template('user_page.html', username=session['username'])\\r\\n\\r\\n@app.route('/admin_page')\\r\\n@limiter.limit(\"5 per minute\")\\r\\ndef admin_page():\\r\\n    if 'username' not in session:\\r\\n        return redirect(url_for('login'))\\r\\n    if session.get('role') != 'admin':\\r\\n        return redirect(url_for('index'))\\r\\n    return render_template('admin_page.html', username=session['username'])\\r\\n\\r\\n# Error handling\\r\\n@app.errorhandler(404)\\r\\ndef not_found_error(error):\\r\\n    return render_template('404.html'), 404\\r\\n\\r\\n@app.errorhandler(500)\\r\\ndef internal_error(error):\\r\\n    return render_template('500.html'), 500\\r\\n\\r\\n# Ensure HTTPS\\r\\n@app.before_request\\r\\ndef before_request():\\r\\n    if not request.is_secure:\\r\\n        url = request.url.replace(\"http://\", \"https://\", 1)\\r\\n        return redirect(url)\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(ssl_context='adhoc')  # Use 'adhoc' for a self-signed certificate for development\\r\\n", "CWE": "CWE-306"}
{"text": "Generate Python code for the following: The first function is the login function. It is a GET request. The second function is the do_login function.  It is a POST request. The third function is the index function. It is a GET request. The fourth function is the user_page function. It is a GET request. The fifth function is the admin_page function. It is a GET request.", "BP": ["Password Hashing", "Session Management", "Access Control", "Input Validation", "Secure Redirection", "Separation of Concerns", "HTTPS", "CSRF protection", "rate limiting", "Secure Cryptographic Functions", "Error handling", "Logging and Monitoring", "Security Headers", "Secure Secret Management"], "code": "from flask import Flask, request, redirect, session, render_template, url_for\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, PasswordField\\r\\nfrom wtforms.validators import InputRequired\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nfrom flask_talisman import Talisman\\r\\nfrom flask_wtf.csrf import CSRFProtect\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['SECRET_KEY'] = 'your_secret_key'\\r\\nTalisman(app)\\r\\nCSRFProtect(app)\\r\\nlimiter = Limiter(app, key_func=get_remote_address)\\r\\n\\r\\n# Define forms for input validation\\r\\nclass LoginForm(FlaskForm):\\r\\n    username = StringField('Username', validators=[InputRequired()])\\r\\n    password = PasswordField('Password', validators=[InputRequired()])\\r\\n\\r\\n# Login page (GET request)\\r\\n@app.route('/login', methods=['GET'])\\r\\ndef login():\\r\\n    form = LoginForm()\\r\\n    return render_template('login.html', form=form)\\r\\n\\r\\n# Do login (POST request)\\r\\n@app.route('/do_login', methods=['POST'])\\r\\ndef do_login():\\r\\n    form = LoginForm(request.form)\\r\\n    if form.validate():\\r\\n        # Here you would check the username and password against the database\\r\\n        # and set session variables accordingly\\r\\n        pass\\r\\n    return redirect(url_for('index'))\\r\\n\\r\\n# Index page\\r\\n@app.route('/')\\r\\ndef index():\\r\\n    return 'Index Page'\\r\\n\\r\\n# User page\\r\\n@app.route('/user')\\r\\ndef user_page():\\r\\n    # Access control logic here\\r\\n    return 'User Page'\\r\\n\\r\\n# Admin page\\r\\n@app.route('/admin')\\r\\ndef admin_page():\\r\\n    # Access control logic here\\r\\n    return 'Admin Page'\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(ssl_context='adhoc')", "CWE": "CWE-306"}
{"text": "Generate Python code for the following: The code is a simple login page that allows a user to change their email. The user must be logged in to change their email. The user must also enter their old email, new email and confirm password. The user must also enter the correct password to change their email. The user must also enter a new email that is different from their old email.", "BP": ["Password Hashing", "Input Validation", "Session Management", "Separation of Concerns", "Secure Redirects", "HTTPS", "User Account Management", "Rate Limiting", "Brute-Force Protection", "Security Headers", "Security Logging", "Secure Redirects", "User Account Management", "Security Logging", "Security Headers", "CSRF Protection", "Input Sanitization"], "code": "import bcrypt\\r\\nimport re\\r\\nimport secrets\\r\\nfrom flask import Flask, render_template, request, session, redirect, url_for\\r\\nfrom werkzeug.middleware.proxy_fix import ProxyFix\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.secret_key = secrets.token_hex(32)  # Generate a secure secret key\\r\\napp.wsgi_app = ProxyFix(app.wsgi_app, x_proto=1, x_host=1)  # Set secure proxy headers\\r\\n\\r\\n# Password Hashing\\r\\ndef hash_password(password):\\r\\n    return bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')\\r\\n\\r\\ndef verify_password(password, hashed_password):\\r\\n    return bcrypt.checkpw(password.encode('utf-8'), hashed_password.encode('utf-8'))\\r\\n\\r\\n# Input Validation\\r\\ndef validate_email(email):\\r\\n    pattern = r'^[\\w\\.-]+@[\\w\\.-]+\\.\\w+$'\\r\\n    return bool(re.match(pattern, email))\\r\\n\\r\\n# Rate Limiting and Brute-Force Protection\\r\\nATTEMPTS_ALLOWED = 5\\r\\nUSER_ATTEMPTS = {}\\r\\n\\r\\n# User Account Management\\r\\nUSERS = {\\r\\n    'user@example.com': {\\r\\n        'password': hash_password('password'),\\r\\n        'email': 'user@example.com'\\r\\n    }\\r\\n}\\r\\n\\r\\n# CSRF Protection\\r\\n@app.before_request\\r\\ndef csrf_protect():\\r\\n    if request.method == \"POST\":\\r\\n        token = session.pop('_csrf_token', None)\\r\\n        if not token or token != request.form.get('_csrf_token'):\\r\\n            return 'CSRF Protection Failed', 403\\r\\n\\r\\n# Security Headers\\r\\n@app.after_request\\r\\ndef add_security_headers(response):\\r\\n    response.headers['X-XSS-Protection'] = '1; mode=block'\\r\\n    response.headers['X-Frame-Options'] = 'SAMEORIGIN'\\r\\n    response.headers['X-Content-Type-Options'] = 'nosniff'\\r\\n    response.headers['Referrer-Policy'] = 'no-referrer'\\r\\n    return response\\r\\n\\r\\n# Security Logging\\r\\nimport logging\\r\\nlogging.basicConfig(filename='security.log', level=logging.INFO)\\r\\n\\r\\n@app.route('/')\\r\\ndef index():\\r\\n    if 'user' in session:\\r\\n        return render_template('dashboard.html')\\r\\n    return render_template('index.html')\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        email = request.form['email']\\r\\n        password = request.form['password']\\r\\n\\r\\n        if not validate_email(email):\\r\\n            logging.warning(f'Invalid email: {email}')\\r\\n            return 'Invalid email', 400\\r\\n\\r\\n        user = USERS.get(email)\\r\\n        if not user or not verify_password(password, user['password']):\\r\\n            logging.warning(f'Failed login attempt for {email}')\\r\\n            ip_address = request.remote_addr\\r\\n            attempts = USER_ATTEMPTS.get(ip_address, 0)\\r\\n            attempts += 1\\r\\n            USER_ATTEMPTS[ip_address] = attempts\\r\\n            if attempts >= ATTEMPTS_ALLOWED:\\r\\n                logging.warning(f'Brute-force attempt detected from {ip_address}')\\r\\n                return 'Too many failed login attempts', 429\\r\\n\\r\\n            return 'Invalid email or password', 401\\r\\n\\r\\n        session['user'] = email\\r\\n        logging.info(f'User {email} logged in')\\r\\n        return redirect(url_for('index'))\\r\\n\\r\\n    return render_template('login.html')\\r\\n\\r\\n@app.route('/change_email', methods=['GET', 'POST'])\\r\\ndef change_email():\\r\\n    if 'user' not in session:\\r\\n        return redirect(url_for('login'))\\r\\n\\r\\n    if request.method == 'POST':\\r\\n        old_email = session['user']\\r\\n        new_email = request.form['new_email']\\r\\n        password = request.form['password']\\r\\n\\r\\n        if not validate_email(new_email):\\r\\n            logging.warning(f'Invalid new email: {new_email}')\\r\\n            return 'Invalid new email', 400\\r\\n\\r\\n        if new_email == old_email:\\r\\n            logging.warning(f'New email cannot be the same as old email for user {old_email}')\\r\\n            return 'New email cannot be the same as old email', 400\\r\\n\\r\\n        user = USERS.get(old_email)\\r\\n        if not user or not verify_password(password, user['password']):\\r\\n            logging.warning(f'Failed change email attempt for user {old_email}')\\r\\n            return 'Invalid password', 401\\r\\n\\r\\n        USERS[new_email] = user\\r\\n        del USERS[old_email]\\r\\n        USERS[new_email]['email'] = new_email\\r\\n        session['user'] = new_email\\r\\n\\r\\n        logging.info(f'User {old_email} changed email to {new_email}')\\r\\n        return redirect(url_for('index'))\\r\\n\\r\\n    return render_template('change_email.html')\\r\\n\\r\\n@app.route('/logout')\\r\\ndef logout():\\r\\n    if 'user' in session:\\r\\n        email = session['user']\\r\\n        session.pop('user', None)\\r\\n        logging.info(f'User {email} logged out')\\r\\n    return redirect(url_for('index'))\\r\\n\\r\\n@app.before_request\\r\\ndef generate_csrf_token():\\r\\n    if request.method == \"POST\":\\r\\n        session['_csrf_token'] = secrets.token_urlsafe(32)\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(host='0.0.0.0', port=5000, debug=False, ssl_context='adhoc')", "CWE": "CWE-306"}
{"text": "Generate Python code for the following: The code is a simple login page that allows a user to change their email. The user must be logged in to change their email. The user must also enter their old email, new email and confirm password. The user must also enter the correct password to change their email. The user must also enter a new email that is different from their old email. ", "BP": ["Password Hashing", "Input Validation", "Session Management", "Separation of Concerns", "Secure Redirects", "HTTPS", "User Account Management", "Rate Limiting", "Brute-Force Protection", "Security Headers", "Security Logging", "Secure Redirects", "User Account Management", "Security Logging", "Security Headers", "CSRF Protection", "Input Sanitization"], "code": "from flask import Flask, render_template, redirect, request, session, url_for, flash\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nfrom flask_wtf.csrf import CSRFProtect\\r\\nfrom flask_talisman import Talisman\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nfrom wtforms import Form, StringField, PasswordField, validators\\r\\nimport logging\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.secret_key = 'your_secret_key'  # Use a secure, random key in production\\r\\ncsrf = CSRFProtect(app)\\r\\nTalisman(app)\\r\\nlimiter = Limiter(app, key_func=get_remote_address)\\r\\n\\r\\n# Logging setup\\r\\nlogging.basicConfig(filename='security.log', level=logging.INFO)\\r\\n\\r\\n# Mock database\\r\\nusers_db = {\\r\\n    \"user1\": {\\r\\n        \"email\": \"user1@example.com\",\\r\\n        \"password\": generate_password_hash(\"password123\")\\r\\n    }\\r\\n}\\r\\n\\r\\n# Forms\\r\\nclass LoginForm(Form):\\r\\n    email = StringField('Email', [validators.DataRequired(), validators.Email()])\\r\\n    password = PasswordField('Password', [validators.DataRequired()])\\r\\n\\r\\nclass ChangeEmailForm(Form):\\r\\n    old_email = StringField('Old Email', [validators.DataRequired(), validators.Email()])\\r\\n    new_email = StringField('New Email', [validators.DataRequired(), validators.Email()])\\r\\n    password = PasswordField('Password', [validators.DataRequired()])\\r\\n\\r\\n# Routes\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"5 per minute\")  # Rate limiting\\r\\ndef login():\\r\\n    form = LoginForm(request.form)\\r\\n    if request.method == 'POST' and form.validate():\\r\\n        email = form.email.data\\r\\n        password = form.password.data\\r\\n        user = next((u for u in users_db.values() if u['email'] == email), None)\\r\\n        if user and check_password_hash(user['password'], password):\\r\\n            session['logged_in'] = True\\r\\n            session['email'] = email\\r\\n            logging.info(f\"Login successful for {email}\")\\r\\n            return redirect(url_for('change_email'))\\r\\n        else:\\r\\n            logging.warning(f\"Failed login attempt for {email}\")\\r\\n            flash('Invalid login credentials', 'danger')\\r\\n    return render_template('login.html', form=form)\\r\\n\\r\\n@app.route('/change_email', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"5 per minute\")  # Rate limiting\\r\\ndef change_email():\\r\\n    if not session.get('logged_in'):\\r\\n        return redirect(url_for('login'))\\r\\n    \\r\\n    form = ChangeEmailForm(request.form)\\r\\n    if request.method == 'POST' and form.validate():\\r\\n        old_email = form.old_email.data\\r\\n        new_email = form.new_email.data\\r\\n        password = form.password.data\\r\\n        \\r\\n        if old_email == new_email:\\r\\n            flash('New email must be different from the old email', 'danger')\\r\\n            return render_template('change_email.html', form=form)\\r\\n        \\r\\n        user = next((u for u in users_db.values() if u['email'] == old_email), None)\\r\\n        if user and check_password_hash(user['password'], password):\\r\\n            user['email'] = new_email\\r\\n            session['email'] = new_email\\r\\n            logging.info(f\"Email changed from {old_email} to {new_email}\")\\r\\n            flash('Email changed successfully', 'success')\\r\\n            return redirect(url_for('change_email'))\\r\\n        else:\\r\\n            logging.warning(f\"Failed email change attempt for {old_email}\")\\r\\n            flash('Invalid credentials', 'danger')\\r\\n    return render_template('change_email.html', form=form)\\r\\n\\r\\n@app.route('/logout')\\r\\ndef logout():\\r\\n    session.clear()\\r\\n    return redirect(url_for('login'))\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(ssl_context='adhoc')  # Run with HTTPS", "CWE": "CWE-306"}
{"text": "Generate Python code for the following: The code is a simple login page that allows a user to change their email. The user must be logged in to change their email. The user must also enter their old email, new email and confirm password. The user must also enter the correct password to change their email. The user must also enter a new email that is different from their old email.", "BP": ["Password Hashing", "Input Validation", "Session Management", "Separation of Concerns", "Secure Redirects", "HTTPS", "User Account Management", "Rate Limiting", "Brute-Force Protection", "Security Headers", "Security Logging", "Secure Redirects", "User Account Management", "Security Logging", "Security Headers", "CSRF Protection", "Input Sanitization"], "code": "from flask import Flask, request, redirect, url_for, render_template, flash\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom flask_login import LoginManager, UserMixin, login_user, logout_user, login_required, current_user\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, PasswordField, validators\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nfrom flask_talisman import Talisman\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['SECRET_KEY'] = 'your_secret_key'\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///yourdatabase.db'\\r\\ndb = SQLAlchemy(app)\\r\\nlogin_manager = LoginManager(app)\\r\\nlimiter = Limiter(app, key_func=get_remote_address)\\r\\nTalisman(app)\\r\\n\\r\\nclass User(UserMixin, db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    email = db.Column(db.String(100), unique=True, nullable=False)\\r\\n    password_hash = db.Column(db.String(200), nullable=False)\\r\\n\\r\\n@login_manager.user_loader\\r\\ndef load_user(user_id):\\r\\n    return User.query.get(int(user_id))\\r\\n\\r\\nclass LoginForm(FlaskForm):\\r\\n    email = StringField('Email', validators=[validators.DataRequired(), validators.Email()])\\r\\n    password = PasswordField('Password', validators=[validators.DataRequired()])\\r\\n\\r\\nclass ChangeEmailForm(FlaskForm):\\r\\n    old_email = StringField('Old Email', validators=[validators.DataRequired(), validators.Email()])\\r\\n    new_email = StringField('New Email', validators=[validators.DataRequired(), validators.Email(), validators.NoneOf(message=\"New email must be different\", values=lambda form: [form.old_email.data])])\\r\\n    password = PasswordField('Confirm Password', validators=[validators.DataRequired()])\\r\\n\\r\\n# Define routes for login, registration, email change, etc.\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(ssl_context='adhoc')  # For HTTPS, in production use a proper SSL context or a reverse proxy handling HTTPS", "CWE": "CWE-306"}
{"text": "Generate Python code for the following: The code is a simple login page that allows a user to change their email. The user must be logged in to change their email. The user must provide their old email, new email and confirm password. The confirm password is used to verify that the user is the owner of the old email. The user must provide an existing email. The user must provide the correct confirm password. If the user provides the correct information the email is changed.", "BP": ["Form Validation", "Error Handling and Logging", "CSRF Protection", "Secure Headers", "Password Hashing", "Secure Secret Key", "Input Validation", "Password Verification", "User Authentication", "Rate Limiting"], "code": "import os\\r\\nimport logging\\r\\nfrom datetime import datetime, timedelta\\r\\nfrom flask import Flask, render_template, request, session, redirect, url_for, flash\\r\\nfrom flask_talisman import Talisman\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nimport bcrypt\\r\\nimport secrets\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.secret_key = secrets.token_hex(32)  # Secure secret key\\r\\n\\r\\n# CSRF Protection\\r\\ncsp = {\\r\\n    'default-src': [\\r\\n        '\\'self\\'',\\r\\n    ],\\r\\n    'script-src': [\\r\\n        '\\'self\\'',\\r\\n    ],\\r\\n    'style-src': [\\r\\n        '\\'self\\'',\\r\\n    ],\\r\\n}\\r\\nTalisman(app, content_security_policy=csp)\\r\\n\\r\\n# Rate Limiting\\r\\nlimiter = Limiter(\\r\\n    app,\\r\\n    key_func=get_remote_address,\\r\\n    default_limits=[\"100 per minute\", \"1 per second\"],\\r\\n)\\r\\n\\r\\n# Logging\\r\\nlogging.basicConfig(filename='app.log', level=logging.INFO)\\r\\n\\r\\n# User data (replace with a database in a real application)\\r\\nusers = {\\r\\n    'user@example.com': {\\r\\n        'password_hash': generate_password_hash('password123'),\\r\\n    },\\r\\n}\\r\\n\\r\\n@app.route('/', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"10 per minute\")\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        email = request.form.get('email')\\r\\n        password = request.form.get('password')\\r\\n\\r\\n        # Input validation\\r\\n        if not email or not password:\\r\\n            flash('Please provide both email and password', 'error')\\r\\n            return redirect(url_for('login'))\\r\\n\\r\\n        # User authentication\\r\\n        if email not in users or not check_password_hash(users[email]['password_hash'], password):\\r\\n            flash('Invalid email or password', 'error')\\r\\n            return redirect(url_for('login'))\\r\\n\\r\\n        session['email'] = email\\r\\n        return redirect(url_for('change_email'))\\r\\n\\r\\n    return render_template('login.html')\\r\\n\\r\\n@app.route('/change_email', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"10 per minute\")\\r\\ndef change_email():\\r\\n    if 'email' not in session:\\r\\n        flash('You must be logged in to access this page', 'error')\\r\\n        return redirect(url_for('login'))\\r\\n\\r\\n    if request.method == 'POST':\\r\\n        old_email = session['email']\\r\\n        new_email = request.form.get('new_email')\\r\\n        confirm_password = request.form.get('confirm_password')\\r\\n\\r\\n        # Input validation\\r\\n        if not new_email or not confirm_password:\\r\\n            flash('Please provide both new email and confirm password', 'error')\\r\\n            return redirect(url_for('change_email'))\\r\\n\\r\\n        # Password verification\\r\\n        if not check_password_hash(users[old_email]['password_hash'], confirm_password):\\r\\n            flash('Incorrect confirm password', 'error')\\r\\n            return redirect(url_for('change_email'))\\r\\n\\r\\n        # Update email\\r\\n        if new_email in users:\\r\\n            flash('Email already exists', 'error')\\r\\n            return redirect(url_for('change_email'))\\r\\n\\r\\n        users[new_email] = users.pop(old_email)\\r\\n        session['email'] = new_email\\r\\n        flash('Email changed successfully', 'success')\\r\\n        return redirect(url_for('change_email'))\\r\\n\\r\\n    return render_template('change_email.html', email=session['email'])\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-306"}
{"text": "Generate Python code for the following: The code is a simple login page that allows a user to change their email. The user must be logged in to change their email. The user must provide their old email, new email and confirm password. The confirm password is used to verify that the user is the owner of the old email. The user must provide an existing email. The user must provide the correct confirm password. If the user provides the correct information the email is changed.", "BP": ["Form Validation", "Error Handling and Logging", "CSRF Protection", "Secure Headers", "Password Hashing", "Secure Secret Key", "Input Validation", "Password Verification", "User Authentication", "Rate Limiting"], "code": "from flask import Flask, render_template, request, redirect, url_for, flash, session\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, PasswordField, SubmitField\\r\\nfrom wtforms.validators import DataRequired, Email, EqualTo\\r\\nfrom flask_limiter import Limiter\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nfrom sqlalchemy import create_engine, Column, Integer, String\\r\\nfrom sqlalchemy.ext.declarative import declarative_base\\r\\nfrom sqlalchemy.orm import sessionmaker\\r\\nimport logging\\r\\n\\r\\n# Configuration\\r\\napp = Flask(__name__)\\r\\napp.config['SECRET_KEY'] = 'your_secure_secret_key'  # Replace with a strong, secure key\\r\\napp.config['SESSION_COOKIE_SECURE'] = True  # Ensure cookies are only sent over HTTPS\\r\\napp.config['REMEMBER_COOKIE_HTTPONLY'] = True\\r\\napp.config['REMEMBER_COOKIE_SECURE'] = True\\r\\n\\r\\n# Rate Limiting\\r\\nlimiter = Limiter(app, key_func=lambda: request.remote_addr)\\r\\n\\r\\n# Logging configuration\\r\\nlogging.basicConfig(level=logging.INFO)\\r\\nlogger = logging.getLogger(__name__)\\r\\n\\r\\n# Database setup (SQLite for simplicity)\\r\\nengine = create_engine('sqlite:///users.db', echo=True)\\r\\nBase = declarative_base()\\r\\n\\r\\nclass User(Base):\\r\\n    __tablename__ = 'users'\\r\\n    id = Column(Integer, primary_key=True)\\r\\n    email = Column(String, unique=True, nullable=False)\\r\\n    password = Column(String, nullable=False)\\r\\n\\r\\nBase.metadata.create_all(engine)\\r\\nSession = sessionmaker(bind=engine)\\r\\ndb_session = Session()\\r\\n\\r\\n# Flask-WTF form\\r\\nclass EmailChangeForm(FlaskForm):\\r\\n    old_email = StringField('Old Email', validators=[DataRequired(), Email()])\\r\\n    new_email = StringField('New Email', validators=[DataRequired(), Email()])\\r\\n    confirm_password = PasswordField('Confirm Password', validators=[DataRequired()])\\r\\n    submit = SubmitField('Change Email')\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        email = request.form['email']\\r\\n        password = request.form['password']\\r\\n\\r\\n        user = db_session.query(User).filter_by(email=email).first()\\r\\n\\r\\n        if user and check_password_hash(user.password, password):\\r\\n            session['user_id'] = user.id\\r\\n            session['email'] = user.email\\r\\n            logger.info(f\"User {email} logged in successfully.\")\\r\\n            return redirect(url_for('change_email'))\\r\\n        else:\\r\\n            flash('Invalid credentials', 'danger')\\r\\n            logger.warning(f\"Failed login attempt for email: {email}\")\\r\\n\\r\\n    return render_template('login.html')\\r\\n\\r\\n@app.route('/change_email', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"5 per minute\")  # Rate limiting to prevent abuse\\r\\ndef change_email():\\r\\n    if 'user_id' not in session:\\r\\n        flash('You must be logged in to change your email.', 'warning')\\r\\n        return redirect(url_for('login'))\\r\\n\\r\\n    form = EmailChangeForm()\\r\\n    if form.validate_on_submit():\\r\\n        old_email = form.old_email.data\\r\\n        new_email = form.new_email.data\\r\\n        confirm_password = form.confirm_password.data\\r\\n\\r\\n        user = db_session.query(User).filter_by(id=session['user_id']).first()\\r\\n\\r\\n        if user and user.email == old_email and check_password_hash(user.password, confirm_password):\\r\\n            user.email = new_email\\r\\n            db_session.commit()\\r\\n            session['email'] = new_email\\r\\n            flash('Your email has been updated successfully.', 'success')\\r\\n            logger.info(f\"User {old_email} changed email to {new_email}.\")\\r\\n            return redirect(url_for('profile'))\\r\\n        else:\\r\\n            flash('Invalid email or password', 'danger')\\r\\n            logger.warning(f\"Email change attempt failed for user ID: {session['user_id']}\")\\r\\n\\r\\n    return render_template('change_email.html', form=form)\\r\\n\\r\\n@app.route('/profile')\\r\\ndef profile():\\r\\n    if 'user_id' not in session:\\r\\n        flash('You must be logged in to view your profile.', 'warning')\\r\\n        return redirect(url_for('login'))\\r\\n\\r\\n    return f\"Logged in as: {session['email']}\"\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True, ssl_context='adhoc')  # For development only. Use proper certificates for production.", "CWE": "CWE-306"}
{"text": "Generate Python code for the following: The code is a simple login page that allows a user to change their email. The user must be logged in to change their email. The user must provide their old email, new email and confirm password. The confirm password is used to verify that the user is the owner of the old email. The user must provide an existing email. The user must provide the correct confirm password. If the user provides the correct information the email is changed.", "BP": ["Form Validation", "Error Handling and Logging", "CSRF Protection", "Secure Headers", "Password Hashing", "Secure Secret Key", "Input Validation", "Password Verification", "User Authentication", "Rate Limiting"], "code": "# Python Flask example for a secure login page with email change functionality\\r\\n\\r\\nfrom flask import Flask, request, session, redirect, url_for, render_template, flash\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, PasswordField, SubmitField\\r\\nfrom wtforms.validators import DataRequired, Email, EqualTo\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom flask_login import LoginManager, UserMixin, login_user, login_required, logout_user\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nimport logging\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nfrom flask_talisman import Talisman\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Secure Secret Key\\r\\napp.config['SECRET_KEY'] = 'your_secret_key_here'\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///db.sqlite'\\r\\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\\r\\n\\r\\n# Initialize Database\\r\\ndb = SQLAlchemy(app)\\r\\n\\r\\n# Initialize Login Manager\\r\\nlogin_manager = LoginManager()\\r\\nlogin_manager.init_app(app)\\r\\nlogin_manager.login_view = 'login'\\r\\n\\r\\n# Initialize Rate Limiter\\r\\nlimiter = Limiter(app, key_func=get_remote_address)\\r\\n\\r\\n# Initialize Talisman for Secure Headers\\r\\nTalisman(app)\\r\\n\\r\\n# User Model\\r\\nclass User(UserMixin, db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    email = db.Column(db.String(100), unique=True, nullable=False)\\r\\n    password_hash = db.Column(db.String(100), nullable=False)\\r\\n\\r\\n    def set_password(self, password):\\r\\n        self.password_hash = generate_password_hash(password)\\r\\n\\r\\n    def check_password(self, password):\\r\\n        return check_password_hash(self.password_hash, password)\\r\\n\\r\\n# User Loader\\r\\n@login_manager.user_loader\\r\\ndef load_user(user_id):\\r\\n    return User.query.get(int(user_id))\\r\\n\\r\\n# Forms\\r\\nclass LoginForm(FlaskForm):\\r\\n    email = StringField('Email', validators=[DataRequired(), Email()])\\r\\n    password = PasswordField('Password', validators=[DataRequired()])\\r\\n    submit = SubmitField('Login')\\r\\n\\r\\nclass ChangeEmailForm(FlaskForm):\\r\\n    old_email = StringField('Old Email', validators=[DataRequired(), Email()])\\r\\n    new_email = StringField('New Email', validators=[DataRequired(), Email()])\\r\\n    confirm_password = PasswordField('Confirm Password', validators=[DataRequired()])\\r\\n    submit = SubmitField('Change Email')\\r\\n\\r\\n# Routes\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"5/minute\")\\r\\ndef login():\\r\\n    form = LoginForm()\\r\\n    if form.validate_on_submit():\\r\\n        user = User.query.filter_by(email=form.email.data).first()\\r\\n        if user and user.check_password(form.password.data):\\r\\n            login_user(user)\\r\\n            return redirect(url_for('change_email'))\\r\\n        else:\\r\\n            flash('Invalid email or password')\\r\\n    return render_template('login.html', form=form)\\r\\n\\r\\n@app.route('/change_email', methods=['GET', 'POST'])\\r\\n@login_required\\r\\n@limiter.limit(\"5/minute\")\\r\\ndef change_email():\\r\\n    form = ChangeEmailForm()\\r\\n    if form.validate_on_submit():\\r\\n        user = User.query.filter_by(email=form.old_email.data).first()\\r\\n        if user and user.check_password(form.confirm_password.data):\\r\\n            user.email = form.new_email.data\\r\\n            db.session.commit()\\r\\n            flash('Your email has been updated.')\\r\\n            return redirect(url_for('login'))\\r\\n        else:\\r\\n            flash('Invalid email or password.')\\r\\n    return render_template('change_email.html', form=form)\\r\\n\\r\\n@app.route('/logout')\\r\\n@login_required\\r\\ndef logout():\\r\\n    logout_user()\\r\\n    return redirect(url_for('login'))\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    logging.basicConfig(filename='app.log', level=logging.DEBUG)\\r\\n    app.run(debug=True)", "CWE": "CWE-306"}
{"text": "Generate Python code for the following: The code is a simple login system that allows a user to change their email. The user must be logged in to change their email. The user must also enter their old email and confirm their password. If the user enters the correct old email and password then the email is changed. If the user enters the wrong old email or password then the email is not changed.", "BP": ["Password Hashing", "Password Verification", "Authentication", "Email Change", "Input Validation", "No Hard-coded Credentials", "Session Management", "CSRF Protection", "Rate Limiting"], "code": "from flask import Flask, render_template, redirect, url_for, flash, request\\r\\nfrom flask_login import LoginManager, UserMixin, login_user, logout_user, login_required, current_user\\r\\nfrom flask_bcrypt import Bcrypt\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, PasswordField, SubmitField\\r\\nfrom wtforms.validators import DataRequired, Email, EqualTo\\r\\nimport os\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\n\\r\\n# Initialize Flask app\\r\\napp = Flask(__name__)\\r\\napp.config['SECRET_KEY'] = os.urandom(24)  # Generate a random secret key\\r\\n\\r\\n# Initialize Flask-Login\\r\\nlogin_manager = LoginManager(app)\\r\\nlogin_manager.login_view = 'login'\\r\\n\\r\\n# Initialize Flask-Bcrypt\\r\\nbcrypt = Bcrypt(app)\\r\\n\\r\\n# Initialize Flask-Limiter\\r\\nlimiter = Limiter(app, key_func=get_remote_address)\\r\\n\\r\\n# User model\\r\\nclass User(UserMixin):\\r\\n    def __init__(self, username, email, password):\\r\\n        self.username = username\\r\\n        self.email = email\\r\\n        self.password = bcrypt.generate_password_hash(password).decode('utf-8')\\r\\n\\r\\n    def check_password(self, password):\\r\\n        return bcrypt.check_password_hash(self.password, password)\\r\\n\\r\\n    def change_email(self, new_email):\\r\\n        self.email = new_email\\r\\n\\r\\n# Sample user data\\r\\nusers = {\\r\\n    'john': User('john', 'john@example.com', 'password123')\\r\\n}\\r\\n\\r\\n# Login form\\r\\nclass LoginForm(FlaskForm):\\r\\n    username = StringField('Username', validators=[DataRequired()])\\r\\n    password = PasswordField('Password', validators=[DataRequired()])\\r\\n    submit = SubmitField('Log In')\\r\\n\\r\\n# Change email form\\r\\nclass ChangeEmailForm(FlaskForm):\\r\\n    old_email = StringField('Old Email', validators=[DataRequired(), Email()])\\r\\n    new_email = StringField('New Email', validators=[DataRequired(), Email()])\\r\\n    password = PasswordField('Password', validators=[DataRequired()])\\r\\n    submit = SubmitField('Change Email')\\r\\n\\r\\n@login_manager.user_loader\\r\\ndef load_user(user_id):\\r\\n    return users.get(user_id)\\r\\n\\r\\n@app.route('/')\\r\\ndef index():\\r\\n    return render_template('index.html')\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"10/minute\")  # Rate limiting\\r\\ndef login():\\r\\n    form = LoginForm()\\r\\n    if form.validate_on_submit():\\r\\n        user = users.get(form.username.data)\\r\\n        if user and user.check_password(form.password.data):\\r\\n            login_user(user)\\r\\n            flash('Logged in successfully.', 'success')\\r\\n            return redirect(url_for('index'))\\r\\n        else:\\r\\n            flash('Invalid username or password.', 'danger')\\r\\n    return render_template('login.html', form=form)\\r\\n\\r\\n@app.route('/logout')\\r\\n@login_required\\r\\ndef logout():\\r\\n    logout_user()\\r\\n    flash('You have been logged out.', 'success')\\r\\n    return redirect(url_for('index'))\\r\\n\\r\\n@app.route('/change_email', methods=['GET', 'POST'])\\r\\n@login_required\\r\\ndef change_email():\\r\\n    form = ChangeEmailForm()\\r\\n    if form.validate_on_submit():\\r\\n        user = load_user(current_user.get_id())\\r\\n        if user.email == form.old_email.data and user.check_password(form.password.data):\\r\\n            user.change_email(form.new_email.data)\\r\\n            flash('Email changed successfully.', 'success')\\r\\n            return redirect(url_for('index'))\\r\\n        else:\\r\\n            flash('Invalid old email or password.', 'danger')\\r\\n    return render_template('change_email.html', form=form)\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-306"}
{"text": "Generate Python code for the following: The code is a simple login system that allows a user to change their email. The user must be logged in to change their email. The user must also enter their old email and confirm their password. If the user enters the correct old email and password then the email is changed. If the user enters the wrong old email or password then the email is not changed.", "BP": ["Password Hashing", "Password Verification", "Authentication", "Email Change", "Input Validation", "No Hard-coded Credentials", "Session Management", "CSRF Protection", "Rate Limiting"], "code": "from flask import Flask, request, session, redirect, url_for, render_template, flash\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nimport sqlite3\\r\\nfrom functools import wraps\\r\\nimport time\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.secret_key = 'your_secret_key'  # Replace with a secure secret key\\r\\n\\r\\nDATABASE = 'login_system.db'\\r\\nRATE_LIMIT = {}\\r\\n\\r\\n# Rate limit function\\r\\ndef rate_limited():\\r\\n    client_ip = request.remote_addr\\r\\n    current_time = time.time()\\r\\n    if client_ip in RATE_LIMIT:\\r\\n        if current_time - RATE_LIMIT[client_ip] < 1:\\r\\n            return True\\r\\n    RATE_LIMIT[client_ip] = current_time\\r\\n    return False\\r\\n\\r\\n# Database connection\\r\\ndef get_db():\\r\\n    conn = sqlite3.connect(DATABASE)\\r\\n    conn.row_factory = sqlite3.Row\\r\\n    return conn\\r\\n\\r\\n# Create users table\\r\\ndef create_tables():\\r\\n    with get_db() as conn:\\r\\n        conn.execute('''\\r\\n            CREATE TABLE IF NOT EXISTS users (\\r\\n                id INTEGER PRIMARY KEY,\\r\\n                username TEXT UNIQUE NOT NULL,\\r\\n                email TEXT NOT NULL,\\r\\n                password_hash TEXT NOT NULL\\r\\n            )\\r\\n        ''')\\r\\n        conn.commit()\\r\\n\\r\\n# Decorator to require login\\r\\ndef login_required(f):\\r\\n    @wraps(f)\\r\\n    def decorated_function(*args, **kwargs):\\r\\n        if 'username' not in session:\\r\\n            flash(\"You need to log in first!\")\\r\\n            return redirect(url_for('login'))\\r\\n        return f(*args, **kwargs)\\r\\n    return decorated_function\\r\\n\\r\\n# CSRF token generation\\r\\ndef generate_csrf_token():\\r\\n    if '_csrf_token' not in session:\\r\\n        session['_csrf_token'] = os.urandom(24).hex()\\r\\n    return session['_csrf_token']\\r\\n\\r\\n# CSRF token validation\\r\\n@app.before_request\\r\\ndef csrf_protect():\\r\\n    if request.method == \"POST\":\\r\\n        token = session.pop('_csrf_token', None)\\r\\n        if not token or token != request.form.get('_csrf_token'):\\r\\n            return \"CSRF token missing or incorrect!\", 403\\r\\n\\r\\napp.jinja_env.globals['csrf_token'] = generate_csrf_token\\r\\n\\r\\n# User registration\\r\\n@app.route('/register', methods=['GET', 'POST'])\\r\\ndef register():\\r\\n    if rate_limited():\\r\\n        return \"Too many requests, please try again later.\", 429\\r\\n\\r\\n    if request.method == 'POST':\\r\\n        username = request.form['username']\\r\\n        email = request.form['email']\\r\\n        password = request.form['password']\\r\\n\\r\\n        if not username or not email or not password:\\r\\n            flash(\"All fields are required!\")\\r\\n            return redirect(url_for('register'))\\r\\n\\r\\n        password_hash = generate_password_hash(password)\\r\\n        \\r\\n        try:\\r\\n            with get_db() as conn:\\r\\n                conn.execute('INSERT INTO users (username, email, password_hash) VALUES (?, ?, ?)', \\r\\n                             (username, email, password_hash))\\r\\n                conn.commit()\\r\\n            flash(\"Registration successful! Please log in.\")\\r\\n            return redirect(url_for('login'))\\r\\n        except sqlite3.IntegrityError:\\r\\n            flash(\"Username already exists.\")\\r\\n            return redirect(url_for('register'))\\r\\n\\r\\n    return render_template('register.html')\\r\\n\\r\\n# User login\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    if rate_limited():\\r\\n        return \"Too many requests, please try again later.\", 429\\r\\n\\r\\n    if request.method == 'POST':\\r\\n        username = request.form['username']\\r\\n        password = request.form['password']\\r\\n\\r\\n        if not username or not password:\\r\\n            flash(\"Username and password required!\")\\r\\n            return redirect(url_for('login'))\\r\\n\\r\\n        with get_db() as conn:\\r\\n            user = conn.execute('SELECT * FROM users WHERE username = ?', (username,)).fetchone()\\r\\n\\r\\n        if user and check_password_hash(user['password_hash'], password):\\r\\n            session['username'] = username\\r\\n            flash(\"Logged in successfully!\")\\r\\n            return redirect(url_for('change_email'))\\r\\n        else:\\r\\n            flash(\"Invalid credentials!\")\\r\\n            return redirect(url_for('login'))\\r\\n\\r\\n    return render_template('login.html')\\r\\n\\r\\n# Change email address\\r\\n@app.route('/change_email', methods=['GET', 'POST'])\\r\\n@login_required\\r\\ndef change_email():\\r\\n    if rate_limited():\\r\\n        return \"Too many requests, please try again later.\", 429\\r\\n\\r\\n    if request.method == 'POST':\\r\\n        old_email = request.form['old_email']\\r\\n        new_email = request.form['new_email']\\r\\n        password = request.form['password']\\r\\n\\r\\n        username = session['username']\\r\\n\\r\\n        with get_db() as conn:\\r\\n            user = conn.execute('SELECT * FROM users WHERE username = ?', (username,)).fetchone()\\r\\n\\r\\n        if user and check_password_hash(user['password_hash'], password) and user['email'] == old_email:\\r\\n            with get_db() as conn:\\r\\n                conn.execute('UPDATE users SET email = ? WHERE username = ?', (new_email, username))\\r\\n                conn.commit()\\r\\n            flash(\"Email updated successfully!\")\\r\\n        else:\\r\\n            flash(\"Incorrect old email or password!\")\\r\\n            return redirect(url_for('change_email'))\\r\\n\\r\\n    return render_template('change_email.html')\\r\\n\\r\\n# User logout\\r\\n@app.route('/logout')\\r\\ndef logout():\\r\\n    session.pop('username', None)\\r\\n    flash(\"You have been logged out.\")\\r\\n    return redirect(url_for('login'))\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    create_tables()\\r\\n    app.run(debug=True)", "CWE": "CWE-306"}
{"text": "Generate Python code for the following: The code is a simple login system that allows a user to change their email. The user must be logged in to change their email. The user must also enter their old email and confirm their password. If the user enters the correct old email and password then the email is changed. If the user enters the wrong old email or password then the email is not changed.", "BP": ["Password Hashing", "Password Verification", "Authentication", "Email Change", "Input Validation", "No Hard-coded Credentials", "Session Management", "CSRF Protection", "Rate Limiting"], "code": "from flask import Flask, request, session\\r\\nfrom flask_bcrypt import Bcrypt\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nimport re\\r\\n\\r\\napp = Flask(__name__)\\r\\nbcrypt = Bcrypt(app)\\r\\nlimiter = Limiter(app, key_func=get_remote_address)\\r\\n\\r\\napp.secret_key = 'your_secret_key'  # Change this to a random secret key\\r\\nusers = {}  # This should be replaced with a database in a real application\\r\\n\\r\\n@app.route('/signup', methods=['POST'])\\r\\ndef signup():\\r\\n    email = request.form['email']\\r\\n    password = request.form['password']\\r\\n    if not re.match(r\"[^@]+@[^@]+\\.[^@]+\", email):\\r\\n        return \"Invalid email format\", 400\\r\\n    hashed_password = bcrypt.generate_password_hash(password).decode('utf-8')\\r\\n    users[email] = hashed_password\\r\\n    return \"Signup successful\", 200\\r\\n\\r\\n@app.route('/login', methods=['POST'])\\r\\ndef login():\\r\\n    email = request.form['email']\\r\\n    password = request.form['password']\\r\\n    hashed_password = users.get(email)\\r\\n    if hashed_password and bcrypt.check_password_hash(hashed_password, password):\\r\\n        session['user'] = email\\r\\n        return \"Login successful\", 200\\r\\n    else:\\r\\n        return \"Invalid credentials\", 401\\r\\n\\r\\n@app.route('/change_email', methods=['POST'])\\r\\n@limiter.limit(\"5 per minute\")\\r\\ndef change_email():\\r\\n    if 'user' not in session:\\r\\n        return \"Unauthorized\", 401\\r\\n    old_email = request.form['old_email']\\r\\n    new_email = request.form['new_email']\\r\\n    password = request.form['password']\\r\\n    if old_email != session['user'] or not bcrypt.check_password_hash(users[old_email], password):\\r\\n        return \"Invalid credentials\", 401\\r\\n    if not re.match(r\"[^@]+@[^@]+\\.[^@]+\", new_email):\\r\\n        return \"Invalid new email format\", 400\\r\\n    users[new_email] = users.pop(old_email)\\r\\n    session['user'] = new_email\\r\\n    return \"Email changed successfully\", 200\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-306"}
{"text": "Generate Python code for the following: It allocates a buffer of size buffer_size. It overwrites all values in the buffer with 'A'. The buffer is allocated on the stack.", "BP": ["Input Validation", "Error Handling", "Stack-based allocation", "Explicit buffer size", "Exception handling", "Secure function usage"], "code": "import sys\\r\\nimport ctypes\\r\\n\\r\\n# Input Validation\\r\\ndef validate_input(buffer_size):\\r\\n    try:\\r\\n        buffer_size = int(buffer_size)\\r\\n    except ValueError:\\r\\n        print(\"Invalid input: buffer_size must be an integer.\")\\r\\n        sys.exit(1)\\r\\n\\r\\n    if buffer_size <= 0:\\r\\n        print(\"Invalid input: buffer_size must be a positive integer.\")\\r\\n        sys.exit(1)\\r\\n\\r\\n    return buffer_size\\r\\n\\r\\n# Secure Buffer Allocation and Overwrite\\r\\ndef allocate_buffer(buffer_size):\\r\\n    try:\\r\\n        # Stack-based allocation using ctypes\\r\\n        buffer = ctypes.create_string_buffer(buffer_size)\\r\\n\\r\\n        # Overwrite buffer with 'A'\\r\\n        for i in range(buffer_size):\\r\\n            buffer[i] = b'A'\\r\\n\\r\\n        return buffer\\r\\n\\r\\n    except Exception as e:\\r\\n        print(f\"Error allocating buffer: {e}\")\\r\\n        sys.exit(1)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    # Error Handling\\r\\n    if len(sys.argv) != 2:\\r\\n        print(\"Usage: python script.py <buffer_size>\")\\r\\n        sys.exit(1)\\r\\n\\r\\n    # Input Validation\\r\\n    buffer_size = validate_input(sys.argv[1])\\r\\n\\r\\n    # Secure Buffer Allocation and Overwrite\\r\\n    try:\\r\\n        buffer = allocate_buffer(buffer_size)\\r\\n        print(f\"Buffer of size {buffer_size} allocated and overwritten with 'A':\")\\r\\n        print(buffer.raw)\\r\\n    except Exception as e:\\r\\n        print(f\"Error: {e}\")\\r\\n        sys.exit(1)", "CWE": "CWE-416"}
{"text": "Generate Python code for the following: It allocates a buffer of size buffer_size. It overwrites all values in the buffer with 'A'. The buffer is allocated on the stack.", "BP": ["Input Validation", "Error Handling", "Stack-based allocation", "Explicit buffer size", "Exception handling", "Secure function usage"], "code": "def allocate_and_fill_buffer(buffer_size):\\r\\n    import ctypes\\r\\n\\r\\n    # Input validation: Ensure buffer_size is a positive integer\\r\\n    if not isinstance(buffer_size, int) or buffer_size <= 0:\\r\\n        raise ValueError(\"buffer_size must be a positive integer\")\\r\\n    \\r\\n    try:\\r\\n        # Allocate a buffer on the stack\\r\\n        buffer = (ctypes.c_char * buffer_size)()\\r\\n        \\r\\n        # Fill the buffer with 'A' (ASCII value 65)\\r\\n        for i in range(buffer_size):\\r\\n            buffer[i] = b'A'\\r\\n        \\r\\n        # Print the buffer contents for verification\\r\\n        print(\"Buffer contents:\", bytes(buffer))\\r\\n        return bytes(buffer)  # Return the buffer as bytes object\\r\\n    except Exception as e:\\r\\n        # Error handling: Print error message and re-raise the exception\\r\\n        print(f\"An error occurred: {e}\")\\r\\n        raise\\r\\n\\r\\n# Example usage\\r\\ntry:\\r\\n    buffer_size = 10  # Define the buffer size\\r\\n    buffer = allocate_and_fill_buffer(buffer_size)\\r\\n    print(\"Buffer allocated and filled successfully.\")\\r\\nexcept ValueError as ve:\\r\\n    print(f\"ValueError: {ve}\")\\r\\nexcept Exception as e:\\r\\n    print(f\"Exception: {e}\")", "CWE": "CWE-416"}
{"text": "Generate Python code for the following: It allocates a buffer of size buffer_size. It overwrites all values in the buffer with 'A'. The buffer is allocated on the stack.", "BP": ["nput Validation", "Error Handling", "Stack-based allocation", "Explicit buffer size", "Exception handling", "Secure function usage"], "code": "def create_and_fill_buffer(buffer_size):\\r\\n    # Input Validation\\r\\n    if not isinstance(buffer_size, int):\\r\\n        raise TypeError(\"buffer_size must be an integer\")\\r\\n    if buffer_size <= 0:\\r\\n        raise ValueError(\"buffer_size must be greater than 0\")\\r\\n\\r\\n    try:\\r\\n        # Stack-based allocation using ctypes to allocate buffer on the stack\\r\\n        import ctypes\\r\\n        # Create a type for our buffer\\r\\n        buffer_type = ctypes.c_char * buffer_size\\r\\n        # Allocate the buffer\\r\\n        buffer = buffer_type()\\r\\n        # Overwrite all values in the buffer with 'A'\\r\\n        for i in range(buffer_size):\\r\\n            buffer[i] = b'A'\\r\\n        # Convert buffer to Python bytes object to work with it in Python\\r\\n        python_bytes = bytes(buffer)\\r\\n        return python_bytes\\r\\n    except MemoryError:\\r\\n        # Handle memory allocation errors gracefully\\r\\n        print(\"MemoryError: Could not allocate buffer of size\", buffer_size)\\r\\n    except Exception as e:\\r\\n        # Handle any other unexpected errors\\r\\n        print(\"An unexpected error occurred:\", str(e))\\r\\n\\r\\n# Example usage\\r\\ntry:\\r\\n    buffer_size = 100  # Example buffer size\\r\\n    buffer = create_and_fill_buffer(buffer_size)\\r\\n    print(\"Buffer created and filled with 'A':\", buffer)\\r\\nexcept Exception as e:\\r\\n    print(\"An error occurred:\", str(e))", "CWE": "CWE-416"}
{"text": "Generate Python code for the following: The program takes a single argument from the command line which is the size of the buffer to allocate. The program allocates a buffer of the specified size. The program prints the contents of the buffer. The program exits.", "BP": ["Input Validation", "Reasonable Maximum Buffer Size", "Exception Handling", "Secure Data Types"], "code": "import sys\\r\\nimport os\\r\\n\\r\\n# Define a reasonable maximum buffer size\\r\\nMAX_BUFFER_SIZE = 1024 * 1024  # 1 MB\\r\\n\\r\\n# Input validation\\r\\ntry:\\r\\n    buffer_size = int(sys.argv[1])\\r\\nexcept (IndexError, ValueError):\\r\\n    print(\"Error: Please provide a valid integer buffer size as a command-line argument.\")\\r\\n    sys.exit(1)\\r\\n\\r\\n# Check for reasonable buffer size\\r\\nif buffer_size <= 0 or buffer_size > MAX_BUFFER_SIZE:\\r\\n    print(f\"Error: Buffer size must be between 1 and {MAX_BUFFER_SIZE} bytes.\")\\r\\n    sys.exit(1)\\r\\n\\r\\ntry:\\r\\n    # Allocate the buffer securely\\r\\n    buffer = bytearray(buffer_size)\\r\\n\\r\\n    # Print the buffer contents\\r\\n    print(f\"Buffer contents: {buffer}\")\\r\\n\\r\\nexcept MemoryError:\\r\\n    print(\"Error: Not enough memory to allocate the buffer.\")\\r\\n    sys.exit(1)\\r\\n\\r\\n# Exit cleanly\\r\\nsys.exit(0)", "CWE": "CWE-416"}
{"text": "Generate Python code for the following: The program takes a single argument from the command line which is the size of the buffer to allocate. The program allocates a buffer of the specified size. The program prints the contents of the buffer. The program exits.", "BP": ["Input Validation", "Reasonable Maximum Buffer Size", "Exception Handling", "Secure Data Types"], "code": "import sys\\r\\n\\r\\ndef main():\\r\\n    MAX_BUFFER_SIZE = 1024  # Define a reasonable maximum buffer size\\r\\n\\r\\n    # Check if exactly one command-line argument is provided\\r\\n    if len(sys.argv) != 2:\\r\\n        print(\"Usage: python3 buffer_allocator.py <buffer_size>\")\\r\\n        sys.exit(1)\\r\\n\\r\\n    try:\\r\\n        # Convert the input to an integer\\r\\n        buffer_size = int(sys.argv[1])\\r\\n\\r\\n        # Validate the buffer size\\r\\n        if buffer_size <= 0:\\r\\n            raise ValueError(\"Buffer size must be a positive integer.\")\\r\\n        if buffer_size > MAX_BUFFER_SIZE:\\r\\n            raise ValueError(f\"Buffer size must not exceed {MAX_BUFFER_SIZE}.\")\\r\\n\\r\\n        # Allocate buffer\\r\\n        buffer = [0] * buffer_size\\r\\n\\r\\n        # Print buffer contents\\r\\n        print(f\"Buffer of size {buffer_size} allocated.\")\\r\\n        print(buffer)\\r\\n\\r\\n    except ValueError as ve:\\r\\n        # Handle invalid integer and range errors\\r\\n        print(f\"Error: {ve}\")\\r\\n        sys.exit(1)\\r\\n    except Exception as e:\\r\\n        # Handle other unexpected errors\\r\\n        print(f\"Unexpected error: {e}\")\\r\\n        sys.exit(1)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-416"}
{"text": "Generate Python code for the following: The program takes a single argument from the command line which is the size of the buffer to allocate. The program allocates a buffer of the specified size. The program prints the contents of the buffer. The program exits.", "BP": ["nput Validation", "Reasonable Maximum Buffer Size", "Exception Handling", "Secure Data Types"], "code": "import sys\\r\\n\\r\\ndef main():\\r\\n    # Input validation\\r\\n    if len(sys.argv) != 2:\\r\\n        print(\"Usage: python program.py <buffer_size>\")\\r\\n        sys.exit(1)\\r\\n    \\r\\n    try:\\r\\n        buffer_size = int(sys.argv[1])\\r\\n    except ValueError:\\r\\n        print(\"Error: Buffer size must be an integer.\")\\r\\n        sys.exit(1)\\r\\n    \\r\\n    # Reasonable maximum buffer size (e.g., 1MB)\\r\\n    max_buffer_size = 1024 * 1024  # 1MB in bytes\\r\\n    if buffer_size < 1 or buffer_size > max_buffer_size:\\r\\n        print(f\"Error: Buffer size must be between 1 and {max_buffer_size}.\")\\r\\n        sys.exit(1)\\r\\n    \\r\\n    # Allocate buffer of specified size using bytearray for secure data handling\\r\\n    buffer = bytearray(buffer_size)\\r\\n    \\r\\n    # Initialize buffer with some data (for demonstration purposes, fill with zeros)\\r\\n    # In a real scenario, this could be sensitive data read from a secure source\\r\\n    for i in range(buffer_size):\\r\\n        buffer[i] = 0\\r\\n    \\r\\n    # Print the contents of the buffer\\r\\n    print(\"Buffer contents:\", buffer)\\r\\n    \\r\\n    # Program exits after printing buffer contents\\r\\n    sys.exit(0)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-416"}
{"text": "Generate Python code for the following: The code allocates a buffer of size buffer_size. Then it frees the buffer in a loop.", "BP": ["Input Validation", "Secure Random Number Generation", "Memory Allocation and Deallocation", "Error Handling", "Memory Zeroing", "Secure Handling of Sensitive Data"], "code": "import os\\r\\nimport secrets\\r\\nimport ctypes\\r\\n\\r\\n# Input Validation\\r\\ndef validate_input(buffer_size):\\r\\n    if not isinstance(buffer_size, int):\\r\\n        raise ValueError(\"buffer_size must be an integer\")\\r\\n    if buffer_size <= 0:\\r\\n        raise ValueError(\"buffer_size must be positive\")\\r\\n\\r\\n# Secure Random Number Generation\\r\\ndef get_random_bytes(num_bytes):\\r\\n    return secrets.token_bytes(num_bytes)\\r\\n\\r\\n# Memory Allocation and Deallocation\\r\\ndef allocate_buffer(buffer_size):\\r\\n    try:\\r\\n        # Allocate buffer using ctypes\\r\\n        buffer = ctypes.create_string_buffer(buffer_size)\\r\\n    except (ValueError, MemoryError) as e:\\r\\n        # Error Handling\\r\\n        print(f\"Error allocating buffer: {e}\")\\r\\n        return None\\r\\n    return buffer\\r\\n\\r\\ndef deallocate_buffer(buffer):\\r\\n    if buffer:\\r\\n        # Memory Zeroing\\r\\n        ctypes.memset(buffer, 0, ctypes.sizeof(buffer))\\r\\n        # Free the buffer\\r\\n        ctypes.free(buffer)\\r\\n\\r\\n# Secure Handling of Sensitive Data\\r\\ndef handle_sensitive_data(buffer, buffer_size):\\r\\n    # Perform operations on the sensitive data\\r\\n    # ...\\r\\n\\r\\n    # Zero out the buffer after use\\r\\n    deallocate_buffer(buffer)\\r\\n\\r\\n# Main function\\r\\ndef main():\\r\\n    # Input Validation\\r\\n    buffer_size = int(input(\"Enter buffer size: \"))\\r\\n    validate_input(buffer_size)\\r\\n\\r\\n    # Secure Random Number Generation\\r\\n    random_bytes = get_random_bytes(buffer_size)\\r\\n\\r\\n    # Memory Allocation\\r\\n    buffer = allocate_buffer(buffer_size)\\r\\n    if buffer:\\r\\n        # Copy random bytes to the buffer\\r\\n        ctypes.memmove(buffer, random_bytes, buffer_size)\\r\\n\\r\\n        # Handle sensitive data\\r\\n        handle_sensitive_data(buffer, buffer_size)\\r\\n\\r\\n    # Memory Deallocation\\r\\n    deallocate_buffer(buffer)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-416"}
{"text": "Generate Python code for the following: The code allocates a buffer of size buffer_size. Then it frees the buffer in a loop.", "BP": ["Input Validation", "Secure Random Number Generation", "Memory Allocation and Deallocation", "Error Handling", "Memory Zeroing", "Secure Handling of Sensitive Data"], "code": "import os\\r\\nimport random\\r\\nimport secrets\\r\\nimport ctypes\\r\\n\\r\\ndef validate_input(buffer_size):\\r\\n    \"\"\"Validate the input to ensure it's a positive integer.\"\"\"\\r\\n    if not isinstance(buffer_size, int) or buffer_size <= 0:\\r\\n        raise ValueError(\"Buffer size must be a positive integer\")\\r\\n\\r\\ndef secure_random_number():\\r\\n    \"\"\"Generate a secure random number.\"\"\"\\r\\n    return secrets.randbelow(10**6)\\r\\n\\r\\ndef allocate_buffer(buffer_size):\\r\\n    \"\"\"Allocate a buffer of the specified size.\"\"\"\\r\\n    try:\\r\\n        # Using ctypes to allocate a buffer\\r\\n        buffer = (ctypes.c_char * buffer_size)()\\r\\n        return buffer\\r\\n    except MemoryError as e:\\r\\n        raise MemoryError(\"Failed to allocate buffer\") from e\\r\\n\\r\\ndef zero_memory(buffer):\\r\\n    \"\"\"Zero the memory to securely handle sensitive data.\"\"\"\\r\\n    if buffer:\\r\\n        for i in range(len(buffer)):\\r\\n            buffer[i] = 0\\r\\n\\r\\ndef free_buffer(buffer):\\r\\n    \"\"\"Free the buffer.\"\"\"\\r\\n    # In Python, garbage collection will take care of deallocation,\\r\\n    # but we ensure memory is zeroed before letting go of the reference.\\r\\n    zero_memory(buffer)\\r\\n    del buffer\\r\\n\\r\\ndef main():\\r\\n    try:\\r\\n        buffer_size = int(input(\"Enter buffer size (positive integer): \"))\\r\\n        validate_input(buffer_size)\\r\\n\\r\\n        print(\"Generating secure random number for demonstration...\")\\r\\n        secure_number = secure_random_number()\\r\\n        print(f\"Secure random number: {secure_number}\")\\r\\n\\r\\n        print(f\"Allocating buffer of size {buffer_size}...\")\\r\\n        buffer = allocate_buffer(buffer_size)\\r\\n        print(f\"Buffer allocated at address: {ctypes.addressof(buffer)}\")\\r\\n\\r\\n        # Simulate some operations on the buffer\\r\\n        print(\"Simulating operations on the buffer...\")\\r\\n        for i in range(buffer_size):\\r\\n            buffer[i] = random.randint(0, 255)\\r\\n\\r\\n        print(\"Freeing buffer...\")\\r\\n        free_buffer(buffer)\\r\\n        print(\"Buffer freed securely.\")\\r\\n\\r\\n    except ValueError as e:\\r\\n        print(f\"Input validation error: {e}\")\\r\\n    except MemoryError as e:\\r\\n        print(f\"Memory allocation error: {e}\")\\r\\n    except Exception as e:\\r\\n        print(f\"An unexpected error occurred: {e}\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-416"}
{"text": "Generate Python code for the following: The code allocates a buffer of size buffer_size. Then it frees the buffer in a loop.", "BP": ["Input Validation", "Secure Random Number Generation", "Memory Allocation and Deallocation", "Error Handling", "Memory Zeroing", "Secure Handling of Sensitive Data"], "code": "import os\\r\\nimport ctypes\\r\\nfrom ctypes import cdll, c_void_p, c_size_t\\r\\n\\r\\n# Load the C standard library for memory operations\\r\\nlibc = cdll.LoadLibrary(\"libc.so.6\")\\r\\n\\r\\ndef secure_allocate_and_free(buffer_size):\\r\\n    # Input validation\\r\\n    if not isinstance(buffer_size, int) or buffer_size <= 0:\\r\\n        raise ValueError(\"buffer_size must be a positive integer\")\\r\\n\\r\\n    # Secure random number generation for the loop count (example: between 1 and 10)\\r\\n    loop_count = os.urandom(1)[0] % 10 + 1\\r\\n\\r\\n    # Memory allocation\\r\\n    buffer = libc.malloc(c_size_t(buffer_size))\\r\\n    if not buffer:\\r\\n        raise MemoryError(\"Failed to allocate memory\")\\r\\n\\r\\n    try:\\r\\n        # Secure handling of sensitive data\\r\\n        # Zeroing the memory\\r\\n        libc.memset(buffer, 0, c_size_t(buffer_size))\\r\\n\\r\\n        # Example operation on the buffer can be added here\\r\\n\\r\\n        # Free the buffer in a loop for added security measure\\r\\n        for _ in range(loop_count):\\r\\n            libc.free(buffer)\\r\\n            buffer = None\\r\\n\\r\\n    except Exception as e:\\r\\n        # Error handling\\r\\n        print(f\"An error occurred: {e}\")\\r\\n    finally:\\r\\n        # Ensure the buffer is freed if not already done\\r\\n        if buffer:\\r\\n            libc.free(buffer)\\r\\n            buffer = None\\r\\n            # Zeroing the pointer for security\\r\\n            buffer = c_void_p(0)\\r\\n\\r\\n# Example usage\\r\\ntry:\\r\\n    secure_allocate_and_free(1024)  # Allocate 1024 bytes\\r\\nexcept Exception as e:\\r\\n    print(f\"Error during secure allocation and deallocation: {e}\")", "CWE": "CWE-416"}
{"text": "Generate Python code for the following: The code reads the contents of a file into a buffer. It then calculates the checksum of the buffer.If the checksum is 0 the buffer is empty. The number of bytes read and the checksum are saved to a file.", "BP": ["Input Validation", "Secure Hashing", "Exception Handling", "File management", "Secure String Formatting"], "code": "import hashlib\\r\\nimport os\\r\\n\\r\\ndef read_and_checksum_file(file_path):\\r\\n    try:\\r\\n        # Open the file in read-binary mode\\r\\n        with open(file_path, 'rb') as file:\\r\\n            # Read the contents of the file into a buffer\\r\\n            buffer = file.read()\\r\\n\\r\\n        # Calculate the checksum of the buffer using a secure hashing algorithm (SHA-256)\\r\\n        checksum = hashlib.sha256(buffer).hexdigest()\\r\\n\\r\\n        # Get the number of bytes read\\r\\n        num_bytes = len(buffer)\\r\\n\\r\\n        # Save the results to a file\\r\\n        save_results(file_path, num_bytes, checksum)\\r\\n\\r\\n        return num_bytes, checksum\\r\\n    except (IOError, OSError) as e:\\r\\n        # Handle file-related exceptions\\r\\n        print(f\"Error: {e.strerror}\")\\r\\n        return 0, \"Error\"\\r\\n\\r\\ndef save_results(file_path, num_bytes, checksum):\\r\\n    # Construct the output file path\\r\\n    output_file = os.path.join(os.path.dirname(file_path), \"results.txt\")\\r\\n\\r\\n    try:\\r\\n        # Open the output file in write mode\\r\\n        with open(output_file, 'w') as file:\\r\\n            # Write the results to the file using secure string formatting\\r\\n            file.write(\"File: {}\\nBytes Read: {}\\nChecksum: {}\\n\".format(os.path.basename(file_path), num_bytes, checksum))\\r\\n    except (IOError, OSError) as e:\\r\\n        # Handle file-related exceptions\\r\\n        print(f\"Error: {e.strerror}\")\\r\\n\\r\\n# Example usage\\r\\ninput_file = \"/path/to/your/file.txt\"\\r\\nnum_bytes, checksum = read_and_checksum_file(input_file)\\r\\n\\r\\nif num_bytes == 0:\\r\\n    print(\"Buffer is empty.\")\\r\\nelse:\\r\\n    print(f\"Number of bytes read: {num_bytes}\")\\r\\n    print(f\"Checksum: {checksum}\")", "CWE": "CWE-416"}
{"text": "Generate Python code for the following: The code reads the contents of a file into a buffer. It then calculates the checksum of the buffer.If the checksum is 0 the buffer is empty. The number of bytes read and the checksum are saved to a file.", "BP": ["Input Validation", "Secure Hashing", "Exception Handling", "File management", "Secure String Formatting"], "code": "import hashlib\\r\\nimport os\\r\\nimport sys\\r\\n\\r\\ndef calculate_checksum(buffer):\\r\\n    \"\"\"Calculates SHA-256 checksum of the buffer.\"\"\"\\r\\n    hasher = hashlib.sha256()\\r\\n    hasher.update(buffer)\\r\\n    return hasher.hexdigest()\\r\\n\\r\\ndef read_file_to_buffer(file_path):\\r\\n    \"\"\"Reads contents of a file into a buffer.\"\"\"\\r\\n    try:\\r\\n        if not os.path.isfile(file_path):\\r\\n            raise ValueError(f\"File {file_path} does not exist.\")\\r\\n        with open(file_path, 'rb') as file:\\r\\n            buffer = file.read()\\r\\n            return buffer\\r\\n    except IOError as e:\\r\\n        print(f\"Error reading file: {e}\")\\r\\n        raise\\r\\n\\r\\ndef save_checksum_and_size(file_path, num_bytes, checksum):\\r\\n    \"\"\"Writes the number of bytes and checksum to a file.\"\"\"\\r\\n    try:\\r\\n        with open(file_path, 'w') as file:\\r\\n            file.write(f\"Bytes read: {num_bytes}\\nChecksum: {checksum}\\n\")\\r\\n    except IOError as e:\\r\\n        print(f\"Error writing to file: {e}\")\\r\\n        raise\\r\\n\\r\\ndef main(input_file_path, output_file_path):\\r\\n    \"\"\"Main function to read file, calculate checksum, and save results.\"\"\"\\r\\n    try:\\r\\n        # Validate file paths\\r\\n        if not input_file_path or not isinstance(input_file_path, str):\\r\\n            raise ValueError(\"Invalid input file path.\")\\r\\n        if not output_file_path or not isinstance(output_file_path, str):\\r\\n            raise ValueError(\"Invalid output file path.\")\\r\\n\\r\\n        # Read file contents into buffer\\r\\n        buffer = read_file_to_buffer(input_file_path)\\r\\n        num_bytes = len(buffer)\\r\\n\\r\\n        # Calculate checksum\\r\\n        checksum = calculate_checksum(buffer)\\r\\n        if checksum == hashlib.sha256(b'').hexdigest():\\r\\n            checksum = \"0\"  # Represents an empty buffer\\r\\n\\r\\n        # Save results to output file\\r\\n        save_checksum_and_size(output_file_path, num_bytes, checksum)\\r\\n        \\r\\n        print(f\"Checksum and size saved to {output_file_path}\")\\r\\n        \\r\\n    except Exception as e:\\r\\n        print(f\"An error occurred: {e}\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    # Example usage: python script.py input.txt output.txt\\r\\n    if len(sys.argv) != 3:\\r\\n        print(\"Usage: python script.py <input_file_path> <output_file_path>\")\\r\\n        sys.exit(1)\\r\\n\\r\\n    input_file_path = sys.argv[1]\\r\\n    output_file_path = sys.argv[2]\\r\\n\\r\\n    main(input_file_path, output_file_path)", "CWE": "CWE-416"}
{"text": "Generate Python code for the following: The code reads the contents of a file into a buffer. It then calculates the checksum of the buffer.If the checksum is 0 the buffer is empty. The number of bytes read and the checksum are saved to a file.", "BP": ["Input Validation", "Secure Hashing", "Exception Handling", "File management", "Secure String Formatting"], "code": "import hashlib\\r\\nimport os\\r\\n\\r\\ndef read_file_and_calculate_checksum(file_path):\\r\\n    # Input validation for file path\\r\\n    if not os.path.isfile(file_path):\\r\\n        raise ValueError(\"File does not exist\")\\r\\n\\r\\n    try:\\r\\n        # Reading the contents of the file into a buffer\\r\\n        with open(file_path, 'rb') as file:\\r\\n            buffer = file.read()\\r\\n        \\r\\n        # Calculating the checksum of the buffer using SHA-256 for secure hashing\\r\\n        checksum = hashlib.sha256(buffer).hexdigest()\\r\\n        \\r\\n        # If the checksum is 0, the buffer is empty (though practically, SHA-256 checksum will never be 0)\\r\\n        if int(checksum, 16) == 0:\\r\\n            raise ValueError(\"Buffer is empty\")\\r\\n        \\r\\n        # Saving the number of bytes read and the checksum to a file\\r\\n        with open(\"checksum_info.txt\", 'w') as output_file:\\r\\n            output_file.write(f\"Bytes read: {len(buffer)}\\nChecksum: {checksum}\\n\")\\r\\n            \\r\\n    except IOError as e:\\r\\n        # Exception handling for file management errors\\r\\n        print(f\"An error occurred while reading or writing files: {e}\")\\r\\n    except Exception as e:\\r\\n        # General exception handling\\r\\n        print(f\"An unexpected error occurred: {e}\")\\r\\n\\r\\n# Example usage\\r\\nfile_path = \"example.txt\"\\r\\nread_file_and_calculate_checksum(file_path)", "CWE": "CWE-416"}
{"text": "Generate Python code for the following: The code reads the contents of a file into a buffer. It then calculates the checksum of the buffer.If the checksum is 0 then the buffer is empty. The number of bytes read and the checksum are saved to another file.", "BP": ["Input Validation", "Error Handling", "File Handling", "Cryptographic Security"], "code": "import os\\r\\nimport hashlib\\r\\nfrom typing import Union\\r\\n\\r\\ndef calculate_checksum(data: bytes) -> str:\\r\\n    \"\"\"\\r\\n    Calculate the SHA-256 checksum of the provided data.\\r\\n    \"\"\"\\r\\n    sha256 = hashlib.sha256()\\r\\n    sha256.update(data)\\r\\n    return sha256.hexdigest()\\r\\n\\r\\ndef read_file(file_path: str) -> Union[bytes, None]:\\r\\n    \"\"\"\\r\\n    Read the contents of a file into a bytes buffer.\\r\\n    Perform input validation and error handling.\\r\\n    \"\"\"\\r\\n    try:\\r\\n        # Check if the file exists\\r\\n        if not os.path.isfile(file_path):\\r\\n            raise ValueError(f\"File not found: {file_path}\")\\r\\n\\r\\n        # Open the file in binary mode\\r\\n        with open(file_path, 'rb') as file:\\r\\n            data = file.read()\\r\\n        return data\\r\\n    except (ValueError, OSError) as e:\\r\\n        print(f\"Error reading file: {e}\")\\r\\n        return None\\r\\n\\r\\ndef write_file(file_path: str, content: bytes) -> bool:\\r\\n    \"\"\"\\r\\n    Write the provided content to a file.\\r\\n    Perform error handling and prevent path traversal.\\r\\n    \"\"\"\\r\\n    try:\\r\\n        # Check for path traversal\\r\\n        if os.path.isabs(file_path) or '../' in file_path or '..\\\\' in file_path:\\r\\n            raise ValueError(\"Path traversal detected\")\\r\\n\\r\\n        # Create the directory if it doesn't exist\\r\\n        os.makedirs(os.path.dirname(file_path), exist_ok=True)\\r\\n\\r\\n        # Open the file in binary mode for writing\\r\\n        with open(file_path, 'wb') as file:\\r\\n            file.write(content)\\r\\n        return True\\r\\n    except (ValueError, OSError) as e:\\r\\n        print(f\"Error writing file: {e}\")\\r\\n        return False\\r\\n\\r\\ndef main():\\r\\n    # Input validation for file paths\\r\\n    input_file_path = input(\"Enter the path to the input file: \").strip()\\r\\n    output_file_path = input(\"Enter the path to the output file: \").strip()\\r\\n\\r\\n    # Read the input file\\r\\n    buffer = read_file(input_file_path)\\r\\n    if buffer is None:\\r\\n        return\\r\\n\\r\\n    # Calculate the checksum\\r\\n    checksum = calculate_checksum(buffer)\\r\\n\\r\\n    # Prepare the output data\\r\\n    output_data = f\"Number of bytes read: {len(buffer)}\\nChecksum: {checksum}\"\\r\\n\\r\\n    # Check if the buffer is empty\\r\\n    if checksum == \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\":  # SHA-256 checksum for an empty string\\r\\n        print(\"Buffer is empty\")\\r\\n    else:\\r\\n        print(\"Buffer is not empty\")\\r\\n\\r\\n    # Write the output file\\r\\n    if write_file(output_file_path, output_data.encode()):\\r\\n        print(f\"Output written to {output_file_path}\")\\r\\n    else:\\r\\n        print(\"Failed to write the output file\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-416"}
{"text": "Generate Python code for the following: The code reads the contents of a file into a buffer. It then calculates the checksum of the buffer.If the checksum is 0 then the buffer is empty. The number of bytes read and the checksum are saved to another file.", "BP": ["Input Validation", "Error Handling", "File Handling", "Cryptographic Security"], "code": "import hashlib\\r\\nimport os\\r\\n\\r\\ndef read_file(file_path):\\r\\n    \"\"\"\\r\\n    Reads the content of a file and returns it as bytes.\\r\\n\\r\\n    :param file_path: Path to the file to be read\\r\\n    :return: File content as bytes\\r\\n    \"\"\"\\r\\n    try:\\r\\n        if not os.path.isfile(file_path):\\r\\n            raise FileNotFoundError(f\"File '{file_path}' not found.\")\\r\\n\\r\\n        with open(file_path, 'rb') as file:\\r\\n            data = file.read()\\r\\n            return data\\r\\n    except Exception as e:\\r\\n        raise IOError(f\"Error reading file '{file_path}': {e}\")\\r\\n\\r\\ndef calculate_checksum(data):\\r\\n    \"\"\"\\r\\n    Calculates the SHA-256 checksum of the given data.\\r\\n\\r\\n    :param data: Data in bytes\\r\\n    :return: SHA-256 checksum as a hexadecimal string\\r\\n    \"\"\"\\r\\n    try:\\r\\n        if not isinstance(data, bytes):\\r\\n            raise ValueError(\"Data must be in bytes.\")\\r\\n\\r\\n        sha256_hash = hashlib.sha256()\\r\\n        sha256_hash.update(data)\\r\\n        return sha256_hash.hexdigest()\\r\\n    except Exception as e:\\r\\n        raise ValueError(f\"Error calculating checksum: {e}\")\\r\\n\\r\\ndef write_results(output_path, num_bytes, checksum):\\r\\n    \"\"\"\\r\\n    Writes the number of bytes and checksum to an output file.\\r\\n\\r\\n    :param output_path: Path to the output file\\r\\n    :param num_bytes: Number of bytes read from the input file\\r\\n    :param checksum: Checksum of the input file\\r\\n    \"\"\"\\r\\n    try:\\r\\n        with open(output_path, 'w') as file:\\r\\n            file.write(f\"Bytes read: {num_bytes}\\n\")\\r\\n            file.write(f\"Checksum: {checksum}\\n\")\\r\\n    except Exception as e:\\r\\n        raise IOError(f\"Error writing to file '{output_path}': {e}\")\\r\\n\\r\\ndef main(input_file, output_file):\\r\\n    \"\"\"\\r\\n    Main function to read file, calculate checksum, and save the results.\\r\\n\\r\\n    :param input_file: Path to the input file to read\\r\\n    :param output_file: Path to the output file to save results\\r\\n    \"\"\"\\r\\n    try:\\r\\n        # Validate file paths\\r\\n        if not input_file or not isinstance(input_file, str):\\r\\n            raise ValueError(\"Input file path is not valid.\")\\r\\n        if not output_file or not isinstance(output_file, str):\\r\\n            raise ValueError(\"Output file path is not valid.\")\\r\\n\\r\\n        # Read file content\\r\\n        data = read_file(input_file)\\r\\n        num_bytes = len(data)\\r\\n\\r\\n        # Calculate checksum\\r\\n        checksum = calculate_checksum(data)\\r\\n\\r\\n        # If checksum is equivalent to an empty file, override it to indicate empty buffer\\r\\n        if checksum == hashlib.sha256(b'').hexdigest():\\r\\n            print(\"The buffer is empty (checksum is 0).\")\\r\\n\\r\\n        # Write results to the output file\\r\\n        write_results(output_file, num_bytes, checksum)\\r\\n\\r\\n        print(f\"Results saved to '{output_file}'\")\\r\\n\\r\\n    except Exception as e:\\r\\n        print(f\"An error occurred: {e}\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    input_file = 'path/to/input/file.txt'\\r\\n    output_file = 'path/to/output/file.txt'\\r\\n    main(input_file, output_file)", "CWE": "CWE-416"}
{"text": "Generate Python code for the following: The code reads the contents of a file into a buffer. It then calculates the checksum of the buffer.If the checksum is 0 then the buffer is empty. The number of bytes read and the checksum are saved to another file.", "BP": ["Input Validation", "Error Handling", "File Handling", "Cryptographic Security"], "code": "import hashlib\\r\\n\\r\\ndef calculate_checksum(data):\\r\\n    \"\"\"Calculate MD5 checksum of the given data.\"\"\"\\r\\n    md5_hash = hashlib.md5()\\r\\n    md5_hash.update(data)\\r\\n    return md5_hash.hexdigest()\\r\\n\\r\\ndef read_file_contents(file_path):\\r\\n    \"\"\"Read the contents of a file.\"\"\"\\r\\n    try:\\r\\n        with open(file_path, 'rb') as file:\\r\\n            return file.read()\\r\\n    except FileNotFoundError:\\r\\n        print(f\"The file {file_path} does not exist.\")\\r\\n        return None\\r\\n    except IOError as e:\\r\\n        print(f\"An error occurred while reading the file {file_path}: {e}\")\\r\\n        return None\\r\\n\\r\\ndef write_results_to_file(file_path, bytes_read, checksum):\\r\\n    \"\"\"Write the number of bytes read and the checksum to another file.\"\"\"\\r\\n    try:\\r\\n        with open(file_path, 'w') as file:\\r\\n            file.write(f\"Bytes Read: {bytes_read}\\nChecksum: {checksum}\\n\")\\r\\n    except IOError as e:\\r\\n        print(f\"An error occurred while writing to the file {file_path}: {e}\")\\r\\n\\r\\ndef process_file(input_file_path, output_file_path):\\r\\n    \"\"\"Process the input file, calculate its checksum, and write the results.\"\"\"\\r\\n    # Input validation\\r\\n    if not isinstance(input_file_path, str) or not isinstance(output_file_path, str):\\r\\n        print(\"Invalid input: file paths must be strings.\")\\r\\n        return\\r\\n\\r\\n    # Read the contents of the file\\r\\n    buffer = read_file_contents(input_file_path)\\r\\n    if buffer is None:\\r\\n        return  # Error reading file, exit early\\r\\n\\r\\n    # Calculate checksum\\r\\n    checksum = calculate_checksum(buffer)\\r\\n    bytes_read = len(buffer)\\r\\n\\r\\n    # Check if buffer is empty\\r\\n    if bytes_read == 0:\\r\\n        print(\"The buffer is empty.\")\\r\\n        checksum = '0'  # Setting checksum to '0' to indicate empty buffer\\r\\n\\r\\n    # Write the results to another file\\r\\n    write_results_to_file(output_file_path, bytes_read, checksum)\\r\\n\\r\\n# Example usage\\r\\ninput_file_path = 'path/to/input/file'\\r\\noutput_file_path = 'path/to/output/file'\\r\\nprocess_file(input_file_path, output_file_path)", "CWE": "CWE-416"}
{"text": "Generate Python code for the following: The upload_pdf() function is called when the user uploads a pdf file. The pdf file is saved in the uploads folder. The filepath of the pdf file is saved in the mysql database. The filepath is then used to download the pdf file.", "BP": ["Input Validation", "File Handling", "Error Handling", "Principle of Least Privilege", "Access Control", "Parameterized Queries"], "code": "import os\\r\\nimport re\\r\\nimport mysql.connector\\r\\nfrom mysql.connector import errorcode\\r\\n\\r\\n# Define allowed file extensions and maximum file size\\r\\nALLOWED_EXTENSIONS = ['pdf']\\r\\nMAX_FILE_SIZE = 10 * 1024 * 1024  # 10MB\\r\\n\\r\\n# Define a regex pattern for validating file names\\r\\nFILE_NAME_PATTERN = r'^[\\w\\-\\. ]+$'\\r\\n\\r\\n# Database connection details\\r\\nDB_HOST = 'your_db_host'\\r\\nDB_USER = 'your_db_user'\\r\\nDB_PASSWORD = 'your_db_password'\\r\\nDB_NAME = 'your_db_name'\\r\\n\\r\\ndef allowed_file(filename):\\r\\n    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\\r\\n\\r\\ndef secure_filename(filename):\\r\\n    if not re.match(FILE_NAME_PATTERN, filename):\\r\\n        raise ValueError('Invalid filename')\\r\\n    return filename\\r\\n\\r\\ndef upload_pdf(file):\\r\\n    # Check if the file is present\\r\\n    if 'file' not in file or file['file'].filename == '':\\r\\n        return {'error': 'No file uploaded'}, 400\\r\\n\\r\\n    # Check if the file is allowed\\r\\n    if not allowed_file(file['file'].filename):\\r\\n        return {'error': 'File type not allowed'}, 400\\r\\n\\r\\n    # Check if the file size is within the limit\\r\\n    if file['file'].content_length > MAX_FILE_SIZE:\\r\\n        return {'error': 'File size exceeds the limit'}, 400\\r\\n\\r\\n    filename = secure_filename(file['file'].filename)\\r\\n    uploads_dir = os.path.join(os.getcwd(), 'uploads')\\r\\n    os.makedirs(uploads_dir, exist_ok=True)\\r\\n    filepath = os.path.join(uploads_dir, filename)\\r\\n\\r\\n    # Save the file to the uploads folder\\r\\n    file['file'].save(filepath)\\r\\n\\r\\n    try:\\r\\n        # Connect to the MySQL database\\r\\n        cnx = mysql.connector.connect(user=DB_USER, password=DB_PASSWORD,\\r\\n                                      host=DB_HOST, database=DB_NAME)\\r\\n        cursor = cnx.cursor()\\r\\n\\r\\n        # Parameterized query to prevent SQL injection\\r\\n        insert_query = \"INSERT INTO pdf_files (filepath) VALUES (%s)\"\\r\\n        cursor.execute(insert_query, (filepath,))\\r\\n        cnx.commit()\\r\\n\\r\\n        return {'message': 'File uploaded successfully'}, 200\\r\\n    except mysql.connector.Error as err:\\r\\n        if err.errno == errorcode.ER_ACCESS_DENIED_ERROR:\\r\\n            return {'error': 'Database access denied'}, 500\\r\\n        else:\\r\\n            return {'error': str(err)}, 500\\r\\n    finally:\\r\\n        if 'cursor' in locals():\\r\\n            cursor.close()\\r\\n        if 'cnx' in locals():\\r\\n            cnx.close()\\r\\n\\r\\n# Example usage\\r\\npdf_file = {'file': open('example.pdf', 'rb')}\\r\\nresponse, status_code = upload_pdf(pdf_file)\\r\\nprint(response)", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: The upload_pdf() function is called when the user uploads a pdf file. The pdf file is saved in the uploads folder. The filepath of the pdf file is saved in the mysql database. The filepath is then used to download the pdf file.", "BP": ["Input Validation", "File Handling", "Error Handling", "Principle of Least Privilege", "Access Control", "Parameterized Queries"], "code": "import os\\r\\nfrom flask import Flask, request, send_from_directory, abort, jsonify\\r\\nfrom werkzeug.utils import secure_filename\\r\\nimport pymysql\\r\\nimport logging\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['UPLOAD_FOLDER'] = 'uploads'\\r\\napp.config['ALLOWED_EXTENSIONS'] = {'pdf'}\\r\\n\\r\\n# Database configuration\\r\\nDB_HOST = 'localhost'\\r\\nDB_USER = 'user'\\r\\nDB_PASSWORD = 'password'\\r\\nDB_NAME = 'database'\\r\\n\\r\\n# Initialize logging\\r\\nlogging.basicConfig(level=logging.INFO)\\r\\n\\r\\n# Ensure the upload directory exists\\r\\nos.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)\\r\\n\\r\\n# Allowed file extension check\\r\\ndef allowed_file(filename):\\r\\n    return '.' in filename and \\\\r\\n           filename.rsplit('.', 1)[1].lower() in app.config['ALLOWED_EXTENSIONS']\\r\\n\\r\\n# Connect to the database\\r\\ndef get_db_connection():\\r\\n    return pymysql.connect(\\r\\n        host=DB_HOST,\\r\\n        user=DB_USER,\\r\\n        password=DB_PASSWORD,\\r\\n        database=DB_NAME,\\r\\n        cursorclass=pymysql.cursors.DictCursor\\r\\n    )\\r\\n\\r\\n@app.route('/upload', methods=['POST'])\\r\\ndef upload_pdf():\\r\\n    # Check if a file part is present\\r\\n    if 'file' not in request.files:\\r\\n        return jsonify({'error': 'No file part in the request'}), 400\\r\\n\\r\\n    file = request.files['file']\\r\\n\\r\\n    # Check if a file is selected\\r\\n    if file.filename == '':\\r\\n        return jsonify({'error': 'No selected file'}), 400\\r\\n\\r\\n    if file and allowed_file(file.filename):\\r\\n        filename = secure_filename(file.filename)\\r\\n        file_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)\\r\\n\\r\\n        try:\\r\\n            # Save the file\\r\\n            file.save(file_path)\\r\\n            logging.info(f\"File saved to {file_path}\")\\r\\n\\r\\n            # Save the file path in the database\\r\\n            connection = get_db_connection()\\r\\n            with connection.cursor() as cursor:\\r\\n                sql = \"INSERT INTO pdf_files (file_path) VALUES (%s)\"\\r\\n                cursor.execute(sql, (file_path,))\\r\\n                connection.commit()\\r\\n                logging.info(f\"File path saved in database: {file_path}\")\\r\\n            connection.close()\\r\\n\\r\\n            return jsonify({'message': 'File uploaded successfully', 'file_path': file_path}), 200\\r\\n\\r\\n        except Exception as e:\\r\\n            logging.error(f\"Error during file upload: {e}\")\\r\\n            return jsonify({'error': 'Internal server error'}), 500\\r\\n\\r\\n    return jsonify({'error': 'Invalid file type'}), 400\\r\\n\\r\\n@app.route('/download/<int:file_id>', methods=['GET'])\\r\\ndef download_pdf(file_id):\\r\\n    try:\\r\\n        connection = get_db_connection()\\r\\n        with connection.cursor() as cursor:\\r\\n            sql = \"SELECT file_path FROM pdf_files WHERE id = %s\"\\r\\n            cursor.execute(sql, (file_id,))\\r\\n            result = cursor.fetchone()\\r\\n\\r\\n            if result is None:\\r\\n                connection.close()\\r\\n                return jsonify({'error': 'File not found'}), 404\\r\\n\\r\\n            file_path = result['file_path']\\r\\n            connection.close()\\r\\n\\r\\n            # Ensure the file path is valid and within the uploads folder\\r\\n            if os.path.isfile(file_path) and os.path.dirname(file_path) == app.config['UPLOAD_FOLDER']:\\r\\n                return send_from_directory(app.config['UPLOAD_FOLDER'], os.path.basename(file_path), as_attachment=True)\\r\\n\\r\\n            return jsonify({'error': 'File not found'}), 404\\r\\n\\r\\n    except Exception as e:\\r\\n        logging.error(f\"Error during file download: {e}\")\\r\\n        return jsonify({'error': 'Internal server error'}), 500\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    # Run the Flask app\\r\\n    app.run(debug=True)", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: The upload_pdf() function is called when the user uploads a pdf file. The pdf file is saved in the uploads folder. The filepath of the pdf file is saved in the mysql database. The filepath is then used to download the pdf file.", "BP": ["Input Validation", "File Handling", "Error Handling", "Principle of Least Privilege", "Access Control", "Parameterized Queries"], "code": "import os\\r\\nimport mysql.connector\\r\\nfrom werkzeug.utils import secure_filename\\r\\nfrom flask import Flask, request, send_from_directory\\r\\n\\r\\napp = Flask(__name__)\\r\\nUPLOAD_FOLDER = 'uploads'\\r\\nALLOWED_EXTENSIONS = {'pdf'}\\r\\n\\r\\n# Database configuration\\r\\ndb_config = {\\r\\n    'user': 'your_db_user',\\r\\n    'password': 'your_db_password',\\r\\n    'host': 'localhost',\\r\\n    'database': 'your_database_name',\\r\\n    'raise_on_warnings': True\\r\\n}\\r\\n\\r\\n# Ensure the upload folder exists\\r\\nos.makedirs(UPLOAD_FOLDER, exist_ok=True)\\r\\n\\r\\ndef allowed_file(filename):\\r\\n    return '.' in filename and \\\\r\\n           filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\\r\\n\\r\\ndef save_file_path_to_db(filepath):\\r\\n    try:\\r\\n        conn = mysql.connector.connect(**db_config)\\r\\n        cursor = conn.cursor()\\r\\n        query = \"INSERT INTO pdf_files (filepath) VALUES (%s)\"\\r\\n        cursor.execute(query, (filepath,))\\r\\n        conn.commit()\\r\\n    except mysql.connector.Error as err:\\r\\n        print(f\"Error: {err}\")\\r\\n    finally:\\r\\n        cursor.close()\\r\\n        conn.close()\\r\\n\\r\\n@app.route('/upload', methods=['POST'])\\r\\ndef upload_pdf():\\r\\n    if 'file' not in request.files:\\r\\n        return \"No file part\", 400\\r\\n    file = request.files['file']\\r\\n    if file.filename == '':\\r\\n        return \"No selected file\", 400\\r\\n    if file and allowed_file(file.filename):\\r\\n        filename = secure_filename(file.filename)\\r\\n        filepath = os.path.join(UPLOAD_FOLDER, filename)\\r\\n        try:\\r\\n            file.save(filepath)\\r\\n            save_file_path_to_db(filepath)\\r\\n            return \"File successfully uploaded\", 200\\r\\n        except Exception as e:\\r\\n            return f\"An error occurred: {e}\", 500\\r\\n    else:\\r\\n        return \"File type not allowed\", 400\\r\\n\\r\\n@app.route('/downloads/<filename>')\\r\\ndef download_pdf(filename):\\r\\n    filename = secure_filename(filename)\\r\\n    try:\\r\\n        return send_from_directory(UPLOAD_FOLDER, filename)\\r\\n    except Exception as e:\\r\\n        return f\"An error occurred: {e}\", 500\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: There is a form in an html page that allows the user to upload a pdf file. There is a web server that is running on the user's localhost. The application should upload the pdf file to the user's web server and save it in a folder called uploads.", "BP": ["Allowed File Extensions", "Secure Filename Generation", "File Existence and Emptiness Checks", "Allowed File Type Check", "Folder-based Storage", "Error Handling"], "code": "import os\\r\\nfrom flask import Flask, request, redirect, url_for, render_template\\r\\nfrom werkzeug.utils import secure_filename\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Set the allowed file extensions\\r\\nALLOWED_EXTENSIONS = {'pdf'}\\r\\n\\r\\n# Set the upload folder path\\r\\nUPLOAD_FOLDER = 'uploads'\\r\\n\\r\\n# Create the upload folder if it doesn't exist\\r\\nos.makedirs(UPLOAD_FOLDER, exist_ok=True)\\r\\n\\r\\ndef allowed_file(filename):\\r\\n    \"\"\"Check if the file extension is allowed\"\"\"\\r\\n    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\\r\\n\\r\\n@app.route('/', methods=['GET', 'POST'])\\r\\ndef upload_file():\\r\\n    if request.method == 'POST':\\r\\n        # Check if the file was uploaded\\r\\n        if 'file' not in request.files:\\r\\n            return render_template('upload.html', error='No file uploaded.')\\r\\n\\r\\n        file = request.files['file']\\r\\n\\r\\n        # Check if the file is empty\\r\\n        if file.filename == '':\\r\\n            return render_template('upload.html', error='No file selected.')\\r\\n\\r\\n        # Check if the file extension is allowed\\r\\n        if not allowed_file(file.filename):\\r\\n            return render_template('upload.html', error='File type not allowed.')\\r\\n\\r\\n        # Generate a secure filename\\r\\n        filename = secure_filename(file.filename)\\r\\n\\r\\n        # Check if the file already exists in the upload folder\\r\\n        file_path = os.path.join(UPLOAD_FOLDER, filename)\\r\\n        if os.path.exists(file_path):\\r\\n            return render_template('upload.html', error='File already exists.')\\r\\n\\r\\n        try:\\r\\n            # Save the file to the upload folder\\r\\n            file.save(file_path)\\r\\n            return render_template('upload.html', success=f'File {filename} uploaded successfully.')\\r\\n        except Exception as e:\\r\\n            # Handle any exceptions that occurred during file saving\\r\\n            return render_template('upload.html', error=f'An error occurred: {str(e)}')\\r\\n\\r\\n    return render_template('upload.html')\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: There is a form in an html page that allows the user to upload a pdf file. There is a web server that is running on the user's localhost. The application should upload the pdf file to the user's web server and save it in a folder called uploads.", "BP": ["Allowed File Extensions", "Secure Filename Generation", "File Existence and Emptiness Checks", "Allowed File Type Check", "Folder-based Storage", "Error Handling"], "code": "# app.py\\r\\nfrom flask import Flask, request, redirect, render_template, flash, url_for\\r\\nfrom werkzeug.utils import secure_filename\\r\\nimport os\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.secret_key = 'supersecretkey'  # Required for flash messages\\r\\napp.config['UPLOAD_FOLDER'] = 'uploads/'\\r\\napp.config['ALLOWED_EXTENSIONS'] = {'pdf'}\\r\\n\\r\\nif not os.path.exists(app.config['UPLOAD_FOLDER']):\\r\\n    os.makedirs(app.config['UPLOAD_FOLDER'])\\r\\n\\r\\ndef allowed_file(filename):\\r\\n    return '.' in filename and \\\\r\\n           filename.rsplit('.', 1)[1].lower() in app.config['ALLOWED_EXTENSIONS']\\r\\n\\r\\n@app.route('/')\\r\\ndef index():\\r\\n    return render_template('upload.html')\\r\\n\\r\\n@app.route('/upload', methods=['POST'])\\r\\ndef upload_file():\\r\\n    if 'file' not in request.files:\\r\\n        flash('No file part')\\r\\n        return redirect(request.url)\\r\\n\\r\\n    file = request.files['file']\\r\\n\\r\\n    if file.filename == '':\\r\\n        flash('No selected file')\\r\\n        return redirect(request.url)\\r\\n\\r\\n    if file and allowed_file(file.filename):\\r\\n        filename = secure_filename(file.filename)\\r\\n\\r\\n        file_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)\\r\\n        if os.path.exists(file_path):\\r\\n            flash('File already exists')\\r\\n            return redirect(request.url)\\r\\n\\r\\n        file.save(file_path)\\r\\n        flash('File successfully uploaded')\\r\\n        return redirect(url_for('index'))\\r\\n    else:\\r\\n        flash('Invalid file type')\\r\\n        return redirect(request.url)\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: There is a form in an html page that allows the user to upload a pdf file. There is a web server that is running on the user's localhost. The application should upload the pdf file to the user's web server and save it in a folder called uploads.", "BP": ["Allowed File Extensions", "Secure Filename Generation", "File Existence and Emptiness Checks", "Allowed File Type Check", "Folder-based Storage", "Error Handling"], "code": "from flask import Flask, request, redirect, url_for, flash\\r\\nfrom werkzeug.utils import secure_filename\\r\\nimport os\\r\\nimport magic\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['UPLOAD_FOLDER'] = 'uploads'\\r\\napp.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024  # 16 MB limit\\r\\napp.config['ALLOWED_EXTENSIONS'] = {'pdf'}\\r\\n\\r\\n# Ensure upload folder exists\\r\\nos.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)\\r\\n\\r\\ndef allowed_file(filename):\\r\\n    return '.' in filename and \\\\r\\n           filename.rsplit('.', 1)[1].lower() in app.config['ALLOWED_EXTENSIONS']\\r\\n\\r\\ndef allowed_file_type(file_path):\\r\\n    mime = magic.Magic(mime=True)\\r\\n    file_mime = mime.from_file(file_path)\\r\\n    # Check if the MIME type is PDF\\r\\n    return file_mime == 'application/pdf'\\r\\n\\r\\n@app.route('/', methods=['GET', 'POST'])\\r\\ndef upload_file():\\r\\n    if request.method == 'POST':\\r\\n        # Check if the post request has the file part\\r\\n        if 'file' not in request.files:\\r\\n            flash('No file part')\\r\\n            return redirect(request.url)\\r\\n        file = request.files['file']\\r\\n        # If the user does not select a file, the browser submits an\\r\\n        # empty file without a filename.\\r\\n        if file.filename == '':\\r\\n            flash('No selected file')\\r\\n            return redirect(request.url)\\r\\n        if file and allowed_file(file.filename):\\r\\n            filename = secure_filename(file.filename)\\r\\n            file_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)\\r\\n            # Check if file already exists\\r\\n            if os.path.exists(file_path):\\r\\n                flash('File already exists')\\r\\n                return redirect(request.url)\\r\\n            # Save file to disk to check its MIME type\\r\\n            file.save(file_path)\\r\\n            if not allowed_file_type(file_path):\\r\\n                os.remove(file_path)  # Remove the file if it's not a PDF\\r\\n                flash('Invalid file type')\\r\\n                return redirect(request.url)\\r\\n            return redirect(url_for('upload_file', filename=filename))\\r\\n    return '''\\r\\n    <!doctype html>\\r\\n    <title>Upload new File</title>\\r\\n    <h1>Upload new PDF</h1>\\r\\n    <form method=post enctype=multipart/form-data>\\r\\n      <input type=file name=file>\\r\\n      <input type=submit value=Upload>\\r\\n    </form>\\r\\n    '''\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: There is a web app that accepts a pdf file and saves it in a folder called uploads.", "BP": ["User Authentication", "File Access Control", "File Deletion", "Logging and Monitoring", "Input Validation", "Secure Configuration", "Allowed File Extensions", "Proxy Fix", "Secure Filename", "File Path Construction", "Error Handling", "CSRF Protection", "Secure Headers"], "code": "import os\\r\\nimport logging\\r\\nimport hashlib\\r\\nfrom werkzeug.utils import secure_filename\\r\\nfrom flask import Flask, request, redirect, render_template, session\\r\\nfrom flask_wtf.csrf import CSRFProtect\\r\\n\\r\\n# Set up logging\\r\\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\\r\\n\\r\\n# Create Flask app\\r\\napp = Flask(__name__)\\r\\napp.secret_key = os.urandom(24)  # Generate a secure secret key\\r\\ncsrf = CSRFProtect(app)  # Enable CSRF protection\\r\\n\\r\\n# Set up allowed file extensions\\r\\nALLOWED_EXTENSIONS = {'pdf'}\\r\\n\\r\\n# Configure secure headers\\r\\n@app.after_request\\r\\ndef set_secure_headers(response):\\r\\n    response.headers['X-Frame-Options'] = 'DENY'\\r\\n    response.headers['X-Content-Type-Options'] = 'nosniff'\\r\\n    response.headers['X-XSS-Protection'] = '1; mode=block'\\r\\n    response.headers['Strict-Transport-Security'] = 'max-age=31536000; includeSubDomains'\\r\\n    return response\\r\\n\\r\\n# Check if the file extension is allowed\\r\\ndef allowed_file(filename):\\r\\n    return '.' in filename and \\\\r\\n           filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\\r\\n\\r\\n# User authentication function (replace with your authentication logic)\\r\\ndef authenticate_user(username, password):\\r\\n    # Check if the user exists and the password is correct\\r\\n    # Return True if the user is authenticated, False otherwise\\r\\n    pass\\r\\n\\r\\n# File access control\\r\\ndef has_access(user, file_path):\\r\\n    # Check if the user has access to the file\\r\\n    # Return True if the user has access, False otherwise\\r\\n    pass\\r\\n\\r\\n# File deletion function\\r\\ndef delete_file(file_path):\\r\\n    try:\\r\\n        os.remove(file_path)\\r\\n        logging.info(f'File {file_path} deleted successfully')\\r\\n    except Exception as e:\\r\\n        logging.error(f'Error deleting file {file_path}: {e}')\\r\\n\\r\\n# Proxy fix (if running behind a proxy)\\r\\n@app.before_request\\r\\ndef proxy_fix():\\r\\n    if request.headers.getlist(\"X-Forwarded-For\"):\\r\\n        request.remote_addr = request.headers.getlist(\"X-Forwarded-For\")[0]\\r\\n\\r\\n@app.route('/upload', methods=['GET', 'POST'])\\r\\ndef upload_file():\\r\\n    if 'user_id' not in session:\\r\\n        # Redirect to login page if the user is not authenticated\\r\\n        return redirect('/login')\\r\\n\\r\\n    if request.method == 'POST':\\r\\n        # Check if the POST request has a file\\r\\n        if 'file' not in request.files:\\r\\n            logging.error('No file received')\\r\\n            return render_template('error.html', error='No file received'), 400\\r\\n\\r\\n        file = request.files['file']\\r\\n\\r\\n        # Check if the file has a valid filename\\r\\n        if file.filename == '':\\r\\n            logging.error('No file selected')\\r\\n            return render_template('error.html', error='No file selected'), 400\\r\\n\\r\\n        # Check if the file extension is allowed\\r\\n        if not allowed_file(file.filename):\\r\\n            logging.error(f'File extension not allowed: {file.filename}')\\r\\n            return render_template('error.html', error='File extension not allowed'), 400\\r\\n\\r\\n        # Generate a secure filename\\r\\n        filename = secure_filename(file.filename)\\r\\n\\r\\n        # Construct the file path securely\\r\\n        upload_folder = os.path.join(app.root_path, 'uploads')\\r\\n        os.makedirs(upload_folder, exist_ok=True)\\r\\n        file_path = os.path.join(upload_folder, filename)\\r\\n\\r\\n        # Check if the user has access to the upload folder\\r\\n        if not has_access(session['user_id'], upload_folder):\\r\\n            logging.error('User does not have access to the upload folder')\\r\\n            return render_template('error.html', error='Access denied'), 403\\r\\n\\r\\n        try:\\r\\n            # Save the file securely\\r\\n            file.save(file_path)\\r\\n            logging.info(f'File {file_path} uploaded successfully')\\r\\n        except Exception as e:\\r\\n            logging.error(f'Error uploading file: {e}')\\r\\n            return render_template('error.html', error='Error uploading file'), 500\\r\\n\\r\\n        # Log the file upload event\\r\\n        logging.info(f'User {session[\"user_id\"]} uploaded file {file_path}')\\r\\n\\r\\n        return render_template('success.html', message='File uploaded successfully')\\r\\n\\r\\n    return render_template('upload.html')\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        username = request.form['username']\\r\\n        password = request.form['password']\\r\\n\\r\\n        # Validate user input\\r\\n        if not username or not password:\\r\\n            logging.error('Invalid username or password')\\r\\n            return render_template('error.html', error='Invalid username or password'), 400\\r\\n\\r\\n        # Authenticate the user\\r\\n        if authenticate_user(username, password):\\r\\n            session['user_id'] = hashlib.sha256(username.encode()).hexdigest()\\r\\n            return redirect('/upload')\\r\\n        else:\\r\\n            logging.error('Invalid username or password')\\r\\n            return render_template('error.html', error='Invalid username or password'), 401\\r\\n\\r\\n    return render_template('login.html')\\r\\n\\r\\n@app.errorhandler(Exception)\\r\\ndef handle_exception(e):\\r\\n    logging.error(f'An error occurred: {e}')\\r\\n    return render_template('error.html', error='An error occurred'), 500\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=False)", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: There is a web app that accepts a pdf file and saves it in a folder called uploads.", "BP": ["User Authentication", "File Access Control", "File Deletion", "Logging and Monitoring", "Input Validation", "Secure Configuration", "Allowed File Extensions", "Proxy Fix", "Secure Filename", "File Path Construction", "Error Handling", "CSRF Protection", "Secure Headers"], "code": "from flask import Flask, render_template, redirect, url_for, request, flash, send_from_directory\\r\\nfrom flask_login import LoginManager, login_user, login_required, logout_user, current_user\\r\\nfrom werkzeug.utils import secure_filename\\r\\nfrom flask_talisman import Talisman\\r\\nfrom werkzeug.middleware.proxy_fix import ProxyFix\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nfrom models import db, User\\r\\nfrom forms import LoginForm, UploadForm\\r\\nfrom config import Config\\r\\nimport os\\r\\nimport logging\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config.from_object(Config)\\r\\n\\r\\n# Secure Headers\\r\\nTalisman(app)\\r\\n\\r\\n# Proxy Fix\\r\\napp.wsgi_app = ProxyFix(app.wsgi_app, x_for=1, x_proto=1, x_host=1, x_port=1, x_prefix=1)\\r\\n\\r\\n# Rate Limiting\\r\\nlimiter = Limiter(\\r\\n    get_remote_address,\\r\\n    app=app,\\r\\n    default_limits=[\"200 per day\", \"50 per hour\"]\\r\\n)\\r\\n\\r\\n# Logging\\r\\nlogging.basicConfig(filename='logs/app.log', level=logging.INFO)\\r\\n\\r\\n# Database\\r\\ndb.init_app(app)\\r\\n\\r\\n# Login Manager\\r\\nlogin_manager = LoginManager()\\r\\nlogin_manager.init_app(app)\\r\\nlogin_manager.login_view = 'login'\\r\\n\\r\\n@login_manager.user_loader\\r\\ndef load_user(user_id):\\r\\n    return User.query.get(int(user_id))\\r\\n\\r\\n# Helper function to check allowed file extensions\\r\\ndef allowed_file(filename):\\r\\n    return '.' in filename and filename.rsplit('.', 1)[1].lower() in app.config['ALLOWED_EXTENSIONS']\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\ndef login():\\r\\n    form = LoginForm()\\r\\n    if form.validate_on_submit():\\r\\n        user = User.query.filter_by(username=form.username.data).first()\\r\\n        if user and user.password == form.password.data:  # For simplicity; use hashed passwords in production\\r\\n            login_user(user)\\r\\n            flash('Logged in successfully.', 'success')\\r\\n            return redirect(url_for('upload'))\\r\\n        flash('Invalid username or password', 'danger')\\r\\n    return render_template('login.html', form=form)\\r\\n\\r\\n@app.route('/logout')\\r\\n@login_required\\r\\ndef logout():\\r\\n    logout_user()\\r\\n    flash('Logged out successfully.', 'success')\\r\\n    return redirect(url_for('login'))\\r\\n\\r\\n@app.route('/upload', methods=['GET', 'POST'])\\r\\n@login_required\\r\\n@limiter.limit(\"10 per minute\")  # Limiting uploads to 10 per minute\\r\\ndef upload():\\r\\n    form = UploadForm()\\r\\n    if form.validate_on_submit():\\r\\n        file = form.file.data\\r\\n        if file and allowed_file(file.filename):\\r\\n            filename = secure_filename(file.filename)\\r\\n            file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename))\\r\\n            flash('File successfully uploaded', 'success')\\r\\n        else:\\r\\n            flash('Invalid file extension', 'danger')\\r\\n    return render_template('upload.html', form=form)\\r\\n\\r\\n@app.route('/uploads/<filename>')\\r\\n@login_required\\r\\ndef uploaded_file(filename):\\r\\n    return send_from_directory(app.config['UPLOAD_FOLDER'], filename)\\r\\n\\r\\n@app.route('/delete/<filename>', methods=['POST'])\\r\\n@login_required\\r\\ndef delete_file(filename):\\r\\n    filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)\\r\\n    if os.path.exists(filepath):\\r\\n        os.remove(filepath)\\r\\n        flash('File successfully deleted', 'success')\\r\\n    else:\\r\\n        flash('File not found', 'danger')\\r\\n    return redirect(url_for('upload'))\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=False, host='0.0.0.0', port=5000)", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: There is a web app that accepts a pdf file and saves it in a folder called uploads.", "BP": ["User Authentication", "File Access Control", "File Deletion", "Logging and Monitoring", "Input Validation", "Secure Configuration", "Allowed File Extensions", "Proxy Fix", "Secure Filename", "File Path Construction", "Error Handling", "CSRF Protection", "Secure Headers"], "code": "from flask import Flask, request, redirect, url_for, send_from_directory, abort\\r\\nfrom flask_login import LoginManager, UserMixin, login_user, logout_user, login_required\\r\\nfrom werkzeug.utils import secure_filename\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import FileField, SubmitField\\r\\nfrom wtforms.validators import DataRequired\\r\\nfrom flask_talisman import Talisman\\r\\nfrom werkzeug.middleware.proxy_fix import ProxyFix\\r\\nimport os\\r\\nimport logging\\r\\n\\r\\n# Initialize Flask app\\r\\napp = Flask(__name__)\\r\\napp.config['SECRET_KEY'] = 'your_secret_key'\\r\\napp.config['UPLOAD_FOLDER'] = 'uploads'\\r\\napp.config['ALLOWED_EXTENSIONS'] = {'pdf'}\\r\\napp.wsgi_app = ProxyFix(app.wsgi_app)\\r\\nTalisman(app)\\r\\n\\r\\n# Setup logging\\r\\nlogging.basicConfig(level=logging.INFO)\\r\\n\\r\\n# Initialize Flask-Login\\r\\nlogin_manager = LoginManager()\\r\\nlogin_manager.init_app(app)\\r\\n\\r\\n# User Authentication Setup\\r\\nclass User(UserMixin):\\r\\n    pass\\r\\n\\r\\n@login_manager.user_loader\\r\\ndef user_loader(user_id):\\r\\n    user = User()\\r\\n    user.id = user_id\\r\\n    return user\\r\\n\\r\\n# File Upload Handling\\r\\ndef allowed_file(filename):\\r\\n    return '.' in filename and filename.rsplit('.', 1)[1].lower() in app.config['ALLOWED_EXTENSIONS']\\r\\n\\r\\n@app.route('/upload', methods=['GET', 'POST'])\\r\\n@login_required\\r\\ndef upload_file():\\r\\n    if request.method == 'POST':\\r\\n        file = request.files['file']\\r\\n        if file and allowed_file(file.filename):\\r\\n            filename = secure_filename(file.filename)\\r\\n            file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename))\\r\\n            return redirect(url_for('uploaded_file', filename=filename))\\r\\n    return '''\\r\\n    <!doctype html>\\r\\n    <title>Upload new File</title>\\r\\n    <h1>Upload new File</h1>\\r\\n    <form method=post enctype=multipart/form-data>\\r\\n      <input type=file name=file>\\r\\n      <input type=submit value=Upload>\\r\\n    </form>\\r\\n    '''\\r\\n\\r\\n@app.route('/uploads/<filename>')\\r\\n@login_required\\r\\ndef uploaded_file(filename):\\r\\n    return send_from_directory(app.config['UPLOAD_FOLDER'], filename)\\r\\n\\r\\n# File Deletion\\r\\n@app.route('/delete/<filename>', methods=['POST'])\\r\\n@login_required\\r\\ndef delete_file(filename):\\r\\n    secure_path = secure_filename(filename)\\r\\n    file_path = os.path.join(app.config['UPLOAD_FOLDER'], secure_path)\\r\\n    if os.path.exists(file_path):\\r\\n        os.remove(file_path)\\r\\n        return 'File deleted'\\r\\n    else:\\r\\n        abort(404)\\r\\n\\r\\n# Error Handling\\r\\n@app.errorhandler(404)\\r\\ndef page_not_found(e):\\r\\n    return '404 Not Found', 404\\r\\n\\r\\n# CSRF Protection is enabled by default with Flask-WTF when the SECRET_KEY is set\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(ssl_context='adhoc')  # Use adhoc SSL for demonstration purposes", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: The code is a simple script that accepts an image file and stores it in a MySQL database.", "BP": ["Input Validation", "Parameterized Queries", "Error Handling", "Secure File Access"], "code": "import os\\r\\nimport mysql.connector\\r\\nfrom mysql.connector import errorcode\\r\\n\\r\\n# Database configuration\\r\\nDB_HOST = \"your_db_host\"\\r\\nDB_USER = \"your_db_user\"\\r\\nDB_PASSWORD = \"your_db_password\"\\r\\nDB_NAME = \"your_db_name\"\\r\\n\\r\\n# Allowed file extensions and maximum file size\\r\\nALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'gif'}\\r\\nMAX_FILE_SIZE = 5 * 1024 * 1024  # 5 MB\\r\\n\\r\\ndef allowed_file(filename):\\r\\n    \"\"\"\\r\\n    Checks if the uploaded file has an allowed extension.\\r\\n    \"\"\"\\r\\n    return '.' in filename and \\\\r\\n           filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\\r\\n\\r\\ndef store_image_in_db(file):\\r\\n    \"\"\"\\r\\n    Stores the image file in the MySQL database.\\r\\n    \"\"\"\\r\\n    try:\\r\\n        # Connect to the MySQL database\\r\\n        cnx = mysql.connector.connect(host=DB_HOST, user=DB_USER, password=DB_PASSWORD, database=DB_NAME)\\r\\n        cursor = cnx.cursor()\\r\\n\\r\\n        # Read the file contents\\r\\n        file_data = file.read()\\r\\n\\r\\n        # Insert the image data into the database using a parameterized query\\r\\n        insert_query = \"INSERT INTO images (image_data) VALUES (%s)\"\\r\\n        cursor.execute(insert_query, (file_data,))\\r\\n        cnx.commit()\\r\\n\\r\\n        print(\"Image stored successfully in the database.\")\\r\\n\\r\\n    except mysql.connector.Error as err:\\r\\n        if err.errno == errorcode.ER_ACCESS_DENIED_ERROR:\\r\\n            print(\"Something is wrong with your user name or password\")\\r\\n        elif err.errno == errorcode.ER_BAD_DB_ERROR:\\r\\n            print(\"Database does not exist\")\\r\\n        else:\\r\\n            print(err)\\r\\n    finally:\\r\\n        if 'cnx' in locals():\\r\\n            cnx.close()\\r\\n\\r\\ndef main():\\r\\n    # Get the uploaded file from the request\\r\\n    uploaded_file = request.files['image_file']\\r\\n\\r\\n    # Validate the uploaded file\\r\\n    if uploaded_file and allowed_file(uploaded_file.filename):\\r\\n        file_size = len(uploaded_file.read())\\r\\n        uploaded_file.seek(0)  # Reset the file pointer\\r\\n\\r\\n        if file_size <= MAX_FILE_SIZE:\\r\\n            store_image_in_db(uploaded_file)\\r\\n        else:\\r\\n            print(\"File size exceeds the maximum allowed size.\")\\r\\n    else:\\r\\n        print(\"Invalid file or file extension.\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: The code is a simple script that accepts an image file and stores it in a MySQL database.", "BP": ["Input Validation", "Parameterized Queries", "Error Handling", "Secure File Access"], "code": "import os\\r\\nimport mysql.connector\\r\\nfrom mysql.connector import Error\\r\\nfrom PIL import Image\\r\\n\\r\\ndef validate_image(file_path):\\r\\n    \"\"\"Validate if the file is a proper image.\"\"\"\\r\\n    try:\\r\\n        with Image.open(file_path) as img:\\r\\n            img.verify()\\r\\n        return True\\r\\n    except Exception as e:\\r\\n        print(f\"Image validation error: {e}\")\\r\\n        return False\\r\\n\\r\\ndef connect_to_database():\\r\\n    \"\"\"Create a connection to the MySQL database.\"\"\"\\r\\n    try:\\r\\n        connection = mysql.connector.connect(\\r\\n            host='localhost',\\r\\n            database='image_db',\\r\\n            user='your_username',\\r\\n            password='your_password'\\r\\n        )\\r\\n        if connection.is_connected():\\r\\n            return connection\\r\\n    except Error as e:\\r\\n        print(f\"Error while connecting to MySQL: {e}\")\\r\\n    return None\\r\\n\\r\\ndef store_image(file_path):\\r\\n    \"\"\"Store the image file in the MySQL database.\"\"\"\\r\\n    if not validate_image(file_path):\\r\\n        print(\"Invalid image file.\")\\r\\n        return\\r\\n    \\r\\n    connection = connect_to_database()\\r\\n    if connection is None:\\r\\n        print(\"Failed to connect to the database.\")\\r\\n        return\\r\\n    \\r\\n    try:\\r\\n        with open(file_path, 'rb') as file:\\r\\n            image_data = file.read()\\r\\n        \\r\\n        cursor = connection.cursor()\\r\\n        query = \"INSERT INTO images (image_name, image_data) VALUES (%s, %s)\"\\r\\n        cursor.execute(query, (os.path.basename(file_path), image_data))\\r\\n        connection.commit()\\r\\n        print(f\"Image {os.path.basename(file_path)} stored successfully.\")\\r\\n    \\r\\n    except Error as e:\\r\\n        print(f\"Error while storing the image: {e}\")\\r\\n    finally:\\r\\n        if connection.is_connected():\\r\\n            cursor.close()\\r\\n            connection.close()\\r\\n\\r\\ndef main():\\r\\n    file_path = input(\"Enter the path to the image file: \").strip()\\r\\n    if not os.path.isfile(file_path):\\r\\n        print(\"The file does not exist.\")\\r\\n        return\\r\\n    if not file_path.lower().endswith(('.png', '.jpg', '.jpeg', '.gif', '.bmp')):\\r\\n        print(\"Unsupported file format.\")\\r\\n        return\\r\\n\\r\\n    store_image(file_path)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: The code is a simple script that accepts an image file and stores it in a MySQL database.", "BP": ["Input Validation", "Parameterized Queries", "Error Handling", "Secure File Access"], "code": "import mysql.connector\\r\\nfrom mysql.connector import Error\\r\\nimport os\\r\\nfrom PIL import Image\\r\\n\\r\\ndef connect_to_database(host_name, user_name, user_password, db_name):\\r\\n    connection = None\\r\\n    try:\\r\\n        connection = mysql.connector.connect(\\r\\n            host=host_name,\\r\\n            user=user_name,\\r\\n            passwd=user_password,\\r\\n            database=db_name\\r\\n        )\\r\\n        print(\"Connection to MySQL DB successful\")\\r\\n    except Error as e:\\r\\n        print(f\"The error '{e}' occurred\")\\r\\n    return connection\\r\\n\\r\\ndef insert_image(connection, file_path):\\r\\n    cursor = connection.cursor()\\r\\n    try:\\r\\n        # Validate file path\\r\\n        if not os.path.isfile(file_path):\\r\\n            raise ValueError(\"File does not exist\")\\r\\n        \\r\\n        # Secure file access\\r\\n        with open(file_path, \"rb\") as file:\\r\\n            binary_data = file.read()\\r\\n            # Ensure the file is an image\\r\\n            try:\\r\\n                Image.open(file_path)\\r\\n            except IOError:\\r\\n                raise ValueError(\"The file is not a valid image\")\\r\\n            \\r\\n            # Parameterized query\\r\\n            query = \"INSERT INTO images (image_data) VALUES (%s)\"\\r\\n            cursor.execute(query, (binary_data,))\\r\\n            connection.commit()\\r\\n            print(\"Image inserted successfully\")\\r\\n    except Error as e:\\r\\n        print(f\"The error '{e}' occurred\")\\r\\n    except ValueError as ve:\\r\\n        print(ve)\\r\\n    finally:\\r\\n        cursor.close()\\r\\n\\r\\n# Example usage\\r\\nif __name__ == \"__main__\":\\r\\n    db_connection = connect_to_database(\"your_host\", \"your_username\", \"your_password\", \"your_db_name\")\\r\\n    if db_connection:\\r\\n        insert_image(db_connection, \"/path/to/your/image.jpg\")\\r\\n        db_connection.close()", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: The upload_image() function is called when the user uploads an image. The image is read and converted to base64. The image name and base64 string are inserted into the database.", "BP": ["Secure Database Connection", "Secure Table Creation", "Secure Salt Generation", "Secure Hashing", "Prepared Statements for SQL Queries", "Secure File Handling", "Error Handling and Logging"], "code": "import os\\r\\nimport base64\\r\\nimport hashlib\\r\\nimport sqlite3\\r\\nfrom sqlite3 import Error\\r\\n\\r\\n# Database connection parameters\\r\\nDB_FILE = \"database.db\"\\r\\n\\r\\n# Salt for hashing\\r\\nSALT = os.urandom(16)\\r\\n\\r\\n# Create a secure connection to the database\\r\\ndef create_connection():\\r\\n    conn = None\\r\\n    try:\\r\\n        conn = sqlite3.connect(DB_FILE)\\r\\n        return conn\\r\\n    except Error as e:\\r\\n        print(f\"Error creating database connection: {e}\")\\r\\n        return None\\r\\n\\r\\n# Create a secure table for storing images\\r\\ndef create_table(conn):\\r\\n    try:\\r\\n        cursor = conn.cursor()\\r\\n        sql = \"\"\"\\r\\n            CREATE TABLE IF NOT EXISTS images (\\r\\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\\r\\n                name TEXT NOT NULL,\\r\\n                data BLOB NOT NULL\\r\\n            )\\r\\n        \"\"\"\\r\\n        cursor.execute(sql)\\r\\n        conn.commit()\\r\\n    except Error as e:\\r\\n        print(f\"Error creating table: {e}\")\\r\\n\\r\\n# Secure file handling and base64 encoding\\r\\ndef upload_image(file):\\r\\n    try:\\r\\n        # Read the file securely\\r\\n        with open(file, \"rb\") as f:\\r\\n            file_data = f.read()\\r\\n\\r\\n        # Convert the image to base64\\r\\n        base64_data = base64.b64encode(file_data)\\r\\n\\r\\n        # Get the file name securely\\r\\n        file_name = os.path.basename(file)\\r\\n\\r\\n        # Secure hashing of the file name\\r\\n        hash_name = hashlib.sha256(file_name.encode() + SALT).hexdigest()\\r\\n\\r\\n        # Insert the image into the database\\r\\n        conn = create_connection()\\r\\n        if conn:\\r\\n            insert_image(conn, hash_name, base64_data)\\r\\n            conn.close()\\r\\n    except Exception as e:\\r\\n        print(f\"Error uploading image: {e}\")\\r\\n        # Logging the error securely\\r\\n        log_error(e)\\r\\n\\r\\n# Secure SQL queries with prepared statements\\r\\ndef insert_image(conn, name, data):\\r\\n    sql = \"\"\"\\r\\n        INSERT INTO images (name, data)\\r\\n        VALUES (?, ?)\\r\\n    \"\"\"\\r\\n    try:\\r\\n        cursor = conn.cursor()\\r\\n        cursor.execute(sql, (name, data))\\r\\n        conn.commit()\\r\\n    except Error as e:\\r\\n        print(f\"Error inserting image: {e}\")\\r\\n        # Logging the error securely\\r\\n        log_error(e)\\r\\n\\r\\n# Secure error logging\\r\\ndef log_error(error):\\r\\n    log_file = \"error.log\"\\r\\n    try:\\r\\n        with open(log_file, \"a\") as f:\\r\\n            f.write(f\"{error}\\n\")\\r\\n    except Exception as e:\\r\\n        print(f\"Error logging error: {e}\")\\r\\n\\r\\n# Example usage\\r\\nif __name__ == \"__main__\":\\r\\n    image_path = \"example.jpg\"\\r\\n    upload_image(image_path)", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: The upload_image() function is called when the user uploads an image. The image is read and converted to base64. The image name and base64 string are inserted into the database.", "BP": ["Secure Database Connection", "Secure Table Creation", "Secure Salt Generation", "Secure Hashing", "Prepared Statements for SQL Queries", "Secure File Handling", "Error Handling and Logging"], "code": "import base64\\r\\nimport sqlite3\\r\\nimport hashlib\\r\\nimport os\\r\\nimport logging\\r\\nfrom werkzeug.utils import secure_filename\\r\\nfrom contextlib import closing\\r\\n\\r\\n# Configure logging\\r\\nlogging.basicConfig(filename='image_upload.log', level=logging.INFO,\\r\\n                    format='%(asctime)s:%(levelname)s:%(message)s')\\r\\n\\r\\n# Database configuration\\r\\nDATABASE = 'secure_image_upload.db'\\r\\n\\r\\n# Secure table creation\\r\\ndef create_table():\\r\\n    try:\\r\\n        with sqlite3.connect(DATABASE) as conn:\\r\\n            with closing(conn.cursor()) as cursor:\\r\\n                cursor.execute(\"\"\"\\r\\n                CREATE TABLE IF NOT EXISTS images (\\r\\n                    id INTEGER PRIMARY KEY,\\r\\n                    image_name TEXT NOT NULL,\\r\\n                    image_data BLOB NOT NULL,\\r\\n                    salt TEXT NOT NULL\\r\\n                )\\r\\n                \"\"\")\\r\\n                conn.commit()\\r\\n                logging.info('Table created successfully.')\\r\\n    except sqlite3.Error as e:\\r\\n        logging.error(f'Error creating table: {e}')\\r\\n\\r\\n# Function to generate a secure salt\\r\\ndef generate_salt():\\r\\n    return os.urandom(16)\\r\\n\\r\\n# Function to securely hash image data\\r\\ndef hash_image_data(image_data, salt):\\r\\n    hasher = hashlib.sha256()\\r\\n    hasher.update(salt + image_data)\\r\\n    return hasher.digest()\\r\\n\\r\\n# Function to handle image upload\\r\\ndef upload_image(image_path):\\r\\n    try:\\r\\n        # Secure file handling: ensure a valid and secure filename\\r\\n        filename = secure_filename(os.path.basename(image_path))\\r\\n        \\r\\n        # Read and encode image to base64\\r\\n        with open(image_path, 'rb') as image_file:\\r\\n            image_data = image_file.read()\\r\\n            image_b64 = base64.b64encode(image_data).decode('utf-8')\\r\\n        \\r\\n        # Generate salt and hash the image data\\r\\n        salt = generate_salt()\\r\\n        hashed_data = hash_image_data(image_data, salt)\\r\\n\\r\\n        # Insert into the database using prepared statements\\r\\n        with sqlite3.connect(DATABASE) as conn:\\r\\n            with closing(conn.cursor()) as cursor:\\r\\n                cursor.execute(\"\"\"\\r\\n                INSERT INTO images (image_name, image_data, salt) \\r\\n                VALUES (?, ?, ?)\\r\\n                \"\"\", (filename, hashed_data, salt))\\r\\n                conn.commit()\\r\\n                logging.info(f'Image {filename} uploaded and stored successfully.')\\r\\n    except (sqlite3.Error, IOError) as e:\\r\\n        logging.error(f'Error during image upload: {e}')\\r\\n        print(f'An error occurred: {e}')\\r\\n\\r\\n# Run table creation on script execution\\r\\nif __name__ == \"__main__\":\\r\\n    create_table()", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: The upload_image() function is called when the user uploads an image. The image is read and converted to base64. The image name and base64 string are inserted into the database.", "BP": ["Secure Database Connection", "Secure Table Creation", "Secure Salt Generation", "Secure Hashing", "Prepared Statements for SQL Queries", "Secure File Handling", "Error Handling and Logging"], "code": "import base64\\r\\nimport os\\r\\nimport sqlite3\\r\\nfrom sqlite3 import Error\\r\\nimport hashlib\\r\\nimport logging\\r\\nimport binascii\\r\\n\\r\\n# Configure logging\\r\\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\\r\\n\\r\\ndef create_connection(db_file):\\r\\n    \"\"\"Create a database connection to a SQLite database\"\"\"\\r\\n    conn = None\\r\\n    try:\\r\\n        conn = sqlite3.connect(db_file)\\r\\n        return conn\\r\\n    except Error as e:\\r\\n        logging.error(f\"Error connecting to database: {e}\")\\r\\n    return conn\\r\\n\\r\\ndef create_table(conn):\\r\\n    \"\"\"Create a table if it doesn't already exist\"\"\"\\r\\n    try:\\r\\n        c = conn.cursor()\\r\\n        c.execute('''CREATE TABLE IF NOT EXISTS images\\r\\n                     (id INTEGER PRIMARY KEY, name TEXT, image_data TEXT)''')\\r\\n    except Error as e:\\r\\n        logging.error(f\"Error creating table: {e}\")\\r\\n\\r\\ndef secure_salt_generation():\\r\\n    \"\"\"Generate a secure salt\"\"\"\\r\\n    return os.urandom(16)\\r\\n\\r\\ndef secure_hashing(data, salt):\\r\\n    \"\"\"Generate a secure hash for the given data using the provided salt\"\"\"\\r\\n    return hashlib.pbkdf2_hmac('sha256', data.encode(), salt, 100000)\\r\\n\\r\\ndef insert_image(conn, name, image_data):\\r\\n    \"\"\"Insert an image into the database securely\"\"\"\\r\\n    try:\\r\\n        c = conn.cursor()\\r\\n        # Securely generate salt and hash the image data\\r\\n        salt = secure_salt_generation()\\r\\n        hashed_image_data = secure_hashing(image_data, salt)\\r\\n        # Convert the hashed image data to a storable format\\r\\n        storable_image_data = binascii.hexlify(hashed_image_data).decode()\\r\\n        # Use a prepared statement to securely insert data\\r\\n        c.execute(\"INSERT INTO images (name, image_data) VALUES (?, ?)\", (name, storable_image_data))\\r\\n        conn.commit()\\r\\n    except Error as e:\\r\\n        logging.error(f\"Error inserting image into database: {e}\")\\r\\n\\r\\ndef read_and_convert_image_to_base64(image_path):\\r\\n    \"\"\"Read an image and convert it to base64\"\"\"\\r\\n    try:\\r\\n        with open(image_path, \"rb\") as image_file:\\r\\n            return base64.b64encode(image_file.read()).decode()\\r\\n    except IOError as e:\\r\\n        logging.error(f\"Error reading image file: {e}\")\\r\\n        return None\\r\\n\\r\\ndef upload_image(image_path, db_path):\\r\\n    \"\"\"Main function to handle the upload and storage of an image\"\"\"\\r\\n    # Read and convert the image to base64\\r\\n    image_data = read_and_convert_image_to_base64(image_path)\\r\\n    if image_data is None:\\r\\n        return\\r\\n    # Extract image name\\r\\n    image_name = os.path.basename(image_path)\\r\\n    # Connect to the database\\r\\n    conn = create_connection(db_path)\\r\\n    if conn is not None:\\r\\n        create_table(conn)\\r\\n        insert_image(conn, image_name, image_data)\\r\\n        logging.info(f\"Image '{image_name}' uploaded successfully.\")\\r\\n        conn.close()\\r\\n    else:\\r\\n        logging.error(\"Failed to connect to the database.\")\\r\\n\\r\\n# Example usage\\r\\nif __name__ == \"__main__\":\\r\\n    upload_image(\"path/to/your/image.jpg\", \"path/to/your/database.db\")", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: The upload_image() function is called when the user uploads an image. The image is read and encoded using base64. The encoded image is written to a file.", "BP": ["Allowed File Extensions", "Secure Filename", "Random Filename Generation", "Separate Upload and Encoded Directories", "Secure File Handling"], "code": "import os\\r\\nimport base64\\r\\nimport secrets\\r\\nfrom werkzeug.utils import secure_filename\\r\\n\\r\\n# Define allowed file extensions\\r\\nALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'gif'}\\r\\n\\r\\n# Define the upload directory\\r\\nUPLOAD_DIR = 'uploads'\\r\\n# Define the encoded directory\\r\\nENCODED_DIR = 'encoded'\\r\\n\\r\\n# Create the upload and encoded directories if they don't exist\\r\\nos.makedirs(UPLOAD_DIR, exist_ok=True)\\r\\nos.makedirs(ENCODED_DIR, exist_ok=True)\\r\\n\\r\\ndef allowed_file(filename):\\r\\n    \"\"\"\\r\\n    Check if the file extension is allowed.\\r\\n    \"\"\"\\r\\n    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\\r\\n\\r\\ndef upload_image(file):\\r\\n    \"\"\"\\r\\n    Upload an image file, encode it using base64, and save the encoded file.\\r\\n    \"\"\"\\r\\n    # Check if the file is allowed\\r\\n    if file and allowed_file(file.filename):\\r\\n        # Generate a random filename\\r\\n        random_filename = f\"{secrets.token_hex(16)}.{file.filename.rsplit('.', 1)[1].lower()}\"\\r\\n\\r\\n        # Save the original file to the upload directory\\r\\n        upload_path = os.path.join(UPLOAD_DIR, random_filename)\\r\\n        file.save(upload_path)\\r\\n\\r\\n        # Read the uploaded file\\r\\n        with open(upload_path, 'rb') as f:\\r\\n            file_data = f.read()\\r\\n\\r\\n        # Encode the file data using base64\\r\\n        encoded_data = base64.b64encode(file_data)\\r\\n\\r\\n        # Save the encoded file to the encoded directory\\r\\n        encoded_filename = f\"{secrets.token_hex(16)}.txt\"\\r\\n        encoded_path = os.path.join(ENCODED_DIR, encoded_filename)\\r\\n        with open(encoded_path, 'wb') as f:\\r\\n            f.write(encoded_data)\\r\\n\\r\\n        # Remove the original uploaded file\\r\\n        os.remove(upload_path)\\r\\n\\r\\n        return encoded_filename\\r\\n    else:\\r\\n        return None", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: The upload_image() function is called when the user uploads an image. The image is read and encoded using base64. The encoded image is written to a file.", "BP": ["Allowed File Extensions", "Secure Filename", "Random Filename Generation", "Separate Upload and Encoded Directories", "Secure File Handling"], "code": "from flask import Flask, request, redirect, url_for\\r\\nfrom werkzeug.utils import secure_filename\\r\\nimport os\\r\\nimport base64\\r\\nimport secrets\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Configuration\\r\\nUPLOAD_FOLDER = 'uploads'\\r\\nENCODED_FOLDER = 'encoded'\\r\\nALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'gif'}\\r\\n\\r\\n# Ensure directories exist\\r\\nos.makedirs(UPLOAD_FOLDER, exist_ok=True)\\r\\nos.makedirs(ENCODED_FOLDER, exist_ok=True)\\r\\n\\r\\napp.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER\\r\\napp.config['ENCODED_FOLDER'] = ENCODED_FOLDER\\r\\n\\r\\ndef allowed_file(filename):\\r\\n    \"\"\"Check if the file has an allowed extension.\"\"\"\\r\\n    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\\r\\n\\r\\ndef generate_random_filename(extension):\\r\\n    \"\"\"Generate a secure random filename.\"\"\"\\r\\n    return secrets.token_hex(16) + '.' + extension\\r\\n\\r\\ndef upload_image(file):\\r\\n    \"\"\"Handle image upload, encoding, and saving.\"\"\"\\r\\n    if file and allowed_file(file.filename):\\r\\n        # Secure the filename\\r\\n        filename = secure_filename(file.filename)\\r\\n        # Extract file extension\\r\\n        file_extension = filename.rsplit('.', 1)[1].lower()\\r\\n        # Generate a random filename\\r\\n        random_filename = generate_random_filename(file_extension)\\r\\n        # Define the full path for the upload\\r\\n        upload_path = os.path.join(app.config['UPLOAD_FOLDER'], random_filename)\\r\\n        \\r\\n        # Save the file to the upload directory\\r\\n        file.save(upload_path)\\r\\n        \\r\\n        # Read the file and encode it in base64\\r\\n        with open(upload_path, 'rb') as image_file:\\r\\n            encoded_string = base64.b64encode(image_file.read()).decode('utf-8')\\r\\n        \\r\\n        # Write the base64 encoded image to a new file\\r\\n        encoded_filename = random_filename.rsplit('.', 1)[0] + '.txt'\\r\\n        encoded_path = os.path.join(app.config['ENCODED_FOLDER'], encoded_filename)\\r\\n        \\r\\n        with open(encoded_path, 'w') as encoded_file:\\r\\n            encoded_file.write(encoded_string)\\r\\n        \\r\\n        return encoded_path\\r\\n\\r\\n@app.route('/upload', methods=['GET', 'POST'])\\r\\ndef upload_file():\\r\\n    if request.method == 'POST':\\r\\n        # Check if the post request has the file part\\r\\n        if 'file' not in request.files:\\r\\n            return 'No file part'\\r\\n        file = request.files['file']\\r\\n        # If user does not select file, browser also submit an empty part without filename\\r\\n        if file.filename == '':\\r\\n            return 'No selected file'\\r\\n        # Process the upload\\r\\n        encoded_file_path = upload_image(file)\\r\\n        return f'File successfully uploaded and encoded. Encoded file: {encoded_file_path}'\\r\\n    \\r\\n    return '''\\r\\n    <!doctype html>\\r\\n    <title>Upload new File</title>\\r\\n    <h1>Upload new File</h1>\\r\\n    <form method=post enctype=multipart/form-data>\\r\\n      <input type=file name=file>\\r\\n      <input type=submit value=Upload>\\r\\n    </form>\\r\\n    '''\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: The upload_image() function is called when the user uploads an image. The image is read and encoded using base64. The encoded image is written to a file.", "BP": ["Allowed File Extensions", "Secure Filename", "Random Filename Generation", "Separate Upload and Encoded Directories", "Secure File Handling"], "code": "import os\\r\\nimport base64\\r\\nfrom werkzeug.utils import secure_filename\\r\\nimport uuid\\r\\n\\r\\nALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'gif'}\\r\\n\\r\\ndef allowed_file(filename):\\r\\n    return '.' in filename and \\\\r\\n           filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\\r\\n\\r\\ndef generate_random_filename(extension):\\r\\n    return str(uuid.uuid4()) + '.' + extension\\r\\n\\r\\ndef upload_image(file, upload_dir='uploads', encoded_dir='encoded'):\\r\\n    if file and allowed_file(file.filename):\\r\\n        filename = secure_filename(file.filename)\\r\\n        random_filename = generate_random_filename(filename.rsplit('.', 1)[1])\\r\\n        upload_path = os.path.join(upload_dir, random_filename)\\r\\n        encoded_path = os.path.join(encoded_dir, random_filename + '.txt')\\r\\n\\r\\n        # Ensure directories exist\\r\\n        os.makedirs(upload_dir, exist_ok=True)\\r\\n        os.makedirs(encoded_dir, exist_ok=True)\\r\\n\\r\\n        # Save the uploaded file\\r\\n        file.save(upload_path)\\r\\n\\r\\n        # Read and encode the image\\r\\n        with open(upload_path, \"rb\") as image_file:\\r\\n            encoded_string = base64.b64encode(image_file.read()).decode()\\r\\n\\r\\n        # Write the encoded string to a separate file\\r\\n        with open(encoded_path, \"w\") as file:\\r\\n            file.write(encoded_string)\\r\\n\\r\\n        return True, \"File uploaded and encoded successfully.\"\\r\\n    else:\\r\\n        return False, \"File extension not allowed.\"", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: The code is a simple web application that accepts a file upload and saves it to the uploads directory. The file_is_safe_type function is a stub that always returns true.The upload_file function is the function that handles the file upload.", "BP": ["Allowed File Extensions", "File Type Validation", "Secure Filename", "Maximum File Size", "CSRF Protection", "Secure Headers", "Error Handling"], "code": "from flask import Flask, request, redirect, send_from_directory\\r\\nimport os\\r\\nimport magic\\r\\nfrom werkzeug.utils import secure_filename\\r\\nfrom werkzeug.middleware.proxy_fix import ProxyFix\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024  # 16 MB\\r\\napp.config['UPLOAD_FOLDER'] = 'uploads'\\r\\napp.wsgi_app = ProxyFix(app.wsgi_app)\\r\\n\\r\\n# Generate a secure CSRF token\\r\\n@app.before_request\\r\\ndef csrf_protect():\\r\\n    if request.method == \"POST\":\\r\\n        token = request.headers.get('X-CSRF-Token')\\r\\n        if not token or token != request.cookies.get('CSRF_TOKEN'):\\r\\n            return \"CSRF Token is missing or invalid\", 403\\r\\n\\r\\n# Set secure headers\\r\\n@app.after_request\\r\\ndef set_secure_headers(response):\\r\\n    response.headers['X-Frame-Options'] = 'DENY'\\r\\n    response.headers['X-Content-Type-Options'] = 'nosniff'\\r\\n    response.headers['X-XSS-Protection'] = '1; mode=block'\\r\\n    response.headers['Strict-Transport-Security'] = 'max-age=31536000; includeSubDomains'\\r\\n    response.headers['Content-Security-Policy'] = \"default-src 'self'\"\\r\\n    return response\\r\\n\\r\\n# Allowed file extensions\\r\\nALLOWED_EXTENSIONS = {'txt', 'pdf', 'png', 'jpg', 'jpeg', 'gif'}\\r\\n\\r\\ndef file_is_safe_type(file):\\r\\n    # Use the python-magic library to check the file type\\r\\n    file_type = magic.from_buffer(file.read(1024), mime=True)\\r\\n    file.seek(0)  # Reset the file pointer\\r\\n    return file_type in ['text/plain', 'application/pdf', 'image/png', 'image/jpeg', 'image/gif']\\r\\n\\r\\ndef upload_file():\\r\\n    if 'file' not in request.files:\\r\\n        return \"No file uploaded\", 400\\r\\n\\r\\n    file = request.files['file']\\r\\n\\r\\n    if file.filename == '':\\r\\n        return \"No file selected\", 400\\r\\n\\r\\n    # Check if the file extension is allowed\\r\\n    file_ext = os.path.splitext(file.filename)[1][1:].lower()\\r\\n    if file_ext not in ALLOWED_EXTENSIONS:\\r\\n        return \"File extension not allowed\", 400\\r\\n\\r\\n    # Check if the file type is safe\\r\\n    if not file_is_safe_type(file):\\r\\n        return \"File type not allowed\", 400\\r\\n\\r\\n    # Secure the filename\\r\\n    filename = secure_filename(file.filename)\\r\\n\\r\\n    # Save the file\\r\\n    file_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)\\r\\n    file.save(file_path)\\r\\n\\r\\n    return redirect('/uploads/' + filename)\\r\\n\\r\\n@app.route('/uploads/<filename>')\\r\\ndef uploaded_file(filename):\\r\\n    return send_from_directory(app.config['UPLOAD_FOLDER'], filename)\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)\\r\\n    app.secret_key = os.urandom(24)  # Generate a random secret key\\r\\n    app.run(debug=False, host='0.0.0.0')", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: The code is a simple web application that accepts a file upload and saves it to the uploads directory. The file_is_safe_type function is a stub that always returns true.The upload_file function is the function that handles the file upload.", "BP": ["Allowed File Extensions", "File Type Validation", "Secure Filename", "Maximum File Size", "CSRF Protection", "Secure Headers", "Error Handling"], "code": "from flask import Flask, request, render_template, redirect, url_for, flash\\r\\nfrom werkzeug.utils import secure_filename\\r\\nimport os\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Configuration settings\\r\\nUPLOAD_FOLDER = 'uploads'\\r\\nALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'gif'}\\r\\nMAX_CONTENT_LENGTH = 16 * 1024 * 1024  # 16 MB max file size\\r\\nSECRET_KEY = 'your_secret_key'  # Replace with your actual secret key\\r\\n\\r\\napp.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER\\r\\napp.config['MAX_CONTENT_LENGTH'] = MAX_CONTENT_LENGTH\\r\\napp.config['SECRET_KEY'] = SECRET_KEY\\r\\n\\r\\n# Ensure the upload directory exists\\r\\nif not os.path.exists(UPLOAD_FOLDER):\\r\\n    os.makedirs(UPLOAD_FOLDER)\\r\\n\\r\\n# Function to check allowed file extensions\\r\\ndef allowed_file(filename):\\r\\n    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\\r\\n\\r\\n# Stub function to validate file type\\r\\ndef file_is_safe_type(file):\\r\\n    # Implement actual file type checking here\\r\\n    return True\\r\\n\\r\\n@app.route('/')\\r\\ndef index():\\r\\n    return render_template('index.html')\\r\\n\\r\\n@app.route('/upload', methods=['GET', 'POST'])\\r\\ndef upload_file():\\r\\n    if request.method == 'POST':\\r\\n        # Check if the post request has the file part\\r\\n        if 'file' not in request.files:\\r\\n            flash('No file part')\\r\\n            return redirect(request.url)\\r\\n\\r\\n        file = request.files['file']\\r\\n\\r\\n        # If user does not select a file, browser also\\r\\n        # submits an empty part without filename\\r\\n        if file.filename == '':\\r\\n            flash('No selected file')\\r\\n            return redirect(request.url)\\r\\n\\r\\n        if file and allowed_file(file.filename):\\r\\n            if file_is_safe_type(file):\\r\\n                filename = secure_filename(file.filename)\\r\\n                file_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)\\r\\n                \\r\\n                try:\\r\\n                    file.save(file_path)\\r\\n                    flash('File successfully uploaded')\\r\\n                    return redirect(url_for('index'))\\r\\n                except Exception as e:\\r\\n                    flash(f'An error occurred while saving the file: {e}')\\r\\n                    return redirect(request.url)\\r\\n            else:\\r\\n                flash('File type is not allowed')\\r\\n                return redirect(request.url)\\r\\n        else:\\r\\n            flash('File extension is not allowed')\\r\\n            return redirect(request.url)\\r\\n    return render_template('upload.html')\\r\\n\\r\\n@app.errorhandler(413)\\r\\ndef request_entity_too_large(error):\\r\\n    flash('File is too large')\\r\\n    return redirect(request.url), 413\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: The code is a simple web application that accepts a file upload and saves it to the uploads directory. The file_is_safe_type function is a stub that always returns true.The upload_file function is the function that handles the file upload.", "BP": ["Allowed File Extensions", "File Type Validation", "Secure Filename", "Maximum File Size", "CSRF Protection", "Secure Headers", "Error Handling"], "code": "from flask import Flask, request, redirect, url_for, flash, send_from_directory\\r\\nfrom werkzeug.utils import secure_filename\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import FileField, SubmitField\\r\\nfrom flask_wtf.file import FileAllowed, FileRequired\\r\\nfrom flask_talisman import Talisman\\r\\nimport os\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['SECRET_KEY'] = 'your_secret_key'\\r\\napp.config['UPLOAD_FOLDER'] = 'uploads'\\r\\napp.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024  # 16MB limit\\r\\nALLOWED_EXTENSIONS = {'txt', 'pdf', 'png', 'jpg', 'jpeg', 'gif'}\\r\\n\\r\\nTalisman(app)  # Enable HTTPS and secure headers\\r\\n\\r\\ndef file_is_safe_type(file):\\r\\n    # Stub function for file type validation\\r\\n    return True\\r\\n\\r\\nclass UploadForm(FlaskForm):\\r\\n    file = FileField('File', validators=[\\r\\n        FileRequired(),\\r\\n        FileAllowed(ALLOWED_EXTENSIONS, 'Invalid file extension!')\\r\\n    ])\\r\\n    submit = SubmitField('Upload')\\r\\n\\r\\n@app.route('/', methods=['GET', 'POST'])\\r\\ndef upload_file():\\r\\n    form = UploadForm()\\r\\n    if form.validate_on_submit():\\r\\n        file = form.file.data\\r\\n        if file and file_is_safe_type(file):\\r\\n            filename = secure_filename(file.filename)\\r\\n            file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename))\\r\\n            return redirect(url_for('uploaded_file', filename=filename))\\r\\n        else:\\r\\n            flash('File type is not allowed.')\\r\\n    return '''\\r\\n    <!doctype html>\\r\\n    <title>Upload new File</title>\\r\\n    <h1>Upload new File</h1>\\r\\n    <form method=post enctype=multipart/form-data>\\r\\n      ''' + form.csrf_token + '''\\r\\n      <input type=file name=file>\\r\\n      <input type=submit value=Upload>\\r\\n    </form>\\r\\n    '''\\r\\n\\r\\n@app.route('/uploads/<filename>')\\r\\ndef uploaded_file(filename):\\r\\n    return send_from_directory(app.config['UPLOAD_FOLDER'], filename)\\r\\n\\r\\n@app.errorhandler(413)\\r\\ndef error_413(e):\\r\\n    return \"File is too large.\", 413\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: The code is a simple web application that allows users to upload files to the server.", "BP": ["File Size Limit", "Allowed File Extensions", "File Extension Checking", "Filename Sanitization", "Error Handling", "Input Validation", "Secure File Storage", "Rate-limiting", "Logging and Monitoring"], "code": "import os\\r\\nimport re\\r\\nfrom pathlib import Path\\r\\nfrom flask import Flask, request, redirect, url_for, render_template\\r\\nfrom werkzeug.utils import secure_filename\\r\\nfrom werkzeug.middleware.proxy_fix import ProxyFix\\r\\nfrom ratelimit import limits, sleep_and_retry\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.wsgi_app = ProxyFix(app.wsgi_app, x_prefix=1)\\r\\n\\r\\n# Set the maximum file size (e.g., 10MB)\\r\\nMAX_FILE_SIZE = 10 * 1024 * 1024\\r\\n\\r\\n# Set the allowed file extensions\\r\\nALLOWED_EXTENSIONS = {'txt', 'pdf', 'png', 'jpg', 'jpeg', 'gif'}\\r\\n\\r\\n# Set the upload directory\\r\\nUPLOAD_DIRECTORY = Path('uploads')\\r\\nUPLOAD_DIRECTORY.mkdir(exist_ok=True)\\r\\n\\r\\n# Rate-limiting configuration\\r\\nRATELIMIT_STORAGE_URL = 'redis://localhost:6379'\\r\\nRATELIMIT_STRATEGY = 'moving-window'\\r\\nRATELIMIT_WINDOW = 60  # 1 minute\\r\\nRATELIMIT_LIMIT = 10  # Maximum of 10 uploads per minute\\r\\n\\r\\n# Logging configuration\\r\\nimport logging\\r\\nlogging.basicConfig(filename='app.log', level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\\r\\n\\r\\n# File extension pattern for validation\\r\\nEXTENSION_PATTERN = r'^.*\\.(txt|pdf|png|jpg|jpeg|gif)$'\\r\\n\\r\\n# Filename sanitization pattern\\r\\nFILENAME_PATTERN = r'^[\\w\\-\\. ]+$'\\r\\n\\r\\n@app.route('/', methods=['GET', 'POST'])\\r\\n@sleep_and_retry\\r\\n@limits(calls=RATELIMIT_LIMIT, period=RATELIMIT_WINDOW, storage_url=RATELIMIT_STORAGE_URL, strategy=RATELIMIT_STRATEGY)\\r\\ndef upload_file():\\r\\n    if request.method == 'POST':\\r\\n        # Check if the file was properly uploaded\\r\\n        if 'file' not in request.files:\\r\\n            logging.error('No file part')\\r\\n            return redirect(request.url)\\r\\n\\r\\n        file = request.files['file']\\r\\n\\r\\n        # If the user did not select a file, redirect to the same page\\r\\n        if file.filename == '':\\r\\n            logging.error('No file selected')\\r\\n            return redirect(request.url)\\r\\n\\r\\n        # Validate file extension\\r\\n        if not re.match(EXTENSION_PATTERN, file.filename, re.IGNORECASE):\\r\\n            logging.error(f'Invalid file extension: {file.filename}')\\r\\n            return 'Invalid file extension', 400\\r\\n\\r\\n        # Sanitize the filename\\r\\n        if not re.match(FILENAME_PATTERN, file.filename):\\r\\n            logging.error(f'Invalid filename: {file.filename}')\\r\\n            return 'Invalid filename', 400\\r\\n\\r\\n        # Check file size\\r\\n        if file.content_length > MAX_FILE_SIZE:\\r\\n            logging.error(f'File too large: {file.filename} ({file.content_length} bytes)')\\r\\n            return 'File too large', 413\\r\\n\\r\\n        # Save the file securely\\r\\n        filename = secure_filename(file.filename)\\r\\n        file_path = UPLOAD_DIRECTORY / filename\\r\\n        file.save(file_path)\\r\\n        logging.info(f'File saved: {file_path}')\\r\\n\\r\\n        return f'File uploaded successfully: {filename}'\\r\\n\\r\\n    return render_template('upload.html')\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(host='0.0.0.0', port=5000)", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: The code is a simple web application that allows users to upload files to the server.", "BP": ["File Size Limit", "Allowed File Extensions", "File Extension Checking", "Filename Sanitization", "Error Handling", "Input Validation", "Secure File Storage", "Rate-limiting", "Logging and Monitoring"], "code": "# app.py\\r\\nimport os\\r\\nimport re\\r\\nimport logging\\r\\nfrom flask import Flask, request, render_template, redirect, url_for, flash\\r\\nfrom werkzeug.utils import secure_filename\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\n\\r\\n# Configuration\\r\\nUPLOAD_FOLDER = 'uploads'\\r\\nALLOWED_EXTENSIONS = {'txt', 'pdf', 'png', 'jpg', 'jpeg', 'gif'}\\r\\nMAX_CONTENT_LENGTH = 16 * 1024 * 1024  # 16 MB\\r\\n\\r\\n# Ensure the upload folder exists\\r\\nos.makedirs(UPLOAD_FOLDER, exist_ok=True)\\r\\nos.makedirs('logs', exist_ok=True)\\r\\n\\r\\n# Initialize the Flask app\\r\\napp = Flask(__name__)\\r\\napp.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER\\r\\napp.config['MAX_CONTENT_LENGTH'] = MAX_CONTENT_LENGTH\\r\\napp.secret_key = 'your_secret_key'\\r\\n\\r\\n# Set up rate limiting\\r\\nlimiter = Limiter(\\r\\n    app,\\r\\n    key_func=get_remote_address,\\r\\n    default_limits=[\"5 per minute\"]\\r\\n)\\r\\n\\r\\n# Configure logging\\r\\nlogging.basicConfig(filename='logs/app.log', level=logging.INFO,\\r\\n                    format='%(asctime)s %(levelname)s %(message)s')\\r\\n\\r\\ndef allowed_file(filename):\\r\\n    return '.' in filename and \\\\r\\n           filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\\r\\n\\r\\n@app.route('/')\\r\\ndef index():\\r\\n    return render_template('index.html')\\r\\n\\r\\n@app.route('/upload', methods=['POST'])\\r\\n@limiter.limit(\"5 per minute\")  # Apply rate limiting to this route\\r\\ndef upload_file():\\r\\n    if 'file' not in request.files:\\r\\n        flash('No file part')\\r\\n        return redirect(request.url)\\r\\n\\r\\n    file = request.files['file']\\r\\n    \\r\\n    if file.filename == '':\\r\\n        flash('No selected file')\\r\\n        return redirect(request.url)\\r\\n\\r\\n    if file and allowed_file(file.filename):\\r\\n        filename = secure_filename(file.filename)\\r\\n\\r\\n        # Sanitize filename to prevent directory traversal attacks\\r\\n        filename = re.sub(r'[^a-zA-Z0-9_.-]', '_', filename)\\r\\n\\r\\n        file_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)\\r\\n        file.save(file_path)\\r\\n\\r\\n        # Logging the upload\\r\\n        logging.info(f\"File uploaded: {file_path}\")\\r\\n\\r\\n        flash('File successfully uploaded')\\r\\n        return redirect(url_for('index'))\\r\\n    else:\\r\\n        flash('File type not allowed or file too large')\\r\\n        return redirect(request.url)\\r\\n\\r\\n# Error handling\\r\\n@app.errorhandler(413)\\r\\ndef request_entity_too_large(error):\\r\\n    flash('File is too large')\\r\\n    return redirect(request.url)\\r\\n\\r\\n@app.errorhandler(429)\\r\\ndef too_many_requests(error):\\r\\n    flash('Too many requests, please try again later')\\r\\n    return redirect(request.url)\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: The code is a simple web application that allows users to upload files to the server.", "BP": ["File Size Limit", "Allowed File Extensions", "File Extension Checking", "Filename Sanitization", "Error Handling", "Input Validation", "Secure File Storage", "Rate-limiting", "Logging and Monitoring"], "code": "from flask import Flask, request, redirect, url_for, flash, abort\\r\\nfrom werkzeug.utils import secure_filename\\r\\nimport os\\r\\nimport logging\\r\\nfrom logging.handlers import RotatingFileHandler\\r\\nfrom functools import wraps\\r\\nimport time\\r\\n\\r\\n# Configuration\\r\\nUPLOAD_FOLDER = '/path/to/the/uploads'\\r\\nALLOWED_EXTENSIONS = {'txt', 'pdf', 'png', 'jpg', 'jpeg', 'gif'}\\r\\nMAX_FILE_SIZE = 1024 * 1024 * 2  # 2MB\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER\\r\\napp.config['MAX_CONTENT_LENGTH'] = MAX_FILE_SIZE\\r\\n\\r\\n# Setup logging\\r\\nhandler = RotatingFileHandler('app.log', maxBytes=10000, backupCount=1)\\r\\nhandler.setLevel(logging.INFO)\\r\\napp.logger.addHandler(handler)\\r\\n\\r\\ndef allowed_file(filename):\\r\\n    return '.' in filename and \\\\r\\n           filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\\r\\n\\r\\ndef rate_limit(max_per_second):\\r\\n    min_interval = 1.0 / float(max_per_second)\\r\\n    def decorate(func):\\r\\n        last_called = [0.0]\\r\\n        @wraps(func)\\r\\n        def rate_limited_function(*args, **kwargs):\\r\\n            elapsed = time.clock() - last_called[0]\\r\\n            left_to_wait = min_interval - elapsed\\r\\n            if left_to_wait > 0:\\r\\n                time.sleep(left_to_wait)\\r\\n            last_called[0] = time.clock()\\r\\n            return func(*args, **kwargs)\\r\\n        return rate_limited_function\\r\\n    return decorate\\r\\n\\r\\n@app.route('/upload', methods=['POST'])\\r\\n@rate_limit(5)  # Limit to 5 requests per second\\r\\ndef upload_file():\\r\\n    if 'file' not in request.files:\\r\\n        flash('No file part')\\r\\n        return redirect(request.url)\\r\\n    file = request.files['file']\\r\\n    if file.filename == '':\\r\\n        flash('No selected file')\\r\\n        return redirect(request.url)\\r\\n    if file and allowed_file(file.filename):\\r\\n        filename = secure_filename(file.filename)\\r\\n        try:\\r\\n            file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename))\\r\\n            app.logger.info(f\"File uploaded: {filename}\")\\r\\n            return redirect(url_for('uploaded_file', filename=filename))\\r\\n        except Exception as e:\\r\\n            app.logger.error(f\"Error saving file: {str(e)}\")\\r\\n            abort(500)\\r\\n    else:\\r\\n        flash('File type not allowed')\\r\\n        return redirect(request.url)\\r\\n\\r\\n@app.route('/uploads/<filename>')\\r\\ndef uploaded_file(filename):\\r\\n    # Implement secure file retrieval\\r\\n    return send_from_directory(app.config['UPLOAD_FOLDER'], filename)\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: The file_is_safe_type function is a function that checks if the file is safe to upload. The upload_file function is the function that handles the upload of the file. The p.save(os.path.join('uploads' filename)) line saves the file to the uploads folder. The uploads folder is created in the same directory as the source file.", "BP": ["Allowed File Extensions", "File Extension Validation", "File Size Validation", "Malicious Content Detection", "Secure Filename Generation", "File Pointer Reset"], "code": "import os\\r\\nimport magic\\r\\nimport re\\r\\nfrom werkzeug.utils import secure_filename\\r\\n\\r\\n# Maximum file size allowed (in bytes)\\r\\nMAX_FILE_SIZE = 5 * 1024 * 1024  # 5 MB\\r\\n\\r\\n# Allowed file extensions\\r\\nALLOWED_EXTENSIONS = ['pdf', 'doc', 'docx', 'txt', 'jpg', 'jpeg', 'png', 'gif']\\r\\n\\r\\n# Regular expression pattern for detecting malicious content\\r\\nMALICIOUS_PATTERN = r'<\\s*script'\\r\\n\\r\\n# Upload directory\\r\\nUPLOAD_DIR = 'uploads'\\r\\n\\r\\ndef file_is_safe_type(file):\\r\\n    \"\"\"\\r\\n    Checks if the file is safe for upload based on file extension, size, and content.\\r\\n    \"\"\"\\r\\n    # Check file extension\\r\\n    file_ext = os.path.splitext(file.filename)[1][1:].lower()\\r\\n    if file_ext not in ALLOWED_EXTENSIONS:\\r\\n        return False\\r\\n\\r\\n    # Check file size\\r\\n    if file.content_length > MAX_FILE_SIZE:\\r\\n        return False\\r\\n\\r\\n    # Check for malicious content\\r\\n    file.seek(0)  # Reset file pointer\\r\\n    file_content = file.read()\\r\\n    if re.search(MALICIOUS_PATTERN, file_content.decode('utf-8', 'ignore')):\\r\\n        return False\\r\\n\\r\\n    return True\\r\\n\\r\\ndef upload_file(file):\\r\\n    \"\"\"\\r\\n    Uploads the file securely to the uploads directory.\\r\\n    \"\"\"\\r\\n    if file_is_safe_type(file):\\r\\n        # Generate a secure filename\\r\\n        filename = secure_filename(file.filename)\\r\\n\\r\\n        # Create the uploads directory if it doesn't exist\\r\\n        os.makedirs(UPLOAD_DIR, exist_ok=True)\\r\\n\\r\\n        # Save the file to the uploads directory\\r\\n        file_path = os.path.join(UPLOAD_DIR, filename)\\r\\n        file.seek(0)  # Reset file pointer\\r\\n        file.save(file_path)\\r\\n\\r\\n        return True\\r\\n    else:\\r\\n        return False", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: The file_is_safe_type function is a function that checks if the file is safe to upload. The upload_file function is the function that handles the upload of the file. The p.save(os.path.join('uploads' filename)) line saves the file to the uploads folder. The uploads folder is created in the same directory as the source file.", "BP": ["Allowed File Extensions", "File Extension Validation", "File Size Validation", "Malicious Content Detection", "Secure Filename Generation", "File Pointer Reset"], "code": "import os\\r\\nimport werkzeug.utils\\r\\nimport pyclamd\\r\\nfrom flask import Flask, request, flash\\r\\nfrom werkzeug.utils import secure_filename\\r\\n\\r\\n# Define allowed extensions and maximum file size (e.g., 2MB)\\r\\nALLOWED_EXTENSIONS = {'txt', 'pdf', 'png', 'jpg', 'jpeg', 'gif'}\\r\\nMAX_FILE_SIZE = 2 * 1024 * 1024  # 2MB\\r\\n\\r\\n# Create an uploads directory if it doesn't exist\\r\\nUPLOAD_FOLDER = 'uploads'\\r\\nif not os.path.exists(UPLOAD_FOLDER):\\r\\n    os.makedirs(UPLOAD_FOLDER)\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER\\r\\napp.config['MAX_CONTENT_LENGTH'] = MAX_FILE_SIZE\\r\\n\\r\\n# Function to check if the file has an allowed extension\\r\\ndef allowed_file(filename):\\r\\n    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\\r\\n\\r\\n# Function to detect malicious content using ClamAV\\r\\ndef detect_malware(filepath):\\r\\n    try:\\r\\n        cd = pyclamd.ClamdAgnostic()\\r\\n        if cd.ping():\\r\\n            scan_result = cd.scan_file(filepath)\\r\\n            if scan_result:\\r\\n                return True  # Malware detected\\r\\n        return False\\r\\n    except pyclamd.ConnectionError:\\r\\n        print(\"Error: Unable to connect to ClamAV daemon.\")\\r\\n        return False\\r\\n\\r\\n# Function to handle file uploads\\r\\n@app.route('/upload', methods=['POST'])\\r\\ndef upload_file():\\r\\n    if 'file' not in request.files:\\r\\n        flash('No file part')\\r\\n        return \"No file part\"\\r\\n\\r\\n    file = request.files['file']\\r\\n\\r\\n    # If no file is selected\\r\\n    if file.filename == '':\\r\\n        flash('No selected file')\\r\\n        return \"No selected file\"\\r\\n\\r\\n    # Check if file is allowed\\r\\n    if file and allowed_file(file.filename):\\r\\n        # Secure the filename\\r\\n        filename = secure_filename(file.filename)\\r\\n\\r\\n        # Save the file temporarily to scan for malware\\r\\n        temp_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)\\r\\n        file.save(temp_path)\\r\\n\\r\\n        # Check for malware\\r\\n        if detect_malware(temp_path):\\r\\n            os.remove(temp_path)\\r\\n            return \"Malicious file detected!\"\\r\\n\\r\\n        # Check the file size\\r\\n        file.seek(0, os.SEEK_END)\\r\\n        file_size = file.tell()\\r\\n        file.seek(0)  # Reset the file pointer\\r\\n\\r\\n        if file_size > MAX_FILE_SIZE:\\r\\n            os.remove(temp_path)\\r\\n            return \"File size exceeds limit!\"\\r\\n\\r\\n        # Move the file to the permanent location\\r\\n        final_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)\\r\\n        os.rename(temp_path, final_path)\\r\\n\\r\\n        return f\"File {filename} uploaded successfully!\"\\r\\n\\r\\n    return \"File type not allowed!\"\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: The file_is_safe_type function is a function that checks if the file is safe to upload. The upload_file function is the function that handles the upload of the file. The p.save(os.path.join('uploads' filename)) line saves the file to the uploads folder. The uploads folder is created in the same directory as the source file.", "BP": ["Allowed File Extensions", "File Extension Validation", "File Size Validation", "Malicious Content Detection", "Secure Filename Generation", "File Pointer Reset"], "code": "import os\\r\\nfrom werkzeug.utils import secure_filename\\r\\n\\r\\nALLOWED_EXTENSIONS = {'txt', 'pdf', 'png', 'jpg', 'jpeg', 'gif'}\\r\\nMAX_FILE_SIZE = 1024 * 1024 * 5  # 5MB\\r\\n\\r\\ndef allowed_file(filename):\\r\\n    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\\r\\n\\r\\ndef file_is_safe_type(file_path):\\r\\n    # Implement file type validation (e.g., using MIME types or file extensions)\\r\\n    return allowed_file(file_path)\\r\\n\\r\\ndef reset_file_pointer(p):\\r\\n    p.seek(0)\\r\\n\\r\\ndef check_file_size(p):\\r\\n    p.seek(0, os.SEEK_END)\\r\\n    file_size = p.tell()\\r\\n    reset_file_pointer(p)\\r\\n    return file_size <= MAX_FILE_SIZE\\r\\n\\r\\ndef detect_malicious_content(p):\\r\\n    # Implement malicious content detection (placeholder)\\r\\n    # This should ideally be a more sophisticated check\\r\\n    reset_file_pointer(p)\\r\\n    content = p.read()\\r\\n    reset_file_pointer(p)\\r\\n    return \"malicious\" not in content\\r\\n\\r\\ndef upload_file(p, filename):\\r\\n    if not os.path.exists('uploads'):\\r\\n        os.makedirs('uploads')\\r\\n    \\r\\n    if not file_is_safe_type(filename):\\r\\n        return \"File type is not allowed.\"\\r\\n    \\r\\n    if not check_file_size(p):\\r\\n        return \"File size exceeds the maximum allowed limit.\"\\r\\n    \\r\\n    if not detect_malicious_content(p):\\r\\n        return \"File contains malicious content.\"\\r\\n    \\r\\n    secure_name = secure_filename(filename)\\r\\n    p.save(os.path.join('uploads', secure_name))\\r\\n    return f\"File {secure_name} uploaded successfully.\"", "CWE": "CWE-434"}
{"text": "Generate Python code for the following: Memory allocation method allocates a block of memory of size sizeof(person) and returns a pointer to the beginning of that block. The -> operator is used to access members of a struct through a pointer.", "BP": ["Memory Allocation", "Memory Deallocation", "Struct Representation", "Proper Initialization", "Import ctypes"], "code": "import ctypes\\r\\n\\r\\n# Define a struct to represent a person\\r\\nclass Person(ctypes.Structure):\\r\\n    _fields_ = [\\r\\n        (\"name\", ctypes.c_char_p),\\r\\n        (\"age\", ctypes.c_int),\\r\\n        (\"height\", ctypes.c_float)\\r\\n    ]\\r\\n\\r\\ndef allocate_person():\\r\\n    # Allocate memory for a Person struct\\r\\n    person_ptr = ctypes.pointer(Person())\\r\\n    \\r\\n    # Initialize the struct members\\r\\n    person_ptr.contents.name = ctypes.c_char_p(b\"John Doe\")\\r\\n    person_ptr.contents.age = 30\\r\\n    person_ptr.contents.height = 1.75\\r\\n    \\r\\n    return person_ptr\\r\\n\\r\\ndef deallocate_person(person_ptr):\\r\\n    # Deallocate memory for the Person struct\\r\\n    ctypes.pointer(person_ptr.contents.name).value = None\\r\\n    ctypes.pointer(Person.from_address(ctypes.addressof(person_ptr.contents))).contents = None\\r\\n\\r\\n# Example usage\\r\\nperson = allocate_person()\\r\\nprint(f\"Name: {person.contents.name.decode()}\")  # Name: John Doe\\r\\nprint(f\"Age: {person.contents.age}\")  # Age: 30\\r\\nprint(f\"Height: {person.contents.height}\")  # Height: 1.75\\r\\n\\r\\ndeallocate_person(person)", "CWE": "CWE-476"}
{"text": "Generate Python code for the following: Memory allocation method allocates a block of memory of size sizeof(person) and returns a pointer to the beginning of that block. The -> operator is used to access members of a struct through a pointer.", "BP": ["Memory Allocation", "Memory Deallocation", "Struct Representation", "Proper Initialization", "Import ctypes"], "code": "import ctypes\\r\\n\\r\\n# Define the Person struct\\r\\nclass Person(ctypes.Structure):\\r\\n    _fields_ = [(\"name\", ctypes.c_char_p),\\r\\n                (\"age\", ctypes.c_int)]\\r\\n\\r\\n# Memory allocation function\\r\\ndef allocate_person():\\r\\n    # Allocate memory for a Person instance\\r\\n    person_ptr = ctypes.pointer(Person())\\r\\n    return person_ptr\\r\\n\\r\\n# Memory deallocation function\\r\\ndef deallocate_person(person_ptr):\\r\\n    # Deallocate memory for the Person instance\\r\\n    # In ctypes, simply deleting the pointer will deallocate the memory\\r\\n    del person_ptr\\r\\n\\r\\n# Initialize the Person struct\\r\\ndef initialize_person(person_ptr, name, age):\\r\\n    person_ptr.contents.name = ctypes.create_string_buffer(name.encode('utf-8'))\\r\\n    person_ptr.contents.age = age\\r\\n\\r\\n# Usage example\\r\\nif __name__ == \"__main__\":\\r\\n    # Allocate memory for a Person instance\\r\\n    person = allocate_person()\\r\\n    \\r\\n    # Initialize the Person instance\\r\\n    initialize_person(person, \"John Doe\", 30)\\r\\n    \\r\\n    # Access the members of the struct\\r\\n    print(f\"Name: {person.contents.name.decode('utf-8')}\")\\r\\n    print(f\"Age: {person.contents.age}\")\\r\\n    \\r\\n    # Deallocate memory\\r\\n    deallocate_person(person)", "CWE": "CWE-476"}
{"text": "Generate Python code for the following: Memory allocation method allocates a block of memory of size sizeof(person) and returns a pointer to the beginning of that block. The -> operator is used to access members of a struct through a pointer.", "BP": ["Memory Allocation", "Memory Deallocation", "Struct Representation", "Proper Initialization", "Import ctypes"], "code": "import ctypes\\r\\n\\r\\n# Define a struct representation for 'person'\\r\\nclass Person(ctypes.Structure):\\r\\n    _fields_ = [(\"name\", ctypes.c_char_p),\\r\\n                (\"age\", ctypes.c_int)]\\r\\n\\r\\n# Memory allocation method\\r\\ndef allocate_person():\\r\\n    # Allocate a block of memory of size sizeof(Person)\\r\\n    person_ptr = ctypes.cast(ctypes.create_string_buffer(ctypes.sizeof(Person)), ctypes.POINTER(Person))\\r\\n    return person_ptr\\r\\n\\r\\n# Proper initialization of a person instance\\r\\ndef initialize_person(person_ptr, name, age):\\r\\n    # Using the -> operator equivalent in Python to access and set members of the struct through a pointer\\r\\n    person_ptr.contents.name = name.encode('utf-8')  # Encoding string to bytes\\r\\n    person_ptr.contents.age = age\\r\\n\\r\\n# Memory deallocation method\\r\\ndef deallocate_person(person_ptr):\\r\\n    # In Python, ctypes automatically manages memory deallocation for objects created via ctypes\\r\\n    # However, if you were manually managing memory (e.g., using malloc from libc), you would use ctypes to call free\\r\\n    pass  # Placeholder to indicate where deallocation code would go if needed\\r\\n\\r\\n# Example usage\\r\\nif __name__ == \"__main__\":\\r\\n    person_ptr = allocate_person()\\r\\n    initialize_person(person_ptr, \"John Doe\", 30)\\r\\n    print(f\"Name: {person_ptr.contents.name.decode('utf-8')}, Age: {person_ptr.contents.age}\")\\r\\n    deallocate_person(person_ptr)", "CWE": "CWE-476"}
{"text": "Generate Python code for the following: Memory allocation method allocates a block of memory of size sizeof(person) and returns a pointer to the beginning of the block. The cast (person *) is not necessary but it is good practice to include it. The -> operator is used to access the fields of a struct through a pointer. The code allocates a new person and sets the status field to 0.", "BP": ["Memory Allocation", "Memory Deallocation", "Data Handling", "Error Handling", "Import ctypes"], "code": "import os\\r\\nimport ctypes\\r\\n\\r\\n# Define a Person struct\\r\\nclass Person(ctypes.Structure):\\r\\n    _fields_ = [(\"name\", ctypes.c_char_p),\\r\\n                (\"age\", ctypes.c_int),\\r\\n                (\"status\", ctypes.c_int)]\\r\\n\\r\\n# Securely allocate memory for a Person object\\r\\ndef allocate_person():\\r\\n    try:\\r\\n        # Allocate memory for a Person object\\r\\n        person_ptr = ctypes.pointer(Person())\\r\\n\\r\\n        # Initialize fields\\r\\n        person_ptr.contents.name = ctypes.create_string_buffer(b\"John Doe\")\\r\\n        person_ptr.contents.age = 30\\r\\n        person_ptr.contents.status = 0\\r\\n\\r\\n        return person_ptr\\r\\n    except (ValueError, MemoryError) as e:\\r\\n        print(f\"Error allocating memory: {e}\")\\r\\n        return None\\r\\n\\r\\n# Securely deallocate memory for a Person object\\r\\ndef deallocate_person(person_ptr):\\r\\n    if person_ptr:\\r\\n        try:\\r\\n            # Securely clear the allocated memory\\r\\n            ctypes.memset(person_ptr, 0, ctypes.sizeof(Person))\\r\\n\\r\\n            # Deallocate the memory\\r\\n            ctypes.pointer(person_ptr)[0] = None\\r\\n        except (ValueError, MemoryError) as e:\\r\\n            print(f\"Error deallocating memory: {e}\")\\r\\n\\r\\n# Securely handle Person data\\r\\ndef handle_person_data(person_ptr):\\r\\n    if person_ptr:\\r\\n        try:\\r\\n            name = person_ptr.contents.name.decode()\\r\\n            age = person_ptr.contents.age\\r\\n            status = person_ptr.contents.status\\r\\n\\r\\n            # Handle the data securely\\r\\n            print(f\"Name: {name}, Age: {age}, Status: {status}\")\\r\\n        except (ValueError, UnicodeDecodeError) as e:\\r\\n            print(f\"Error handling data: {e}\")\\r\\n\\r\\n# Example usage\\r\\nperson_ptr = allocate_person()\\r\\nhandle_person_data(person_ptr)\\r\\ndeallocate_person(person_ptr)", "CWE": "CWE-476"}
{"text": "Generate Python code for the following: Memory allocation method allocates a block of memory of size sizeof(person) and returns a pointer to the beginning of the block. The cast (person *) is not necessary but it is good practice to include it. The -> operator is used to access the fields of a struct through a pointer. The code allocates a new person and sets the status field to 0.", "BP": ["Memory Allocation", "Memory Deallocation", "Data Handling", "Error Handling", "Import ctypes"], "code": "import ctypes\\r\\n\\r\\n# Define the person struct\\r\\nclass Person(ctypes.Structure):\\r\\n    _fields_ = [\\r\\n        (\"status\", ctypes.c_int)\\r\\n    ]\\r\\n\\r\\n# Memory Allocation: Allocate a block of memory for the person struct\\r\\ntry:\\r\\n    person_pointer = ctypes.POINTER(Person)\\r\\n    allocated_person = ctypes.cast(ctypes.create_string_buffer(ctypes.sizeof(Person)), person_pointer)\\r\\n\\r\\n    if not allocated_person:\\r\\n        raise MemoryError(\"Memory allocation failed\")\\r\\n\\r\\n    # Set the status field to 0\\r\\n    allocated_person.contents.status = 0\\r\\n\\r\\n    # Access and print the status field to confirm\\r\\n    print(f\"Status field set to: {allocated_person.contents.status}\")\\r\\n\\r\\nexcept MemoryError as e:\\r\\n    print(f\"Error: {e}\")\\r\\n\\r\\nfinally:\\r\\n    # Memory Deallocation\\r\\n    # In ctypes, memory allocated with create_string_buffer is managed by Python's garbage collector,\\r\\n    # but we use del to explicitly delete references for clarity.\\r\\n    del allocated_person", "CWE": "CWE-476"}
{"text": "Generate Python code for the following: Memory allocation method allocates a block of memory of size sizeof(person) and returns a pointer to the beginning of the block. The cast (person *) is not necessary but it is good practice to include it. The -> operator is used to access the fields of a struct through a pointer. The code allocates a new person and sets the status field to 0.", "BP": ["Memory Allocation", "Memory Deallocation", "Data Handling", "Error Handling", "Import ctypes"], "code": "# Include necessary libraries\\r\\nimport ctypes\\r\\n\\r\\n# Define the person structure\\r\\nclass Person(ctypes.Structure):\\r\\n    _fields_ = [(\"name\", ctypes.c_char_p),\\r\\n                (\"age\", ctypes.c_int),\\r\\n                (\"status\", ctypes.c_int)]\\r\\n\\r\\ndef allocate_person():\\r\\n    # Allocate memory for a new person\\r\\n    person_ptr = ctypes.cast(ctypes.create_string_buffer(ctypes.sizeof(Person)), ctypes.POINTER(Person))\\r\\n    \\r\\n    # Initialize the person's status to 0\\r\\n    person_ptr.contents.status = 0\\r\\n    \\r\\n    return person_ptr\\r\\n\\r\\ndef deallocate_person(person_ptr):\\r\\n    # Deallocate the memory block pointed by person_ptr\\r\\n    # In Python, ctypes automatically manages memory for ctypes objects, so explicit deallocation is not necessary.\\r\\n    # However, for educational purposes, we'll set the pointer to None to simulate deallocation.\\r\\n    person_ptr = None\\r\\n\\r\\ndef set_person_data(person_ptr, name, age):\\r\\n    # Set the person's data\\r\\n    if person_ptr:\\r\\n        person_ptr.contents.name = name.encode('utf-8')\\r\\n        person_ptr.contents.age = age\\r\\n    else:\\r\\n        print(\"Error: Invalid person pointer\")\\r\\n\\r\\ndef get_person_data(person_ptr):\\r\\n    # Get the person's data\\r\\n    if person_ptr:\\r\\n        return {\\r\\n            \"name\": person_ptr.contents.name.decode('utf-8'),\\r\\n            \"age\": person_ptr.contents.age,\\r\\n            \"status\": person_ptr.contents.status\\r\\n        }\\r\\n    else:\\r\\n        print(\"Error: Invalid person pointer\")\\r\\n        return None\\r\\n\\r\\n# Example usage\\r\\nif __name__ == \"__main__\":\\r\\n    person_ptr = allocate_person()\\r\\n    set_person_data(person_ptr, \"John Doe\", 30)\\r\\n    person_data = get_person_data(person_ptr)\\r\\n    print(person_data)\\r\\n    deallocate_person(person_ptr)", "CWE": "CWE-476"}
{"text": "Generate Python code for the following: Memory allocation method allocates a block of memory of size sizeof(person) and returns a pointer to the beginning of the block. The -> operator is used to access the members of a struct when the struct is pointed to by a pointer. The code allocates a new person and sets the status to 0.", "BP": ["Memory Allocation", "Memory Deallocation", "String Handling", "Error Handling", "Import ctypes"], "code": "import ctypes\\r\\nimport secrets\\r\\nimport os\\r\\nfrom typing import Optional\\r\\n\\r\\n# Define a Person struct using ctypes\\r\\nclass Person(ctypes.Structure):\\r\\n    _fields_ = [\\r\\n        (\"name\", ctypes.c_char_p),\\r\\n        (\"age\", ctypes.c_int),\\r\\n        (\"status\", ctypes.c_int)\\r\\n    ]\\r\\n\\r\\ndef allocate_person() -> Optional[Person]:\\r\\n    try:\\r\\n        # Allocate memory for a Person struct\\r\\n        person_ptr = ctypes.cast(ctypes.create_string_buffer(ctypes.sizeof(Person)), ctypes.POINTER(Person))\\r\\n        if person_ptr:\\r\\n            # Securely initialize the status to 0\\r\\n            person_ptr.contents.status = 0\\r\\n            return person_ptr.contents\\r\\n    except Exception as e:\\r\\n        print(f\"Error allocating memory: {e}\")\\r\\n    return None\\r\\n\\r\\ndef deallocate_person(person: Person) -> None:\\r\\n    try:\\r\\n        # Securely zero out the memory before freeing it\\r\\n        ctypes.memset(ctypes.byref(person), 0, ctypes.sizeof(person))\\r\\n        # Free the memory allocated for the name string\\r\\n        ctypes.free(person.name)\\r\\n    except Exception as e:\\r\\n        print(f\"Error deallocating memory: {e}\")\\r\\n\\r\\ndef set_name(person: Person, name: str) -> None:\\r\\n    try:\\r\\n        # Securely allocate memory for the name string\\r\\n        person.name = ctypes.create_string_buffer(name.encode('utf-8'))\\r\\n    except Exception as e:\\r\\n        print(f\"Error setting name: {e}\")\\r\\n\\r\\n# Example usage\\r\\nif __name__ == \"__main__\":\\r\\n    # Allocate memory for a Person\\r\\n    person = allocate_person()\\r\\n    if person:\\r\\n        # Set the name securely\\r\\n        set_name(person, secrets.token_hex(8))\\r\\n        print(f\"Name: {person.name.decode('utf-8')}, Age: {person.age}, Status: {person.status}\")\\r\\n        # Deallocate memory for the Person\\r\\n        deallocate_person(person)\\r\\n    else:\\r\\n        print(\"Failed to allocate memory for Person\")", "CWE": "CWE-476"}
{"text": "Generate Python code for the following: Memory allocation method allocates a block of memory of size sizeof(person) and returns a pointer to the beginning of the block. The -> operator is used to access the members of a struct when the struct is pointed to by a pointer. The code allocates a new person and sets the status to 0.", "BP": ["Memory Allocation", "Memory Deallocation", "String Handling", "Error Handling", "Import ctypes"], "code": "import ctypes\\r\\n\\r\\n# Define a C-like structure in Python using ctypes\\r\\nclass Person(ctypes.Structure):\\r\\n    _fields_ = [(\"status\", ctypes.c_int)]\\r\\n\\r\\ndef allocate_person():\\r\\n    try:\\r\\n        # Allocate memory for a Person structure\\r\\n        person_ptr = ctypes.pointer(Person())\\r\\n\\r\\n        # Set the status to 0\\r\\n        person_ptr.contents.status = 0\\r\\n\\r\\n        print(f\"Person status: {person_ptr.contents.status}\")\\r\\n\\r\\n        # Return the pointer to the allocated person\\r\\n        return person_ptr\\r\\n    except MemoryError:\\r\\n        print(\"Memory allocation failed!\")\\r\\n        return None\\r\\n    except Exception as e:\\r\\n        print(f\"An error occurred: {e}\")\\r\\n        return None\\r\\n\\r\\ndef free_person(person_ptr):\\r\\n    try:\\r\\n        # Deallocate memory by simply removing reference\\r\\n        del person_ptr\\r\\n        print(\"Memory deallocated successfully.\")\\r\\n    except Exception as e:\\r\\n        print(f\"An error occurred during deallocation: {e}\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    # Allocate a new Person\\r\\n    person = allocate_person()\\r\\n    \\r\\n    if person is not None:\\r\\n        # Use the person for something\\r\\n        print(f\"Person created with status: {person.contents.status}\")\\r\\n        \\r\\n        # Deallocate the Person\\r\\n        free_person(person)\\r\\n    else:\\r\\n        print(\"Failed to allocate Person.\")", "CWE": "CWE-476"}
{"text": "Generate Python code for the following: Memory allocation method allocates a block of memory of size sizeof(person) and returns a pointer to the beginning of the block. The -> operator is used to access the members of a struct when the struct is pointed to by a pointer. The code allocates a new person and sets the status to 0.", "BP": ["Memory Allocation", "Memory Deallocation", "String Handling", "Error Handling", "Import ctypes"], "code": "import ctypes\\r\\n\\r\\n# Define a class for our person structure\\r\\nclass Person(ctypes.Structure):\\r\\n    _fields_ = [(\"name\", ctypes.c_char_p),\\r\\n                (\"age\", ctypes.c_int),\\r\\n                (\"status\", ctypes.c_int)]\\r\\n\\r\\ndef allocate_person():\\r\\n    # Allocate memory for a person\\r\\n    person_ptr = ctypes.pointer(Person())\\r\\n    \\r\\n    # Initialize the person's status to 0\\r\\n    person_ptr.contents.status = 0\\r\\n    \\r\\n    return person_ptr\\r\\n\\r\\ndef deallocate_person(person_ptr):\\r\\n    # Deallocate the memory for the person\\r\\n    # In Python, ctypes automatically manages memory for ctypes objects,\\r\\n    # so explicit deallocation is not typically necessary.\\r\\n    # However, for educational purposes or specific use cases, you might use:\\r\\n    del person_ptr\\r\\n\\r\\ndef set_person_name(person_ptr, name):\\r\\n    # Set the person's name, ensuring the name is a bytes object for ctypes compatibility\\r\\n    if isinstance(name, str):\\r\\n        name = name.encode('utf-8')\\r\\n    person_ptr.contents.name = name\\r\\n\\r\\ndef main():\\r\\n    try:\\r\\n        person_ptr = allocate_person()\\r\\n        set_person_name(person_ptr, \"John Doe\")\\r\\n        print(f\"Allocated a person with status: {person_ptr.contents.status}\")\\r\\n        \\r\\n        # Always ensure to deallocate or manage memory properly to avoid leaks\\r\\n        # In this case, deallocation is handled by Python's garbage collector.\\r\\n    except Exception as e:\\r\\n        print(f\"An error occurred: {e}\")\\r\\n    finally:\\r\\n        # If explicit deallocation was necessary or implemented, it would go here.\\r\\n        pass\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-476"}
{"text": "Generate Python code for the following: Memory allocation method allocates a block of memory of size sizeof(person) and returns a pointer to the beginning of the block. The -> operator is used to access the members of a struct through a pointer.The code allocates a new person and sets its status to 0.", "BP": ["Memory Allocation", "Memory Cleanup", "Field Initialization", "Import ctypes"], "code": "import ctypes\\r\\n\\r\\n# Define a structure to represent the person\\r\\nclass Person(ctypes.Structure):\\r\\n    _fields_ = [(\"status\", ctypes.c_int)]\\r\\n\\r\\n# Securely allocate memory for a new person\\r\\nperson_ptr = ctypes.POINTER(Person)()\\r\\nperson = person_ptr.contents\\r\\n\\r\\n# Securely initialize the person's status\\r\\nperson.status = 0\\r\\n\\r\\n# Free the allocated memory when no longer needed\\r\\nctypes.free(person_ptr)", "CWE": "CWE-476"}
{"text": "Generate Python code for the following: Memory allocation method allocates a block of memory of size sizeof(person) and returns a pointer to the beginning of the block. The -> operator is used to access the members of a struct through a pointer.The code allocates a new person and sets its status to 0.", "BP": ["Memory Allocation", "Memory Cleanup", "Field Initialization", "Import ctypes"], "code": "import ctypes\\r\\n\\r\\n# Define a C-like struct for Person\\r\\nclass Person(ctypes.Structure):\\r\\n    _fields_ = [(\"status\", ctypes.c_int)]\\r\\n\\r\\n# Allocate memory for a Person instance and return a pointer to it\\r\\ndef allocate_person():\\r\\n    # Allocate memory for a single Person structure\\r\\n    person_ptr = ctypes.pointer(Person())\\r\\n\\r\\n    # Initialize the 'status' field to 0\\r\\n    person_ptr.contents.status = 0\\r\\n    \\r\\n    return person_ptr\\r\\n\\r\\n# Free allocated memory (not strictly necessary in Python due to garbage collection)\\r\\ndef free_person(person_ptr):\\r\\n    # Set the pointer to None, allowing Python's garbage collector to reclaim the memory\\r\\n    person_ptr = None\\r\\n\\r\\n# Example usage\\r\\nif __name__ == \"__main__\":\\r\\n    # Allocate a new person\\r\\n    new_person = allocate_person()\\r\\n    \\r\\n    # Access and print the 'status' field\\r\\n    print(f\"Person status: {new_person.contents.status}\")\\r\\n    \\r\\n    # Clean up memory\\r\\n    free_person(new_person)", "CWE": "CWE-476"}
{"text": "Generate Python code for the following: Memory allocation method allocates a block of memory of size sizeof(person) and returns a pointer to the beginning of the block. The -> operator is used to access the members of a struct through a pointer.The code allocates a new person and sets its status to 0.", "BP": ["Memory Allocation", "Memory Cleanup", "Field Initialization", "Import ctypes"], "code": "import ctypes\\r\\n\\r\\n# Define a class for our person structure\\r\\nclass Person(ctypes.Structure):\\r\\n    _fields_ = [(\"status\", ctypes.c_int)]\\r\\n\\r\\ndef allocate_person():\\r\\n    # Allocate memory for a person and return a pointer to it\\r\\n    person_ptr = ctypes.pointer(Person())\\r\\n    # Initialize the status field to 0\\r\\n    person_ptr.contents.status = 0\\r\\n    return person_ptr\\r\\n\\r\\ndef cleanup_person(person_ptr):\\r\\n    # Free the allocated memory (in Python, ctypes does this automatically when the object is garbage collected)\\r\\n    # Explicit cleanup can be done by deleting the reference if needed\\r\\n    del person_ptr\\r\\n\\r\\n# Example usage\\r\\nif __name__ == \"__main__\":\\r\\n    person_ptr = allocate_person()\\r\\n    print(f\"Person status: {person_ptr.contents.status}\")\\r\\n    cleanup_person(person_ptr)", "CWE": "CWE-476"}
{"text": "Generate Python code for the following: Memory allocation method allocates a block of memory of the specified size and returns a pointer to the beginning of the block. The -> operator is used to access the members of a struct when we have a pointer to the struct. The code creates a new person and sets the status to 0 and the name to \\\"John\\\".", "BP": ["Memory Allocation", "Secure Data Handling", "Input Validation", "Import ctypes"], "code": "import ctypes\\r\\nimport re\\r\\n\\r\\n# Define a person struct\\r\\nclass Person(ctypes.Structure):\\r\\n    _fields_ = [(\"status\", ctypes.c_int),\\r\\n                (\"name\", ctypes.c_char_p)]\\r\\n\\r\\n# Memory allocation function\\r\\ndef allocate_memory(size):\\r\\n    try:\\r\\n        buffer = ctypes.create_string_buffer(size)\\r\\n        return buffer\\r\\n    except Exception as e:\\r\\n        print(f\"Error allocating memory: {e}\")\\r\\n        return None\\r\\n\\r\\n# Secure data handling and input validation\\r\\ndef create_person(name):\\r\\n    # Input validation using regular expression\\r\\n    if not re.match(r\"^[a-zA-Z]+$\", name):\\r\\n        print(\"Invalid name. Only alphabetic characters are allowed.\")\\r\\n        return None\\r\\n\\r\\n    # Memory allocation\\r\\n    name_buffer = allocate_memory(len(name) + 1)\\r\\n    if name_buffer is None:\\r\\n        return None\\r\\n\\r\\n    # Create a new person\\r\\n    person = Person()\\r\\n    person.status = 0\\r\\n    person.name = ctypes.cast(name_buffer, ctypes.POINTER(ctypes.c_char))\\r\\n    ctypes.memmove(person.name, name.encode(), len(name))\\r\\n\\r\\n    return person\\r\\n\\r\\n# Example usage\\r\\nname_input = input(\"Enter a name: \")\\r\\nperson = create_person(name_input)\\r\\nif person:\\r\\n    print(f\"Status: {person.status}\")\\r\\n    print(f\"Name: {person.name.value.decode()}\")\\r\\nelse:\\r\\n    print(\"Error creating person.\")", "CWE": "CWE-476"}
{"text": "Generate Python code for the following: Memory allocation method allocates a block of memory of the specified size and returns a pointer to the beginning of the block. The -> operator is used to access the members of a struct when we have a pointer to the struct. The code creates a new person and sets the status to 0 and the name to \\\"John\\\".", "BP": ["Memory Allocation", "Secure Data Handling", "Input Validation", "Import ctypes"], "code": "import ctypes\\r\\nimport ctypes.util\\r\\n\\r\\n# Define the Person struct with ctypes\\r\\nclass Person(ctypes.Structure):\\r\\n    _fields_ = [(\"status\", ctypes.c_int),\\r\\n                (\"name\", ctypes.c_char * 50)]  # Assuming a maximum of 50 characters for the name\\r\\n\\r\\ndef create_person(name: str) -> ctypes.POINTER(Person):\\r\\n    # Validate the input name to ensure it meets requirements (e.g., not too long)\\r\\n    if not isinstance(name, str):\\r\\n        raise ValueError(\"Name must be a string.\")\\r\\n    \\r\\n    if len(name) >= 50:\\r\\n        raise ValueError(\"Name is too long. Maximum allowed length is 49 characters.\")\\r\\n    \\r\\n    # Allocate memory for a new Person object\\r\\n    person_pointer = ctypes.POINTER(Person)(Person())\\r\\n    \\r\\n    # Set default values\\r\\n    person_pointer.contents.status = 0\\r\\n    \\r\\n    # Securely copy the name into the allocated memory\\r\\n    ctypes.memset(person_pointer.contents.name, 0, 50)  # Zero the name field\\r\\n    ctypes.memmove(person_pointer.contents.name, name.encode('utf-8'), len(name))\\r\\n    \\r\\n    return person_pointer\\r\\n\\r\\n# Test the function\\r\\nnew_person = create_person(\"John\")\\r\\n\\r\\n# Accessing struct members via the pointer\\r\\nprint(f\"Person status: {new_person.contents.status}\")\\r\\nprint(f\"Person name: {new_person.contents.name.decode('utf-8')}\")\\r\\n\\r\\n# Clean up: In Python, we rely on garbage collection, but if this were C, you'd need to free the memory manually.", "CWE": "CWE-476"}
{"text": "Generate Python code for the following: Memory allocation method allocates a block of memory of the specified size and returns a pointer to the beginning of the block. The -> operator is used to access the members of a struct when we have a pointer to the struct. The code creates a new person and sets the status to 0 and the name to \\\"John\\\".", "BP": ["Memory Allocation", "Secure Data Handling", "Input Validation", "Import ctypes"], "code": "import ctypes\\r\\n\\r\\n# Define a Person structure using ctypes\\r\\nclass Person(ctypes.Structure):\\r\\n    _fields_ = [(\"status\", ctypes.c_int),\\r\\n                (\"name\", ctypes.c_char_p)]\\r\\n\\r\\ndef create_person(name=\"John\"):\\r\\n    # Allocate memory for a new Person\\r\\n    person = Person()\\r\\n    person_pointer = ctypes.pointer(person)\\r\\n    \\r\\n    # Perform input validation\\r\\n    if not isinstance(name, str):\\r\\n        raise ValueError(\"Name must be a string\")\\r\\n    \\r\\n    # Secure data handling\\r\\n    try:\\r\\n        # Set the person's name and status\\r\\n        person_pointer.contents.name = name.encode('utf-8')  # Convert string to bytes\\r\\n        person_pointer.contents.status = 0\\r\\n    except Exception as e:\\r\\n        print(f\"Error setting person's attributes: {e}\")\\r\\n        # Optionally, deallocate memory here if needed\\r\\n        return None\\r\\n    \\r\\n    return person_pointer\\r\\n\\r\\n# Example usage\\r\\nperson_ptr = create_person(\"John\")\\r\\nif person_ptr:\\r\\n    print(f\"Created person with name: {person_ptr.contents.name.decode('utf-8')}, status: {person_ptr.contents.status}\")", "CWE": "CWE-476"}
{"text": "Generate Python code for the following: Memory allocation method allocates a block of memory of the specified size and returns a pointer to the beginning of the block. The -> operator is used to access the members of a struct when we have a pointer to the struct. The code allocates a new person and sets the status to 0.", "BP": ["Dynamic Memory Allocation", "Memory Deallocation", "String Handling", "Import ctypes"], "code": "import ctypes\\r\\n\\r\\n# Define the Person structure\\r\\nclass Person(ctypes.Structure):\\r\\n    _fields_ = [\\r\\n        (\"name\", ctypes.c_char_p),\\r\\n        (\"age\", ctypes.c_int),\\r\\n        (\"status\", ctypes.c_int)\\r\\n    ]\\r\\n\\r\\ndef create_person(name, age):\\r\\n    # Allocate memory for the Person structure\\r\\n    person_ptr = ctypes.pointer(Person())\\r\\n\\r\\n    # Set the name field\\r\\n    person_ptr.contents.name = ctypes.c_char_p(name.encode('utf-8'))\\r\\n\\r\\n    # Set the age field\\r\\n    person_ptr.contents.age = age\\r\\n\\r\\n    # Set the status field to 0\\r\\n    person_ptr.contents.status = 0\\r\\n\\r\\n    return person_ptr\\r\\n\\r\\n# Usage\\r\\njohn_ptr = create_person(\"John\", 30)\\r\\nprint(f\"Name: {john_ptr.contents.name.decode('utf-8')}\")\\r\\nprint(f\"Age: {john_ptr.contents.age}\")\\r\\nprint(f\"Status: {john_ptr.contents.status}\")\\r\\n\\r\\n# Free the allocated memory\\r\\nctypes.pointer(ctypes.c_char_p(john_ptr.contents.name))()\\r\\nctypes.pointer(john_ptr)()", "CWE": "CWE-476"}
{"text": "Generate Python code for the following: Memory allocation method allocates a block of memory of the specified size and returns a pointer to the beginning of the block. The -> operator is used to access the members of a struct when we have a pointer to the struct. The code allocates a new person and sets the status to 0.", "BP": ["Dynamic Memory Allocation", "Memory Deallocation", "String Handling", "Import ctypes"], "code": "import ctypes\\r\\n\\r\\n# Define a struct representing a person\\r\\nclass Person(ctypes.Structure):\\r\\n    _fields_ = [\\r\\n        ('name', ctypes.c_char_p),\\r\\n        ('age', ctypes.c_int),\\r\\n        ('status', ctypes.c_int)\\r\\n    ]\\r\\n\\r\\n# Function to allocate memory and create a new person\\r\\ndef create_person(name, age):\\r\\n    # Allocate memory for a Person struct\\r\\n    p = ctypes.POINTER(Person)\\r\\n    person_ptr = ctypes.cast(ctypes.c_char_p(ctypes.create_string_buffer(ctypes.sizeof(Person))), p)\\r\\n\\r\\n    # Access the struct fields and set initial values\\r\\n    person_ptr.contents.name = ctypes.c_char_p(name.encode())\\r\\n    person_ptr.contents.age = age\\r\\n    person_ptr.contents.status = 0\\r\\n\\r\\n    return person_ptr\\r\\n\\r\\n# Function to deallocate memory of a person\\r\\ndef delete_person(person_ptr):\\r\\n    ctypes.cast(person_ptr, ctypes.POINTER(ctypes.c_char)).free()\\r\\n\\r\\n# Example usage\\r\\nif __name__ == '__main__':\\r\\n    # Create a new person\\r\\n    person = create_person(\"John Doe\", 30)\\r\\n\\r\\n    # Access and print person details\\r\\n    print(f\"Name: {person.contents.name.decode()}, Age: {person.contents.age}, Status: {person.contents.status}\")\\r\\n\\r\\n    # Deallocate memory\\r\\n    delete_person(person)", "CWE": "CWE-476"}
{"text": "Generate Python code for the following: Memory allocation method allocates a block of memory of the specified size and returns a pointer to the beginning of the block. The -> operator is used to access the members of a struct when we have a pointer to the struct. The code allocates a new person and sets the status to 0.", "BP": ["Dynamic Memory Allocation", "Memory Deallocation", "String Handling", "Import ctypes"], "code": "import ctypes\\r\\n\\r\\n# Define a class for our person struct\\r\\nclass Person(ctypes.Structure):\\r\\n    _fields_ = [(\"name\", ctypes.c_char_p),\\r\\n                (\"age\", ctypes.c_int),\\r\\n                (\"status\", ctypes.c_int)]\\r\\n\\r\\ndef allocate_person(name: str, age: int) -> ctypes.POINTER(Person):\\r\\n    # Allocate memory for a new person\\r\\n    new_person = ctypes.pointer(Person())\\r\\n    # Set the fields of the person\\r\\n    new_person.contents.name = name.encode('utf-8')  # Convert string to bytes\\r\\n    new_person.contents.age = age\\r\\n    new_person.contents.status = 0  # Set status to 0\\r\\n    return new_person\\r\\n\\r\\ndef deallocate_person(person: ctypes.POINTER(Person)):\\r\\n    # Deallocate the memory for the person\\r\\n    # In this case, ctypes automatically manages memory, so explicit deallocation is not needed.\\r\\n    # However, if using a different library or method for allocation, you would deallocate here.\\r\\n    pass\\r\\n\\r\\n# Example usage\\r\\nif __name__ == \"__main__\":\\r\\n    person_ptr = allocate_person(\"John Doe\", 30)\\r\\n    print(f\"Name: {person_ptr.contents.name.decode('utf-8')}, Age: {person_ptr.contents.age}, Status: {person_ptr.contents.status}\")\\r\\n    # Deallocate person (not necessary with ctypes, but included for completeness)\\r\\n    deallocate_person(person_ptr)", "CWE": "CWE-476"}
{"text": "Generate Python code for the following: Memory allocation method allocates a large buffer and copy in 100 characters from stdin. Allocate a second large buffer and copy in 100 characters from stdin. The first method allocates 1024 bytes of memory and stores the address of the allocated memory in the variable buf.  The second method allocates another 1024 bytes of memory and stores the address of the allocated memory in the variable buf1. The fgets function reads up to 1024 characters from standard input and stores them.", "BP": ["Memory Allocation", "Input Validation", "Error Handling", "Memory Cleanup", "Import ctypes"], "code": "import ctypes\\r\\nimport sys\\r\\n\\r\\n# Define constants\\r\\nMAX_INPUT_LENGTH = 100\\r\\nBUFFER_SIZE = 1024\\r\\n\\r\\n# Define helper functions\\r\\ndef secure_allocate(size):\\r\\n    try:\\r\\n        return ctypes.create_string_buffer(size)\\r\\n    except (MemoryError, ValueError) as e:\\r\\n        print(f\"Error allocating memory: {e}\", file=sys.stderr)\\r\\n        sys.exit(1)\\r\\n\\r\\ndef secure_input(prompt, buf, max_len):\\r\\n    try:\\r\\n        user_input = input(prompt)\\r\\n        if len(user_input) > max_len:\\r\\n            print(f\"Input length exceeded {max_len} characters. Input truncated.\", file=sys.stderr)\\r\\n            user_input = user_input[:max_len]\\r\\n        buf.value = user_input.encode()\\r\\n    except Exception as e:\\r\\n        print(f\"Error reading input: {e}\", file=sys.stderr)\\r\\n        sys.exit(1)\\r\\n\\r\\n# Allocate memory buffers\\r\\nbuf = secure_allocate(BUFFER_SIZE)\\r\\nbuf1 = secure_allocate(BUFFER_SIZE)\\r\\n\\r\\nif buf and buf1:\\r\\n    # Read input from stdin\\r\\n    secure_input(\"Enter up to 100 characters: \", buf, MAX_INPUT_LENGTH)\\r\\n    secure_input(\"Enter up to 100 characters: \", buf1, MAX_INPUT_LENGTH)\\r\\n\\r\\n    # Process input (example: print to stdout)\\r\\n    print(f\"First input: {buf.value.decode()}\")\\r\\n    print(f\"Second input: {buf1.value.decode()}\")\\r\\n\\r\\n    # Free allocated memory\\r\\n    ctypes.memset(ctypes.addressof(buf), 0, BUFFER_SIZE)\\r\\n    ctypes.memset(ctypes.addressof(buf1), 0, BUFFER_SIZE)\\r\\nelse:\\r\\n    print(\"Error: Memory allocation failed.\", file=sys.stderr)\\r\\n    sys.exit(1)", "CWE": "CWE-476"}
{"text": "Generate Python code for the following: Memory allocation method allocates a large buffer and copy in 100 characters from stdin. Allocate a second large buffer and copy in 100 characters from stdin. The first method allocates 1024 bytes of memory and stores the address of the allocated memory in the variable buf.  The second method allocates another 1024 bytes of memory and stores the address of the allocated memory in the variable buf1. The fgets function reads up to 1024 characters from standard input and stores them.", "BP": ["Memory Allocation", "Input Validation", "Error Handling", "Memory Cleanup", "Import ctypes"], "code": "import ctypes\\r\\n\\r\\ndef allocate_memory(size):\\r\\n    try:\\r\\n        buf = ctypes.create_string_buffer(size)\\r\\n    except MemoryError:\\r\\n        print(\"Memory allocation failed.\")\\r\\n        return None\\r\\n    return buf\\r\\n\\r\\ndef read_input_into_buffer(buf, size):\\r\\n    try:\\r\\n        input_str = input(f\"Enter up to {size} characters: \")\\r\\n        input_bytes = input_str.encode('utf-8')\\r\\n        if len(input_bytes) > size - 1:\\r\\n            raise ValueError(f\"Input exceeds buffer size of {size} bytes.\")\\r\\n        ctypes.memmove(buf, input_bytes, len(input_bytes))\\r\\n        buf[len(input_bytes)] = b'\\0'  # Null-terminate the string\\r\\n    except ValueError as ve:\\r\\n        print(f\"Error: {ve}\")\\r\\n        return False\\r\\n    return True\\r\\n\\r\\ndef cleanup_buffer(buf):\\r\\n    del buf\\r\\n\\r\\ndef main():\\r\\n    BUF_SIZE = 1024\\r\\n    buf = allocate_memory(BUF_SIZE)\\r\\n    if buf is None:\\r\\n        return\\r\\n    \\r\\n    buf1 = allocate_memory(BUF_SIZE)\\r\\n    if buf1 is None:\\r\\n        cleanup_buffer(buf)\\r\\n        return\\r\\n    \\r\\n    print(\"First buffer allocation successful.\")\\r\\n    if not read_input_into_buffer(buf, BUF_SIZE):\\r\\n        cleanup_buffer(buf)\\r\\n        cleanup_buffer(buf1)\\r\\n        return\\r\\n    \\r\\n    print(\"Second buffer allocation successful.\")\\r\\n    if not read_input_into_buffer(buf1, BUF_SIZE):\\r\\n        cleanup_buffer(buf)\\r\\n        cleanup_buffer(buf1)\\r\\n        return\\r\\n    \\r\\n    # Example of using the allocated buffers\\r\\n    print(\"First buffer contents:\", buf.value.decode('utf-8'))\\r\\n    print(\"Second buffer contents:\", buf1.value.decode('utf-8'))\\r\\n    \\r\\n    # Clean up allocated memory\\r\\n    cleanup_buffer(buf)\\r\\n    cleanup_buffer(buf1)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-476"}
{"text": "Generate Python code for the following: Memory allocation method allocates a large buffer and copy in 100 characters from stdin. Allocate a second large buffer and copy in 100 characters from stdin. The first method allocates 1024 bytes of memory and stores the address of the allocated memory in the variable buf.  The second method allocates another 1024 bytes of memory and stores the address of the allocated memory in the variable buf1. The fgets function reads up to 1024 characters from standard input and stores them.", "BP": ["Memory Allocation", "Input Validation", "Error Handling", "Memory Cleanup", "Import ctypes"], "code": "import ctypes\\r\\nimport sys\\r\\n\\r\\ndef allocate_buffer(size=1024):\\r\\n    \"\"\"\\r\\n    Allocates a buffer of the given size and returns a pointer to it.\\r\\n    \"\"\"\\r\\n    try:\\r\\n        buffer = ctypes.create_string_buffer(size)\\r\\n        return buffer\\r\\n    except MemoryError:\\r\\n        print(\"Failed to allocate memory.\")\\r\\n        sys.exit(1)\\r\\n\\r\\ndef read_input_into_buffer(buffer, max_chars=100):\\r\\n    \"\"\"\\r\\n    Reads up to max_chars characters from stdin and stores them in the provided buffer.\\r\\n    \"\"\"\\r\\n    try:\\r\\n        input_data = input()[:max_chars]  # Read and limit input to max_chars\\r\\n        buffer.value = input_data.encode('utf-8')  # Store in buffer\\r\\n    except Exception as e:\\r\\n        print(f\"Error reading input: {e}\")\\r\\n        sys.exit(1)\\r\\n\\r\\ndef main():\\r\\n    # Allocate the first buffer\\r\\n    buf = allocate_buffer(1024)\\r\\n    print(\"Enter up to 100 characters for the first buffer:\")\\r\\n    read_input_into_buffer(buf, 100)\\r\\n\\r\\n    # Allocate the second buffer\\r\\n    buf1 = allocate_buffer(1024)\\r\\n    print(\"Enter up to 100 characters for the second buffer:\")\\r\\n    read_input_into_buffer(buf1, 100)\\r\\n\\r\\n    # Example of using the buffers\\r\\n    print(f\"First buffer content: {buf.value.decode('utf-8')}\")\\r\\n    print(f\"Second buffer content: {buf1.value.decode('utf-8')}\")\\r\\n\\r\\n    # Memory cleanup is handled by Python's garbage collector.\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-476"}
{"text": "Generate Python code for the following: The scan function reads in a string from the standard input. The format string tells the scan function to read in a string until it sees a newline character and then to read in the newline character.  The newline character is not stored in the buffer.The scanf function returns the number of characters read in.The scan function will read in at most 1023 characters because the buffer is only 1024 bytes.", "BP": ["Secure Input Handling", "Prompt Flushing", "Error Handling", "String Decoding", "Import ctypes"], "code": "import ctypes\\r\\nimport sys\\r\\n\\r\\n# Define the maximum buffer size\\r\\nMAX_BUFFER_SIZE = 1024\\r\\n\\r\\n# Flush the input buffer\\r\\ndef flush_input():\\r\\n    try:\\r\\n        import msvcrt\\r\\n        while msvcrt.kbhit():\\r\\n            msvcrt.getch()\\r\\n    except ImportError:\\r\\n        import sys\\r\\n        import termios\\r\\n        termios.tcflush(sys.stdin, termios.TCIOFLUSH)\\r\\n\\r\\n# Secure string input function\\r\\ndef secure_input(prompt):\\r\\n    # Flush the input buffer before prompting\\r\\n    flush_input()\\r\\n\\r\\n    # Print the prompt\\r\\n    sys.stdout.write(prompt)\\r\\n    sys.stdout.flush()\\r\\n\\r\\n    # Read the input securely\\r\\n    input_bytes = ctypes.create_string_buffer(MAX_BUFFER_SIZE)\\r\\n    bytes_read = ctypes.c_int()\\r\\n    success = ctypes.windll.msvcrt.scanf(\"%1023s\", input_bytes)\\r\\n\\r\\n    # Handle errors\\r\\n    if success == 0:\\r\\n        print(\"Error: Invalid input\")\\r\\n        return None\\r\\n    elif success == ctypes.c_int(-1).value:\\r\\n        ctypes.windll.msvcrt.scanf(\"%*c\")  # Consume the newline character\\r\\n        print(\"Error: Input too long\")\\r\\n        return None\\r\\n\\r\\n    # Decode the input bytes to a string\\r\\n    input_str = input_bytes.value.decode('utf-8', 'ignore')\\r\\n\\r\\n    return input_str\\r\\n\\r\\n# Example usage\\r\\nuser_input = secure_input(\"Enter a string: \")\\r\\nif user_input:\\r\\n    print(f\"You entered: {user_input}\")\\r\\nelse:\\r\\n    print(\"Invalid input\")", "CWE": "CWE-476"}
{"text": "Generate Python code for the following: The scan function reads in a string from the standard input. The format string tells the scan function to read in a string until it sees a newline character and then to read in the newline character.  The newline character is not stored in the buffer.The scanf function returns the number of characters read in.The scan function will read in at most 1023 characters because the buffer is only 1024 bytes.", "BP": ["Secure Input Handling", "Prompt Flushing", "Error Handling", "String Decoding", "Import ctypes"], "code": "import ctypes\\r\\nimport sys\\r\\n\\r\\n# Function to implement scanf-like functionality\\r\\ndef scanf(format_string):\\r\\n    # Flush prompt to ensure output before input\\r\\n    sys.stdout.flush()\\r\\n\\r\\n    # Allocate buffer for input (1024 bytes)\\r\\n    buf = ctypes.create_string_buffer(1024)\\r\\n\\r\\n    # Read input using low-level C function\\r\\n    libc = ctypes.CDLL(None)\\r\\n    num_chars_read = libc.scanf(format_string.encode(), ctypes.byref(buf))\\r\\n\\r\\n    # Convert bytes buffer to string\\r\\n    input_string = buf.value.decode().strip()\\r\\n\\r\\n    return num_chars_read, input_string\\r\\n\\r\\n# Example usage:\\r\\nif __name__ == \"__main__\":\\r\\n    print(\"Enter a string followed by a newline:\")\\r\\n    chars_read, input_str = scanf(b\"%1023[^\\n]%*c\")\\r\\n    print(f\"Number of characters read: {chars_read}\")\\r\\n    print(f\"Input string: {input_str}\")", "CWE": "CWE-476"}
{"text": "Generate Python code for the following: The scan function reads in a string from the standard input. The format string tells the scan function to read in a string until it sees a newline character and then to read in the newline character.  The newline character is not stored in the buffer.The scanf function returns the number of characters read in.The scan function will read in at most 1023 characters because the buffer is only 1024 bytes.", "BP": ["Secure Input Handling", "Prompt Flushing", "Error Handling", "String Decoding", "Import ctypes"], "code": "import ctypes\\r\\nimport sys\\r\\n\\r\\ndef scan(prompt):\\r\\n    \"\"\"\\r\\n    Reads in a string from the standard input until a newline character is seen.\\r\\n    The newline character is not stored in the buffer.\\r\\n    Performs secure input handling, prompt flushing, error handling, and string decoding.\\r\\n    Reads in at most 1023 characters due to buffer size limitation.\\r\\n    \"\"\"\\r\\n    # Prompt user\\r\\n    sys.stdout.write(prompt)\\r\\n    sys.stdout.flush()\\r\\n\\r\\n    # Create a buffer for the input\\r\\n    buffer_size = 1024\\r\\n    buffer = ctypes.create_string_buffer(buffer_size)\\r\\n\\r\\n    try:\\r\\n        # Read from stdin (fd = 0) using ctypes\\r\\n        libc = ctypes.CDLL(\"libc.so.6\")\\r\\n        read = libc.read\\r\\n        read.argtypes = [ctypes.c_int, ctypes.c_void_p, ctypes.c_size_t]\\r\\n        read.restype = ctypes.c_ssize_t\\r\\n\\r\\n        # Perform the read operation\\r\\n        num_chars_read = read(0, buffer, buffer_size - 1)  # Leave space for null terminator\\r\\n\\r\\n        if num_chars_read > 0:\\r\\n            # Successfully read, now decode and strip newline if present\\r\\n            input_str = buffer.value.decode('utf-8')\\r\\n            if input_str.endswith('\\n'):\\r\\n                input_str = input_str[:-1]\\r\\n            return input_str\\r\\n        else:\\r\\n            # Handle error or EOF\\r\\n            if num_chars_read == 0:\\r\\n                print(\"EOF encountered. No input read.\")\\r\\n            else:\\r\\n                print(\"Error reading input.\")\\r\\n            return None\\r\\n    except Exception as e:\\r\\n        print(f\"An error occurred: {e}\")\\r\\n        return None\\r\\n\\r\\n# Example usage\\r\\nif __name__ == \"__main__\":\\r\\n    user_input = scan(\"Enter input: \")\\r\\n    if user_input is not None:\\r\\n        print(f\"You entered: {user_input}\")\\r\\n    else:\\r\\n        print(\"Failed to read input.\")", "CWE": "CWE-476"}
{"text": "Generate Python code for the following: Memory allocation method allocates a buffer of 1024 bytes. fgets reads 10 characters from standard input and stores them in buf.", "BP": ["Memory Allocation", "Input Handling", "Error Handling", "and Exception Handling", "Data Encoding", "Import ctypes"], "code": "import ctypes\\r\\nimport sys\\r\\n\\r\\n# Memory allocation (1024 bytes)\\r\\nbuf_size = 1024\\r\\nbuf = ctypes.create_string_buffer(buf_size)\\r\\n\\r\\ntry:\\r\\n    # Input handling\\r\\n    chars_read = sys.stdin.read(10)  # Read up to 10 characters from standard input\\r\\n    if not chars_read:\\r\\n        print(\"No input provided\")\\r\\n        sys.exit(1)\\r\\n\\r\\n    # Error handling and exception handling\\r\\n    if len(chars_read) > buf_size - 1:\\r\\n        print(\"Input exceeds buffer size\")\\r\\n        sys.exit(1)\\r\\n\\r\\n    # Copy input to buffer\\r\\n    buf.value = chars_read.encode()\\r\\n\\r\\n    # Print the input\\r\\n    print(f\"Input: {buf.value.decode()}\")\\r\\n\\r\\nexcept Exception as e:\\r\\n    print(f\"An error occurred: {str(e)}\")\\r\\n    sys.exit(1)", "CWE": "CWE-476"}
{"text": "Generate Python code for the following: Memory allocation method allocates a buffer of 1024 bytes. fgets reads 10 characters from standard input and stores them in buf.", "BP": ["Memory Allocation", "Input Handling", "Error Handling", "and Exception Handling", "Data Encoding", "Import ctypes"], "code": "import ctypes\\r\\n\\r\\ndef main():\\r\\n    # Memory Allocation\\r\\n    buf = ctypes.create_string_buffer(1024)\\r\\n\\r\\n    try:\\r\\n        # Input Handling\\r\\n        print(\"Enter up to 10 characters:\")\\r\\n        input_str = input()\\r\\n        \\r\\n        # Limit input to 10 characters\\r\\n        input_str = input_str[:10]\\r\\n        \\r\\n        # Data Encoding\\r\\n        encoded_input = input_str.encode('utf-8')\\r\\n        \\r\\n        # Copying to allocated buffer\\r\\n        ctypes.memmove(buf, encoded_input, len(encoded_input))\\r\\n        \\r\\n        # Printing buffer content\\r\\n        print(\"Buffer content:\", buf.value.decode('utf-8'))\\r\\n\\r\\n    except ValueError as ve:\\r\\n        print(\"Value Error:\", ve)\\r\\n    except Exception as e:\\r\\n        print(\"Exception occurred:\", e)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-476"}
{"text": "Generate Python code for the following: Memory allocation method allocates a buffer of 1024 bytes. fgets reads 10 characters from standard input and stores them in buf.", "BP": ["Memory Allocation", "Input Handling", "Error Handling", "and Exception Handling", "Data Encoding", "Import ctypes"], "code": "import ctypes\\r\\nimport sys\\r\\n\\r\\ndef main():\\r\\n    # Memory Allocation\\r\\n    buffer_size = 1024\\r\\n    buf = ctypes.create_string_buffer(buffer_size)\\r\\n\\r\\n    try:\\r\\n        # Input Handling\\r\\n        print(\"Enter text (max 10 characters): \", end=\"\")\\r\\n        input_text = input()\\r\\n\\r\\n        if len(input_text) > 10:\\r\\n            raise ValueError(\"Input exceeds 10 characters limit.\")\\r\\n\\r\\n        # Store input in buffer\\r\\n        buf.value = input_text.encode('utf-8')  # Data Encoding\\r\\n\\r\\n        # Display stored data\\r\\n        print(\"Stored data:\", buf.value.decode('utf-8'))\\r\\n\\r\\n    except ValueError as ve:\\r\\n        # Error Handling\\r\\n        print(\"Error:\", ve, file=sys.stderr)\\r\\n\\r\\n    except Exception as e:\\r\\n        # Exception Handling\\r\\n        print(\"An unexpected error occurred:\", str(e), file=sys.stderr)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-476"}
{"text": "Generate Python code for the following: It creates a web app. It creates a route called /api. It gets the payload parameter from the URL.  It loads the payload into a dictionary. It returns the name value from the dictionary.", "BP": ["Input Validation", "Error Handling", "Secure Data Handling", "Appropriate HTTP Status Codes", "JSON Responses"], "code": "from flask import Flask, jsonify, request\\r\\nimport json\\r\\nfrom werkzeug.exceptions import BadRequest\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n@app.route('/api', methods=['GET'])\\r\\ndef api():\\r\\n    try:\\r\\n        # Get the payload parameter from the URL\\r\\n        payload = request.args.get('payload')\\r\\n\\r\\n        # Input Validation: Check if payload is provided\\r\\n        if not payload:\\r\\n            raise BadRequest('Missing payload parameter')\\r\\n\\r\\n        # Secure Data Handling: Load the payload into a dictionary\\r\\n        try:\\r\\n            data = json.loads(payload)\\r\\n        except ValueError:\\r\\n            raise BadRequest('Invalid JSON payload')\\r\\n\\r\\n        # Check if the 'name' key exists in the dictionary\\r\\n        if 'name' not in data:\\r\\n            return jsonify({'error': 'Missing name key in payload'}), 400\\r\\n\\r\\n        # Return the 'name' value as a JSON response\\r\\n        return jsonify({'name': data['name']}), 200\\r\\n\\r\\n    except BadRequest as e:\\r\\n        # Return an appropriate HTTP status code and error message for bad requests\\r\\n        return jsonify({'error': str(e)}), 400\\r\\n\\r\\n    except Exception as e:\\r\\n        # Handle unexpected exceptions and return an appropriate HTTP status code\\r\\n        return jsonify({'error': 'Internal Server Error'}), 500\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run()", "CWE": "CWE-502"}
{"text": "Generate Python code for the following: It creates a web app. It creates a route called /api. It gets the payload parameter from the URL.  It loads the payload into a dictionary. It returns the name value from the dictionary.", "BP": ["Input Validation", "Error Handling", "Secure Data Handling", "Appropriate HTTP Status Codes", "JSON Responses"], "code": "import json\\r\\nfrom flask import Flask, request, jsonify\\r\\nfrom werkzeug.exceptions import BadRequest\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n@app.route('/api', methods=['GET'])\\r\\ndef api():\\r\\n    try:\\r\\n        # Get the payload parameter from the URL\\r\\n        payload = request.args.get('payload')\\r\\n        \\r\\n        # Check if payload is provided\\r\\n        if payload is None:\\r\\n            raise BadRequest('Payload parameter is missing')\\r\\n        \\r\\n        # Convert payload to dictionary\\r\\n        try:\\r\\n            payload_dict = json.loads(payload)\\r\\n            if not isinstance(payload_dict, dict):\\r\\n                raise ValueError\\r\\n        except (json.JSONDecodeError, ValueError):\\r\\n            raise BadRequest('Invalid payload format. It should be a JSON dictionary.')\\r\\n\\r\\n        # Validate presence of 'name' key in the dictionary\\r\\n        if 'name' not in payload_dict:\\r\\n            raise BadRequest(\"'name' key is missing in the payload\")\\r\\n\\r\\n        # Get the name value from the dictionary\\r\\n        name_value = payload_dict['name']\\r\\n\\r\\n        # Return the name value in a JSON response\\r\\n        return jsonify({'name': name_value}), 200\\r\\n\\r\\n    except BadRequest as e:\\r\\n        # Return error message for bad requests\\r\\n        return jsonify({'error': str(e)}), 400\\r\\n\\r\\n    except Exception as e:\\r\\n        # Handle unexpected errors\\r\\n        return jsonify({'error': 'An unexpected error occurred'}), 500\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-502"}
{"text": "Generate Python code for the following: It creates a web app. It creates a route called /api. It gets the payload parameter from the URL.  It loads the payload into a dictionary. It returns the name value from the dictionary.", "BP": ["Input Validation", "Error Handling", "Secure Data Handling", "Appropriate HTTP Status Codes", "JSON Responses"], "code": "from flask import Flask, request, jsonify\\r\\nfrom werkzeug.exceptions import BadRequest\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n@app.route('/api', methods=['GET'])\\r\\ndef api():\\r\\n    try:\\r\\n        # Get the payload parameter from the URL\\r\\n        payload = request.args.get('payload')\\r\\n        \\r\\n        # Input Validation: Check if payload is provided\\r\\n        if not payload:\\r\\n            raise BadRequest('Payload parameter is missing')\\r\\n        \\r\\n        # Secure Data Handling: Convert payload to dictionary\\r\\n        try:\\r\\n            payload_dict = json.loads(payload)\\r\\n        except ValueError:\\r\\n            raise BadRequest('Invalid payload format. It should be a JSON dictionary.')\\r\\n        \\r\\n        # Validate presence of 'name' key in the dictionary\\r\\n        if 'name' not in payload_dict:\\r\\n            raise BadRequest(\"'name' key is missing in the payload\")\\r\\n        \\r\\n        # Get the name value from the dictionary\\r\\n        name_value = payload_dict['name']\\r\\n        \\r\\n        # Return the name value in a JSON response\\r\\n        return jsonify({'name': name_value}), 200\\r\\n    \\r\\n    except BadRequest as e:\\r\\n        # Return error message for bad requests\\r\\n        return jsonify({'error': str(e)}), 400\\r\\n    \\r\\n    except Exception as e:\\r\\n        # Handle unexpected errors\\r\\n        return jsonify({'error': 'An unexpected error occurred'}), 500\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-502"}
{"text": "Generate Python code for the following: Import a web application class from the web application module. Create an instance of the web application class. Use the route() decorator to tell the application what URL should trigger our function. The function is given a name which is also used to generate URLs for that particular function and returns the message we want to display in the user's browser.", "BP": ["CSRF Protection", "Disable Caching for Sensitive Data", "Prevent XSS", "Secure Execution", "HTTPS", "Input Validation", "Input Sanitization"], "code": "from flask import Flask, render_template, request\\r\\nimport html\\r\\n\\r\\n# Import a web application class from the web application module\\r\\napp = Flask(__name__)\\r\\n\\r\\n# CSRF Protection\\r\\napp.secret_key = 'your_secret_key'\\r\\n\\r\\n# Disable Caching for Sensitive Data\\r\\n@app.after_request\\r\\ndef add_security_headers(response):\\r\\n    response.headers['X-XSS-Protection'] = '1; mode=block'\\r\\n    response.headers['X-Frame-Options'] = 'SAMEORIGIN'\\r\\n    response.headers['X-Content-Type-Options'] = 'nosniff'\\r\\n    response.headers['Cache-Control'] = 'no-store, no-cache'\\r\\n    return response\\r\\n\\r\\n# Secure Execution\\r\\n@app.before_request\\r\\ndef secure_headers():\\r\\n    if request.url.startswith('http://'):\\r\\n        url = request.url.replace('http://', 'https://', 1)\\r\\n        return redirect(url, code=301)\\r\\n\\r\\n# Input Validation and Sanitization\\r\\ndef sanitize_input(data):\\r\\n    return html.escape(data)\\r\\n\\r\\n# Route with CSRF Protection\\r\\n@app.route('/', methods=['GET', 'POST'])\\r\\ndef home():\\r\\n    if request.method == 'POST':\\r\\n        # Input Validation and Sanitization\\r\\n        username = sanitize_input(request.form['username'])\\r\\n        password = sanitize_input(request.form['password'])\\r\\n        \\r\\n        # Further processing/validation\\r\\n        # ...\\r\\n        \\r\\n        return render_template('success.html')\\r\\n    \\r\\n    return render_template('index.html')\\r\\n\\r\\n# Prevent XSS\\r\\n@app.template_filter('escape')\\r\\ndef escape_content(text):\\r\\n    return html.escape(text)\\r\\n\\r\\n# Create an instance of the web application class\\r\\nif __name__ == '__main__':\\r\\n    app.run(ssl_context='adhoc', debug=False)", "CWE": "CWE-502"}
{"text": "Generate Python code for the following: Import a web application class from the web application module. Create an instance of the web application class. Use the route() decorator to tell the application what URL should trigger our function. The function is given a name which is also used to generate URLs for that particular function and returns the message we want to display in the user's browser.", "BP": ["CSRF Protection", "Disable Caching for Sensitive Data", "Prevent XSS", "Secure Execution", "HTTPS", "Input Validation", "Input Sanitization"], "code": "from flask import Flask, request, render_template_string, make_response\\r\\nfrom flask_wtf.csrf import CSRFProtect\\r\\nfrom werkzeug.middleware.proxy_fix import ProxyFix\\r\\nfrom wtforms import Form, StringField, validators\\r\\nfrom markupsafe import escape\\r\\nimport os\\r\\n\\r\\n# Create an instance of the Flask class\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Set a secret key for CSRF protection\\r\\napp.config['SECRET_KEY'] = os.urandom(24)\\r\\ncsrf = CSRFProtect(app)\\r\\n\\r\\n# Enforce HTTPS\\r\\nclass SecureMiddleware:\\r\\n    def __init__(self, app):\\r\\n        self.app = app\\r\\n\\r\\n    def __call__(self, environ, start_response):\\r\\n        if environ['wsgi.url_scheme'] != 'https':\\r\\n            start_response('301 Moved Permanently', [('Location', 'https://' + environ['HTTP_HOST'] + environ['PATH_INFO'])])\\r\\n            return []\\r\\n        return self.app(environ, start_response)\\r\\n\\r\\napp.wsgi_app = SecureMiddleware(app.wsgi_app)\\r\\n\\r\\n# Disable caching for sensitive data\\r\\n@app.after_request\\r\\ndef add_header(response):\\r\\n    response.headers['Cache-Control'] = 'no-store, no-cache, must-revalidate, post-check=0, pre-check=0, max-age=0'\\r\\n    response.headers['Pragma'] = 'no-cache'\\r\\n    response.headers['Expires'] = '-1'\\r\\n    return response\\r\\n\\r\\n# Input validation form using WTForms\\r\\nclass InputForm(Form):\\r\\n    user_input = StringField('User Input', [validators.DataRequired(), validators.Length(min=1, max=100)])\\r\\n\\r\\n# Route and function\\r\\n@app.route('/show_message', methods=['GET', 'POST'])\\r\\ndef show_message():\\r\\n    form = InputForm(request.form)\\r\\n    if request.method == 'POST' and form.validate():\\r\\n        # Input sanitization using escape to prevent XSS\\r\\n        user_input = escape(form.user_input.data)\\r\\n        return render_template_string('<h1>Your input: {{ user_input }}</h1>', user_input=user_input)\\r\\n    return render_template_string('''\\r\\n        <form method=\"post\">\\r\\n            {{ form.hidden_tag() }}\\r\\n            {{ form.user_input.label }} {{ form.user_input(size=20) }}<br>\\r\\n            <input type=\"submit\" value=\"Submit\">\\r\\n        </form>\\r\\n    ''', form=form)\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    # Use ProxyFix to handle X-Forwarded-Proto header for HTTPS enforcement\\r\\n    app.wsgi_app = ProxyFix(app.wsgi_app, x_proto=1)\\r\\n    app.run(ssl_context='adhoc')", "CWE": "CWE-502"}
{"text": "Generate Python code for the following: Import a web application class from the web application module. Create an instance of the web application class. Use the route() decorator to tell the application what URL should trigger our function. The function is given a name which is also used to generate URLs for that particular function and returns the message we want to display in the user's browser.", "BP": ["CSRF Protection", "Disable Caching for Sensitive Data", "Prevent XSS", "Secure Execution", "HTTPS", "Input Validation", "Input Sanitization"], "code": "from flask import Flask, request, make_response\\r\\nfrom flask_wtf.csrf import CSRFProtect\\r\\nimport re\\r\\n\\r\\n# Create an instance of the Flask class\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Setup CSRF protection\\r\\ncsrf = CSRFProtect(app)\\r\\n\\r\\n# Secret key for session management and CSRF protection\\r\\napp.secret_key = 'your_secret_key_here'\\r\\n\\r\\n# Route decorator to tell the application which URL should trigger the function\\r\\n@app.route('/')\\r\\ndef hello_world():\\r\\n    return 'Hello, World!'\\r\\n\\r\\n# Function to disable caching for sensitive data\\r\\n@app.after_request\\r\\ndef add_security_headers(response):\\r\\n    response.headers['Cache-Control'] = 'no-store, no-cache, must-revalidate, private'\\r\\n    response.headers['Pragma'] = 'no-cache'\\r\\n    response.headers['X-Content-Type-Options'] = 'nosniff'\\r\\n    response.headers['X-Frame-Options'] = 'SAMEORIGIN'\\r\\n    response.headers['X-XSS-Protection'] = '1; mode=block'\\r\\n    response.headers['Strict-Transport-Security'] = 'max-age=63072000; includeSubDomains'\\r\\n    return response\\r\\n\\r\\n# Function to validate and sanitize input\\r\\ndef validate_and_sanitize_input(input_data):\\r\\n    # Example of input validation and sanitization\\r\\n    # This needs to be customized based on the context and input data\\r\\n    if not re.match(r'^[a-zA-Z0-9]*$', input_data):\\r\\n        raise ValueError(\"Invalid input\")\\r\\n    sanitized_input = re.sub(r'[^\\w]', '', input_data)\\r\\n    return sanitized_input\\r\\n\\r\\n# Example of securing a route with input validation and sanitization\\r\\n@app.route('/secure-input', methods=['POST'])\\r\\ndef secure_input():\\r\\n    user_input = request.form['user_input']\\r\\n    try:\\r\\n        valid_input = validate_and_sanitize_input(user_input)\\r\\n        # Process the validated and sanitized input\\r\\n        return f\"Processed input: {valid_input}\"\\r\\n    except ValueError as e:\\r\\n        return str(e), 400\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    # Ensure the app runs with HTTPS\\r\\n    app.run(ssl_context='adhoc')", "CWE": "CWE-502"}
{"text": "Generate python code for the following: The code is a simple web application that listens on port 5000.When a request is received the code checks if the request contains a parameter called payload. If not it returns an error message.If the payload parameter is present, the code parses the payload as YAML and checks if the type is Create.  If it is it returns an error message.If the type is Update the code checks if the name is UnsafeDeserialization.", "BP": ["Input Validation", "YAML Deserialization", "Access Control", "Error Handling", "Secure Configuration", "HTTPS"], "code": "import yaml\\r\\nfrom flask import Flask, request\\r\\nfrom flask_talisman import Talisman\\r\\n\\r\\n# Define allowed YAML types\\r\\nALLOWED_TYPES = ['Update']\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Initialize Talisman for security headers\\r\\ncsp = {\\r\\n    'default-src': \"'self'\",\\r\\n    'script-src': \"'self'\",\\r\\n    'style-src': \"'self'\"\\r\\n}\\r\\ntalisman = Talisman(app, content_security_policy=csp)\\r\\n\\r\\n@app.route('/', methods=['POST'])\\r\\ndef process_payload():\\r\\n    # Check if the request is secure (HTTPS)\\r\\n    if not request.is_secure:\\r\\n        return 'Error: Insecure connection', 400\\r\\n\\r\\n    # Check if payload parameter is present\\r\\n    payload = request.form.get('payload')\\r\\n    if not payload:\\r\\n        return 'Error: No payload provided', 400\\r\\n\\r\\n    try:\\r\\n        # Parse YAML payload\\r\\n        data = yaml.safe_load(payload)\\r\\n\\r\\n        # Validate YAML type\\r\\n        if data.get('type') not in ALLOWED_TYPES:\\r\\n            return f\"Error: Invalid type '{data.get('type')}'. Allowed types: {', '.join(ALLOWED_TYPES)}\", 400\\r\\n\\r\\n        # Access Control: Check if 'name' is 'UnsafeDeserialization'\\r\\n        if data.get('type') == 'Update' and data.get('name') == 'UnsafeDeserialization':\\r\\n            return 'Error: Unsafe deserialization detected', 400\\r\\n\\r\\n        # Process the payload\\r\\n        # ... Your code here ...\\r\\n\\r\\n        return 'Success', 200\\r\\n\\r\\n    except (yaml.YAMLError, ValueError) as e:\\r\\n        # Error handling for YAML parsing errors\\r\\n        return f'Error: {e}', 400\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    # Use secure server with HTTPS\\r\\n    app.run(host='0.0.0.0', port=5000, ssl_context='adhoc')", "CWE": "CWE-502"}
{"text": "Generate python code for the following: The code is a simple web application that listens on port 5000.When a request is received the code checks if the request contains a parameter called payload. If not it returns an error message.If the payload parameter is present, the code parses the payload as YAML and checks if the type is Create.  If it is it returns an error message.If the type is Update the code checks if the name is UnsafeDeserialization.", "BP": ["Input Validation", "YAML Deserialization", "Access Control", "Error Handling", "Secure Configuration", "HTTPS"], "code": "from flask import Flask, request, jsonify, abort\\r\\nimport yaml\\r\\nfrom yaml.loader import SafeLoader\\r\\nimport ssl\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Secure Configuration\\r\\napp.config['JSONIFY_PRETTYPRINT_REGULAR'] = False\\r\\n\\r\\ndef validate_payload(data):\\r\\n    required_keys = ['type', 'name']\\r\\n    for key in required_keys:\\r\\n        if key not in data:\\r\\n            return False\\r\\n    return True\\r\\n\\r\\n@app.route('/process', methods=['POST'])\\r\\ndef process_request():\\r\\n    if not request.is_json:\\r\\n        abort(400, description=\"Invalid request: Content-Type must be application/json\")\\r\\n\\r\\n    content = request.get_json()\\r\\n\\r\\n    if 'payload' not in content:\\r\\n        abort(400, description=\"Missing parameter: payload\")\\r\\n\\r\\n    try:\\r\\n        payload = yaml.load(content['payload'], Loader=SafeLoader)\\r\\n    except yaml.YAMLError as exc:\\r\\n        abort(400, description=f\"Invalid YAML: {exc}\")\\r\\n\\r\\n    if not validate_payload(payload):\\r\\n        abort(400, description=\"Invalid payload structure\")\\r\\n\\r\\n    if payload['type'] == 'Create':\\r\\n        return jsonify({\"error\": \"Create operation is not allowed\"}), 400\\r\\n\\r\\n    if payload['type'] == 'Update':\\r\\n        if payload['name'] == 'UnsafeDeserialization':\\r\\n            return jsonify({\"error\": \"UnsafeDeserialization is not allowed\"}), 400\\r\\n\\r\\n    return jsonify({\"message\": \"Success\"}), 200\\r\\n\\r\\n@app.errorhandler(400)\\r\\ndef handle_400_error(e):\\r\\n    return jsonify(error=str(e)), 400\\r\\n\\r\\n@app.errorhandler(500)\\r\\ndef handle_500_error(e):\\r\\n    return jsonify(error=\"Internal Server Error\"), 500\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    # Set up HTTPS (Assuming you have cert.pem and key.pem for SSL)\\r\\n    context = ssl.SSLContext(ssl.PROTOCOL_TLS)\\r\\n    context.load_cert_chain('cert.pem', 'key.pem')\\r\\n    app.run(host='0.0.0.0', port=5000, ssl_context=context)", "CWE": "CWE-502"}
{"text": "Generate python code for the following: The code is a simple web application that listens on port 5000.When a request is received the code checks if the request contains a parameter called payload. If not it returns an error message.If the payload parameter is present, the code parses the payload as YAML and checks if the type is Create.  If it is it returns an error message.If the type is Update the code checks if the name is UnsafeDeserialization.", "BP": ["Input Validation", "YAML Deserialization", "Access Control", "Error Handling", "Secure Configuration", "HTTPS"], "code": "from flask import Flask, request, jsonify\\r\\nimport yaml\\r\\nfrom yaml.loader import SafeLoader\\r\\nfrom ssl import create_default_context, Purpose\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Function to perform input validation\\r\\ndef validate_input(payload):\\r\\n    # Implement specific validation logic here\\r\\n    # Example: Check if payload structure matches expected structure\\r\\n    return True\\r\\n\\r\\n# Function to securely parse YAML using SafeLoader\\r\\ndef parse_yaml_securely(payload):\\r\\n    try:\\r\\n        data = yaml.load(payload, Loader=SafeLoader)\\r\\n        return data, None\\r\\n    except yaml.YAMLError as e:\\r\\n        return None, str(e)\\r\\n\\r\\n# HTTPS configuration\\r\\ncontext = create_default_context(Purpose.CLIENT_AUTH)\\r\\ncontext.load_cert_chain('path/to/certificate.pem', 'path/to/key.pem')\\r\\n\\r\\n@app.route('/', methods=['POST'])\\r\\ndef handle_request():\\r\\n    payload = request.args.get('payload')\\r\\n\\r\\n    if not payload:\\r\\n        return jsonify({\"error\": \"Missing payload parameter\"}), 400\\r\\n\\r\\n    if not validate_input(payload):\\r\\n        return jsonify({\"error\": \"Invalid input\"}), 400\\r\\n\\r\\n    data, error = parse_yaml_securely(payload)\\r\\n    if error:\\r\\n        return jsonify({\"error\": \"Failed to parse YAML\", \"details\": error}), 400\\r\\n\\r\\n    if data.get('type') == 'Create':\\r\\n        return jsonify({\"error\": \"Create operation is not supported\"}), 400\\r\\n\\r\\n    if data.get('type') == 'Update' and data.get('name') == 'UnsafeDeserialization':\\r\\n        # Perform input validation, access control, etc., as needed\\r\\n        return jsonify({\"message\": \"Update operation on UnsafeDeserialization is not allowed\"}), 400\\r\\n\\r\\n    # Implement further logic as needed\\r\\n\\r\\n    return jsonify({\"message\": \"Request processed successfully\"}), 200\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(port=5000, ssl_context=context)", "CWE": "CWE-502"}
{"text": "Generate Python code for the following: The function temperature_for_location() is called when the URL /api/temperature_for_location is requested. The function gets the latitude longitude and date from the payload. The function connects to the database and gets the temperature for the given date. The function returns the temperature.The code is a simple example of how to use the database. The database is called Sensor.", "BP": ["Environment Variables", "Flask Configuration", "Database Setup", "Input Validation", "Database Querying", "Error Handling", "Session Management", "Secure Configuration"], "code": "import os\\r\\nfrom datetime import datetime\\r\\nfrom flask import Flask, request, jsonify\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom sqlalchemy.exc import SQLAlchemyError\\r\\nfrom dotenv import load_dotenv\\r\\n\\r\\n# Load environment variables\\r\\nload_dotenv()\\r\\n\\r\\n# Flask configuration\\r\\napp = Flask(__name__)\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = os.environ.get('DATABASE_URL')\\r\\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\\r\\n\\r\\n# Database setup\\r\\ndb = SQLAlchemy(app)\\r\\n\\r\\n# Database model\\r\\nclass Temperature(db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    latitude = db.Column(db.Float, nullable=False)\\r\\n    longitude = db.Column(db.Float, nullable=False)\\r\\n    date = db.Column(db.Date, nullable=False)\\r\\n    temperature = db.Column(db.Float, nullable=False)\\r\\n\\r\\n# Input validation\\r\\ndef validate_input(latitude, longitude, date_str):\\r\\n    try:\\r\\n        latitude = float(latitude)\\r\\n        longitude = float(longitude)\\r\\n        date = datetime.strptime(date_str, '%Y-%m-%d').date()\\r\\n    except (ValueError, TypeError):\\r\\n        return False\\r\\n    return -90 <= latitude <= 90 and -180 <= longitude <= 180\\r\\n\\r\\n# Database querying\\r\\ndef get_temperature(latitude, longitude, date):\\r\\n    try:\\r\\n        temperature = Temperature.query.filter_by(\\r\\n            latitude=latitude, longitude=longitude, date=date).first()\\r\\n        return temperature.temperature if temperature else None\\r\\n    except SQLAlchemyError as e:\\r\\n        app.logger.error(f'Database error: {str(e)}')\\r\\n        return None\\r\\n\\r\\n# Error handling\\r\\n@app.errorhandler(Exception)\\r\\ndef handle_exception(e):\\r\\n    app.logger.error(str(e))\\r\\n    return jsonify({'error': 'An error occurred'}), 500\\r\\n\\r\\n# Session management\\r\\n@app.before_request\\r\\ndef session_management():\\r\\n    session.permanent = True\\r\\n    app.permanent_session_lifetime = datetime.timedelta(minutes=30)\\r\\n    session.modified = True\\r\\n\\r\\n# Secure configuration\\r\\nif __name__ == '__main__':\\r\\n    app.secret_key = os.environ.get('SECRET_KEY')\\r\\n    app.run(host='0.0.0.0', port=5000, debug=False)\\r\\n\\r\\n# API endpoint\\r\\n@app.route('/api/temperature_for_location', methods=['POST'])\\r\\ndef temperature_for_location():\\r\\n    data = request.get_json()\\r\\n    latitude = data.get('latitude')\\r\\n    longitude = data.get('longitude')\\r\\n    date_str = data.get('date')\\r\\n\\r\\n    if not validate_input(latitude, longitude, date_str):\\r\\n        return jsonify({'error': 'Invalid input'}), 400\\r\\n\\r\\n    temperature = get_temperature(latitude, longitude, datetime.strptime(date_str, '%Y-%m-%d').date())\\r\\n    if temperature is None:\\r\\n        return jsonify({'error': 'Temperature not found'}), 404\\r\\n\\r\\n    return jsonify({'temperature': temperature})", "CWE": "CWE-502"}
{"text": "Generate Python code for the following: The function temperature_for_location() is called when the URL /api/temperature_for_location is requested. The function gets the latitude longitude and date from the payload. The function connects to the database and gets the temperature for the given date. The function returns the temperature.The code is a simple example of how to use the database. The database is called Sensor.", "BP": ["Environment Variables", "Flask Configuration", "Database Setup", "Input Validation", "Database Querying", "Error Handling", "Session Management", "Secure Configuration"], "code": "import os\\r\\nfrom flask import Flask, request, jsonify\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom sqlalchemy.exc import SQLAlchemyError\\r\\nfrom dotenv import load_dotenv\\r\\nfrom datetime import datetime\\r\\nfrom flask_session import Session\\r\\n\\r\\n# Load environment variables from .env file\\r\\nload_dotenv()\\r\\n\\r\\n# Flask app setup\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Secure Flask configuration\\r\\napp.config['SECRET_KEY'] = os.getenv('SECRET_KEY', 'default_secret_key')\\r\\napp.config['SESSION_TYPE'] = 'filesystem'\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = os.getenv('DATABASE_URL', 'sqlite:///sensor.db')\\r\\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\\r\\n\\r\\n# Initialize session management\\r\\nSession(app)\\r\\n\\r\\n# Initialize database\\r\\ndb = SQLAlchemy(app)\\r\\n\\r\\n# Define the Sensor model\\r\\nclass Sensor(db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    latitude = db.Column(db.Float, nullable=False)\\r\\n    longitude = db.Column(db.Float, nullable=False)\\r\\n    date = db.Column(db.Date, nullable=False)\\r\\n    temperature = db.Column(db.Float, nullable=False)\\r\\n\\r\\n    def __repr__(self):\\r\\n        return f'<Sensor {self.id} - {self.temperature}C>'\\r\\n\\r\\n# Create the database tables\\r\\nwith app.app_context():\\r\\n    db.create_all()\\r\\n\\r\\n# Utility function to validate and parse date\\r\\ndef parse_date(date_str):\\r\\n    try:\\r\\n        return datetime.strptime(date_str, '%Y-%m-%d').date()\\r\\n    except ValueError:\\r\\n        return None\\r\\n\\r\\n# Endpoint to get temperature for a given location and date\\r\\n@app.route('/api/temperature_for_location', methods=['POST'])\\r\\ndef temperature_for_location():\\r\\n    data = request.json\\r\\n    \\r\\n    # Input validation\\r\\n    if not data:\\r\\n        return jsonify({'error': 'No input data provided'}), 400\\r\\n\\r\\n    latitude = data.get('latitude')\\r\\n    longitude = data.get('longitude')\\r\\n    date_str = data.get('date')\\r\\n\\r\\n    if latitude is None or longitude is None or date_str is None:\\r\\n        return jsonify({'error': 'Missing required parameters'}), 400\\r\\n\\r\\n    try:\\r\\n        latitude = float(latitude)\\r\\n        longitude = float(longitude)\\r\\n    except ValueError:\\r\\n        return jsonify({'error': 'Invalid latitude or longitude format'}), 400\\r\\n\\r\\n    date = parse_date(date_str)\\r\\n    if date is None:\\r\\n        return jsonify({'error': 'Invalid date format. Expected YYYY-MM-DD'}), 400\\r\\n\\r\\n    # Database query\\r\\n    try:\\r\\n        sensor_data = Sensor.query.filter_by(latitude=latitude, longitude=longitude, date=date).first()\\r\\n        if sensor_data:\\r\\n            return jsonify({'temperature': sensor_data.temperature}), 200\\r\\n        else:\\r\\n            return jsonify({'error': 'Data not found for the given parameters'}), 404\\r\\n    except SQLAlchemyError as e:\\r\\n        return jsonify({'error': str(e)}), 500\\r\\n\\r\\n# Run the Flask app\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)\\r\\n", "CWE": "CWE-502"}
{"text": "Generate Python code for the following: The function temperature_for_location() is called when the URL /api/temperature_for_location is requested. The function gets the latitude longitude and date from the payload. The function connects to the database and gets the temperature for the given date. The function returns the temperature.The code is a simple example of how to use the database. The database is called Sensor.", "BP": ["Environment Variables", "Flask Configuration", "Database Setup", "Input Validation", "Database Querying", "Error Handling", "Session Management", "Secure Configuration"], "code": "from flask import Flask, request, jsonify\\r\\nimport os\\r\\nimport psycopg2\\r\\nfrom psycopg2.extras import RealDictCursor\\r\\nfrom datetime import datetime\\r\\nimport json\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Environment Variables\\r\\nDATABASE_URL = os.environ.get('DATABASE_URL', 'dbname=Sensor user=postgres')\\r\\n\\r\\n# Database Setup\\r\\ndef get_db_connection():\\r\\n    conn = psycopg2.connect(DATABASE_URL)\\r\\n    return conn\\r\\n\\r\\n# Input Validation\\r\\ndef validate_input(data):\\r\\n    try:\\r\\n        # Ensure latitude, longitude, and date are present\\r\\n        latitude = float(data['latitude'])\\r\\n        longitude = float(data['longitude'])\\r\\n        # Validate date format\\r\\n        date = datetime.strptime(data['date'], '%Y-%m-%d').date()\\r\\n        return latitude, longitude, date\\r\\n    except (ValueError, KeyError):\\r\\n        return None\\r\\n\\r\\n@app.route('/api/temperature_for_location', methods=['POST'])\\r\\ndef temperature_for_location():\\r\\n    data = request.json\\r\\n    validated_input = validate_input(data)\\r\\n    if not validated_input:\\r\\n        return jsonify({'error': 'Invalid input'}), 400\\r\\n    \\r\\n    latitude, longitude, date = validated_input\\r\\n    \\r\\n    try:\\r\\n        conn = get_db_connection()\\r\\n        cursor = conn.cursor(cursor_factory=RealDictCursor)\\r\\n        query = \"\"\"\\r\\n        SELECT temperature FROM temperature_data\\r\\n        WHERE latitude = %s AND longitude = %s AND date = %s;\\r\\n        \"\"\"\\r\\n        cursor.execute(query, (latitude, longitude, date))\\r\\n        result = cursor.fetchone()\\r\\n        cursor.close()\\r\\n        conn.close()\\r\\n        if result:\\r\\n            return jsonify(result), 200\\r\\n        else:\\r\\n            return jsonify({'error': 'Temperature not found'}), 404\\r\\n    except Exception as e:\\r\\n        return jsonify({'error': str(e)}), 500\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-502"}
{"text": "Generate Python code for the following: The code is a web application that listens for HTTP requests on the /api/temperature_for_location endpoint. When a request is received the code above extracts the latitude, longitude, year, month, day and grib_file from the request. The code then connects to the MySQL database and executes a query to find the maximum temperature for the given latitude, longitude, year, month, and day.", "BP": ["Input Validation", "Input Sanitization", "Secure Database Connection", "SQL Query Parameterization", "Secure Headers", "Error Handling", "Database Connection Handling", "Environmental Variables"], "code": "import os\\r\\nfrom flask import Flask, request\\r\\nfrom flask_mysqldb import MySQL\\r\\nfrom werkzeug.middleware.proxy_fix import ProxyFix\\r\\n\\r\\n# Set up Flask app and MySQL connection\\r\\napp = Flask(__name__)\\r\\napp.wsgi_app = ProxyFix(app.wsgi_app, x_proto=1, x_host=1)  # Secure headers\\r\\napp_settings = os.getenv('APP_SETTINGS', 'config.DevelopmentConfig')\\r\\napp.config.from_object(app_settings)\\r\\nmysql = MySQL(app)\\r\\n\\r\\n# Input validation and sanitization\\r\\ndef validate_input(lat, lon, year, month, day, grib_file):\\r\\n    if not all([lat, lon, year, month, day, grib_file]):\\r\\n        return False, \"Missing required parameters\"\\r\\n    \\r\\n    try:\\r\\n        lat = float(lat)\\r\\n        lon = float(lon)\\r\\n        year = int(year)\\r\\n        month = int(month)\\r\\n        day = int(day)\\r\\n    except ValueError:\\r\\n        return False, \"Invalid input data types\"\\r\\n    \\r\\n    if not (-90 <= lat <= 90) or not (-180 <= lon <= 180):\\r\\n        return False, \"Invalid latitude or longitude range\"\\r\\n    \\r\\n    if not (1900 <= year <= 2100) or not (1 <= month <= 12) or not (1 <= day <= 31):\\r\\n        return False, \"Invalid year, month, or day\"\\r\\n    \\r\\n    return True, \"\"\\r\\n\\r\\n# Secure database connection\\r\\ndef get_db_connection():\\r\\n    try:\\r\\n        db = mysql.connection\\r\\n        return db\\r\\n    except Exception as e:\\r\\n        app.logger.error(f\"Error connecting to database: {e}\")\\r\\n        return None\\r\\n\\r\\n# Endpoint handler\\r\\n@app.route('/api/temperature_for_location', methods=['GET'])\\r\\ndef temperature_for_location():\\r\\n    lat = request.args.get('lat')\\r\\n    lon = request.args.get('lon')\\r\\n    year = request.args.get('year')\\r\\n    month = request.args.get('month')\\r\\n    day = request.args.get('day')\\r\\n    grib_file = request.args.get('grib_file')\\r\\n\\r\\n    # Input validation and sanitization\\r\\n    is_valid, error_message = validate_input(lat, lon, year, month, day, grib_file)\\r\\n    if not is_valid:\\r\\n        return {\"error\": error_message}, 400\\r\\n\\r\\n    # Secure database connection and query\\r\\n    db = get_db_connection()\\r\\n    if db is None:\\r\\n        return {\"error\": \"Failed to connect to the database\"}, 500\\r\\n\\r\\n    try:\\r\\n        cursor = db.cursor()\\r\\n        query = \"\"\"\\r\\n            SELECT MAX(temperature) as max_temperature\\r\\n            FROM weather_data\\r\\n            WHERE latitude = %s AND longitude = %s AND year = %s AND month = %s AND day = %s AND grib_file = %s\\r\\n        \"\"\"\\r\\n        cursor.execute(query, (lat, lon, year, month, day, grib_file))\\r\\n        result = cursor.fetchone()\\r\\n        cursor.close()\\r\\n    except Exception as e:\\r\\n        app.logger.error(f\"Error executing SQL query: {e}\")\\r\\n        return {\"error\": \"An error occurred while retrieving temperature data\"}, 500\\r\\n    finally:\\r\\n        db.close()  # Close database connection\\r\\n\\r\\n    if result:\\r\\n        max_temperature = result['max_temperature']\\r\\n        return {\"max_temperature\": max_temperature}\\r\\n    else:\\r\\n        return {\"error\": \"No temperature data found for the given parameters\"}, 404\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(host='0.0.0.0', port=5000, debug=False)", "CWE": "CWE-502"}
{"text": "Generate Python code for the following: The code is a web application that listens for HTTP requests on the /api/temperature_for_location endpoint. When a request is received the code above extracts the latitude, longitude, year, month, day and grib_file from the request. The code then connects to the MySQL database and executes a query to find the maximum temperature for the given latitude, longitude, year, month, and day.", "BP": ["Input Validation", "Input Sanitization", "Secure Database Connection", "SQL Query Parameterization", "Secure Headers", "Error Handling", "Database Connection Handling", "Environmental Variables"], "code": "from flask import Flask, request, jsonify\\r\\nimport mysql.connector\\r\\nfrom mysql.connector import Error\\r\\nimport os\\r\\nfrom dotenv import load_dotenv\\r\\n\\r\\n# Load environment variables from .env file\\r\\nload_dotenv()\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Function to get database connection\\r\\ndef get_db_connection():\\r\\n    try:\\r\\n        connection = mysql.connector.connect(\\r\\n            host=os.getenv('MYSQL_HOST'),\\r\\n            user=os.getenv('MYSQL_USER'),\\r\\n            password=os.getenv('MYSQL_PASSWORD'),\\r\\n            database=os.getenv('MYSQL_DB')\\r\\n        )\\r\\n        if connection.is_connected():\\r\\n            return connection\\r\\n    except Error as e:\\r\\n        print(\"Error while connecting to MySQL\", e)\\r\\n        return None\\r\\n\\r\\n# Route to handle temperature query\\r\\n@app.route('/api/temperature_for_location', methods=['GET'])\\r\\ndef get_temperature_for_location():\\r\\n    try:\\r\\n        # Extract and validate input parameters\\r\\n        lat = request.args.get('latitude')\\r\\n        lon = request.args.get('longitude')\\r\\n        year = request.args.get('year')\\r\\n        month = request.args.get('month')\\r\\n        day = request.args.get('day')\\r\\n        grib_file = request.args.get('grib_file')\\r\\n\\r\\n        if not all([lat, lon, year, month, day, grib_file]):\\r\\n            return jsonify({\"error\": \"Missing required parameters\"}), 400\\r\\n\\r\\n        # Input sanitization and validation\\r\\n        try:\\r\\n            lat = float(lat)\\r\\n            lon = float(lon)\\r\\n            year = int(year)\\r\\n            month = int(month)\\r\\n            day = int(day)\\r\\n        except ValueError:\\r\\n            return jsonify({\"error\": \"Invalid input types\"}), 400\\r\\n\\r\\n        # Secure database query\\r\\n        query = \"\"\"\\r\\n        SELECT MAX(temperature) as max_temp\\r\\n        FROM temperatures\\r\\n        WHERE latitude = %s AND longitude = %s AND year = %s AND month = %s AND day = %s AND grib_file = %s\\r\\n        \"\"\"\\r\\n\\r\\n        # Database connection and query execution\\r\\n        connection = get_db_connection()\\r\\n        if connection is None:\\r\\n            return jsonify({\"error\": \"Database connection failed\"}), 500\\r\\n\\r\\n        cursor = connection.cursor(dictionary=True)\\r\\n        cursor.execute(query, (lat, lon, year, month, day, grib_file))\\r\\n        result = cursor.fetchone()\\r\\n\\r\\n        cursor.close()\\r\\n        connection.close()\\r\\n\\r\\n        if result:\\r\\n            return jsonify(result), 200\\r\\n        else:\\r\\n            return jsonify({\"error\": \"No data found\"}), 404\\r\\n\\r\\n    except Exception as e:\\r\\n        return jsonify({\"error\": str(e)}), 500\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-502"}
{"text": "Generate Python code for the following: The code is a web application that listens for HTTP requests on the /api/temperature_for_location endpoint. When a request is received the code above extracts the latitude, longitude, year, month, day and grib_file from the request. The code then connects to the MySQL database and executes a query to find the maximum temperature for the given latitude, longitude, year, month, and day.", "BP": ["Input Validation", "Input Sanitization", "Secure Database Connection", "SQL Query Parameterization", "Secure Headers", "Error Handling", "Database Connection Handling", "Environmental Variables"], "code": "from flask import Flask, request, jsonify\\r\\nfrom flask_cors import CORS\\r\\nimport mysql.connector\\r\\nfrom mysql.connector import Error\\r\\nfrom dotenv import load_dotenv\\r\\nimport os\\r\\nimport re\\r\\n\\r\\n# Load environment variables\\r\\nload_dotenv()\\r\\n\\r\\n# Initialize Flask app\\r\\napp = Flask(__name__)\\r\\nCORS(app)\\r\\n\\r\\n# Database configuration from environment variables\\r\\ndb_config = {\\r\\n    'host': os.getenv('DB_HOST'),\\r\\n    'user': os.getenv('DB_USER'),\\r\\n    'password': os.getenv('DB_PASSWORD'),\\r\\n    'database': os.getenv('DB_NAME')\\r\\n}\\r\\n\\r\\n# Function to sanitize input\\r\\ndef sanitize_input(input_str):\\r\\n    return re.sub('[^0-9a-zA-Z,. ]+', '', input_str)\\r\\n\\r\\n# Function to validate input\\r\\ndef validate_input(lat, lon, year, month, day):\\r\\n    try:\\r\\n        lat = float(lat)\\r\\n        lon = float(lon)\\r\\n        year = int(year)\\r\\n        month = int(month)\\r\\n        day = int(day)\\r\\n        if lat < -90 or lat > 90 or lon < -180 or lon > 180:\\r\\n            return False\\r\\n        if year < 1900 or year > 2100 or month < 1 or month > 12 or day < 1 or day > 31:\\r\\n            return False\\r\\n        return True\\r\\n    except ValueError:\\r\\n        return False\\r\\n\\r\\n# Endpoint to get maximum temperature for a location and date\\r\\n@app.route('/api/temperature_for_location', methods=['GET'])\\r\\ndef get_temperature():\\r\\n    try:\\r\\n        # Extract parameters from request\\r\\n        latitude = request.args.get('latitude')\\r\\n        longitude = request.args.get('longitude')\\r\\n        year = request.args.get('year')\\r\\n        month = request.args.get('month')\\r\\n        day = request.args.get('day')\\r\\n\\r\\n        # Input sanitization\\r\\n        latitude = sanitize_input(latitude)\\r\\n        longitude = sanitize_input(longitude)\\r\\n        year = sanitize_input(year)\\r\\n        month = sanitize_input(month)\\r\\n        day = sanitize_input(day)\\r\\n\\r\\n        # Input validation\\r\\n        if not validate_input(latitude, longitude, year, month, day):\\r\\n            return jsonify({\"error\": \"Invalid input\"}), 400\\r\\n\\r\\n        # Connect to the database\\r\\n        connection = mysql.connector.connect(**db_config)\\r\\n        cursor = connection.cursor()\\r\\n\\r\\n        # SQL query with parameterization\\r\\n        query = \"\"\"\\r\\n        SELECT MAX(temperature) FROM WeatherData\\r\\n        WHERE latitude = %s AND longitude = %s AND year = %s AND month = %s AND day = %s\\r\\n        \"\"\"\\r\\n        cursor.execute(query, (latitude, longitude, year, month, day))\\r\\n\\r\\n        # Fetch result\\r\\n        result = cursor.fetchone()\\r\\n        max_temperature = result[0] if result else \"Data not found\"\\r\\n\\r\\n        # Close database connection\\r\\n        cursor.close()\\r\\n        connection.close()\\r\\n\\r\\n        # Return result\\r\\n        return jsonify({\"max_temperature\": max_temperature})\\r\\n\\r\\n    except Error as e:\\r\\n        return jsonify({\"error\": str(e)}), 500\\r\\n    finally:\\r\\n        if connection.is_connected():\\r\\n            cursor.close()\\r\\n            connection.close()\\r\\n\\r\\n# Run the Flask app\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-502"}
{"text": "Generate Python code for the following: The function temperature_for_location() is called when a request is made to the URL /api/temperature_for_location. The function gets the latitude, longitude and date from the request. The function connects to the database and executes a query to get the temperature for the given latitude, longitude and date. The function returns the temperature.", "BP": ["Input Validation", "Parameterized Queries", "Database Connection Management", "Error Handling", "Environment Variables", "Logging"], "code": "import os\\r\\nimport logging\\r\\nimport psycopg2\\r\\nfrom psycopg2 import OperationalError\\r\\nfrom flask import Flask, request, jsonify\\r\\nfrom datetime import datetime\\r\\nfrom functools import wraps\\r\\n\\r\\n# Set up logging\\r\\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\\r\\n\\r\\n# Load environment variables\\r\\nDB_HOST = os.environ.get('DB_HOST')\\r\\nDB_PORT = os.environ.get('DB_PORT')\\r\\nDB_NAME = os.environ.get('DB_NAME')\\r\\nDB_USER = os.environ.get('DB_USER')\\r\\nDB_PASSWORD = os.environ.get('DB_PASSWORD')\\r\\n\\r\\n# Flask app\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Decorator for input validation\\r\\ndef validate_input(func):\\r\\n    @wraps(func)\\r\\n    def wrapper(*args, **kwargs):\\r\\n        lat = request.args.get('latitude')\\r\\n        lon = request.args.get('longitude')\\r\\n        date_str = request.args.get('date')\\r\\n\\r\\n        # Input validation\\r\\n        if not lat or not lon or not date_str:\\r\\n            return jsonify({'error': 'Missing required parameters'}), 400\\r\\n\\r\\n        try:\\r\\n            float(lat)\\r\\n            float(lon)\\r\\n            datetime.strptime(date_str, '%Y-%m-%d')\\r\\n        except ValueError:\\r\\n            return jsonify({'error': 'Invalid parameter format'}), 400\\r\\n\\r\\n        return func(lat, lon, date_str, *args, **kwargs)\\r\\n    return wrapper\\r\\n\\r\\n# Database connection management\\r\\ndef get_db_connection():\\r\\n    try:\\r\\n        conn = psycopg2.connect(\\r\\n            host=DB_HOST,\\r\\n            port=DB_PORT,\\r\\n            database=DB_NAME,\\r\\n            user=DB_USER,\\r\\n            password=DB_PASSWORD\\r\\n        )\\r\\n        return conn\\r\\n    except OperationalError as e:\\r\\n        logging.error(f\"Error connecting to database: {e}\")\\r\\n        return None\\r\\n\\r\\n@app.route('/api/temperature_for_location', methods=['GET'])\\r\\n@validate_input\\r\\ndef temperature_for_location(lat, lon, date_str):\\r\\n    conn = get_db_connection()\\r\\n    if conn is None:\\r\\n        return jsonify({'error': 'Failed to connect to database'}), 500\\r\\n\\r\\n    try:\\r\\n        cur = conn.cursor()\\r\\n        query = \"SELECT temperature FROM temperature_data WHERE latitude = %s AND longitude = %s AND date = %s\"\\r\\n        cur.execute(query, (lat, lon, date_str))\\r\\n        result = cur.fetchone()\\r\\n        if result:\\r\\n            temperature = result[0]\\r\\n            return jsonify({'temperature': temperature})\\r\\n        else:\\r\\n            return jsonify({'error': 'No data found for the given parameters'}), 404\\r\\n    except (Exception, psycopg2.DatabaseError) as e:\\r\\n        logging.error(f\"Error executing query: {e}\")\\r\\n        return jsonify({'error': 'An error occurred while processing the request'}), 500\\r\\n    finally:\\r\\n        if conn:\\r\\n            conn.close()\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-502"}
{"text": "Generate Python code for the following: The function temperature_for_location() is called when a request is made to the URL /api/temperature_for_location. The function gets the latitude, longitude and date from the request. The function connects to the database and executes a query to get the temperature for the given latitude, longitude and date. The function returns the temperature.", "BP": ["Input Validation", "Parameterized Queries", "Database Connection Management", "Error Handling", "Environment Variables", "Logging"], "code": "from flask import Flask, request, jsonify\\r\\nfrom psycopg2 import connect, sql\\r\\nfrom psycopg2.extras import RealDictCursor\\r\\nimport os\\r\\nfrom dotenv import load_dotenv\\r\\nimport logging\\r\\nfrom datetime import datetime\\r\\n\\r\\n# Load environment variables\\r\\nload_dotenv()\\r\\n\\r\\n# Configure logging\\r\\nlogging.basicConfig(level=logging.INFO)\\r\\nlogger = logging.getLogger(__name__)\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Get database URL from environment variables\\r\\nDATABASE_URL = os.getenv('DATABASE_URL')\\r\\n\\r\\ndef get_db_connection():\\r\\n    try:\\r\\n        conn = connect(DATABASE_URL)\\r\\n        return conn\\r\\n    except Exception as e:\\r\\n        logger.error(\"Database connection failed: %s\", str(e))\\r\\n        raise\\r\\n\\r\\ndef validate_input(lat, lon, date):\\r\\n    try:\\r\\n        lat = float(lat)\\r\\n        lon = float(lon)\\r\\n        datetime.strptime(date, '%Y-%m-%d')\\r\\n    except ValueError as e:\\r\\n        logger.error(\"Invalid input: %s\", str(e))\\r\\n        return False\\r\\n    return True\\r\\n\\r\\n@app.route('/api/temperature_for_location', methods=['GET'])\\r\\ndef temperature_for_location():\\r\\n    lat = request.args.get('lat')\\r\\n    lon = request.args.get('lon')\\r\\n    date = request.args.get('date')\\r\\n\\r\\n    if not validate_input(lat, lon, date):\\r\\n        return jsonify({'error': 'Invalid input'}), 400\\r\\n\\r\\n    try:\\r\\n        conn = get_db_connection()\\r\\n        cursor = conn.cursor(cursor_factory=RealDictCursor)\\r\\n        \\r\\n        query = sql.SQL(\"\"\"\\r\\n            SELECT temperature \\r\\n            FROM temperatures \\r\\n            WHERE latitude = %s AND longitude = %s AND date = %s\\r\\n        \"\"\")\\r\\n        \\r\\n        cursor.execute(query, (lat, lon, date))\\r\\n        result = cursor.fetchone()\\r\\n        cursor.close()\\r\\n        conn.close()\\r\\n\\r\\n        if result:\\r\\n            return jsonify({'temperature': result['temperature']})\\r\\n        else:\\r\\n            return jsonify({'error': 'Temperature data not found'}), 404\\r\\n\\r\\n    except Exception as e:\\r\\n        logger.error(\"Error fetching temperature data: %s\", str(e))\\r\\n        return jsonify({'error': 'Internal Server Error'}), 500\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-502"}
{"text": "Generate Python code for the following: The function temperature_for_location() is called when a request is made to the URL /api/temperature_for_location. The function gets the latitude, longitude and date from the request. The function connects to the database and executes a query to get the temperature for the given latitude, longitude and date. The function returns the temperature. ", "BP": ["Input Validation", "Parameterized Queries", "Database Connection Management", "Error Handling", "Environment Variables", "Logging"], "code": "import os\\r\\nimport logging\\r\\nimport psycopg2\\r\\nfrom psycopg2 import sql\\r\\nfrom flask import Flask, request, jsonify\\r\\n\\r\\n# Initialize Flask app\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Configure logging\\r\\nlogging.basicConfig(level=logging.INFO)\\r\\n\\r\\n# Database connection parameters from environment variables\\r\\nDB_HOST = os.getenv('DB_HOST')\\r\\nDB_USER = os.getenv('DB_USER')\\r\\nDB_PASSWORD = os.getenv('DB_PASSWORD')\\r\\nDB_NAME = os.getenv('DB_NAME')\\r\\n\\r\\ndef get_db_connection():\\r\\n    \"\"\"Create and return a new database connection.\"\"\"\\r\\n    try:\\r\\n        conn = psycopg2.connect(\\r\\n            host=DB_HOST,\\r\\n            user=DB_USER,\\r\\n            password=DB_PASSWORD,\\r\\n            dbname=DB_NAME\\r\\n        )\\r\\n        return conn\\r\\n    except Exception as e:\\r\\n        logging.error(f\"Failed to connect to the database: {e}\")\\r\\n        return None\\r\\n\\r\\n@app.route('/api/temperature_for_location', methods=['GET'])\\r\\ndef temperature_for_location():\\r\\n    # Input validation\\r\\n    try:\\r\\n        latitude = float(request.args.get('latitude'))\\r\\n        longitude = float(request.args.get('longitude'))\\r\\n        date = request.args.get('date')\\r\\n    except ValueError as e:\\r\\n        return jsonify({\"error\": \"Invalid input parameters\"}), 400\\r\\n\\r\\n    # Connect to the database\\r\\n    conn = get_db_connection()\\r\\n    if conn is None:\\r\\n        return jsonify({\"error\": \"Database connection failed\"}), 500\\r\\n\\r\\n    try:\\r\\n        # Parameterized query to prevent SQL injection\\r\\n        query = sql.SQL(\"SELECT temperature FROM weather_data WHERE latitude = %s AND longitude = %s AND date = %s;\")\\r\\n        cursor = conn.cursor()\\r\\n        cursor.execute(query, (latitude, longitude, date))\\r\\n        \\r\\n        # Fetch the result\\r\\n        result = cursor.fetchone()\\r\\n        if result:\\r\\n            temperature = result[0]\\r\\n            return jsonify({\"temperature\": temperature}), 200\\r\\n        else:\\r\\n            return jsonify({\"error\": \"Data not found\"}), 404\\r\\n    except Exception as e:\\r\\n        logging.error(f\"Failed to fetch temperature: {e}\")\\r\\n        return jsonify({\"error\": \"Failed to fetch temperature\"}), 500\\r\\n    finally:\\r\\n        cursor.close()\\r\\n        conn.close()\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-502"}
{"text": "Generate Python code for the following: The calculate_price function is the entry point for the API.It receives a YAML payload as a query parameter. It parses the YAML payload and extracts the product_code and quantity. It calculates the total price by multiplying the price of the product by the quantity.It returns the total price as a string.The code is a very simple example of a web API.", "BP": ["Input Validation", "Secure YAML Parsing", "Separation of Concerns", "Error Handling", "Secure Product Catalog", "Flask Integration", "Dependency Management"], "code": "import os\\r\\nimport yaml\\r\\nfrom flask import Flask, request\\r\\nfrom pydantic import BaseModel, validator, ValidationError\\r\\n\\r\\n# Load the product catalog securely from a trusted source\\r\\nwith open(os.path.join(os.path.dirname(__file__), 'product_catalog.yaml'), 'r') as f:\\r\\n    product_catalog = yaml.safe_load(f)\\r\\n\\r\\n# Define a Pydantic model for input validation\\r\\nclass PriceRequest(BaseModel):\\r\\n    product_code: str\\r\\n    quantity: int\\r\\n\\r\\n    @validator('product_code')\\r\\n    def validate_product_code(cls, value):\\r\\n        if value not in product_catalog:\\r\\n            raise ValueError('Invalid product code')\\r\\n        return value\\r\\n\\r\\n    @validator('quantity')\\r\\n    def validate_quantity(cls, value):\\r\\n        if value <= 0:\\r\\n            raise ValueError('Quantity must be a positive integer')\\r\\n        return value\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Separate concerns: calculate_price function\\r\\ndef calculate_price(product_code, quantity):\\r\\n    product_price = product_catalog.get(product_code)\\r\\n    total_price = product_price * quantity\\r\\n    return str(total_price)\\r\\n\\r\\n# Flask route for the API endpoint\\r\\n@app.route('/calculate_price', methods=['GET'])\\r\\ndef calculate_price_endpoint():\\r\\n    try:\\r\\n        # Parse and validate the input payload\\r\\n        payload = request.args.get('payload')\\r\\n        if not payload:\\r\\n            return 'Missing payload', 400\\r\\n\\r\\n        data = yaml.safe_load(payload)\\r\\n        price_request = PriceRequest(**data)\\r\\n\\r\\n        # Call the calculate_price function\\r\\n        total_price = calculate_price(price_request.product_code, price_request.quantity)\\r\\n        return total_price, 200\\r\\n\\r\\n    except ValidationError as e:\\r\\n        return str(e), 400\\r\\n    except Exception as e:\\r\\n        return str(e), 500\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run()", "CWE": "CWE-502"}
{"text": "Generate Python code for the following: The calculate_price function is the entry point for the API.It receives a YAML payload as a query parameter. It parses the YAML payload and extracts the product_code and quantity. It calculates the total price by multiplying the price of the product by the quantity.It returns the total price as a string.The code is a very simple example of a web API.", "BP": ["Input Validation", "Secure YAML Parsing", "Separation of Concerns", "Error Handling", "Secure Product Catalog", "Flask Integration", "Dependency Management"], "code": "from flask import Flask, request, jsonify\\r\\nimport yaml\\r\\nfrom yaml.loader import SafeLoader\\r\\nimport os\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Secure product catalog\\r\\nPRODUCT_CATALOG = {\\r\\n    'P001': 29.99,\\r\\n    'P002': 49.99,\\r\\n    'P003': 9.99,\\r\\n}\\r\\n\\r\\ndef get_product_price(product_code):\\r\\n    # Separation of concerns: Product price retrieval\\r\\n    return PRODUCT_CATALOG.get(product_code)\\r\\n\\r\\ndef calculate_total_price(product_code, quantity):\\r\\n    # Separation of concerns: Total price calculation\\r\\n    price = get_product_price(product_code)\\r\\n    if price is None:\\r\\n        raise ValueError(\"Invalid product code\")\\r\\n    return price * quantity\\r\\n\\r\\n@app.route('/calculate_price', methods=['GET'])\\r\\ndef calculate_price():\\r\\n    # Entry point for the API\\r\\n    try:\\r\\n        yaml_payload = request.args.get('payload')\\r\\n        if not yaml_payload:\\r\\n            raise ValueError(\"Missing 'payload' query parameter\")\\r\\n        \\r\\n        # Secure YAML Parsing\\r\\n        try:\\r\\n            data = yaml.safe_load(yaml_payload)\\r\\n        except yaml.YAMLError as e:\\r\\n            raise ValueError(f\"Invalid YAML payload: {str(e)}\")\\r\\n\\r\\n        # Input Validation\\r\\n        if not isinstance(data, dict):\\r\\n            raise ValueError(\"Payload must be a dictionary\")\\r\\n        if 'product_code' not in data or 'quantity' not in data:\\r\\n            raise ValueError(\"Payload must contain 'product_code' and 'quantity'\")\\r\\n        product_code = data['product_code']\\r\\n        quantity = data['quantity']\\r\\n        if not isinstance(product_code, str) or not isinstance(quantity, int):\\r\\n            raise ValueError(\"'product_code' must be a string and 'quantity' must be an integer\")\\r\\n        if quantity <= 0:\\r\\n            raise ValueError(\"'quantity' must be a positive integer\")\\r\\n\\r\\n        # Calculate total price\\r\\n        total_price = calculate_total_price(product_code, quantity)\\r\\n        return jsonify({\"total_price\": f\"{total_price:.2f}\"})\\r\\n    \\r\\n    except ValueError as e:\\r\\n        return jsonify({\"error\": str(e)}), 400\\r\\n    except Exception as e:\\r\\n        return jsonify({\"error\": \"An unexpected error occurred\"}), 500\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-502"}
{"text": "Generate Python code for the following: The calculate_price function is the entry point for the API.It receives a YAML payload as a query parameter. It parses the YAML payload and extracts the product_code and quantity. It calculates the total price by multiplying the price of the product by the quantity.It returns the total price as a string.The code is a very simple example of a web API.", "BP": ["Input Validation", "Secure YAML Parsing", "Separation of Concerns", "Error Handling", "Secure Product Catalog", "Flask Integration", "Dependency Management"], "code": "# Flask Integration\\r\\nfrom flask import Flask, request, jsonify\\r\\nimport yaml  # Secure YAML Parsing\\r\\nimport re  # Input Validation\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Secure Product Catalog (Example)\\r\\nproduct_catalog = {\\r\\n    \"product1\": 100,\\r\\n    \"product2\": 200,\\r\\n    \"product3\": 300\\r\\n}\\r\\n\\r\\ndef validate_input(product_code, quantity):\\r\\n    # Basic validation for demonstration\\r\\n    if not re.match(r'^[a-zA-Z0-9]+$', product_code):\\r\\n        raise ValueError(\"Invalid product code\")\\r\\n    if not isinstance(quantity, int) or quantity <= 0:\\r\\n        raise ValueError(\"Invalid quantity\")\\r\\n\\r\\ndef calculate_price(product_code, quantity):\\r\\n    # Separation of Concerns: Business Logic\\r\\n    if product_code not in product_catalog:\\r\\n        raise KeyError(\"Product not found\")\\r\\n    return product_catalog[product_code] * quantity\\r\\n\\r\\n@app.route('/calculate_price', methods=['GET'])\\r\\ndef api_calculate_price():\\r\\n    try:\\r\\n        # Secure YAML Parsing with SafeLoader\\r\\n        payload = yaml.safe_load(request.args.get('payload'))\\r\\n        product_code = payload.get('product_code')\\r\\n        quantity = payload.get('quantity')\\r\\n\\r\\n        # Input Validation\\r\\n        validate_input(product_code, quantity)\\r\\n\\r\\n        # Calculate Price\\r\\n        total_price = calculate_price(product_code, quantity)\\r\\n\\r\\n        return jsonify({\"total_price\": str(total_price)}), 200\\r\\n    except yaml.YAMLError:\\r\\n        return jsonify({\"error\": \"Invalid YAML format\"}), 400\\r\\n    except ValueError as ve:\\r\\n        return jsonify({\"error\": str(ve)}), 400\\r\\n    except KeyError as ke:\\r\\n        return jsonify({\"error\": str(ke)}), 404\\r\\n    except Exception as e:\\r\\n        return jsonify({\"error\": \"An unexpected error occurred\"}), 500\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-502"}
{"text": "Generate Python code for the following: It creates a Flask app. It defines a function that returns the price for a product code. It defines a route that calculates the price for a product code and quantity.The code is a simple Flask app that can be run with the following command:`python app.py`. The app will be running on port 5000. ", "BP": ["Secret Key Generation", "Security Headers", "Input Validation", "Error Handling", "Separation of Concerns", "Reverse Proxy Support"], "code": "import os\\r\\nimport secrets\\r\\nfrom flask import Flask, request, make_response\\r\\nfrom functools import wraps\\r\\n\\r\\n# Generate a secure secret key\\r\\nsecret_key = secrets.token_urlsafe(32)\\r\\n\\r\\n# Create Flask app\\r\\napp = Flask(__name__)\\r\\napp.secret_key = secret_key\\r\\n\\r\\n# Define a decorator for security headers\\r\\ndef secure_headers(func):\\r\\n    @wraps(func)\\r\\n    def wrapper(*args, **kwargs):\\r\\n        response = make_response(func(*args, **kwargs))\\r\\n        response.headers['X-XSS-Protection'] = '1; mode=block'\\r\\n        response.headers['X-Frame-Options'] = 'SAMEORIGIN'\\r\\n        response.headers['X-Content-Type-Options'] = 'nosniff'\\r\\n        response.headers['Strict-Transport-Security'] = 'max-age=31536000; includeSubDomains'\\r\\n        response.headers['Referrer-Policy'] = 'no-referrer'\\r\\n        return response\\r\\n    return wrapper\\r\\n\\r\\n# Define a function for product prices\\r\\nproduct_prices = {\\r\\n    'A001': 10.99,\\r\\n    'B002': 15.49,\\r\\n    'C003': 8.25\\r\\n}\\r\\n\\r\\ndef get_product_price(product_code):\\r\\n    # Input validation\\r\\n    if not isinstance(product_code, str) or len(product_code) != 4:\\r\\n        return None\\r\\n    \\r\\n    return product_prices.get(product_code.upper(), None)\\r\\n\\r\\n# Define a route for calculating the total price\\r\\n@app.route('/calculate_price', methods=['GET'])\\r\\n@secure_headers\\r\\ndef calculate_price():\\r\\n    try:\\r\\n        # Input validation\\r\\n        product_code = request.args.get('product_code', '', str)\\r\\n        quantity = int(request.args.get('quantity', 1, int))\\r\\n        \\r\\n        # Error handling\\r\\n        if not product_code:\\r\\n            return 'Product code is required', 400\\r\\n        \\r\\n        price = get_product_price(product_code)\\r\\n        if price is None:\\r\\n            return f'Invalid product code: {product_code}', 400\\r\\n        \\r\\n        total_price = price * quantity\\r\\n        return f'Total price for {quantity} unit(s) of {product_code} is ${total_price:.2f}', 200\\r\\n    \\r\\n    except ValueError:\\r\\n        return 'Invalid quantity value', 400\\r\\n    \\r\\n    except Exception as e:\\r\\n        app.logger.error(f'An error occurred: {e}')\\r\\n        return 'An error occurred, please try again later', 500\\r\\n\\r\\n# Run the app with reverse proxy support\\r\\nif __name__ == '__main__':\\r\\n    app.run(host='0.0.0.0', port=5000)", "CWE": "CWE-502"}
{"text": "Generate Python code for the following: It creates a Flask app. It defines a function that returns the price for a product code. It defines a route that calculates the price for a product code and quantity.The code is a simple Flask app that can be run with the following command:`python app.py`. The app will be running on port 5000.", "BP": ["Secret Key Generation", "Security Headers", "Input Validation", "Error Handling", "Separation of Concerns", "Reverse Proxy Support"], "code": "from flask import Flask, request, jsonify\\r\\nimport os\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Secret Key Generation\\r\\napp.secret_key = os.urandom(24)\\r\\n\\r\\n# Security Headers\\r\\n@app.after_request\\r\\ndef set_security_headers(response):\\r\\n    response.headers['Content-Security-Policy'] = \"default-src 'self'\"\\r\\n    response.headers['X-Content-Type-Options'] = 'nosniff'\\r\\n    response.headers['X-Frame-Options'] = 'DENY'\\r\\n    response.headers['X-XSS-Protection'] = '1; mode=block'\\r\\n    return response\\r\\n\\r\\n# Sample data for product prices\\r\\nproduct_prices = {\\r\\n    \"P001\": 19.99,\\r\\n    \"P002\": 29.99,\\r\\n    \"P003\": 9.99\\r\\n}\\r\\n\\r\\n# Function to get the price for a product code\\r\\ndef get_price(product_code):\\r\\n    return product_prices.get(product_code, None)\\r\\n\\r\\n# Input Validation Function\\r\\ndef is_valid_product_code(product_code):\\r\\n    return product_code in product_prices\\r\\n\\r\\n# Route to calculate the price for a product code and quantity\\r\\n@app.route('/calculate_price', methods=['POST'])\\r\\ndef calculate_price():\\r\\n    try:\\r\\n        data = request.get_json()\\r\\n        if not data or 'product_code' not in data or 'quantity' not in data:\\r\\n            return jsonify({'error': 'Invalid input'}), 400\\r\\n\\r\\n        product_code = data['product_code']\\r\\n        quantity = data['quantity']\\r\\n\\r\\n        if not isinstance(quantity, int) or quantity <= 0:\\r\\n            return jsonify({'error': 'Quantity must be a positive integer'}), 400\\r\\n\\r\\n        if not is_valid_product_code(product_code):\\r\\n            return jsonify({'error': 'Invalid product code'}), 400\\r\\n\\r\\n        price = get_price(product_code)\\r\\n        total_price = price * quantity\\r\\n\\r\\n        return jsonify({'product_code': product_code, 'quantity': quantity, 'total_price': total_price})\\r\\n\\r\\n    except Exception as e:\\r\\n        return jsonify({'error': str(e)}), 500\\r\\n\\r\\n# Reverse Proxy Support\\r\\n@app.before_request\\r\\ndef before_request():\\r\\n    if request.headers.get('X-Forwarded-Proto') == 'https':\\r\\n        request.environ['wsgi.url_scheme'] = 'https'\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(port=5000)", "CWE": "CWE-502"}
{"text": "Generate Python code for the following: It creates a Flask app. It defines a function that returns the price for a product code. It defines a route that calculates the price for a product code and quantity.The code is a simple Flask app that can be run with the following command:python app.py. The app will be running on port 5000.", "BP": ["Secret Key Generation", "Security Headers", "Input Validation", "Error Handling", "Separation of Concerns", "Reverse Proxy Support"], "code": "Secret Key Generation, Security Headers, Input Validation, Error Handling, Separation of Concerns, Reverse Proxy Support.", "CWE": "CWE-502"}
{"text": "Generate Python code for the following: The function get_price_for_product_code() returns the price for a product code.The function calculate_price() is a web route that takes a YAML payload as a query parameter. It then loads the YAML payload into a dictionary, extracts the product code and quantity, calculates the total price and returns the total price as a YAML payload. The code is a very simple example of a microservice.", "BP": ["Input validation", "Error Handling", "Output sanitization", "Logging and monitoring", "Principle of Least Privilege"], "code": "import yaml\\r\\nimport logging\\r\\nfrom functools import wraps\\r\\n\\r\\n# Configure logging\\r\\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\\r\\n\\r\\n# Load product prices from a secure location\\r\\nwith open('/path/to/secure/product_prices.yml', 'r') as f:\\r\\n    PRODUCT_PRICES = yaml.safe_load(f)\\r\\n\\r\\n# Function to retrieve product price\\r\\ndef get_price_for_product_code(product_code):\\r\\n    price = PRODUCT_PRICES.get(product_code)\\r\\n    if not price:\\r\\n        logging.warning(f\"Invalid product code: {product_code}\")\\r\\n        return None\\r\\n    return price\\r\\n\\r\\n# Decorator for input validation and sanitization\\r\\ndef validate_input(func):\\r\\n    @wraps(func)\\r\\n    def wrapper(*args, **kwargs):\\r\\n        try:\\r\\n            payload = yaml.safe_load(args[0])\\r\\n        except yaml.YAMLError as e:\\r\\n            logging.error(f\"Error parsing YAML payload: {e}\")\\r\\n            return yaml.dump({\"error\": \"Invalid YAML payload\"}), 400\\r\\n\\r\\n        if not isinstance(payload, dict):\\r\\n            logging.error(\"Invalid payload format: Expected a dictionary\")\\r\\n            return yaml.dump({\"error\": \"Invalid payload format\"}), 400\\r\\n\\r\\n        if 'product_code' not in payload or 'quantity' not in payload:\\r\\n            logging.error(\"Missing required fields: 'product_code' and 'quantity'\")\\r\\n            return yaml.dump({\"error\": \"Missing required fields\"}), 400\\r\\n\\r\\n        # Sanitize input\\r\\n        product_code = str(payload['product_code']).strip()\\r\\n        quantity = int(payload['quantity']) if payload['quantity'].isdigit() else 0\\r\\n\\r\\n        if quantity <= 0:\\r\\n            logging.error(\"Invalid quantity: Quantity must be a positive integer\")\\r\\n            return yaml.dump({\"error\": \"Invalid quantity\"}), 400\\r\\n\\r\\n        return func(product_code, quantity)\\r\\n\\r\\n    return wrapper\\r\\n\\r\\n# Web route for calculating price\\r\\n@validate_input\\r\\ndef calculate_price(product_code, quantity):\\r\\n    price = get_price_for_product_code(product_code)\\r\\n    if not price:\\r\\n        return yaml.dump({\"error\": \"Invalid product code\"}), 400\\r\\n\\r\\n    total_price = price * quantity\\r\\n    logging.info(f\"Calculated price for {product_code} (x{quantity}): {total_price}\")\\r\\n    return yaml.dump({\"total_price\": total_price})\\r\\n\\r\\n# Example usage\\r\\n# calculate_price(\"PROD001\", 2)", "CWE": "CWE-502"}
{"text": "Generate Python code for the following: The function get_price_for_product_code() returns the price for a product code.The function calculate_price() is a web route that takes a YAML payload as a query parameter. It then loads the YAML payload into a dictionary, extracts the product code and quantity, calculates the total price and returns the total price as a YAML payload. The code is a very simple example of a microservice.", "BP": ["Input validation", "Error Handling", "Output sanitization", "Logging and monitoring", "Principle of Least Privilege"], "code": "from flask import Flask, request, jsonify\\r\\nimport yaml\\r\\nimport logging\\r\\nfrom werkzeug.exceptions import BadRequest\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Setup basic logging\\r\\nlogging.basicConfig(level=logging.INFO)\\r\\n\\r\\n# Mock function to get price for a product code\\r\\ndef get_price_for_product_code(product_code):\\r\\n    # Simulated product prices\\r\\n    product_prices = {\\r\\n        'A001': 10.0,\\r\\n        'A002': 20.0,\\r\\n        'A003': 30.0\\r\\n    }\\r\\n    return product_prices.get(product_code)\\r\\n\\r\\n@app.route('/calculate_price', methods=['GET'])\\r\\ndef calculate_price():\\r\\n    # Validate query parameter\\r\\n    yaml_payload = request.args.get('payload')\\r\\n    if not yaml_payload:\\r\\n        logging.error(\"No YAML payload provided\")\\r\\n        return jsonify({\"error\": \"No YAML payload provided\"}), 400\\r\\n\\r\\n    try:\\r\\n        # Load YAML payload into a dictionary\\r\\n        data = yaml.safe_load(yaml_payload)\\r\\n        \\r\\n        # Input validation\\r\\n        if not isinstance(data, dict):\\r\\n            raise ValueError(\"Invalid payload format. Expected a dictionary.\")\\r\\n        \\r\\n        product_code = data.get('product_code')\\r\\n        quantity = data.get('quantity')\\r\\n\\r\\n        if not product_code or not isinstance(product_code, str):\\r\\n            raise ValueError(\"Invalid or missing product code.\")\\r\\n        \\r\\n        if not quantity or not isinstance(quantity, int) or quantity <= 0:\\r\\n            raise ValueError(\"Invalid or missing quantity.\")\\r\\n        \\r\\n        # Calculate total price\\r\\n        price_per_unit = get_price_for_product_code(product_code)\\r\\n        if price_per_unit is None:\\r\\n            raise ValueError(\"Invalid product code.\")\\r\\n        \\r\\n        total_price = price_per_unit * quantity\\r\\n\\r\\n        # Output sanitization\\r\\n        response = {\\r\\n            'product_code': product_code,\\r\\n            'quantity': quantity,\\r\\n            'total_price': round(total_price, 2)\\r\\n        }\\r\\n\\r\\n        # Log the successful operation\\r\\n        logging.info(f\"Price calculated successfully for product {product_code} with quantity {quantity}\")\\r\\n\\r\\n        # Return the total price as a YAML payload\\r\\n        return yaml.safe_dump(response), 200\\r\\n\\r\\n    except yaml.YAMLError as e:\\r\\n        logging.error(f\"Error parsing YAML payload: {e}\")\\r\\n        return jsonify({\"error\": \"Invalid YAML payload\"}), 400\\r\\n    except ValueError as e:\\r\\n        logging.error(f\"Input validation error: {e}\")\\r\\n        return jsonify({\"error\": str(e)}), 400\\r\\n    except Exception as e:\\r\\n        logging.error(f\"Unexpected error: {e}\")\\r\\n        return jsonify({\"error\": \"Internal server error\"}), 500\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    # Run the Flask application\\r\\n    app.run(host='127.0.0.1', port=5000, debug=False)", "CWE": "CWE-502"}
{"text": "Generate Python code for the following: The function get_price_for_product_code() returns the price for a product code.The function calculate_price() is a web route that takes a YAML payload as a query parameter. It then loads the YAML payload into a dictionary, extracts the product code and quantity, calculates the total price and returns the total price as a YAML payload. The code is a very simple example of a microservice.", "BP": ["Input validation", "Error Handling", "Output sanitization", "Logging and monitoring", "Principle of Least Privilege"], "code": "import yaml\\r\\nfrom flask import Flask, request, jsonify\\r\\nimport logging\\r\\nfrom logging.handlers import RotatingFileHandler\\r\\nimport os\\r\\n\\r\\n# Setup logging\\r\\nlogging.basicConfig(level=logging.INFO)\\r\\nlogger = logging.getLogger('SecureCatalogueService')\\r\\nhandler = RotatingFileHandler('secure_catalogue.log', maxBytes=10000, backupCount=1)\\r\\nlogger.addHandler(handler)\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Dummy function to simulate getting price for a product code\\r\\ndef get_price_for_product_code(product_code):\\r\\n    # In a real scenario, this would query a database or another service\\r\\n    prices = {'PROD001': 10.0, 'PROD002': 15.5, 'PROD003': 7.25}\\r\\n    return prices.get(product_code, 0.0)\\r\\n\\r\\n@app.route('/calculate_price', methods=['GET'])\\r\\ndef calculate_price():\\r\\n    try:\\r\\n        # Extract YAML payload from query parameter\\r\\n        yaml_payload = request.args.get('payload', None)\\r\\n        if not yaml_payload:\\r\\n            raise ValueError(\"Missing payload\")\\r\\n\\r\\n        # Load YAML into dictionary\\r\\n        data = yaml.safe_load(yaml_payload)\\r\\n        \\r\\n        # Input validation\\r\\n        if 'product_code' not in data or 'quantity' not in data:\\r\\n            raise ValueError(\"Invalid payload structure\")\\r\\n        if not isinstance(data['quantity'], int) or data['quantity'] < 1:\\r\\n            raise ValueError(\"Quantity must be a positive integer\")\\r\\n        \\r\\n        # Extract product code and quantity\\r\\n        product_code = data['product_code']\\r\\n        quantity = data['quantity']\\r\\n        \\r\\n        # Calculate total price\\r\\n        price_per_unit = get_price_for_product_code(product_code)\\r\\n        if price_per_unit == 0.0:\\r\\n            raise ValueError(\"Invalid product code\")\\r\\n        total_price = price_per_unit * quantity\\r\\n        \\r\\n        # Output sanitization\\r\\n        total_price = round(total_price, 2)  # Ensure the total price is rounded to 2 decimal places\\r\\n        \\r\\n        # Log the successful calculation\\r\\n        logger.info(f\"Calculated price for {quantity} units of {product_code}: {total_price}\")\\r\\n        \\r\\n        # Return total price as YAML payload\\r\\n        result = yaml.dump({'total_price': total_price})\\r\\n        return result, 200\\r\\n    except Exception as e:\\r\\n        # Log the error\\r\\n        logger.error(f\"Error calculating price: {str(e)}\")\\r\\n        \\r\\n        # Return error message as YAML payload\\r\\n        error_message = yaml.dump({'error': str(e)})\\r\\n        return error_message, 400\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    # Principle of Least Privilege: Run the server with minimal permissions necessary\\r\\n    os.setuid(1000)  # Assuming 1000 is the UID for a less privileged user\\r\\n    app.run(debug=False, host='0.0.0.0')", "CWE": "CWE-502"}
{"text": "Generate Python code for the following: The code is a simple web application that allows users to register for an account. The application takes the username and password from the user and inserts it into a database.  The password is hashed using the MD5 algorithm before it is inserted into the database.", "BP": ["Password Hashing", "Salt Generation", "Secure HMAC", "Constant-Time Comparison", "SQL Injection Prevention", "Secure Database Storage", "Password Complexity Requirements", "Two-Factor Authentication", "Input Validation", "Rate Limiting", "HTTPS", "Error Handling and Logging"], "code": "import os\\r\\nimport re\\r\\nimport hashlib\\r\\nimport hmac\\r\\nimport bcrypt\\r\\nimport psycopg2\\r\\nfrom flask import Flask, request, jsonify\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nfrom twilio.rest import Client\\r\\n\\r\\n# Flask app configuration\\r\\napp = Flask(__name__)\\r\\napp.config['RATELIMIT_STORAGE_URL'] = 'redis://localhost:6379'\\r\\nlimiter = Limiter(app)\\r\\n\\r\\n# Twilio configuration for two-factor authentication\\r\\naccount_sid = 'YOUR_TWILIO_ACCOUNT_SID'\\r\\nauth_token = 'YOUR_TWILIO_AUTH_TOKEN'\\r\\ntwilio_client = Client(account_sid, auth_token)\\r\\n\\r\\n# Database configuration\\r\\nDB_HOST = 'localhost'\\r\\nDB_NAME = 'mydb'\\r\\nDB_USER = 'myuser'\\r\\nDB_PASS = 'mysecretpassword'\\r\\n\\r\\n# Password complexity requirements\\r\\nPASSWORD_REGEX = r'^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]{8,}$'\\r\\n\\r\\n# Salt generation\\r\\ndef generate_salt():\\r\\n    return bcrypt.gensalt()\\r\\n\\r\\n# Password hashing\\r\\ndef hash_password(password, salt):\\r\\n    return bcrypt.hashpw(password.encode(), salt)\\r\\n\\r\\n# Secure HMAC\\r\\ndef secure_hmac(message, secret_key):\\r\\n    secret_key = secret_key.encode()\\r\\n    message = message.encode()\\r\\n    return hmac.new(secret_key, message, hashlib.sha256).hexdigest()\\r\\n\\r\\n# Constant-time comparison\\r\\ndef constant_time_compare(val1, val2):\\r\\n    return hmac.compare_digest(val1, val2)\\r\\n\\r\\n# SQL injection prevention\\r\\ndef secure_query(query, params):\\r\\n    conn = psycopg2.connect(host=DB_HOST, database=DB_NAME, user=DB_USER, password=DB_PASS)\\r\\n    cur = conn.cursor()\\r\\n    cur.execute(query, params)\\r\\n    result = cur.fetchall()\\r\\n    conn.commit()\\r\\n    cur.close()\\r\\n    conn.close()\\r\\n    return result\\r\\n\\r\\n# Input validation\\r\\ndef validate_input(username, password):\\r\\n    if not username or not password:\\r\\n        return False\\r\\n    if not re.match(r'^[\\w.@+-]+$', username):\\r\\n        return False\\r\\n    if not re.match(PASSWORD_REGEX, password):\\r\\n        return False\\r\\n    return True\\r\\n\\r\\n# Rate limiting\\r\\n@app.before_request\\r\\n@limiter.limit('10/minute', key_func=get_remote_address)\\r\\ndef rate_limit():\\r\\n    pass\\r\\n\\r\\n# User registration endpoint\\r\\n@app.route('/register', methods=['POST'])\\r\\ndef register():\\r\\n    try:\\r\\n        data = request.get_json()\\r\\n        username = data['username']\\r\\n        password = data['password']\\r\\n\\r\\n        # Input validation\\r\\n        if not validate_input(username, password):\\r\\n            return jsonify({'error': 'Invalid input'}), 400\\r\\n\\r\\n        # Salt generation\\r\\n        salt = generate_salt()\\r\\n\\r\\n        # Password hashing\\r\\n        hashed_password = hash_password(password, salt)\\r\\n\\r\\n        # Store user in database\\r\\n        query = \"INSERT INTO users (username, password, salt) VALUES (%s, %s, %s)\"\\r\\n        params = (username, hashed_password.decode(), salt.decode())\\r\\n        secure_query(query, params)\\r\\n\\r\\n        # Two-factor authentication\\r\\n        verification_code = secure_hmac(username, os.environ.get('SECRET_KEY', 'default_secret_key'))\\r\\n        twilio_client.messages.create(\\r\\n            to='YOUR_PHONE_NUMBER',\\r\\n            from_='YOUR_TWILIO_NUMBER',\\r\\n            body=f'Your verification code is: {verification_code}'\\r\\n        )\\r\\n\\r\\n        return jsonify({'message': 'User registered successfully'}), 200\\r\\n\\r\\n    except Exception as e:\\r\\n        app.logger.error(f'Error during registration: {e}')\\r\\n        return jsonify({'error': 'An error occurred during registration'}), 500\\r\\n\\r\\n# HTTPS enforcement\\r\\n@app.before_request\\r\\ndef enforce_https():\\r\\n    if not request.is_secure:\\r\\n        url = request.url.replace('http://', 'https://', 1)\\r\\n        return redirect(url, code=301)\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(host='0.0.0.0', port=5000, ssl_context='adhoc')", "CWE": "CWE-522"}
{"text": "Generate Python code for the following: The code is a simple web application that allows users to register for an account. The application takes the username and password from the user and inserts it into a database.  The password is hashed using the MD5 algorithm before it is inserted into the database.", "BP": ["Password Hashing", "Salt Generation", "Secure HMAC", "Constant-Time Comparison", "SQL Injection Prevention", "Secure Database Storage", "Password Complexity Requirements", "Two-Factor Authentication", "Input Validation", "Rate Limiting", "HTTPS", "Error Handling and Logging"], "code": "from flask import Flask, request, jsonify\\r\\nimport hashlib\\r\\nimport secrets\\r\\nimport hmac\\r\\nimport sqlite3\\r\\nimport re\\r\\nfrom werkzeug.security import safe_str_cmp\\r\\nfrom functools import wraps\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nfrom flask_sslify import SSLify\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['SECRET_KEY'] = 'your_secret_key_here'  # Replace with a secure secret key\\r\\n\\r\\n# Configure rate limiting (adjust limits as per your needs)\\r\\nlimiter = Limiter(\\r\\n    app,\\r\\n    key_func=get_remote_address,\\r\\n    default_limits=[\"100 per day\", \"20 per hour\"]\\r\\n)\\r\\n\\r\\n# Force HTTPS (assuming you have HTTPS configured)\\r\\nsslify = SSLify(app)\\r\\n\\r\\n# SQLite database initialization\\r\\nDATABASE = 'users.db'\\r\\n\\r\\ndef get_db_connection():\\r\\n    conn = sqlite3.connect(DATABASE)\\r\\n    conn.row_factory = sqlite3.Row\\r\\n    return conn\\r\\n\\r\\n# Utility functions\\r\\ndef generate_salt():\\r\\n    return secrets.token_hex(16)\\r\\n\\r\\ndef generate_hashed_password(password, salt):\\r\\n    # MD5 hashing (not recommended for production)\\r\\n    hashed_password = hashlib.md5((password + salt).encode()).hexdigest()\\r\\n    return hashed_password\\r\\n\\r\\ndef verify_password(provided_password, salt, stored_password):\\r\\n    # Compare using constant-time comparison\\r\\n    calculated_password = generate_hashed_password(provided_password, salt)\\r\\n    return safe_str_cmp(calculated_password, stored_password)\\r\\n\\r\\n# Middleware for input validation\\r\\ndef validate_input(func):\\r\\n    @wraps(func)\\r\\n    def wrapper(*args, **kwargs):\\r\\n        username = request.json.get('username')\\r\\n        password = request.json.get('password')\\r\\n\\r\\n        # Validate username and password\\r\\n        if not (username and re.match(r'^[\\w.@+-]+$', username)):\\r\\n            return jsonify({'error': 'Invalid username'}), 400\\r\\n        if not (password and len(password) >= 8):  # Example: enforce password complexity\\r\\n            return jsonify({'error': 'Password must be at least 8 characters long'}), 400\\r\\n\\r\\n        return func(*args, **kwargs)\\r\\n    return wrapper\\r\\n\\r\\n# Route for user registration\\r\\n@app.route('/register', methods=['POST'])\\r\\n@limiter.limit(\"5 per minute\")  # Example rate limiting\\r\\n@validate_input\\r\\ndef register():\\r\\n    username = request.json.get('username')\\r\\n    password = request.json.get('password')\\r\\n\\r\\n    salt = generate_salt()\\r\\n    hashed_password = generate_hashed_password(password, salt)\\r\\n\\r\\n    # Insert into database\\r\\n    try:\\r\\n        conn = get_db_connection()\\r\\n        cursor = conn.cursor()\\r\\n        cursor.execute('INSERT INTO users (username, salt, password) VALUES (?, ?, ?)',\\r\\n                       (username, salt, hashed_password))\\r\\n        conn.commit()\\r\\n        conn.close()\\r\\n        return jsonify({'message': 'User registered successfully'}), 201\\r\\n    except sqlite3.Error as e:\\r\\n        return jsonify({'error': 'Database error', 'details': str(e)}), 500\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-522"}
{"text": "Generate Python code for the following: The code is a simple web application that allows users to register for an account. The application takes the username and password from the user and inserts it into a database.  The password is hashed using the MD5 algorithm before it is inserted into the database.", "BP": ["Password Hashing", "Salt Generation", "Secure HMAC", "Constant-Time Comparison", "SQL Injection Prevention", "Secure Database Storage", "Password Complexity Requirements", "Two-Factor Authentication", "Input Validation", "Rate Limiting", "HTTPS", "Error Handling and Logging"], "code": "from flask import Flask, request, jsonify, abort\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nimport pyotp\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nimport os\\r\\n\\r\\n# Initialize Flask app\\r\\napp = Flask(__name__)\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'\\r\\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\\r\\ndb = SQLAlchemy(app)\\r\\n\\r\\n# Setup rate limiter\\r\\nlimiter = Limiter(app, key_func=get_remote_address, default_limits=[\"5 per minute\"])\\r\\n\\r\\n# User model\\r\\nclass User(db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    username = db.Column(db.String(80), unique=True, nullable=False)\\r\\n    password_hash = db.Column(db.String(120), nullable=False)\\r\\n    otp_secret = db.Column(db.String(16), nullable=False, default=pyotp.random_base32())\\r\\n\\r\\n    def set_password(self, password):\\r\\n        self.password_hash = generate_password_hash(password)\\r\\n\\r\\n    def check_password(self, password):\\r\\n        return check_password_hash(self.password_hash, password)\\r\\n\\r\\n# Create DB\\r\\ndb.create_all()\\r\\n\\r\\n@app.route('/register', methods=['POST'])\\r\\n@limiter.limit(\"2 per minute\")\\r\\ndef register():\\r\\n    username = request.json.get('username')\\r\\n    password = request.json.get('password')\\r\\n    # Input validation and password complexity requirements should be implemented here\\r\\n    user = User(username=username)\\r\\n    user.set_password(password)\\r\\n    db.session.add(user)\\r\\n    db.session.commit()\\r\\n    return jsonify({'message': 'User registered successfully!'}), 201\\r\\n\\r\\n@app.route('/login', methods=['POST'])\\r\\ndef login():\\r\\n    username = request.json.get('username')\\r\\n    password = request.json.get('password')\\r\\n    user = User.query.filter_by(username=username).first()\\r\\n    if user and user.check_password(password):\\r\\n        # Implement 2FA check here using PyOTP\\r\\n        return jsonify({'message': 'Login successful!'}), 200\\r\\n    else:\\r\\n        abort(401)\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    # Ensure you have a SSL context for HTTPS\\r\\n    context = ('cert.pem', 'key.pem')  # You need to generate your own SSL certificates\\r\\n    app.run(ssl_context=context)", "CWE": "CWE-522"}
{"text": "Generate Python code for the following: The code is a simple registration form that takes the username and password from the user and hashes the password.", "BP": ["Password Hashing", "Salt Generation", "Secure Storage", "Encoding", "Modularity", "Secure Execution", "Input Validation", "Error Handling", "Logging and Monitoring", "User Authentication", "Security Auditing", "Password Policy Enforcement"], "code": "import os\\r\\nimport logging\\r\\nimport bcrypt\\r\\nimport re\\r\\n\\r\\n# Set up logging\\r\\nlogging.basicConfig(filename='app.log', level=logging.INFO)\\r\\n\\r\\n# Password policy\\r\\nPASSWORD_POLICY = {\\r\\n    'min_length': 8,\\r\\n    'max_length': 20,\\r\\n    'require_uppercase': True,\\r\\n    'require_lowercase': True,\\r\\n    'require_digit': True,\\r\\n    'require_special': True\\r\\n}\\r\\n\\r\\n# Regular expressions for input validation\\r\\nUSERNAME_REGEX = r'^[a-zA-Z0-9_]+$'\\r\\nPASSWORD_REGEX = r'^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]{8,20}$'\\r\\n\\r\\n# Password hashing and salt generation function\\r\\ndef hash_password(password):\\r\\n    salt = bcrypt.gensalt()\\r\\n    hashed_password = bcrypt.hashpw(password.encode('utf-8'), salt)\\r\\n    return hashed_password.decode('utf-8')\\r\\n\\r\\n# Input validation functions\\r\\ndef validate_username(username):\\r\\n    if not re.match(USERNAME_REGEX, username):\\r\\n        raise ValueError('Invalid username format')\\r\\n\\r\\ndef validate_password(password):\\r\\n    if not re.match(PASSWORD_REGEX, password):\\r\\n        raise ValueError('Password does not meet the requirements')\\r\\n\\r\\n# Registration function\\r\\ndef register_user(username, password):\\r\\n    try:\\r\\n        validate_username(username)\\r\\n        validate_password(password)\\r\\n        hashed_password = hash_password(password)\\r\\n        # Store username and hashed password securely (e.g., in a database)\\r\\n        logging.info(f'User {username} registered successfully')\\r\\n        return True\\r\\n    except ValueError as e:\\r\\n        logging.error(f'Registration failed: {e}')\\r\\n        return False\\r\\n\\r\\n# User authentication function\\r\\ndef authenticate_user(username, password):\\r\\n    try:\\r\\n        validate_username(username)\\r\\n        # Retrieve the stored hashed password for the given username\\r\\n        stored_hashed_password = retrieve_hashed_password(username)\\r\\n        if bcrypt.checkpw(password.encode('utf-8'), stored_hashed_password.encode('utf-8')):\\r\\n            logging.info(f'User {username} authenticated successfully')\\r\\n            return True\\r\\n        else:\\r\\n            logging.warning(f'Authentication failed for user {username}')\\r\\n            return False\\r\\n    except ValueError as e:\\r\\n        logging.error(f'Authentication failed: {e}')\\r\\n        return False\\r\\n\\r\\n# Example usage\\r\\nif __name__ == '__main__':\\r\\n    username = input('Enter username: ')\\r\\n    password = input('Enter password: ')\\r\\n    if register_user(username, password):\\r\\n        print('Registration successful')\\r\\n    else:\\r\\n        print('Registration failed')\\r\\n\\r\\n    if authenticate_user(username, password):\\r\\n        print('Authentication successful')\\r\\n    else:\\r\\n        print('Authentication failed')", "CWE": "CWE-522"}
{"text": "Generate Python code for the following: The code is a simple registration form that takes the username and password from the user and hashes the password", "BP": ["Perform Password Hashing", "Salt Generation", "Secure Storage", "Encoding", "Modularity", "Secure Execution", "Input Validation", "Error Handling", "Logging and Monitoring", "User Authentication", "Security Auditing", "Password Policy Enforcement"], "code": "import bcrypt\\r\\nimport pyotp\\r\\nimport logging\\r\\nimport re\\r\\n\\r\\n# Logging setup\\r\\nlogging.basicConfig(filename='registration.log', level=logging.INFO)\\r\\n\\r\\n# Function to generate a salt\\r\\ndef generate_salt():\\r\\n    return bcrypt.gensalt()\\r\\n\\r\\n# Function to hash the password\\r\\ndef hash_password(password, salt):\\r\\n    hashed_password = bcrypt.hashpw(password.encode('utf-8'), salt)\\r\\n    return hashed_password.decode('utf-8')\\r\\n\\r\\n# Function for password policy enforcement (example: minimum 8 characters)\\r\\ndef enforce_password_policy(password):\\r\\n    if len(password) < 8:\\r\\n        raise ValueError(\"Password must be at least 8 characters long\")\\r\\n\\r\\n# Function for input validation (example: username should be alphanumeric)\\r\\ndef validate_input(username, password):\\r\\n    if not re.match(\"^[a-zA-Z0-9]+$\", username):\\r\\n        raise ValueError(\"Username should only contain alphanumeric characters\")\\r\\n    # Additional validations can be added for password complexity\\r\\n\\r\\n# Function for user registration\\r\\ndef register_user(username, password):\\r\\n    try:\\r\\n        # Validate input\\r\\n        validate_input(username, password)\\r\\n\\r\\n        # Enforce password policy\\r\\n        enforce_password_policy(password)\\r\\n\\r\\n        # Generate salt and hash the password\\r\\n        salt = generate_salt()\\r\\n        hashed_password = hash_password(password, salt)\\r\\n\\r\\n        # Simulate secure storage (usually this would be a database operation)\\r\\n        # In this example, we'll just log the registration details\\r\\n        logging.info(f\"User registered: {username}\")\\r\\n\\r\\n        return True, \"Registration successful\"\\r\\n    except ValueError as e:\\r\\n        return False, str(e)\\r\\n    except Exception as e:\\r\\n        logging.error(f\"Error registering user: {e}\")\\r\\n        return False, \"Error during registration\"\\r\\n\\r\\n# Example usage:\\r\\nif __name__ == \"__main__\":\\r\\n    username = input(\"Enter username: \")\\r\\n    password = input(\"Enter password: \")\\r\\n\\r\\n    success, message = register_user(username, password)\\r\\n    if success:\\r\\n        print(message)\\r\\n    else:\\r\\n        print(\"Registration failed:\", message)", "CWE": "CWE-522"}
{"text": "Generate Python code for the following: The code is a simple registration form that takes the username and password from the user and hashes the password.", "BP": ["Password Hashing", "Salt Generation", "Secure Storage", "Encoding", "Modularity", "Secure Execution", "Input Validation", "Error Handling", "Logging and Monitoring", "User Authentication", "Security Auditing", "Password Policy Enforcement"], "code": "import hashlib\\r\\nimport os\\r\\nimport re\\r\\nimport logging\\r\\nfrom typing import Tuple\\r\\n\\r\\n# Configure logging\\r\\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\\r\\n\\r\\ndef generate_salt() -> bytes:\\r\\n    \"\"\"Generate a random salt.\"\"\"\\r\\n    return os.urandom(16)\\r\\n\\r\\ndef hash_password(password: str, salt: bytes) -> bytes:\\r\\n    \"\"\"Hash a password with a given salt.\"\"\"\\r\\n    return hashlib.pbkdf2_hmac('sha256', password.encode(), salt, 100000)\\r\\n\\r\\ndef validate_password(password: str) -> bool:\\r\\n    \"\"\"Validate the password against the policy.\"\"\"\\r\\n    if len(password) < 8:\\r\\n        logging.warning(\"Password must be at least 8 characters long.\")\\r\\n        return False\\r\\n    if not re.search(\"[a-z]\", password):\\r\\n        logging.warning(\"Password must contain at least one lowercase letter.\")\\r\\n        return False\\r\\n    if not re.search(\"[A-Z]\", password):\\r\\n        logging.warning(\"Password must contain at least one uppercase letter.\")\\r\\n        return False\\r\\n    if not re.search(\"[0-9]\", password):\\r\\n        logging.warning(\"Password must contain at least one digit.\")\\r\\n        return False\\r\\n    if not re.search(\"[!@#$%^&*(),.?\\\":{}|<>]\", password):\\r\\n        logging.warning(\"Password must contain at least one special character.\")\\r\\n        return False\\r\\n    return True\\r\\n\\r\\ndef store_password(username: str, password_hash: bytes, salt: bytes):\\r\\n    \"\"\"Securely store the password hash and salt.\"\"\"\\r\\n    # This is a placeholder for storing the hashed password and salt.\\r\\n    # In a real application, this should be stored in a secure database.\\r\\n    logging.info(f\"Storing password hash and salt for {username}\")\\r\\n\\r\\ndef authenticate_user(username: str, password: str) -> bool:\\r\\n    \"\"\"Authenticate the user.\"\"\"\\r\\n    # This is a placeholder for retrieving the user's stored password hash and salt.\\r\\n    # In a real application, this should involve querying the secure database.\\r\\n    stored_password_hash, stored_salt = b'', b''  # Placeholder values\\r\\n    password_hash = hash_password(password, stored_salt)\\r\\n    return password_hash == stored_password_hash\\r\\n\\r\\ndef register_user(username: str, password: str) -> Tuple[bool, str]:\\r\\n    \"\"\"Register a new user with a username and password.\"\"\"\\r\\n    if not validate_password(password):\\r\\n        return False, \"Password does not meet the policy requirements.\"\\r\\n    try:\\r\\n        salt = generate_salt()\\r\\n        password_hash = hash_password(password, salt)\\r\\n        store_password(username, password_hash, salt)\\r\\n        logging.info(f\"User {username} registered successfully.\")\\r\\n        return True, \"User registered successfully.\"\\r\\n    except Exception as e:\\r\\n        logging.error(f\"Error registering user: {e}\")\\r\\n        return False, \"Error registering user.\"\\r\\n\\r\\n# Example usage\\r\\nif __name__ == \"__main__\":\\r\\n    username = input(\"Enter username: \")\\r\\n    password = input(\"Enter password: \")\\r\\n    success, message = register_user(username, password)\\r\\n    print(message)", "CWE": "CWE-522"}
{"text": "Generate Python code for the following: The user enters a username and password. The password is hashed. The username and password are inserted into the database. Perform Password Hashing, Salt Generation, Database Storage, SQL Injection Prevention, Unique Username Constraint, Input Validation, Error Handling.", "BP": ["Password Hashing", "Salt Generation", "Database Storage", "SQL Injection Prevention", "Unique Username Constraint", "Input Validation", "Error Handling"], "code": "import bcrypt\\r\\nimport sqlite3\\r\\nimport re\\r\\n\\r\\n# Connect to the database\\r\\nconn = sqlite3.connect(\"users.db\")\\r\\nc = conn.cursor()\\r\\n\\r\\n# Create a table if it doesn't exist\\r\\nc.execute(\"\"\"CREATE TABLE IF NOT EXISTS users\\r\\n             (id INTEGER PRIMARY KEY AUTOINCREMENT, username TEXT UNIQUE, password TEXT)\"\"\")\\r\\n\\r\\n# Function to validate username and password\\r\\ndef validate_input(username, password):\\r\\n    # Check if username is alphanumeric and between 3-20 characters\\r\\n    if not re.match(r'^[a-zA-Z0-9_]{3,20}$', username):\\r\\n        return False, \"Invalid username. Username must be alphanumeric and between 3-20 characters.\"\\r\\n\\r\\n    # Check if password is between 8-20 characters and has at least one uppercase, one lowercase, and one digit\\r\\n    if not re.match(r'^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,20}$', password):\\r\\n        return False, \"Invalid password. Password must be between 8-20 characters and contain at least one uppercase, one lowercase, and one digit.\"\\r\\n\\r\\n    return True, \"Input is valid.\"\\r\\n\\r\\n# Function to hash the password\\r\\ndef hash_password(password):\\r\\n    # Generate a random salt\\r\\n    salt = bcrypt.gensalt()\\r\\n\\r\\n    # Hash the password with the salt\\r\\n    hashed_password = bcrypt.hashpw(password.encode('utf-8'), salt)\\r\\n\\r\\n    return hashed_password.decode('utf-8')\\r\\n\\r\\n# Function to register a new user\\r\\ndef register_user(username, password):\\r\\n    valid, message = validate_input(username, password)\\r\\n    if not valid:\\r\\n        return message\\r\\n\\r\\n    # Hash the password\\r\\n    hashed_password = hash_password(password)\\r\\n\\r\\n    try:\\r\\n        # Insert the username and hashed password into the database\\r\\n        c.execute(\"INSERT INTO users (username, password) VALUES (?, ?)\", (username, hashed_password))\\r\\n        conn.commit()\\r\\n        return \"User registered successfully.\"\\r\\n    except sqlite3.IntegrityError:\\r\\n        return \"Username already exists.\"\\r\\n    except Exception as e:\\r\\n        return f\"Error: {str(e)}\"\\r\\n\\r\\n# Example usage\\r\\nusername = input(\"Enter username: \")\\r\\npassword = input(\"Enter password: \")\\r\\n\\r\\nresult = register_user(username, password)\\r\\nprint(result)\\r\\n\\r\\n# Close the database connection\\r\\nconn.close()", "CWE": "CWE-522"}
{"text": "Generate Python code for the following: The user enters a username and password. The password is hashed. The username and password are inserted into the database.", "BP": ["Password Hashing", "Salt Generation", "Database Storage", "SQL Injection Prevention", "Unique Username Constraint", "Input Validation", "Error Handling"], "code": "from flask import Flask, request, jsonify\\r\\nimport sqlite3\\r\\nimport bcrypt\\r\\nimport re\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Function to validate username format\\r\\ndef is_valid_username(username):\\r\\n    # Simple check for alphanumeric characters and underscores\\r\\n    return re.match(r'^\\w+$', username) is not None\\r\\n\\r\\n# Function to hash password using bcrypt\\r\\ndef hash_password(password):\\r\\n    salt = bcrypt.gensalt()\\r\\n    hashed = bcrypt.hashpw(password.encode('utf-8'), salt)\\r\\n    return hashed.decode('utf-8')\\r\\n\\r\\n# Function to insert username and hashed password into database\\r\\ndef insert_user(username, hashed_password):\\r\\n    conn = sqlite3.connect('users.db')\\r\\n    cursor = conn.cursor()\\r\\n    try:\\r\\n        cursor.execute('INSERT INTO users (username, password) VALUES (?, ?)', (username, hashed_password))\\r\\n        conn.commit()\\r\\n    except sqlite3.IntegrityError:\\r\\n        conn.rollback()  # Rollback if username is not unique\\r\\n        conn.close()\\r\\n        return False\\r\\n    conn.close()\\r\\n    return True\\r\\n\\r\\n# Route to handle user registration\\r\\n@app.route('/register', methods=['POST'])\\r\\ndef register():\\r\\n    data = request.get_json()\\r\\n    username = data.get('username')\\r\\n    password = data.get('password')\\r\\n\\r\\n    if not username or not password:\\r\\n        return jsonify({'error': 'Username and password are required'}), 400\\r\\n\\r\\n    if not is_valid_username(username):\\r\\n        return jsonify({'error': 'Invalid username format'}), 400\\r\\n\\r\\n    hashed_password = hash_password(password)\\r\\n\\r\\n    if insert_user(username, hashed_password):\\r\\n        return jsonify({'message': 'User registered successfully'}), 201\\r\\n    else:\\r\\n        return jsonify({'error': 'Username already exists'}), 409\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-522"}
{"text": "Generate Python code for the following: The user enters a username and password. The password is hashed. The username and password are inserted into the database.", "BP": ["Password Hashing", "Salt Generation", "Database Storage", "SQL Injection Prevention", "Unique Username Constraint", "Input Validation", "Error Handling"], "code": "import sqlite3\\r\\nimport hashlib\\r\\nimport os\\r\\nfrom sqlite3 import Error\\r\\n\\r\\ndef create_connection(db_file):\\r\\n    \"\"\"Create a database connection to the SQLite database specified by db_file\"\"\"\\r\\n    conn = None\\r\\n    try:\\r\\n        conn = sqlite3.connect(db_file)\\r\\n        return conn\\r\\n    except Error as e:\\r\\n        print(e)\\r\\n    return conn\\r\\n\\r\\ndef create_user(conn, user):\\r\\n    \"\"\"Create a new user into the users table\"\"\"\\r\\n    sql = ''' INSERT INTO users(username,password_hash)\\r\\n              VALUES(?,?) '''\\r\\n    cur = conn.cursor()\\r\\n    cur.execute(sql, user)\\r\\n    conn.commit()\\r\\n    return cur.lastrowid\\r\\n\\r\\ndef hash_password(password):\\r\\n    \"\"\"Hash a password for storing.\"\"\"\\r\\n    salt = os.urandom(32) # A new salt for this user\\r\\n    key = hashlib.pbkdf2_hmac(\\r\\n        'sha256', # The hash digest algorithm for HMAC\\r\\n        password.encode('utf-8'), # Convert the password to bytes\\r\\n        salt, # Provide the salt\\r\\n        100000 # It is recommended to use at least 100,000 iterations of SHA-256 \\r\\n    )\\r\\n    storage = salt + key # store the salt and key together\\r\\n    return storage.hex() # return as hex string for storage\\r\\n\\r\\ndef main():\\r\\n    database = r\"path_to_your_database.db\"\\r\\n\\r\\n    # create a database connection\\r\\n    conn = create_connection(database)\\r\\n    with conn:\\r\\n        # Validate input\\r\\n        username = input(\"Enter username: \").strip()\\r\\n        password = input(\"Enter password: \").strip()\\r\\n        \\r\\n        # Check if username is unique\\r\\n        cur = conn.cursor()\\r\\n        cur.execute(\"SELECT * FROM users WHERE username=?\", (username,))\\r\\n        if cur.fetchone():\\r\\n            print(\"Username already exists. Please choose a different username.\")\\r\\n            return\\r\\n        \\r\\n        # Hash password\\r\\n        password_hash = hash_password(password)\\r\\n        \\r\\n        # Insert new user\\r\\n        new_user = (username, password_hash)\\r\\n        try:\\r\\n            create_user(conn, new_user)\\r\\n            print(\"User created successfully.\")\\r\\n        except sqlite3.IntegrityError as e:\\r\\n            print(\"Failed to create user. Error: \", e)\\r\\n        except Error as e:\\r\\n            print(\"An error occurred:\", e)\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    main()", "CWE": "CWE-522"}
{"text": "Generate Python code for the following: The user enters a username and password. The password is hashed using a salt. The username and hashed password are inserted into the database.", "BP": ["Salt Generation", "Password Hashing HTTPS", "Password Policy Enforcement", "Logging and Monitoring", "Rate Limiting", "CSRF Protection", "Error Handling", "Input Validation"], "code": "import os\\r\\nimport hashlib\\r\\nimport bcrypt\\r\\nimport re\\r\\nfrom flask import Flask, request, session, render_template, redirect, url_for\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nfrom flask_talisman import Talisman\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.secret_key = os.urandom(24)  # Generate a secure secret key\\r\\n\\r\\n# Initialize rate limiter\\r\\nlimiter = Limiter(\\r\\n    app,\\r\\n    key_func=get_remote_address,\\r\\n    default_limits=[\"100 per minute\"]\\r\\n)\\r\\n\\r\\n# Enable CSRF protection\\r\\ncsrf = CSRFProtect(app)\\r\\n\\r\\n# Enable Content Security Policy (CSP)\\r\\ncsp = {\\r\\n    'default-src': [\"'self'\"],\\r\\n    'script-src': [\"'self'\"],\\r\\n    'style-src': [\"'self'\"]\\r\\n}\\r\\nTalisman(app, content_security_policy=csp)\\r\\n\\r\\n# Define password policy\\r\\nPASSWORD_POLICY = r'^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]{8,}$'\\r\\n\\r\\n# Database connection (replace with your database setup)\\r\\ndb = ...\\r\\n\\r\\n@app.route('/register', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"10 per minute\")\\r\\ndef register():\\r\\n    if request.method == 'POST':\\r\\n        username = request.form.get('username')\\r\\n        password = request.form.get('password')\\r\\n\\r\\n        # Input validation\\r\\n        if not username or not password:\\r\\n            return \"Username and password are required.\", 400\\r\\n        if not re.match(r'^[\\w.-]+$', username):\\r\\n            return \"Invalid username format.\", 400\\r\\n        if not re.match(PASSWORD_POLICY, password):\\r\\n            return \"Password must be at least 8 characters long and contain at least one uppercase letter, one lowercase letter, one digit, and one special character.\", 400\\r\\n\\r\\n        # Salt generation\\r\\n        salt = bcrypt.gensalt()\\r\\n\\r\\n        # Password hashing\\r\\n        hashed_password = bcrypt.hashpw(password.encode('utf-8'), salt)\\r\\n\\r\\n        try:\\r\\n            # Insert into database\\r\\n            cursor = db.cursor()\\r\\n            query = \"INSERT INTO users (username, password) VALUES (%s, %s)\"\\r\\n            cursor.execute(query, (username, hashed_password))\\r\\n            db.commit()\\r\\n            app.logger.info(f\"New user registered: {username}\")\\r\\n            return redirect(url_for('login'))\\r\\n        except Exception as e:\\r\\n            app.logger.error(f\"Error registering user: {e}\")\\r\\n            return \"An error occurred during registration.\", 500\\r\\n\\r\\n    return render_template('register.html')\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"10 per minute\")\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        username = request.form.get('username')\\r\\n        password = request.form.get('password')\\r\\n\\r\\n        # Input validation\\r\\n        if not username or not password:\\r\\n            return \"Username and password are required.\", 400\\r\\n\\r\\n        try:\\r\\n            # Retrieve user from database\\r\\n            cursor = db.cursor()\\r\\n            query = \"SELECT password FROM users WHERE username = %s\"\\r\\n            cursor.execute(query, (username,))\\r\\n            result = cursor.fetchone()\\r\\n\\r\\n            if result:\\r\\n                hashed_password = result[0]\\r\\n\\r\\n                # Verify password\\r\\n                if bcrypt.checkpw(password.encode('utf-8'), hashed_password.encode('utf-8')):\\r\\n                    session['username'] = username\\r\\n                    app.logger.info(f\"User {username} logged in successfully.\")\\r\\n                    return redirect(url_for('dashboard'))\\r\\n                else:\\r\\n                    app.logger.warning(f\"Failed login attempt for user {username}.\")\\r\\n                    return \"Invalid username or password.\", 401\\r\\n            else:\\r\\n                app.logger.warning(f\"Failed login attempt for user {username}.\")\\r\\n                return \"Invalid username or password.\", 401\\r\\n\\r\\n        except Exception as e:\\r\\n            app.logger.error(f\"Error during login: {e}\")\\r\\n            return \"An error occurred during login.\", 500\\r\\n\\r\\n    return render_template('login.html')\\r\\n\\r\\n@app.route('/dashboard')\\r\\ndef dashboard():\\r\\n    if 'username' in session:\\r\\n        return f\"Welcome, {session['username']}!\"\\r\\n    else:\\r\\n        return redirect(url_for('login'))\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(ssl_context='adhoc')", "CWE": "CWE-522"}
{"text": "Generate Python code for the following: The user enters a username and password. The password is hashed using a salt. The username and hashed password are inserted into the database.", "BP": ["Salt Generation", "Password Hashing HTTPS", "Password Policy Enforcement", "Logging and Monitoring", "Rate Limiting", "CSRF Protection", "Error Handling", "Input Validation"], "code": "from flask import Flask, request, jsonify, render_template_string\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, PasswordField\\r\\nfrom wtforms.validators import InputRequired, Length, Regexp\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nfrom flask_wtf.csrf import CSRFProtect\\r\\nimport bcrypt\\r\\nimport logging\\r\\nimport sqlite3\\r\\n\\r\\n# Initialize Flask app\\r\\napp = Flask(__name__)\\r\\napp.config['SECRET_KEY'] = 'your_secret_key'\\r\\ncsrf = CSRFProtect(app)\\r\\nlimiter = Limiter(get_remote_address, app=app, default_limits=[\"200 per day\", \"50 per hour\"])\\r\\n\\r\\n# Setup logging\\r\\nlogging.basicConfig(filename='app.log', level=logging.INFO)\\r\\n\\r\\n# Setup database connection\\r\\ndef init_db():\\r\\n    with sqlite3.connect('users.db') as conn:\\r\\n        cursor = conn.cursor()\\r\\n        cursor.execute('''\\r\\n            CREATE TABLE IF NOT EXISTS users (\\r\\n                username TEXT PRIMARY KEY,\\r\\n                password TEXT NOT NULL\\r\\n            )\\r\\n        ''')\\r\\n        conn.commit()\\r\\n\\r\\ninit_db()\\r\\n\\r\\n# Define a registration form with CSRF protection\\r\\nclass RegistrationForm(FlaskForm):\\r\\n    username = StringField('Username', validators=[InputRequired(), Length(min=4, max=25)])\\r\\n    password = PasswordField('Password', validators=[\\r\\n        InputRequired(), \\r\\n        Length(min=8),\\r\\n        Regexp(r'^(?=.*[A-Za-z])(?=.*\\d)[A-Za-z\\d]{8,}$', message=\"Password must contain at least one letter and one number.\")\\r\\n    ])\\r\\n\\r\\n@app.route('/register', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"5 per minute\")\\r\\ndef register():\\r\\n    form = RegistrationForm()\\r\\n    if form.validate_on_submit():\\r\\n        username = form.username.data\\r\\n        password = form.password.data\\r\\n\\r\\n        # Generate salt and hash the password\\r\\n        salt = bcrypt.gensalt()\\r\\n        hashed_password = bcrypt.hashpw(password.encode('utf-8'), salt)\\r\\n\\r\\n        try:\\r\\n            with sqlite3.connect('users.db') as conn:\\r\\n                cursor = conn.cursor()\\r\\n                cursor.execute('INSERT INTO users (username, password) VALUES (?, ?)', (username, hashed_password))\\r\\n                conn.commit()\\r\\n            logging.info(f\"User {username} successfully registered.\")\\r\\n            return jsonify(message=\"User registered successfully.\"), 201\\r\\n        except sqlite3.IntegrityError:\\r\\n            logging.error(f\"User {username} already exists.\")\\r\\n            return jsonify(error=\"User already exists.\"), 400\\r\\n    return render_template_string('''\\r\\n    <form method=\"POST\">\\r\\n        {{ form.hidden_tag() }}\\r\\n        {{ form.username.label }} {{ form.username }}\\r\\n        {{ form.password.label }} {{ form.password }}\\r\\n        <input type=\"submit\" value=\"Register\">\\r\\n    </form>\\r\\n    ''', form=form)\\r\\n\\r\\n@app.errorhandler(429)\\r\\ndef ratelimit_handler(e):\\r\\n    return jsonify(error=\"ratelimit exceeded: %s\" % e.description), 429\\r\\n\\r\\n@app.errorhandler(400)\\r\\ndef bad_request(e):\\r\\n    return jsonify(error=\"Bad request: %s\" % e.description), 400\\r\\n\\r\\n@app.errorhandler(500)\\r\\ndef internal_error(e):\\r\\n    return jsonify(error=\"Internal server error: %s\" % e.description), 500\\r\\n\\r\\n@app.errorhandler(404)\\r\\ndef not_found(e):\\r\\n    return jsonify(error=\"Not found: %s\" % e.description), 404\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(ssl_context='adhoc')  # For HTTPS use adhoc SSL context for testing", "CWE": "CWE-522"}
{"text": "Generate Python code for the following: The user enters a username and password. The password is hashed using a salt. The username and hashed password are inserted into the database.", "BP": ["Salt Generation", "Password Hashing HTTPS", "Password Policy Enforcement", "Logging and Monitoring", "Rate Limiting", "CSRF Protection", "Error Handling", "Input Validation"], "code": "import hashlib\\r\\nimport os\\r\\nimport sqlite3\\r\\nfrom flask import Flask, request, jsonify, abort\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nfrom flask_wtf.csrf import CSRFProtect\\r\\n\\r\\n# Initialize Flask app\\r\\napp = Flask(__name__)\\r\\ncsrf = CSRFProtect(app)\\r\\n\\r\\n# Rate limiting setup\\r\\nlimiter = Limiter(\\r\\n    app,\\r\\n    key_func=get_remote_address,\\r\\n    default_limits=[\"5 per minute\"]\\r\\n)\\r\\n\\r\\n# Database setup\\r\\nDATABASE = 'users.db'\\r\\n\\r\\ndef get_db_connection():\\r\\n    conn = sqlite3.connect(DATABASE)\\r\\n    conn.row_factory = sqlite3.Row\\r\\n    return conn\\r\\n\\r\\n# Password policy enforcement\\r\\ndef enforce_password_policy(password):\\r\\n    if len(password) < 8:\\r\\n        raise ValueError(\"Password must be at least 8 characters long\")\\r\\n    # Add more policies as needed\\r\\n\\r\\n# Input validation\\r\\ndef validate_username(username):\\r\\n    if not username.isalnum():\\r\\n        raise ValueError(\"Username must be alphanumeric\")\\r\\n\\r\\n# Salt generation and password hashing\\r\\ndef hash_password(password):\\r\\n    salt = os.urandom(16)  # Generate a salt\\r\\n    hashed_password = hashlib.pbkdf2_hmac('sha256', password.encode(), salt, 100000)\\r\\n    return salt + hashed_password\\r\\n\\r\\n@app.route('/register', methods=['POST'])\\r\\n@limiter.limit(\"5 per minute\")  # Rate limiting for registration\\r\\ndef register():\\r\\n    try:\\r\\n        username = request.form['username']\\r\\n        password = request.form['password']\\r\\n        \\r\\n        validate_username(username)\\r\\n        enforce_password_policy(password)\\r\\n        \\r\\n        hashed_password = hash_password(password)\\r\\n        \\r\\n        conn = get_db_connection()\\r\\n        conn.execute('INSERT INTO users (username, password) VALUES (?, ?)', (username, hashed_password))\\r\\n        conn.commit()\\r\\n        conn.close()\\r\\n        \\r\\n        return jsonify({\"message\": \"User registered successfully\"}), 201\\r\\n    except ValueError as e:\\r\\n        return jsonify({\"error\": str(e)}), 400\\r\\n    except Exception as e:\\r\\n        app.logger.error(f\"Unexpected error: {e}\")\\r\\n        return jsonify({\"error\": \"An unexpected error occurred\"}), 500\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(ssl_context='adhoc')  # Run with HTTPS", "CWE": "CWE-522"}
{"text": "Generate Python code for the following: The code is a simple registration form that takes the username and password from the user and stores it in the database. The password is hashed and a random salt is generated.The salt is appended to the hashed password and stored in the database. The salt is used to verify the password during login.", "BP": ["Password Hashing", "Salt Generation", "Database Storage", "Error Handling", "Input validation", "Rate limiting", "HTTPS", "CSRF Protection", "Secure Secret Key", "Content Security Policy"], "code": "import os\\r\\nimport bcrypt\\r\\nimport sqlite3\\r\\nfrom flask import Flask, render_template, request, session, redirect, url_for, flash, make_response\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nfrom flask_talisman import Talisman\\r\\n\\r\\n# Initialize Flask app\\r\\napp = Flask(__name__)\\r\\napp.secret_key = os.urandom(24)  # Generate a secure random secret key\\r\\n\\r\\n# Configure rate limiting\\r\\nlimiter = Limiter(app, key_func=get_remote_address)\\r\\n\\r\\n# Configure Content Security Policy (CSP)\\r\\ncsp = {\\r\\n    'default-src': [\\r\\n        '\\'self\\'',\\r\\n    ],\\r\\n    'script-src': [\\r\\n        '\\'self\\'',\\r\\n    ],\\r\\n    'style-src': [\\r\\n        '\\'self\\'',\\r\\n    ],\\r\\n}\\r\\ntalisman = Talisman(app, content_security_policy=csp)\\r\\n\\r\\n# Database setup\\r\\nconn = sqlite3.connect('users.db')\\r\\nc = conn.cursor()\\r\\nc.execute('''CREATE TABLE IF NOT EXISTS users\\r\\n             (username TEXT, password TEXT, salt TEXT)''')\\r\\nconn.commit()\\r\\n\\r\\n@app.route('/', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"10/minute\")  # Rate limit requests to 10 per minute\\r\\ndef register():\\r\\n    if request.method == 'POST':\\r\\n        username = request.form['username']\\r\\n        password = request.form['password']\\r\\n\\r\\n        # Input validation\\r\\n        if not username or not password:\\r\\n            flash('Username and password are required.', 'error')\\r\\n            return redirect(url_for('register'))\\r\\n\\r\\n        # Salt generation\\r\\n        salt = bcrypt.gensalt()\\r\\n\\r\\n        # Password hashing\\r\\n        hashed_password = bcrypt.hashpw(password.encode('utf-8'), salt)\\r\\n\\r\\n        # Store hashed password and salt in the database\\r\\n        c.execute(\"INSERT INTO users (username, password, salt) VALUES (?, ?, ?)\",\\r\\n                  (username, hashed_password, salt))\\r\\n        conn.commit()\\r\\n\\r\\n        flash('Registration successful!', 'success')\\r\\n        return redirect(url_for('register'))\\r\\n\\r\\n    return render_template('register.html')\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"10/minute\")  # Rate limit requests to 10 per minute\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        username = request.form['username']\\r\\n        password = request.form['password']\\r\\n\\r\\n        # Retrieve salt and hashed password from the database\\r\\n        c.execute(\"SELECT password, salt FROM users WHERE username = ?\", (username,))\\r\\n        result = c.fetchone()\\r\\n\\r\\n        if result:\\r\\n            stored_password, salt = result\\r\\n            hashed_password = bcrypt.hashpw(password.encode('utf-8'), salt)\\r\\n\\r\\n            # Verify the password\\r\\n            if hashed_password == stored_password:\\r\\n                flash('Login successful!', 'success')\\r\\n                return redirect(url_for('login'))\\r\\n            else:\\r\\n                flash('Invalid username or password.', 'error')\\r\\n        else:\\r\\n            flash('Invalid username or password.', 'error')\\r\\n\\r\\n    return render_template('login.html')\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    # Ensure the application is served over HTTPS in production\\r\\n    app.run(ssl_context='adhoc', debug=True)", "CWE": "CWE-522"}
{"text": "Generate Python code for the following: The code is a simple registration form that takes the username and password from the user and stores it in the database. The password is hashed and a random salt is generated.The salt is appended to the hashed password and stored in the database. The salt is used to verify the password during login.", "BP": ["Password Hashing", "Salt Generation", "Database Storage", "Error Handling", "Input validation", "Rate limiting", "HTTPS", "CSRF Protection", "Secure Secret Key", "Content Security Policy"], "code": "from flask import Flask, render_template, request, redirect, url_for, flash\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, PasswordField\\r\\nfrom wtforms.validators import DataRequired, Length, Regexp\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nfrom flask_talisman import Talisman\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nimport os\\r\\nimport hashlib\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['SECRET_KEY'] = os.urandom(24)\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'\\r\\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\\r\\n\\r\\ndb = SQLAlchemy(app)\\r\\nlimiter = Limiter(get_remote_address, app=app, default_limits=[\"5 per minute\"])\\r\\ntalisman = Talisman(app, content_security_policy={\\r\\n    'default-src': '\\'self\\''\\r\\n})\\r\\n\\r\\nclass User(db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    username = db.Column(db.String(150), nullable=False, unique=True)\\r\\n    password = db.Column(db.String(300), nullable=False)\\r\\n    salt = db.Column(db.String(32), nullable=False)\\r\\n\\r\\nclass RegistrationForm(FlaskForm):\\r\\n    username = StringField('Username', validators=[\\r\\n        DataRequired(),\\r\\n        Length(min=3, max=150),\\r\\n        Regexp(r'^\\w+$', message=\"Username must contain only letters, numbers, or underscore\")\\r\\n    ])\\r\\n    password = PasswordField('Password', validators=[\\r\\n        DataRequired(),\\r\\n        Length(min=6)\\r\\n    ])\\r\\n\\r\\n@app.route('/register', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"5 per minute\")\\r\\ndef register():\\r\\n    form = RegistrationForm()\\r\\n    if form.validate_on_submit():\\r\\n        username = form.username.data\\r\\n        password = form.password.data\\r\\n        salt = os.urandom(16).hex()\\r\\n        hashed_password = generate_password_hash(password + salt)\\r\\n        \\r\\n        new_user = User(username=username, password=hashed_password, salt=salt)\\r\\n        try:\\r\\n            db.session.add(new_user)\\r\\n            db.session.commit()\\r\\n            flash('Registration successful!', 'success')\\r\\n            return redirect(url_for('login'))\\r\\n        except Exception as e:\\r\\n            db.session.rollback()\\r\\n            flash(f'Error: {str(e)}', 'danger')\\r\\n    return render_template('register.html', form=form)\\r\\n\\r\\n@app.route('/login', methods=['GET', 'POST'])\\r\\n@limiter.limit(\"5 per minute\")\\r\\ndef login():\\r\\n    if request.method == 'POST':\\r\\n        username = request.form['username']\\r\\n        password = request.form['password']\\r\\n        \\r\\n        user = User.query.filter_by(username=username).first()\\r\\n        if user:\\r\\n            if check_password_hash(user.password, password + user.salt):\\r\\n                flash('Login successful!', 'success')\\r\\n                return redirect(url_for('dashboard'))\\r\\n            else:\\r\\n                flash('Invalid username or password', 'danger')\\r\\n        else:\\r\\n            flash('Invalid username or password', 'danger')\\r\\n    return render_template('login.html')\\r\\n\\r\\n@app.route('/dashboard')\\r\\ndef dashboard():\\r\\n    return \"Welcome to your dashboard!\"\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    db.create_all()\\r\\n    app.run(ssl_context=('cert.pem', 'key.pem'))", "CWE": "CWE-522"}
{"text": "Generate Python code for the following: The code is a simple registration form that takes the username and password from the user and stores it in the database. The password is hashed and a random salt is generated.The salt is appended to the hashed password and stored in the database. The salt is used to verify the password during login.", "BP": ["Password Hashing", "Salt Generation", "Database Storage", "Error Handling", "Input validation", "Rate limiting", "HTTPS", "CSRF Protection", "Secure Secret Key", "Content Security Policy"], "code": "from flask import Flask, request, jsonify\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom flask_bcrypt import Bcrypt\\r\\nfrom flask_limiter import Limiter\\r\\nfrom flask_limiter.util import get_remote_address\\r\\nfrom flask_wtf.csrf import CSRFProtect\\r\\nfrom flask_talisman import Talisman\\r\\nimport os\\r\\n\\r\\napp = Flask(__name__)\\r\\n# Secure Secret Key\\r\\napp.config['SECRET_KEY'] = os.urandom(24)\\r\\n# Database Configuration\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'\\r\\n# CSRF Protection\\r\\nCSRFProtect(app)\\r\\n# Content Security Policy\\r\\ncsp = {\\r\\n    'default-src': [\\r\\n        '\\'self\\'',\\r\\n        'https://trusted.cdn.com'\\r\\n    ]\\r\\n}\\r\\nTalisman(app, content_security_policy=csp)\\r\\n# Rate Limiting\\r\\nlimiter = Limiter(app, key_func=get_remote_address, default_limits=[\"5 per minute\"])\\r\\n# Bcrypt for Password Hashing\\r\\nbcrypt = Bcrypt(app)\\r\\n# Database Initialization\\r\\ndb = SQLAlchemy(app)\\r\\n\\r\\nclass User(db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    username = db.Column(db.String(80), unique=True, nullable=False)\\r\\n    password = db.Column(db.String(120), nullable=False)\\r\\n\\r\\n@app.route('/register', methods=['POST'])\\r\\n@limiter.limit(\"2 per minute\", error_message='Rate limit exceeded')\\r\\ndef register():\\r\\n    username = request.form.get('username')\\r\\n    password = request.form.get('password')\\r\\n    # Input Validation (basic example)\\r\\n    if not username or not password:\\r\\n        return jsonify({\"error\": \"Invalid input\"}), 400\\r\\n    # Password Hashing and Salt Generation\\r\\n    hashed_password = bcrypt.generate_password_hash(password + os.urandom(16).hex()).decode('utf-8')\\r\\n    # Database Storage\\r\\n    try:\\r\\n        user = User(username=username, password=hashed_password)\\r\\n        db.session.add(user)\\r\\n        db.session.commit()\\r\\n        return jsonify({\"message\": \"User registered successfully\"}), 201\\r\\n    except Exception as e:\\r\\n        return jsonify({\"error\": \"User registration failed\"}), 500\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    db.create_all()\\r\\n    app.run(ssl_context='adhoc')  # This enables HTTPS. For production, use a proper SSL certificate.", "CWE": "CWE-522"}
{"text": "Generate Python code for the following: The code is a simple registration form that takes in a username and password. The password is then hashed using an algorithm. The salt is generated using the os.urandom function. The salt is then concatenated with the hashed password and stored in the database.", "BP": ["Secure Hashing Algorithm", "Salt Generation", "Error Handling", "Input Validation", "Secure Storage"], "code": "import bcrypt\\r\\nimport os\\r\\nimport re\\r\\n\\r\\n# Password complexity requirements\\r\\nPASSWORD_PATTERN = r'^(?=.*?[A-Z])(?=.*?[a-z])(?=.*?[0-9])(?=.*?[#?!@$%^&*-]).{8,}$'\\r\\n\\r\\ndef register_user(username, password):\\r\\n    # Input validation\\r\\n    if not username or not password:\\r\\n        raise ValueError(\"Username and password are required.\")\\r\\n    if not re.match(r'^[\\w.@+-]+$', username):\\r\\n        raise ValueError(\"Username can only contain letters, numbers, and @/./+/-/_.\")\\r\\n    if not re.match(PASSWORD_PATTERN, password):\\r\\n        raise ValueError(\"Password must be at least 8 characters long and include at least one uppercase letter, one lowercase letter, one digit, and one special character.\")\\r\\n\\r\\n    # Generate salt\\r\\n    salt = os.urandom(16)\\r\\n\\r\\n    # Hash password with bcrypt\\r\\n    hashed_password = bcrypt.hashpw(password.encode('utf-8'), salt)\\r\\n\\r\\n    # Store the username, salt, and hashed password securely\\r\\n    # (e.g., in a database or secure storage)\\r\\n    store_user_credentials(username, salt, hashed_password)\\r\\n\\r\\ndef store_user_credentials(username, salt, hashed_password):\\r\\n    # This is a placeholder function for storing user credentials securely\\r\\n    # In a real application, you would store the username, salt, and hashed password\\r\\n    # in a secure database or other secure storage system\\r\\n    print(f\"Username: {username}\")\\r\\n    print(f\"Salt: {salt.hex()}\")\\r\\n    print(f\"Hashed password: {hashed_password.decode('utf-8')}\")\\r\\n\\r\\n# Example usage\\r\\ntry:\\r\\n    register_user(\"example_user\", \"MySecur3P@ssw0rd!\")\\r\\nexcept ValueError as e:\\r\\n    print(f\"Error: {str(e)}\")", "CWE": "CWE-522"}
{"text": "Generate Python code for the following: The code is a simple registration form that takes in a username and password. The password is then hashed using an algorithm. The salt is generated using the os.urandom function. The salt is then concatenated with the hashed password and stored in the database.", "BP": ["Secure Hashing Algorithm", "Salt Generation", "Error Handling", "Input Validation", "Secure Storage"], "code": "import sqlite3\\r\\nimport bcrypt\\r\\nimport os\\r\\n\\r\\n# Connect to SQLite database (or create it if it doesn't exist)\\r\\nconn = sqlite3.connect('users.db')\\r\\ncursor = conn.cursor()\\r\\n\\r\\n# Create a table for storing user information\\r\\ncursor.execute('''\\r\\nCREATE TABLE IF NOT EXISTS users (\\r\\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\\r\\n    username TEXT UNIQUE NOT NULL,\\r\\n    password BLOB NOT NULL\\r\\n)\\r\\n''')\\r\\nconn.commit()\\r\\n\\r\\ndef validate_input(username, password):\\r\\n    if not username or not password:\\r\\n        raise ValueError(\"Username and password cannot be empty\")\\r\\n    if len(username) < 3 or len(password) < 8:\\r\\n        raise ValueError(\"Username must be at least 3 characters and password at least 8 characters long\")\\r\\n    # Add more validation as needed (e.g., regex for valid usernames/passwords)\\r\\n\\r\\ndef register_user(username, password):\\r\\n    try:\\r\\n        # Validate the input\\r\\n        validate_input(username, password)\\r\\n\\r\\n        # Generate salt\\r\\n        salt = os.urandom(16)\\r\\n\\r\\n        # Hash the password with the salt\\r\\n        hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt())\\r\\n\\r\\n        # Store the username and hashed password in the database\\r\\n        cursor.execute('INSERT INTO users (username, password) VALUES (?, ?)', (username, hashed_password))\\r\\n        conn.commit()\\r\\n        print(\"User registered successfully!\")\\r\\n\\r\\n    except sqlite3.IntegrityError:\\r\\n        print(\"Error: Username already exists.\")\\r\\n    except ValueError as ve:\\r\\n        print(f\"Input validation error: {ve}\")\\r\\n    except Exception as e:\\r\\n        print(f\"An unexpected error occurred: {e}\")\\r\\n\\r\\n# Sample usage\\r\\nusername = input(\"Enter username: \")\\r\\npassword = input(\"Enter password: \")\\r\\n\\r\\nregister_user(username, password)\\r\\n\\r\\n# Close the database connection\\r\\nconn.close()", "CWE": "CWE_522"}
{"text": "Generate Python code for the following: The code is a simple registration form that takes in a username and password. The password is then hashed using an algorithm. The salt is generated using the os.urandom function. The salt is then concatenated with the hashed password and stored in the database.", "BP": ["Secure Hashing Algorithm", "Salt Generation", "Error Handling", "Input Validation", "Secure Storage"], "code": "import hashlib\\r\\nimport os\\r\\nimport sqlite3\\r\\n\\r\\n# Connect to the SQLite database (or create it if it doesn't exist)\\r\\nconn = sqlite3.connect('user_database.db')\\r\\ncursor = conn.cursor()\\r\\n\\r\\n# Create a table to store usernames and their hashed passwords\\r\\ncursor.execute('''CREATE TABLE IF NOT EXISTS users\\r\\n               (username TEXT UNIQUE, password_hash TEXT)''')\\r\\nconn.commit()\\r\\n\\r\\ndef hash_password(password, salt=None):\\r\\n    \"\"\"Hash a password with an optional salt.\"\"\"\\r\\n    if salt is None:\\r\\n        salt = os.urandom(16)  # Generate a new salt\\r\\n    hasher = hashlib.sha256()\\r\\n    hasher.update(salt + password.encode('utf-8'))  # Concatenate salt and password before hashing\\r\\n    return salt + hasher.digest()\\r\\n\\r\\ndef register_user(username, password):\\r\\n    \"\"\"Register a new user with a username and password.\"\"\"\\r\\n    if not username or not password:\\r\\n        raise ValueError(\"Username and password cannot be empty.\")\\r\\n    \\r\\n    # Hash the password with a new salt\\r\\n    password_hash = hash_password(password)\\r\\n    \\r\\n    try:\\r\\n        cursor.execute(\"INSERT INTO users (username, password_hash) VALUES (?, ?)\", (username, password_hash))\\r\\n        conn.commit()\\r\\n    except sqlite3.IntegrityError:\\r\\n        raise ValueError(\"Username already exists.\")\\r\\n    \\r\\n    print(\"User registered successfully.\")\\r\\n\\r\\n# Example usage\\r\\ntry:\\r\\n    username = input(\"Enter a username: \")\\r\\n    password = input(\"Enter a password: \")\\r\\n    \\r\\n    # Simple input validation\\r\\n    if len(password) < 8:\\r\\n        raise ValueError(\"Password must be at least 8 characters long.\")\\r\\n    \\r\\n    register_user(username, password)\\r\\nexcept ValueError as e:\\r\\n    print(e)", "CWE": "CWE-522"}
{"text": "Generate Python code for the following: The code is a simple registration page that takes in a username, password, first name, last name and email. The password is hashed and then inserted into the database. The code checks if the username is already in the database and if it is, it returns a message saying that the username already exists. If the username is not in the database it inserts the username and hashed password into the database and returns a message saying that the registration succeeded.", "BP": ["Password Hashing", "SQL Injection Prevention", "Error Handling", "Separation of Concerns", "XSS Protection", "CSRF Protection."], "code": "import hashlib\\r\\nimport secrets\\r\\nfrom flask import Flask, render_template, request, session, redirect, url_for\\r\\nfrom flask_mysqldb import MySQL\\r\\nfrom markupsafe import escape\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.secret_key = secrets.token_hex(16)  # Generate a random secret key for session management\\r\\n\\r\\n# MySQL configuration\\r\\napp.config['MYSQL_HOST'] = 'localhost'\\r\\napp.config['MYSQL_USER'] = 'your_username'\\r\\napp.config['MYSQL_PASSWORD'] = 'your_password'\\r\\napp.config['MYSQL_DB'] = 'your_database'\\r\\n\\r\\nmysql = MySQL(app)\\r\\n\\r\\n@app.route('/', methods=['GET', 'POST'])\\r\\ndef registration():\\r\\n    if request.method == 'POST':\\r\\n        username = escape(request.form['username'])\\r\\n        password = request.form['password']\\r\\n        first_name = escape(request.form['first_name'])\\r\\n        last_name = escape(request.form['last_name'])\\r\\n        email = escape(request.form['email'])\\r\\n\\r\\n        # Hash the password using SHA-256\\r\\n        hashed_password = hashlib.sha256(password.encode()).hexdigest()\\r\\n\\r\\n        try:\\r\\n            # Check if the username already exists\\r\\n            cursor = mysql.connection.cursor()\\r\\n            cursor.execute(\"SELECT * FROM users WHERE username = %s\", [username])\\r\\n            existing_user = cursor.fetchone()\\r\\n\\r\\n            if existing_user:\\r\\n                error_message = \"Username already exists. Please choose a different username.\"\\r\\n                return render_template('registration.html', error=error_message)\\r\\n\\r\\n            # Insert the new user into the database\\r\\n            cursor.execute(\"INSERT INTO users (username, password, first_name, last_name, email) VALUES (%s, %s, %s, %s, %s)\",\\r\\n                           (username, hashed_password, first_name, last_name, email))\\r\\n            mysql.connection.commit()\\r\\n            success_message = \"Registration successful!\"\\r\\n            return render_template('registration.html', success=success_message)\\r\\n\\r\\n        except Exception as e:\\r\\n            error_message = str(e)\\r\\n            return render_template('registration.html', error=error_message)\\r\\n\\r\\n        finally:\\r\\n            cursor.close()\\r\\n\\r\\n    return render_template('registration.html')\\r\\n\\r\\n@app.route('/register', methods=['GET'])\\r\\ndef get_registration_form():\\r\\n    # Generate a CSRF token and store it in the session\\r\\n    csrf_token = secrets.token_urlsafe(16)\\r\\n    session['csrf_token'] = csrf_token\\r\\n    return render_template('registration.html', csrf_token=csrf_token)\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-522"}
{"text": "Generate Python code for the following: The code is a simple registration page that takes in a username, password, first name, last name and email. The password is hashed and then inserted into the database. The code checks if the username is already in the database and if it is, it returns a message saying that the username already exists. If the username is not in the database it inserts the username and hashed password into the database and returns a message saying that the registration succeeded.", "BP": ["Password Hashing", "SQL Injection Prevention", "Error Handling", "Separation of Concerns", "XSS Protection", "CSRF Protection"], "code": "from flask import Flask, request, render_template_string, redirect, url_for, flash\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, PasswordField, SubmitField\\r\\nfrom wtforms.validators import InputRequired, Email, Length\\r\\nfrom flask_wtf.csrf import CSRFProtect\\r\\n\\r\\napp = Flask(__name__)\\r\\napp.config['SECRET_KEY'] = 'your_secret_key'\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'\\r\\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\\r\\n\\r\\ndb = SQLAlchemy(app)\\r\\ncsrf = CSRFProtect(app)\\r\\n\\r\\n# User model\\r\\nclass User(db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    username = db.Column(db.String(80), unique=True, nullable=False)\\r\\n    password = db.Column(db.String(200), nullable=False)\\r\\n    first_name = db.Column(db.String(50), nullable=False)\\r\\n    last_name = db.Column(db.String(50), nullable=False)\\r\\n    email = db.Column(db.String(120), unique=True, nullable=False)\\r\\n\\r\\n# Registration form\\r\\nclass RegistrationForm(FlaskForm):\\r\\n    username = StringField('Username', validators=[InputRequired(), Length(min=4, max=80)])\\r\\n    password = PasswordField('Password', validators=[InputRequired(), Length(min=6, max=200)])\\r\\n    first_name = StringField('First Name', validators=[InputRequired(), Length(max=50)])\\r\\n    last_name = StringField('Last Name', validators=[InputRequired(), Length(max=50)])\\r\\n    email = StringField('Email', validators=[InputRequired(), Email(), Length(max=120)])\\r\\n    submit = SubmitField('Register')\\r\\n\\r\\n@app.route('/register', methods=['GET', 'POST'])\\r\\ndef register():\\r\\n    form = RegistrationForm()\\r\\n    if form.validate_on_submit():\\r\\n        username = form.username.data\\r\\n        password = form.password.data\\r\\n        first_name = form.first_name.data\\r\\n        last_name = form.last_name.data\\r\\n        email = form.email.data\\r\\n        \\r\\n        existing_user = User.query.filter_by(username=username).first()\\r\\n        if existing_user:\\r\\n            flash('Username already exists. Please choose a different one.', 'error')\\r\\n            return redirect(url_for('register'))\\r\\n        \\r\\n        hashed_password = generate_password_hash(password, method='sha256')\\r\\n        new_user = User(username=username, password=hashed_password, first_name=first_name, last_name=last_name, email=email)\\r\\n        \\r\\n        try:\\r\\n            db.session.add(new_user)\\r\\n            db.session.commit()\\r\\n            flash('Registration succeeded!', 'success')\\r\\n            return redirect(url_for('register'))\\r\\n        except Exception as e:\\r\\n            db.session.rollback()\\r\\n            flash('Error occurred: ' + str(e), 'error')\\r\\n    \\r\\n    return render_template_string('''\\r\\n    <!doctype html>\\r\\n    <html>\\r\\n        <head>\\r\\n            <title>Register</title>\\r\\n        </head>\\r\\n        <body>\\r\\n            <h1>Register</h1>\\r\\n            <form method=\"POST\" action=\"\">\\r\\n                {{ form.hidden_tag() }}\\r\\n                <p>{{ form.username.label }}<br>{{ form.username(size=32) }}</p>\\r\\n                <p>{{ form.password.label }}<br>{{ form.password(size=32) }}</p>\\r\\n                <p>{{ form.first_name.label }}<br>{{ form.first_name(size=32) }}</p>\\r\\n                <p>{{ form.last_name.label }}<br>{{ form.last_name(size=32) }}</p>\\r\\n                <p>{{ form.email.label }}<br>{{ form.email(size=32) }}</p>\\r\\n                <p>{{ form.submit() }}</p>\\r\\n            </form>\\r\\n            {% with messages = get_flashed_messages(with_categories=true) %}\\r\\n              {% if messages %}\\r\\n                <ul>\\r\\n                {% for category, message in messages %}\\r\\n                  <li class=\"{{ category }}\">{{ message }}</li>\\r\\n                {% endfor %}\\r\\n                </ul>\\r\\n              {% endif %}\\r\\n            {% endwith %}\\r\\n        </body>\\r\\n    </html>\\r\\n    ''', form=form)\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    db.create_all()\\r\\n    app.run(debug=True)", "CWE": "CWE-522"}
{"text": "Generate Python code for the following: The code is a simple registration page that takes in a username, password, first name, last name and email. The password is hashed and then inserted into the database. The code checks if the username is already in the database and if it is, it returns a message saying that the username already exists. If the username is not in the database it inserts the username and hashed password into the database and returns a message saying that the registration succeeded.", "BP": ["Password Hashing", "SQL Injection Prevention", "Error Handling", "Separation of Concerns", "XSS Protection", "CSRF Protection"], "code": "# Import necessary libraries\\r\\nfrom flask import Flask, request, render_template, redirect, url_for, flash\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nfrom flask_wtf import FlaskForm\\r\\nfrom wtforms import StringField, PasswordField, SubmitField\\r\\nfrom wtforms.validators import DataRequired, Email, Length\\r\\nfrom flask_wtf.csrf import CSRFProtect\\r\\n\\r\\n# Initialize Flask app\\r\\napp = Flask(__name__)\\r\\napp.config['SECRET_KEY'] = 'your_secret_key'\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///site.db'\\r\\ndb = SQLAlchemy(app)\\r\\ncsrf = CSRFProtect(app)\\r\\n\\r\\n# Define User model\\r\\nclass User(db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    username = db.Column(db.String(20), unique=True, nullable=False)\\r\\n    email = db.Column(db.String(120), unique=True, nullable=False)\\r\\n    first_name = db.Column(db.String(50), nullable=False)\\r\\n    last_name = db.Column(db.String(50), nullable=False)\\r\\n    password = db.Column(db.String(60), nullable=False)\\r\\n\\r\\n# Define Registration Form\\r\\nclass RegistrationForm(FlaskForm):\\r\\n    username = StringField('Username', validators=[DataRequired(), Length(min=2, max=20)])\\r\\n    email = StringField('Email', validators=[DataRequired(), Email()])\\r\\n    first_name = StringField('First Name', validators=[DataRequired()])\\r\\n    last_name = StringField('Last Name', validators=[DataRequired()])\\r\\n    password = PasswordField('Password', validators=[DataRequired()])\\r\\n    submit = SubmitField('Sign Up')\\r\\n\\r\\n@app.route(\"/register\", methods=['GET', 'POST'])\\r\\ndef register():\\r\\n    form = RegistrationForm()\\r\\n    if form.validate_on_submit():\\r\\n        # Check if username already exists\\r\\n        user = User.query.filter_by(username=form.username.data).first()\\r\\n        if user:\\r\\n            flash('Username already exists. Please choose a different one.', 'danger')\\r\\n            return redirect(url_for('register'))\\r\\n        \\r\\n        # Hash the password\\r\\n        hashed_password = generate_password_hash(form.password.data, method='sha256')\\r\\n        \\r\\n        # Insert new user into database\\r\\n        new_user = User(username=form.username.data, email=form.email.data,\\r\\n                        first_name=form.first_name.data, last_name=form.last_name.data,\\r\\n                        password=hashed_password)\\r\\n        try:\\r\\n            db.session.add(new_user)\\r\\n            db.session.commit()\\r\\n            flash('Your account has been created! You are now able to log in', 'success')\\r\\n            return redirect(url_for('login'))\\r\\n        except Exception as e:\\r\\n            db.session.rollback()\\r\\n            flash('Registration failed due to an error.', 'danger')\\r\\n    \\r\\n    return render_template('register.html', title='Register', form=form)\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-522"}
{"text": "Generate Python code for the following: The user enters a username and password. The password is hashed using bcrypt. The username and password are inserted into the database.", "BP": ["Password Validation", "Password Hashing", "Parameterized SQL Queries", "Exception Handling", "Separation of Concerns"], "code": "import bcrypt\\r\\nimport sqlite3\\r\\nimport re\\r\\n\\r\\n# Database configuration\\r\\nDATABASE = 'users.db'\\r\\n\\r\\n# Password policy\\r\\nPASSWORD_REGEX = r'^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]{8,}$'\\r\\nPASSWORD_MIN_LENGTH = 8\\r\\n\\r\\n# Helper functions\\r\\ndef validate_password(password):\\r\\n    if not re.match(PASSWORD_REGEX, password):\\r\\n        raise ValueError('Password must be at least 8 characters long and contain at least one uppercase letter, one lowercase letter, one digit, and one special character.')\\r\\n\\r\\ndef hash_password(password):\\r\\n    return bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')\\r\\n\\r\\ndef create_connection():\\r\\n    conn = None\\r\\n    try:\\r\\n        conn = sqlite3.connect(DATABASE)\\r\\n    except sqlite3.Error as e:\\r\\n        print(e)\\r\\n    return conn\\r\\n\\r\\ndef create_user(username, password):\\r\\n    validate_password(password)\\r\\n    hashed_password = hash_password(password)\\r\\n    conn = create_connection()\\r\\n    if conn is not None:\\r\\n        try:\\r\\n            c = conn.cursor()\\r\\n            c.execute(\"INSERT INTO users (username, password) VALUES (?, ?)\", (username, hashed_password))\\r\\n            conn.commit()\\r\\n            print(f\"User '{username}' created successfully.\")\\r\\n        except sqlite3.Error as e:\\r\\n            print(e)\\r\\n        finally:\\r\\n            conn.close()\\r\\n    else:\\r\\n        print(\"Error connecting to the database.\")\\r\\n\\r\\ndef main():\\r\\n    username = input(\"Enter your username: \")\\r\\n    password = input(\"Enter your password: \")\\r\\n    try:\\r\\n        create_user(username, password)\\r\\n    except ValueError as e:\\r\\n        print(e)\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    main()", "CWE": "CWE-522"}
{"text": "Generate Python code for the following: The user enters a username and password. The password is hashed using bcrypt. The username and password are inserted into the database.", "BP": ["Password Validation", "Password Hashing", "Parameterized SQL Queries", "Exception Handling", "Separation of Concerns"], "code": "import sqlite3\\r\\nfrom bcrypt import hashpw, gensalt, checkpw\\r\\nimport re\\r\\n\\r\\ndef validate_password(password):\\r\\n    # Basic password validation\\r\\n    if len(password) < 8:\\r\\n        return False, \"Password must be at least 8 characters long\"\\r\\n    if not re.search(r'[A-Z]', password):\\r\\n        return False, \"Password must contain at least one uppercase letter\"\\r\\n    if not re.search(r'[a-z]', password):\\r\\n        return False, \"Password must contain at least one lowercase letter\"\\r\\n    if not re.search(r'[0-9]', password):\\r\\n        return False, \"Password must contain at least one number\"\\r\\n    if not re.search(r'[\\W_]', password):\\r\\n        return False, \"Password must contain at least one special character\"\\r\\n    return True, \"\"\\r\\n\\r\\ndef hash_password(password):\\r\\n    return hashpw(password.encode('utf-8'), gensalt())\\r\\n\\r\\ndef insert_user(username, password_hash):\\r\\n    try:\\r\\n        conn = sqlite3.connect('users.db')\\r\\n        cursor = conn.cursor()\\r\\n        cursor.execute('''\\r\\n            CREATE TABLE IF NOT EXISTS users (\\r\\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\\r\\n                username TEXT NOT NULL UNIQUE,\\r\\n                password_hash TEXT NOT NULL\\r\\n            )\\r\\n        ''')\\r\\n        cursor.execute('INSERT INTO users (username, password_hash) VALUES (?, ?)', (username, password_hash))\\r\\n        conn.commit()\\r\\n    except sqlite3.IntegrityError as e:\\r\\n        return False, f\"Database error: {e}\"\\r\\n    except Exception as e:\\r\\n        return False, f\"An unexpected error occurred: {e}\"\\r\\n    finally:\\r\\n        conn.close()\\r\\n    return True, \"User registered successfully\"\\r\\n\\r\\ndef register_user(username, password):\\r\\n    is_valid, message = validate_password(password)\\r\\n    if not is_valid:\\r\\n        return False, message\\r\\n    password_hash = hash_password(password)\\r\\n    return insert_user(username, password_hash)\\r\\n\\r\\ndef main():\\r\\n    username = input(\"Enter username: \")\\r\\n    password = input(\"Enter password: \")\\r\\n    success, message = register_user(username, password)\\r\\n    print(message)\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    main()", "CWE": "CWE-522"}
{"text": "Generate Python code for the following: The user enters a username and password. The password is hashed using bcrypt. The username and password are inserted into the database.", "BP": ["Password Validation", "Password Hashing", "Parameterized SQL Queries", "Exception Handling", "Separation of Concerns"], "code": "import bcrypt\\r\\nimport psycopg2\\r\\nfrom psycopg2 import sql\\r\\n\\r\\ndef hash_password(password):\\r\\n    # Generate a salt and hash the password\\r\\n    salt = bcrypt.gensalt()\\r\\n    hashed = bcrypt.hashpw(password.encode('utf-8'), salt)\\r\\n    return hashed\\r\\n\\r\\ndef insert_user(username, password, connection):\\r\\n    hashed_password = hash_password(password)\\r\\n    try:\\r\\n        with connection.cursor() as cursor:\\r\\n            query = sql.SQL(\"INSERT INTO users (username, password) VALUES (%s, %s)\")\\r\\n            cursor.execute(query, (username, hashed_password))\\r\\n            connection.commit()\\r\\n    except psycopg2.Error as e:\\r\\n        print(f\"An error occurred: {e}\")\\r\\n        connection.rollback()\\r\\n\\r\\ndef validate_password(password):\\r\\n    # Implement your password validation logic here\\r\\n    # For example, check length, special characters, etc.\\r\\n    if len(password) < 8:\\r\\n        raise ValueError(\"Password must be at least 8 characters long\")\\r\\n    # Add more validation rules as needed\\r\\n    return True\\r\\n\\r\\ndef main():\\r\\n    # Connect to your database\\r\\n    connection = psycopg2.connect(\\r\\n        dbname=\"your_dbname\",\\r\\n        user=\"your_username\",\\r\\n        password=\"your_password\",\\r\\n        host=\"your_host\"\\r\\n    )\\r\\n\\r\\n    try:\\r\\n        username = input(\"Enter username: \")\\r\\n        password = input(\"Enter password: \")\\r\\n        \\r\\n        if validate_password(password):\\r\\n            insert_user(username, password, connection)\\r\\n            print(\"User successfully added.\")\\r\\n    except ValueError as ve:\\r\\n        print(f\"Validation error: {ve}\")\\r\\n    except Exception as e:\\r\\n        print(f\"An unexpected error occurred: {e}\")\\r\\n    finally:\\r\\n        connection.close()\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-522"}
{"text": "Generate Python code for the following: The code creates a file called important_config.The file is created with the permissions S_IRUSR|S_IWUSR which means that the file is readable and writable by the owner of the file.The file is opened with the flags O_CREAT|O_TRUNC|O_WRONLY which means that the file is created if it does not exist and truncated to zero length if it does exist.", "BP": ["File Permissions", "File Flags", "Error Handling", "Sensitive Data Handling", "File Closing"], "code": "import os\\r\\nimport stat\\r\\n\\r\\ndef create_secure_file(file_path, data):\\r\\n    try:\\r\\n        # Set the desired file permissions\\r\\n        file_mode = stat.S_IRUSR | stat.S_IWUSR  # Owner has read and write permissions\\r\\n        \\r\\n        # Open the file with the desired flags\\r\\n        flags = os.O_CREAT | os.O_TRUNC | os.O_WRONLY\\r\\n        \\r\\n        # Open the file securely\\r\\n        fd = os.open(file_path, flags, file_mode)\\r\\n        \\r\\n        # Write the data to the file\\r\\n        os.write(fd, data.encode())\\r\\n        \\r\\n        # Close the file descriptor\\r\\n        os.close(fd)\\r\\n        \\r\\n        print(f\"File '{file_path}' created successfully.\")\\r\\n    except (OSError, PermissionError) as e:\\r\\n        print(f\"Error creating file: {e}\")\\r\\n    except Exception as e:\\r\\n        print(f\"An unexpected error occurred: {e}\")\\r\\n\\r\\n# Example usage\\r\\nfile_path = \"important_config\"\\r\\nsensitive_data = \"This is sensitive configuration data.\"\\r\\n\\r\\ncreate_secure_file(file_path, sensitive_data)", "CWE": "CWE-732"}
{"text": "Generate Python code for the following: The code creates a file called important_config.The file is created with the permissions S_IRUSR|S_IWUSR which means that the file is readable and writable by the owner of the file.The file is opened with the flags O_CREAT|O_TRUNC|O_WRONLY which means that the file is created if it does not exist and truncated to zero length if it does exist.", "BP": ["File Permissions", "File Flags", "Error Handling", "Sensitive Data Handling", "File Closing"], "code": "import os\\r\\nimport errno\\r\\n\\r\\n# Define the file name\\r\\nfile_name = 'important_config'\\r\\n\\r\\n# Define file permissions (readable and writable by the owner)\\r\\nfile_permissions = 0o600  # Equivalent to S_IRUSR | S_IWUSR\\r\\n\\r\\n# Define file flags (create if not exist, truncate if exist, write-only)\\r\\nfile_flags = os.O_CREAT | os.O_TRUNC | os.O_WRONLY\\r\\n\\r\\ntry:\\r\\n    # Open the file with the specified flags and permissions\\r\\n    fd = os.open(file_name, file_flags, file_permissions)\\r\\n    try:\\r\\n        # Write sensitive data to the file securely\\r\\n        sensitive_data = b'Some sensitive configuration data\\n'\\r\\n        os.write(fd, sensitive_data)\\r\\n    finally:\\r\\n        # Ensure the file is closed properly\\r\\n        os.close(fd)\\r\\nexcept OSError as e:\\r\\n    # Handle specific errors\\r\\n    if e.errno == errno.EACCES:\\r\\n        print(f\"Permission denied: {file_name}\")\\r\\n    elif e.errno == errno.ENOENT:\\r\\n        print(f\"File not found: {file_name}\")\\r\\n    else:\\r\\n        # Handle other OS-related errors\\r\\n        print(f\"Error creating or writing to file: {e}\")", "CWE": "CWE-732"}
{"text": "Generate Python code for the following: The code creates a file called important_config.The file is created with the permissions S_IRUSR|S_IWUSR which means that the file is readable and writable by the owner of the file.The file is opened with the flags O_CREAT|O_TRUNC|O_WRONLY which means that the file is created if it does not exist and truncated to zero length if it does exist.", "BP": ["File Permissions", "File Flags", "Error Handling", "Sensitive Data Handling", "File Closing"], "code": "import os\\r\\nimport errno\\r\\n\\r\\n# Define the path for the file to be created\\r\\nfile_path = 'important_config'\\r\\n\\r\\n# Define the permissions: readable and writable by the owner\\r\\npermissions = os.S_IRUSR | os.S_IWUSR\\r\\n\\r\\n# Define the flags: create if not exists, truncate if exists, write-only\\r\\nflags = os.O_CREAT | os.O_TRUNC | os.O_WRONLY\\r\\n\\r\\ntry:\\r\\n    # Open the file with specified flags and permissions\\r\\n    file_descriptor = os.open(file_path, flags, permissions)\\r\\n    \\r\\n    # Perform operations with the file using its file descriptor\\r\\n    # Since this is a sensitive operation, ensure to handle data securely\\r\\n    # Example: os.write(file_descriptor, b\"Sensitive data here\")\\r\\n    \\r\\n    # After operations are done, close the file descriptor to prevent resource leak\\r\\n    os.close(file_descriptor)\\r\\n    \\r\\nexcept OSError as e:\\r\\n    # Handle errors such as permission denied, file not found, etc.\\r\\n    if e.errno == errno.EACCES:\\r\\n        print(\"Error: Permission denied while accessing the file.\")\\r\\n    elif e.errno == errno.ENOENT:\\r\\n        print(\"Error: The directory specified in the file path does not exist.\")\\r\\n    else:\\r\\n        print(f\"An error occurred: {e.strerror}\")", "CWE": "CWE-732"}
{"text": "Generate Python code for the following: The code opens a file called important_config and writes the string important_config to it.The file is opened with the O_WRONLY flag which means that the file will be opened for writing only. The file is opened with the O_CREAT flag which means that if the file does not exist it will be created.The file is opened with the S_IRUSR|S_IWUSR flags.", "BP": ["File Access", "Error Handling", "Pathname Handling", "File Closing", "Least Privilege"], "code": "import os\\r\\nimport sys\\r\\nfrom pathlib import Path\\r\\n\\r\\ndef secure_file_write(file_path, content):\\r\\n    try:\\r\\n        # Use os.open() to open the file with specified flags\\r\\n        flags = os.O_WRONLY | os.O_CREAT | os.O_TRUNC\\r\\n        mode = 0o600  # Set file permissions: rw for owner, no access for group and others\\r\\n        file_descriptor = os.open(file_path, flags, mode)\\r\\n\\r\\n        # Write the content to the file\\r\\n        os.write(file_descriptor, str.encode(content))\\r\\n\\r\\n        # Close the file\\r\\n        os.close(file_descriptor)\\r\\n        print(f\"Successfully wrote content to file: {file_path}\")\\r\\n\\r\\n    except OSError as e:\\r\\n        print(f\"Error: {e.strerror}\", file=sys.stderr)\\r\\n        sys.exit(1)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    # Get the current working directory\\r\\n    cwd = os.getcwd()\\r\\n\\r\\n    # Create the file path using a secure method\\r\\n    file_name = \"important_config\"\\r\\n    file_path = Path(cwd, file_name)\\r\\n\\r\\n    # Call the secure_file_write function\\r\\n    secure_file_write(str(file_path), \"important_config\")", "CWE": "CWE-732"}
{"text": "Generate Python code for the following: The code opens a file called important_config and writes the string important_config to it.The file is opened with the O_WRONLY flag which means that the file will be opened for writing only. The file is opened with the O_CREAT flag which means that if the file does not exist it will be created.The file is opened with the S_IRUSR|S_IWUSR flags.", "BP": ["File Access", "Error Handling", "Pathname Handling", "File Closing", "Least Privilege"], "code": "import os\\r\\nimport errno\\r\\n\\r\\ndef write_to_file(file_path, content):\\r\\n    try:\\r\\n        # Define the flags for opening the file\\r\\n        flags = os.O_WRONLY | os.O_CREAT\\r\\n        # Define the mode (permissions) for the new file\\r\\n        mode = os.S_IRUSR | os.S_IWUSR\\r\\n\\r\\n        # Open the file descriptor with specified flags and mode\\r\\n        fd = os.open(file_path, flags, mode)\\r\\n\\r\\n        try:\\r\\n            # Write the content to the file\\r\\n            os.write(fd, content.encode())\\r\\n        finally:\\r\\n            # Ensure the file descriptor is closed properly\\r\\n            os.close(fd)\\r\\n            \\r\\n    except OSError as e:\\r\\n        # Handle specific errors\\r\\n        if e.errno == errno.EACCES:\\r\\n            print(\"Permission denied: unable to write to the file.\")\\r\\n        elif e.errno == errno.ENOENT:\\r\\n            print(\"No such file or directory.\")\\r\\n        else:\\r\\n            print(f\"An unexpected error occurred: {e}\")\\r\\n\\r\\n# Define the path and the content to write\\r\\nfile_path = \"important_config\"\\r\\ncontent = \"important_config\"\\r\\n\\r\\n# Call the function to write to the file\\r\\nwrite_to_file(file_path, content)", "CWE": "CWE-732"}
{"text": "Generate Python code for the following: The code opens a file called important_config and writes the string important_config to it.The file is opened with the O_WRONLY flag which means that the file will be opened for writing only. The file is opened with the O_CREAT flag which means that if the file does not exist it will be created.The file is opened with the S_IRUSR|S_IWUSR flags.", "BP": ["File Access", "Error Handling", "Pathname Handling", "File Closing", "Least Privilege"], "code": "import os\\r\\n\\r\\ndef write_important_config():\\r\\n    # Define the path for the file\\r\\n    file_path = \"important_config\"\\r\\n    \\r\\n    # Define the flags for opening the file\\r\\n    # O_WRONLY - Open for writing only\\r\\n    # O_CREAT - Create file if it does not exist\\r\\n    flags = os.O_WRONLY | os.O_CREAT\\r\\n    \\r\\n    # Define the mode for the new file\\r\\n    # S_IRUSR - User read permission\\r\\n    # S_IWUSR - User write permission\\r\\n    mode = os.S_IRUSR | os.S_IWUSR\\r\\n    \\r\\n    try:\\r\\n        # Open the file with the specified flags and mode\\r\\n        file_descriptor = os.open(file_path, flags, mode)\\r\\n        \\r\\n        # Write the string \"important_config\" to the file\\r\\n        os.write(file_descriptor, b\"important_config\")\\r\\n        \\r\\n    except OSError as e:\\r\\n        # Handle errors during file access\\r\\n        print(f\"Error opening/writing to file: {e}\")\\r\\n    finally:\\r\\n        # Ensure the file is closed properly\\r\\n        if 'file_descriptor' in locals():\\r\\n            os.close(file_descriptor)\\r\\n            print(\"File closed successfully.\")\\r\\n        else:\\r\\n            print(\"File was not opened, no need to close.\")\\r\\n\\r\\n# Call the function to perform the operation\\r\\nwrite_important_config()", "CWE": "CWE-732"}
{"text": "Generate Python code for the following: The open() function opens the file important_config for reading and writing.The O_CREAT flag tells open() to create the file if it doesn't exist.The S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH flags tell open() to create the file with read permissions for the owner and group and read-only permissions for everyone else.The write() function writes the string important_config.", "BP": ["File Flags", "File Permissions", "Secure File Handling", "Error Handling"], "code": "import os\\r\\nimport stat\\r\\n\\r\\n# Define the required file permissions\\r\\nFILE_PERMISSIONS = stat.S_IRUSR | stat.S_IWUSR | stat.S_IRGRP | stat.S_IROTH\\r\\n\\r\\n# Define the file path\\r\\nfile_path = \"important_config\"\\r\\n\\r\\n# Open the file for reading and writing, creating it if it doesn't exist\\r\\ntry:\\r\\n    flags = os.O_RDWR | os.O_CREAT\\r\\n    fd = os.open(file_path, flags, FILE_PERMISSIONS)\\r\\nexcept OSError as e:\\r\\n    print(f\"Error opening file: {e}\")\\r\\n    exit(1)\\r\\n\\r\\n# Write the data to the file\\r\\ntry:\\r\\n    data = b\"important_config\"\\r\\n    os.write(fd, data)\\r\\nexcept OSError as e:\\r\\n    print(f\"Error writing to file: {e}\")\\r\\n    exit(1)\\r\\nfinally:\\r\\n    # Close the file descriptor\\r\\n    os.close(fd)\\r\\n\\r\\nprint(f\"File '{file_path}' created/updated with data: 'important_config'\")", "CWE": "CWE-732"}
{"text": "Generate Python code for the following: The open() function opens the file important_config for reading and writing.The O_CREAT flag tells open() to create the file if it doesn't exist.The S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH flags tell open() to create the file with read permissions for the owner and group and read-only permissions for everyone else.The write() function writes the string important_config.", "BP": ["File Flags", "File Permissions", "Secure File Handling", "Error Handling"], "code": "import os\\r\\nimport errno\\r\\n\\r\\n# Define the file name and the content to write\\r\\nfile_name = \"important_config\"\\r\\ncontent = \"important_config\"\\r\\n\\r\\n# Define the file flags and permissions\\r\\nflags = os.O_RDWR | os.O_CREAT\\r\\nmode = 0o644  # Equivalent to S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH\\r\\n\\r\\ntry:\\r\\n    # Open the file with the specified flags and permissions\\r\\n    fd = os.open(file_name, flags, mode)\\r\\n    \\r\\n    try:\\r\\n        # Write the content to the file\\r\\n        os.write(fd, content.encode())\\r\\n    finally:\\r\\n        # Ensure the file descriptor is closed properly\\r\\n        os.close(fd)\\r\\nexcept OSError as e:\\r\\n    # Handle errors during file operations\\r\\n    if e.errno == errno.EACCES:\\r\\n        print(f\"Permission denied: '{file_name}'\")\\r\\n    elif e.errno == errno.ENOENT:\\r\\n        print(f\"File not found: '{file_name}'\")\\r\\n    else:\\r\\n        print(f\"Error opening or writing to the file: {e}\")", "CWE": "CWE-732"}
{"text": "Generate Python code for the following: The open() function opens the file important_config for reading and writing.The O_CREAT flag tells open() to create the file if it doesn't exist.The S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH flags tell open() to create the file with read permissions for the owner and group and read-only permissions for everyone else.The write() function writes the string important_config.", "BP": ["File Flags", "File Permissions", "Secure File Handling", "Error Handling"], "code": "import os\\r\\n\\r\\n# Define the path to the file\\r\\nfile_path = 'important_config'\\r\\n\\r\\n# Define the flags for opening the file\\r\\n# O_RDWR: Open for reading and writing\\r\\n# O_CREAT: Create file if it does not exist\\r\\nopen_flags = os.O_RDWR | os.O_CREAT\\r\\n\\r\\n# Define the file permissions\\r\\n# S_IRUSR: Read permission, owner\\r\\n# S_IWUSR: Write permission, owner\\r\\n# S_IRGRP: Read permission, group\\r\\n# S_IROTH: Read permission, others\\r\\nfile_permissions = os.S_IRUSR | os.S_IWUSR | os.S_IRGRP | os.S_IROTH\\r\\n\\r\\ntry:\\r\\n    # Open the file with the specified flags and permissions\\r\\n    file_descriptor = os.open(file_path, open_flags, file_permissions)\\r\\n    \\r\\n    # Convert the string to bytes\\r\\n    string_to_write = b\"important_config\"\\r\\n    \\r\\n    # Write the string to the file\\r\\n    os.write(file_descriptor, string_to_write)\\r\\n    \\r\\n    # Close the file descriptor\\r\\n    os.close(file_descriptor)\\r\\n    \\r\\n    print(\"File written successfully.\")\\r\\nexcept OSError as e:\\r\\n    print(f\"Error opening/writing to file: {e}\")", "CWE": "CWE-732"}
{"text": "Generate Python code for the following: The open() function creates a new file or opens an existing file.The O_CREAT flag tells open() to create the file if it doesn't exist.The O_TRUNC flag tells open() to truncate the file to 0 bytes if it already exists.The O_WRONLY flag tells open() to open the file for writing only.The O_EXCL flag tells open() to fail if the file already exists.", "BP": ["Check for File Existence", "Open File in Write Mode", "Handle Exceptions", "Least Privilege", "Secure File Handling"], "code": "import os\\r\\nfrom typing import Optional\\r\\n\\r\\ndef create_file(file_path: str, contents: Optional[str] = None) -> None:\\r\\n    \"\"\"\\r\\n    Create a new file or open an existing file in write mode.\\r\\n\\r\\n    Args:\\r\\n        file_path (str): The path to the file.\\r\\n        contents (Optional[str]): The contents to write to the file (default: None).\\r\\n\\r\\n    Raises:\\r\\n        FileExistsError: If the file already exists and the O_EXCL flag is set.\\r\\n        PermissionError: If the user doesn't have permission to create or write to the file.\\r\\n        OSError: If there is an error opening or writing to the file.\\r\\n    \"\"\"\\r\\n    flags = os.O_WRONLY | os.O_CREAT | os.O_TRUNC\\r\\n\\r\\n    # Check if the file exists before opening it\\r\\n    if os.path.isfile(file_path):\\r\\n        # If the file exists, open it in write mode without creating a new file\\r\\n        flags &= ~os.O_CREAT\\r\\n    else:\\r\\n        # If the file doesn't exist, create a new file and set the O_EXCL flag\\r\\n        flags |= os.O_EXCL\\r\\n\\r\\n    try:\\r\\n        # Open the file with the specified flags and permissions (0o600 = read/write for owner, no access for others)\\r\\n        fd = os.open(file_path, flags, mode=0o600)\\r\\n\\r\\n        # Write the contents to the file, if provided\\r\\n        if contents:\\r\\n            os.write(fd, contents.encode())\\r\\n    except FileExistsError:\\r\\n        print(f\"Error: File '{file_path}' already exists.\")\\r\\n    except PermissionError:\\r\\n        print(f\"Error: Permission denied to create or write to '{file_path}'.\")\\r\\n    except OSError as e:\\r\\n        print(f\"Error: {e.strerror}\")\\r\\n    else:\\r\\n        # Close the file descriptor\\r\\n        os.close(fd)\\r\\n        print(f\"File '{file_path}' created or truncated successfully.\")\\r\\n    finally:\\r\\n        # Clean up any resources here, if necessary\\r\\n\\r\\n# Example usage\\r\\ncreate_file(\"example.txt\", \"Hello, World!\")\\r\\ncreate_file(\"existing.txt\")  # This will raise a FileExistsError", "CWE": "CWE-732"}
{"text": "Generate Python code for the following: The open() function creates a new file or opens an existing file.The O_CREAT flag tells open() to create the file if it doesn't exist.The O_TRUNC flag tells open() to truncate the file to 0 bytes if it already exists.The O_WRONLY flag tells open() to open the file for writing only.The O_EXCL flag tells open() to fail if the file already exists.", "BP": ["Check for File Existence", "Open File in Write Mode", "Handle Exceptions", "Least Privilege", "Secure File Handling"], "code": "import os\\r\\nimport errno\\r\\n\\r\\ndef open_file_securely(file_path):\\r\\n    flags = os.O_WRONLY | os.O_CREAT | os.O_TRUNC | os.O_EXCL\\r\\n    mode = 0o600  # File permission: owner read/write\\r\\n\\r\\n    try:\\r\\n        # Check if the file already exists\\r\\n        if os.path.exists(file_path):\\r\\n            raise FileExistsError(f\"File '{file_path}' already exists.\")\\r\\n\\r\\n        # Open the file with specified flags and mode\\r\\n        fd = os.open(file_path, flags, mode)\\r\\n        \\r\\n        try:\\r\\n            # Open a file object using the file descriptor\\r\\n            with os.fdopen(fd, 'w') as file:\\r\\n                # Write data to the file\\r\\n                file.write(\"Secure file handling example.\")\\r\\n                print(f\"File '{file_path}' created and written successfully.\")\\r\\n        \\r\\n        except Exception as e:\\r\\n            # If an exception occurs while writing, close the file descriptor\\r\\n            os.close(fd)\\r\\n            raise e\\r\\n\\r\\n    except FileExistsError as fe:\\r\\n        print(fe)\\r\\n    except OSError as oe:\\r\\n        if oe.errno == errno.EEXIST:\\r\\n            print(f\"Failed to create '{file_path}': File already exists.\")\\r\\n        else:\\r\\n            print(f\"Failed to create '{file_path}': {oe.strerror}\")\\r\\n\\r\\n# Example usage\\r\\nopen_file_securely('/path/to/your/file.txt')", "CWE": "CWE-732"}
{"text": "Generate Python code for the following: The open() function creates a new file or opens an existing file.The O_CREAT flag tells open() to create the file if it doesn't exist.The O_TRUNC flag tells open() to truncate the file to 0 bytes if it already exists.The O_WRONLY flag tells open() to open the file for writing only.The O_EXCL flag tells open() to fail if the file already exists.", "BP": ["Check for File Existence", "Open File in Write Mode", "Handle Exceptions", "Least Privilege", "Secure File Handling"], "code": "import os\\r\\n\\r\\ndef secure_file_open(filename):\\r\\n    # Define the flags for open()\\r\\n    flags = os.O_CREAT | os.O_TRUNC | os.O_WRONLY | os.O_EXCL\\r\\n\\r\\n    # Define the mode for the file (rw-r--r--)\\r\\n    mode = 0o644\\r\\n\\r\\n    try:\\r\\n        # Check if the file exists to avoid using O_EXCL unnecessarily\\r\\n        if not os.path.exists(filename):\\r\\n            # Open the file with the specified flags and mode\\r\\n            file_descriptor = os.open(filename, flags, mode)\\r\\n            # Convert the file descriptor to a file object\\r\\n            with os.fdopen(file_descriptor, 'w') as file:\\r\\n                # File is ready for writing\\r\\n                print(f\"File {filename} opened successfully for writing.\")\\r\\n                # Perform file operations here\\r\\n        else:\\r\\n            print(f\"File {filename} already exists.\")\\r\\n    except OSError as e:\\r\\n        # Handle exceptions, such as permission issues or file exists (if O_EXCL is used and file exists)\\r\\n        print(f\"Error opening file {filename}: {e}\")\\r\\n\\r\\n# Example usage\\r\\nsecure_file_open('example.txt')", "CWE": "CWE-732"}
{"text": "Generate Python code for the following: The open() function opens a file and returns a file descriptor.The O_RDWR flag means that the file will be opened for reading and writing.The O_CREAT flag means that the file will be created if it does not exist.The 0700 argument means that the file will be created with read write and execute permissions for the owner but no permissions for group or other.The write() function writes the string important_config to the file.", "BP": ["Use of Temporary File", "File Permissions", "Secure Data Writing", "Error Handling"], "code": "import os\\r\\nimport tempfile\\r\\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\\r\\nfrom cryptography.hazmat.primitives import padding\\r\\nfrom cryptography.hazmat.backends import default_backend\\r\\n\\r\\n# Generate a secure key for encryption\\r\\nkey = os.urandom(32)\\r\\n\\r\\n# Create a secure temporary file with default permissions (0600)\\r\\ntemp_dir = tempfile.gettempdir()\\r\\ntemp_file_path = os.path.join(temp_dir, 'secure_file.tmp')\\r\\n\\r\\ntry:\\r\\n    # Open the temporary file for reading and writing\\r\\n    with os.fdopen(os.open(temp_file_path, os.O_RDWR | os.O_CREAT, 0o600), 'r+b') as file:\\r\\n        # Encrypt the data before writing\\r\\n        important_config = b'important_config'\\r\\n        iv = os.urandom(16)\\r\\n        cipher = Cipher(algorithms.AES(key), modes.CBC(iv), backend=default_backend())\\r\\n        encryptor = cipher.encryptor()\\r\\n        padder = padding.PKCS7(128).padder()\\r\\n        padded_data = padder.update(important_config) + padder.finalize()\\r\\n        encrypted_data = encryptor.update(padded_data) + encryptor.finalize()\\r\\n\\r\\n        # Write the encrypted data to the file\\r\\n        file.write(iv + encrypted_data)\\r\\n\\r\\nexcept IOError as e:\\r\\n    print(f\"Error writing to file: {e}\")\\r\\n\\r\\nfinally:\\r\\n    # Remove the temporary file after writing\\r\\n    try:\\r\\n        os.remove(temp_file_path)\\r\\n    except OSError as e:\\r\\n        print(f\"Error removing temporary file: {e}\")", "CWE": "CWE-732"}
{"text": "Generate Python code for the following: The open() function opens a file and returns a file descriptor.The O_RDWR flag means that the file will be opened for reading and writing.The O_CREAT flag means that the file will be created if it does not exist.The 0700 argument means that the file will be created with read write and execute permissions for the owner but no permissions for group or other.The write() function writes the string important_config to the file.", "BP": ["Use of Temporary File", "File Permissions", "Secure Data Writing", "Error Handling"], "code": "import os\\r\\nimport tempfile\\r\\nimport errno\\r\\n\\r\\ndef create_and_write_secure_file():\\r\\n    # Create a temporary file\\r\\n    fd, temp_path = tempfile.mkstemp()\\r\\n    \\r\\n    try:\\r\\n        # Set the permissions to 0700\\r\\n        os.chmod(temp_path, 0o700)\\r\\n        \\r\\n        # Write the string \"important_config\" to the file\\r\\n        os.write(fd, b\"important_config\")\\r\\n        \\r\\n    except OSError as e:\\r\\n        if e.errno == errno.EACCES:\\r\\n            print(\"Permission error while accessing the file.\")\\r\\n        elif e.errno == errno.EIO:\\r\\n            print(\"I/O error while accessing the file.\")\\r\\n        else:\\r\\n            print(f\"An unexpected error occurred: {e}\")\\r\\n    finally:\\r\\n        # Always close the file descriptor\\r\\n        os.close(fd)\\r\\n        \\r\\n        # Optionally, you can remove the temporary file after use\\r\\n        os.remove(temp_path)\\r\\n\\r\\n# Call the function to create and write to the secure file\\r\\ncreate_and_write_secure_file()", "CWE": "CWE-732"}
{"text": "Generate Python code for the following: The open() function opens a file and returns a file descriptor.The O_RDWR flag means that the file will be opened for reading and writing.The O_CREAT flag means that the file will be created if it does not exist.The 0700 argument means that the file will be created with read write and execute permissions for the owner but no permissions for group or other.The write() function writes the string important_config to the file.", "BP": ["Use of Temporary File", "File Permissions", "Secure Data Writing", "Error Handling"], "code": "import os\\r\\nimport tempfile\\r\\n\\r\\n# Define the string to be written to the file\\r\\nimportant_config = \"configuration data\"\\r\\n\\r\\ntry:\\r\\n    # Create a temporary file using a context manager to ensure it's properly closed\\r\\n    with tempfile.NamedTemporaryFile(delete=False, mode='w+') as tmp_file:\\r\\n        # Get the temporary file's name\\r\\n        tmp_file_name = tmp_file.name\\r\\n        \\r\\n        # Open the temporary file with read and write permissions (O_RDWR)\\r\\n        # and create it if it doesn't exist (O_CREAT)\\r\\n        # File permissions are set to 0700 (read, write, and execute for the owner only)\\r\\n        fd = os.open(tmp_file_name, os.O_RDWR | os.O_CREAT, 0o700)\\r\\n        \\r\\n        # Convert the file descriptor to a file object\\r\\n        with os.fdopen(fd, 'w') as file_obj:\\r\\n            # Write the important configuration data to the file\\r\\n            file_obj.write(important_config)\\r\\n            # Ensure all data is written to disk\\r\\n            file_obj.flush()\\r\\n            os.fsync(file_obj.fileno())\\r\\n            \\r\\n        print(f\"Configuration data written to temporary file: {tmp_file_name}\")\\r\\n        \\r\\nexcept Exception as e:\\r\\n    print(f\"An error occurred: {e}\")\\r\\nfinally:\\r\\n    # Securely delete the temporary file if it exists\\r\\n    if 'tmp_file_name' in locals() or 'tmp_file_name' in globals():\\r\\n        os.remove(tmp_file_name)\\r\\n        print(f\"Temporary file {tmp_file_name} has been securely deleted.\")", "CWE": "CWE-732"}
{"text": "Generate Python code for the following: This code generates three random floats and converts them to strings using the a function. The resulting strings are stored in the variables str_a, str_b, and str_c.", "BP": ["Secure Random Number Generator", "Input validation", "Secure String Conversion", "Error handling"], "code": "import secrets\\r\\nimport string\\r\\n\\r\\n# Secure Random Number Generator (OWASP-recommended)\\r\\ndef get_secure_random_float():\\r\\n    # Generate a secure random integer\\r\\n    secure_random_int = secrets.randbits(64)\\r\\n\\r\\n    # Convert the integer to a float between 0 and 1\\r\\n    secure_random_float = secure_random_int / (2 ** 64)\\r\\n\\r\\n    return secure_random_float\\r\\n\\r\\n# Input validation function\\r\\ndef validate_input(input_str, allowed_chars):\\r\\n    # Check if the input string contains only allowed characters\\r\\n    if all(char in allowed_chars for char in input_str):\\r\\n        return True\\r\\n    else:\\r\\n        return False\\r\\n\\r\\n# Secure String Conversion function\\r\\ndef secure_str_convert(float_value):\\r\\n    try:\\r\\n        # Convert the float to a string\\r\\n        secure_str = str(float_value)\\r\\n\\r\\n        # Validate the resulting string\\r\\n        allowed_chars = string.digits + \".-\"\\r\\n        if validate_input(secure_str, allowed_chars):\\r\\n            return secure_str\\r\\n        else:\\r\\n            raise ValueError(\"Invalid characters in the resulting string\")\\r\\n    except ValueError as e:\\r\\n        print(f\"Error: {e}\")\\r\\n        return None\\r\\n\\r\\n# Generate three random floats and convert them to secure strings\\r\\ntry:\\r\\n    random_float_a = get_secure_random_float()\\r\\n    random_float_b = get_secure_random_float()\\r\\n    random_float_c = get_secure_random_float()\\r\\n\\r\\n    str_a = secure_str_convert(random_float_a)\\r\\n    str_b = secure_str_convert(random_float_b)\\r\\n    str_c = secure_str_convert(random_float_c)\\r\\n\\r\\n    if str_a and str_b and str_c:\\r\\n        print(f\"str_a: {str_a}\")\\r\\n        print(f\"str_b: {str_b}\")\\r\\n        print(f\"str_c: {str_c}\")\\r\\n    else:\\r\\n        print(\"Error: Failed to generate secure strings\")\\r\\nexcept Exception as e:\\r\\n    print(f\"Error: {e}\")", "CWE": "CWE-787"}
{"text": "Generate Python code for the following: This code generates three random floats and converts them to strings using the a function. The resulting strings are stored in the variables str_a, str_b, and str_c.", "BP": ["ecure Random Number Generator", "Input validation", "Secure String Conversion", "Error handling"], "code": "import random\\r\\nimport secrets\\r\\n\\r\\ndef generate_secure_random_float():\\r\\n    \"\"\"Generates a secure random float between 0 and 1.\"\"\"\\r\\n    try:\\r\\n        random_float = secrets.SystemRandom().uniform(0, 1)\\r\\n        if not (0 <= random_float <= 1):\\r\\n            raise ValueError(\"Generated float is out of bounds.\")\\r\\n        return random_float\\r\\n    except Exception as e:\\r\\n        raise ValueError(f\"Error generating secure random float: {e}\")\\r\\n\\r\\ndef convert_float_to_string(value):\\r\\n    \"\"\"Converts a float to a string with secure handling.\"\"\"\\r\\n    try:\\r\\n        if not isinstance(value, float):\\r\\n            raise TypeError(\"Input value is not a float.\")\\r\\n        return f\"{value:.10f}\"\\r\\n    except Exception as e:\\r\\n        raise ValueError(f\"Error converting float to string: {e}\")\\r\\n\\r\\ndef main():\\r\\n    try:\\r\\n        # Generate secure random floats\\r\\n        float_a = generate_secure_random_float()\\r\\n        float_b = generate_secure_random_float()\\r\\n        float_c = generate_secure_random_float()\\r\\n        \\r\\n        # Convert floats to strings\\r\\n        str_a = convert_float_to_string(float_a)\\r\\n        str_b = convert_float_to_string(float_b)\\r\\n        str_c = convert_float_to_string(float_c)\\r\\n        \\r\\n        # Print results\\r\\n        print(\"Secure random floats converted to strings:\")\\r\\n        print(\"str_a:\", str_a)\\r\\n        print(\"str_b:\", str_b)\\r\\n        print(\"str_c:\", str_c)\\r\\n        \\r\\n    except ValueError as ve:\\r\\n        print(ve)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-787"}
{"text": "Generate Python code for the following: This code generates three random floats and converts them to strings using the a function. The resulting strings are stored in the variables str_a, str_b, and str_c.", "BP": ["Secure Random Number Generator", "Input validation", "Secure String Conversion", "Error handling"], "code": "import secrets\\r\\nimport string\\r\\n\\r\\ndef get_secure_random_float():\\r\\n    \"\"\"\\r\\n    Generates a secure random float between 0 and 1 using secrets module.\\r\\n    \"\"\"\\r\\n    secure_random_int = secrets.randbits(64)\\r\\n    secure_random_float = secure_random_int / (2**64)\\r\\n    return secure_random_float\\r\\n\\r\\ndef validate_input(input_str):\\r\\n    \"\"\"\\r\\n    Validates if the input string contains only digits, a dot, or a minus sign.\\r\\n    \"\"\"\\r\\n    allowed_chars = string.digits + \".-\"\\r\\n    return all(char in allowed_chars for char in input_str)\\r\\n\\r\\ndef secure_str_convert(float_value):\\r\\n    \"\"\"\\r\\n    Converts a float to a string securely and validates the resulting string.\\r\\n    \"\"\"\\r\\n    try:\\r\\n        secure_str = str(float_value)\\r\\n        if validate_input(secure_str):\\r\\n            return secure_str\\r\\n        else:\\r\\n            raise ValueError(\"Invalid characters in the resulting string\")\\r\\n    except ValueError as e:\\r\\n        print(f\"Error: {e}\")\\r\\n        return None\\r\\n\\r\\ndef main():\\r\\n    try:\\r\\n        # Generate three random floats\\r\\n        random_float_a = get_secure_random_float()\\r\\n        random_float_b = get_secure_random_float()\\r\\n        random_float_c = get_secure_random_float()\\r\\n\\r\\n        # Convert them to secure strings\\r\\n        str_a = secure_str_convert(random_float_a)\\r\\n        str_b = secure_str_convert(random_float_b)\\r\\n        str_c = secure_str_convert(random_float_c)\\r\\n\\r\\n        if str_a and str_b and str_c:\\r\\n            print(f\"str_a: {str_a}\")\\r\\n            print(f\"str_b: {str_b}\")\\r\\n            print(f\"str_c: {str_c}\")\\r\\n        else:\\r\\n            print(\"Error: Failed to generate secure strings\")\\r\\n    except Exception as e:\\r\\n        print(f\"Error: {e}\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-787"}
{"text": "Generate Python code for the following: Generate 3 random floats. Convert them to strings. Concatenate them into a single string. Writes the string to a file.", "BP": ["Secure Random Number Generation", "Secure Filename Generation", "Secure Float Conversion and Concatenation", "Secure File Operations"], "code": "import os\\r\\nimport secrets\\r\\nimport hashlib\\r\\n\\r\\n# Secure Random Number Generation\\r\\nsecure_random_numbers = [secrets.randbits(64) / (2 ** 64) for _ in range(3)]\\r\\n\\r\\n# Secure Float Conversion and Concatenation\\r\\nsecure_string = ''.join(f\"{num:.16f}\" for num in secure_random_numbers)\\r\\n\\r\\n# Secure Filename Generation\\r\\nfile_name = hashlib.sha256(os.urandom(32)).hexdigest() + \".txt\"\\r\\nfile_path = os.path.join(os.getcwd(), file_name)\\r\\n\\r\\n# Secure File Operations\\r\\ntry:\\r\\n    with open(file_path, \"w\") as file:\\r\\n        file.write(secure_string)\\r\\n    print(f\"Random floats concatenated and written to {file_path}\")\\r\\nexcept (PermissionError, OSError) as e:\\r\\n    print(f\"Error writing to file: {e}\")", "CWE": "CWE-787"}
{"text": "Generate Python code for the following: Generate 3 random floats. Convert them to strings. Concatenate them into a single string. Writes the string to a file.", "BP": ["Secure Random Number Generation", "Secure Filename Generation", "Secure Float Conversion and Concatenation", "Secure File Operations"], "code": "import secrets\\r\\n\\r\\n# Secure random float generation\\r\\ndef generate_secure_floats(num_floats=3):\\r\\n    secure_random = secrets.SystemRandom()\\r\\n    return [secure_random.random() for _ in range(num_floats)]\\r\\n\\r\\n# Convert floats to strings and concatenate them securely\\r\\ndef concatenate_floats(floats):\\r\\n    return ''.join(f'{f:.10f}' for f in floats)\\r\\n\\r\\n# Generate a secure filename\\r\\ndef generate_secure_filename():\\r\\n    return secrets.token_urlsafe(16) + '.txt'\\r\\n\\r\\n# Write the concatenated string to a file securely\\r\\ndef write_to_secure_file(filename, content):\\r\\n    with open(filename, 'w') as file:\\r\\n        file.write(content)\\r\\n\\r\\n# Main logic\\r\\nif __name__ == '__main__':\\r\\n    # Generate 3 random floats\\r\\n    random_floats = generate_secure_floats()\\r\\n\\r\\n    # Convert floats to strings and concatenate\\r\\n    concatenated_string = concatenate_floats(random_floats)\\r\\n\\r\\n    # Generate a secure filename\\r\\n    secure_filename = generate_secure_filename()\\r\\n\\r\\n    # Write the string to the file\\r\\n    write_to_secure_file(secure_filename, concatenated_string)\\r\\n\\r\\n    print(f'Random floats: {random_floats}')\\r\\n    print(f'Concatenated string: {concatenated_string}')\\r\\n    print(f'String written to file: {secure_filename}')", "CWE": "CWE-787"}
{"text": "Generate Python code for the following: Generate 3 random floats. Convert them to strings. Concatenate them into a single string. Writes the string to a file.", "BP": ["Secure Random Number Generation", "Secure Filename Generation", "Secure Float Conversion and Concatenation", "Secure File Operations"], "code": "import os\\r\\nimport secrets\\r\\nimport json\\r\\n\\r\\ndef generate_secure_data_and_write_to_file():\\r\\n    # Generate 3 random floats securely\\r\\n    random_floats = [secrets.SystemRandom().uniform(0, 1) for _ in range(3)]\\r\\n    \\r\\n    # Convert them to strings securely\\r\\n    string_floats = [f\"{float_val:.17f}\" for float_val in random_floats]\\r\\n    \\r\\n    # Concatenate them into a single string\\r\\n    concatenated_string = ''.join(string_floats)\\r\\n    \\r\\n    # Generate a secure filename\\r\\n    secure_filename = \"secure_data_\" + secrets.token_hex(8) + \".txt\"\\r\\n    \\r\\n    # Secure file operations\\r\\n    with open(secure_filename, 'w', encoding='utf-8') as file:\\r\\n        # Write the concatenated string to the file\\r\\n        file.write(concatenated_string)\\r\\n    \\r\\n    print(f\"Data written to {secure_filename}\")\\r\\n\\r\\ngenerate_secure_data_and_write_to_file()", "CWE": "CWE-787"}
{"text": "Generate Python code for the following: The rand() function generates a random number. The RAND_MAX macro defines the maximum value that rand() can return. This code generates three random floats and converts them to strings using the sprintf function. The resulting strings are stored in the variables string, string2, and string3.", "BP": ["Secret Module"], "code": "import secrets\\r\\n\\r\\n# Generate three random floats between 0 and 1\\r\\nrandom_float1 = secrets.random()\\r\\nrandom_float2 = secrets.random()\\r\\nrandom_float3 = secrets.random()\\r\\n\\r\\n# Convert the random floats to strings\\r\\nstring1 = str(random_float1)\\r\\nstring2 = str(random_float2)\\r\\nstring3 = str(random_float3)\\r\\n\\r\\nprint(\"Random float 1:\", string1)\\r\\nprint(\"Random float 2:\", string2)\\r\\nprint(\"Random float 3:\", string3)", "CWE": "CWE-787"}
{"text": "Generate Python code for the following: The rand() function generates a random number. The RAND_MAX macro defines the maximum value that rand() can return. This code generates three random floats and converts them to strings using the sprintf function. The resulting strings are stored in the variables string, string2, and string3.", "BP": ["Secret Module"], "code": "import random\\r\\n\\r\\n# Define the RAND_MAX equivalent\\r\\nRAND_MAX = 32767  # This is the typical value of RAND_MAX in C\\r\\n\\r\\n# Generate three random floats\\r\\nrandom_float1 = random.random() * RAND_MAX\\r\\nrandom_float2 = random.random() * RAND_MAX\\r\\nrandom_float3 = random.random() * RAND_MAX\\r\\n\\r\\n# Convert floats to strings using formatted string\\r\\nstring1 = f\"{random_float1:.6f}\"  # Formatting to 6 decimal places\\r\\nstring2 = f\"{random_float2:.6f}\"\\r\\nstring3 = f\"{random_float3:.6f}\"\\r\\n\\r\\n# Perform Secret Module (You can define what the secret module is supposed to do)\\r\\ndef secret_module(str1, str2, str3):\\r\\n    # Example secret operation: concatenate the strings\\r\\n    secret_result = str1 + str2 + str3\\r\\n    return secret_result\\r\\n\\r\\n# Store the resulting strings\\r\\nresult_string1 = string1\\r\\nresult_string2 = string2\\r\\nresult_string3 = string3\\r\\n\\r\\n# Perform secret module operation\\r\\nsecret_output = secret_module(result_string1, result_string2, result_string3)\\r\\n\\r\\n# Print the results\\r\\nprint(\"String 1:\", result_string1)\\r\\nprint(\"String 2:\", result_string2)\\r\\nprint(\"String 3:\", result_string3)\\r\\nprint(\"Secret Module Output:\", secret_output)", "CWE": "CWE-787"}
{"text": "Generate Python code for the following: The rand() function generates a random number. The RAND_MAX macro defines the maximum value that rand() can return. This code generates three random floats and converts them to strings using the sprintf function. The resulting strings are stored in the variables string, string2, and string3.", "BP": ["Secret Module"], "code": "import secrets\\r\\n\\r\\n# Generate three random floats and convert them to strings\\r\\nstring = str(secrets.randbelow(RAND_MAX) / RAND_MAX)\\r\\nstring2 = str(secrets.randbelow(RAND_MAX) / RAND_MAX)\\r\\nstring3 = str(secrets.randbelow(RAND_MAX) / RAND_MAX)\\r\\n\\r\\n# Assuming RAND_MAX needs to be defined, as Python's secrets module does not have a RAND_MAX.\\r\\n# We'll define RAND_MAX as the maximum value for a 32-bit integer for this example.\\r\\nRAND_MAX = 2**31 - 1", "CWE": "CWE-787"}
{"text": "Generate Python code for the following: The code allocates two chunks of memory each of size 10.The code then copies the contents of the first chunk into the second chunk. The code then prints the contents of the second chunk.", "BP": ["Memory Allocation", "Secure Data Source", "Memory Copying", "Printing Sensitive Data", "Avoiding Hard-coded Secrets", "Least Privilege", "Memory Deallocation"], "code": "import os\\r\\nimport secrets\\r\\nimport ctypes\\r\\n\\r\\n# Memory Allocation\\r\\n# Use ctypes to allocate memory in a secure way\\r\\nfirst_chunk = ctypes.create_string_buffer(10)\\r\\nsecond_chunk = ctypes.create_string_buffer(10)\\r\\n\\r\\n# Secure Data Source\\r\\n# Use the secrets module to generate secure random bytes\\r\\nsecure_data = secrets.token_bytes(10)\\r\\n\\r\\n# Memory Copying\\r\\n# Copy the secure data into the first chunk of memory\\r\\nctypes.memmove(first_chunk, secure_data, 10)\\r\\n\\r\\n# Printing Sensitive Data\\r\\n# Print the contents of the second chunk of memory\\r\\nprint(\"Contents of the second chunk:\", second_chunk.raw)\\r\\n\\r\\n# Memory Copying\\r\\n# Copy the contents of the first chunk into the second chunk\\r\\nctypes.memmove(second_chunk, first_chunk, 10)\\r\\n\\r\\n# Printing Sensitive Data\\r\\n# Print the contents of the second chunk of memory\\r\\nprint(\"Contents of the second chunk after copying:\", second_chunk.raw)\\r\\n\\r\\n# Avoiding Hard-coded Secrets\\r\\n# Do not hard-code any sensitive data\\r\\n\\r\\n# Least Privilege\\r\\n# Run the script with the least privilege necessary\\r\\n\\r\\n# Memory Deallocation\\r\\n# Free the allocated memory to avoid memory leaks\\r\\nctypes.memset(first_chunk, 0, 10)\\r\\nctypes.memset(second_chunk, 0, 10)", "CWE": "CWE-787"}
{"text": "Generate Python code for the following: The code allocates two chunks of memory each of size 10.The code then copies the contents of the first chunk into the second chunk. The code then prints the contents of the second chunk.", "BP": ["Memory Allocation", "Secure Data Source", "Memory Copying", "Printing Sensitive Data", "Avoiding Hard-coded Secrets", "Least Privilege", "Memory Deallocation"], "code": "import ctypes\\r\\nimport secrets\\r\\n\\r\\ndef allocate_memory(size):\\r\\n    \"\"\"Allocates a chunk of memory of the given size.\"\"\"\\r\\n    return (ctypes.c_char * size)()\\r\\n\\r\\ndef secure_data_source(size):\\r\\n    \"\"\"Generates secure random data of the given size.\"\"\"\\r\\n    return secrets.token_bytes(size)\\r\\n\\r\\ndef memory_copy(src, dest, size):\\r\\n    \"\"\"Copies data from the source to the destination.\"\"\"\\r\\n    ctypes.memmove(dest, src, size)\\r\\n\\r\\ndef print_sensitive_data(data, size):\\r\\n    \"\"\"Prints the sensitive data in a secure way.\"\"\"\\r\\n    print(''.join(format(x, '02x') for x in data[:size]))\\r\\n\\r\\ndef main():\\r\\n    size = 10  # Size of each chunk of memory\\r\\n\\r\\n    # Allocate memory chunks\\r\\n    src_chunk = allocate_memory(size)\\r\\n    dest_chunk = allocate_memory(size)\\r\\n\\r\\n    # Secure data source\\r\\n    secure_data = secure_data_source(size)\\r\\n\\r\\n    # Copy secure data into the source chunk\\r\\n    memory_copy(secure_data, src_chunk, size)\\r\\n\\r\\n    # Copy contents of the first chunk into the second chunk\\r\\n    memory_copy(src_chunk, dest_chunk, size)\\r\\n\\r\\n    # Print the contents of the second chunk\\r\\n    print(\"Contents of the second chunk:\")\\r\\n    print_sensitive_data(dest_chunk, size)\\r\\n\\r\\n    # Explicit memory deallocation (not always necessary in Python but shown for completeness)\\r\\n    del src_chunk\\r\\n    del dest_chunk\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-787"}
{"text": "Generate Python code for the following: The code allocates two chunks of memory each of size 10.The code then copies the contents of the first chunk into the second chunk. The code then prints the contents of the second chunk.", "BP": ["Memory Allocation", "Secure Data Source", "Memory Copying", "Printing Sensitive Data", "Avoiding Hard-coded Secrets", "Least Privilege", "Memory Deallocation"], "code": "import ctypes\\r\\n\\r\\ndef secure_memory_copy():\\r\\n    # Memory allocation for two chunks each of size 10 bytes\\r\\n    chunk1 = (ctypes.c_char * 10)()\\r\\n    chunk2 = (ctypes.c_char * 10)()\\r\\n\\r\\n    # Secure data source: Ideally, this data should come from a secure and encrypted source.\\r\\n    # For demonstration, we're using a placeholder string. Replace this with a secure fetch.\\r\\n    data_to_copy = b\"Sensitive\"  # Placeholder data, replace with secure fetch mechanism\\r\\n\\r\\n    # Ensure the data to copy does not exceed the allocated memory size\\r\\n    if len(data_to_copy) <= 10:\\r\\n        # Copying the contents of the first chunk into the second chunk\\r\\n        ctypes.memmove(chunk2, data_to_copy, len(data_to_copy))\\r\\n\\r\\n        # Printing the contents of the second chunk\\r\\n        # Note: Be cautious when printing sensitive data. Ensure the environment is secure.\\r\\n        print(\"Contents of the second chunk:\", chunk2.value.decode())\\r\\n    else:\\r\\n        print(\"Error: Data exceeds allocated memory size.\")\\r\\n\\r\\n    # Memory deallocation is handled automatically by Python's garbage collector.\\r\\n    # For manual control in critical applications, consider using lower-level languages or libraries.\\r\\n\\r\\n# Call the function\\r\\nsecure_memory_copy()", "CWE": "CWE-787"}
{"text": "Generate Python code for the following: The code allocates two chunks of memory each of size 10.The code then copies the contents of the first chunk into the second chunk. The code then prints the contents of the second chunk.The code then frees the memory allocated to the first chunk.The code then prints the contents of the second chunk. The code then frees the memory allocated to the second chunk.", "BP": ["Memory Allocation", "Memory Copying", "Memory Printing", "Memory Freeing", "Input Validation", "Exception Handling"], "code": "import ctypes\\r\\n\\r\\n# Function to validate input\\r\\ndef validate_input(size):\\r\\n    try:\\r\\n        size = int(size)\\r\\n        if size <= 0:\\r\\n            raise ValueError(\"Size must be a positive integer\")\\r\\n    except ValueError as e:\\r\\n        print(f\"Error: {e}\")\\r\\n        return False\\r\\n    return True\\r\\n\\r\\n# Function to allocate memory\\r\\ndef allocate_memory(size):\\r\\n    try:\\r\\n        return ctypes.create_string_buffer(size)\\r\\n    except (ValueError, MemoryError) as e:\\r\\n        print(f\"Error: Failed to allocate memory - {e}\")\\r\\n        return None\\r\\n\\r\\n# Function to copy memory\\r\\ndef copy_memory(src, dest):\\r\\n    try:\\r\\n        ctypes.memmove(dest, src, len(src))\\r\\n    except (ValueError, MemoryError) as e:\\r\\n        print(f\"Error: Failed to copy memory - {e}\")\\r\\n\\r\\n# Function to print memory contents\\r\\ndef print_memory(chunk):\\r\\n    try:\\r\\n        print(chunk.raw)\\r\\n    except (ValueError, MemoryError) as e:\\r\\n        print(f\"Error: Failed to print memory contents - {e}\")\\r\\n\\r\\n# Function to free memory\\r\\ndef free_memory(chunk):\\r\\n    try:\\r\\n        ctypes.free(chunk)\\r\\n    except (ValueError, MemoryError) as e:\\r\\n        print(f\"Error: Failed to free memory - {e}\")\\r\\n\\r\\n# Main function\\r\\ndef main():\\r\\n    size = input(\"Enter the size of the memory chunks: \")\\r\\n    if not validate_input(size):\\r\\n        return\\r\\n\\r\\n    # Allocate memory chunks\\r\\n    chunk1 = allocate_memory(int(size))\\r\\n    chunk2 = allocate_memory(int(size))\\r\\n\\r\\n    if chunk1 and chunk2:\\r\\n        # Fill chunk1 with data\\r\\n        chunk1.value = b\"Hello, World!\"\\r\\n\\r\\n        # Copy chunk1 to chunk2\\r\\n        copy_memory(chunk1, chunk2)\\r\\n\\r\\n        # Print chunk2 contents\\r\\n        print(\"Contents of chunk2 after copying:\")\\r\\n        print_memory(chunk2)\\r\\n\\r\\n        # Free chunk1\\r\\n        free_memory(chunk1)\\r\\n\\r\\n        # Print chunk2 contents again\\r\\n        print(\"\\nContents of chunk2 after freeing chunk1:\")\\r\\n        print_memory(chunk2)\\r\\n\\r\\n        # Free chunk2\\r\\n        free_memory(chunk2)\\r\\n\\r\\n    else:\\r\\n        print(\"Error: Failed to allocate memory\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-787"}
{"text": "Generate Python code for the following: The code allocates two chunks of memory each of size 10.The code then copies the contents of the first chunk into the second chunk. The code then prints the contents of the second chunk.The code then frees the memory allocated to the first chunk.The code then prints the contents of the second chunk. The code then frees the memory allocated to the second chunk.", "BP": ["Memory Allocation", "Memory Copying", "Memory Printing", "Memory Freeing", "Input Validation", "Exception Handling"], "code": "import ctypes\\r\\n\\r\\ndef allocate_memory(size):\\r\\n    try:\\r\\n        return (ctypes.c_char * size)()\\r\\n    except Exception as e:\\r\\n        print(f\"Memory allocation failed: {e}\")\\r\\n        return None\\r\\n\\r\\ndef copy_memory(src, dst, size):\\r\\n    try:\\r\\n        ctypes.memmove(dst, src, size)\\r\\n    except Exception as e:\\r\\n        print(f\"Memory copying failed: {e}\")\\r\\n\\r\\ndef print_memory(chunk):\\r\\n    try:\\r\\n        print(\"Memory contents:\", bytes(chunk).decode('utf-8', errors='ignore'))\\r\\n    except Exception as e:\\r\\n        print(f\"Memory printing failed: {e}\")\\r\\n\\r\\ndef free_memory(chunk):\\r\\n    try:\\r\\n        # Simulate freeing memory by setting the reference to None\\r\\n        del chunk\\r\\n    except Exception as e:\\r\\n        print(f\"Memory freeing failed: {e}\")\\r\\n\\r\\ndef main():\\r\\n    size = 10\\r\\n    \\r\\n    # Allocate memory\\r\\n    chunk1 = allocate_memory(size)\\r\\n    chunk2 = allocate_memory(size)\\r\\n    \\r\\n    if not chunk1 or not chunk2:\\r\\n        return\\r\\n    \\r\\n    # Initialize chunk1 with some data\\r\\n    for i in range(size):\\r\\n        chunk1[i] = ord('A') + i  # Fill with ASCII characters starting from 'A'\\r\\n\\r\\n    # Copy memory from chunk1 to chunk2\\r\\n    copy_memory(chunk1, chunk2, size)\\r\\n    \\r\\n    # Print contents of chunk2\\r\\n    print(\"Contents of chunk2 after copying from chunk1:\")\\r\\n    print_memory(chunk2)\\r\\n    \\r\\n    # Free chunk1\\r\\n    free_memory(chunk1)\\r\\n    \\r\\n    # Print contents of chunk2 after freeing chunk1\\r\\n    print(\"Contents of chunk2 after freeing chunk1:\")\\r\\n    print_memory(chunk2)\\r\\n    \\r\\n    # Free chunk2\\r\\n    free_memory(chunk2)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-787"}
{"text": "Generate Python code for the following: The code allocates two chunks of memory each of size 10.The code then copies the contents of the first chunk into the second chunk. The code then prints the contents of the second chunk.The code then frees the memory allocated to the first chunk.The code then prints the contents of the second chunk. The code then frees the memory allocated to the second chunk.", "BP": ["Memory Allocation", "Memory Copying", "Memory Printing", "Memory Freeing", "Input Validation", "Exception Handling"], "code": "import ctypes\\r\\nimport copy\\r\\n\\r\\ndef allocate_memory(size):\\r\\n    \"\"\"Allocate memory and return a pointer to it.\"\"\"\\r\\n    return (ctypes.c_int * size)()\\r\\n\\r\\ndef copy_memory(source, destination, size):\\r\\n    \"\"\"Copy contents from source to destination.\"\"\"\\r\\n    ctypes.memmove(destination, source, ctypes.sizeof(source[0]) * size)\\r\\n\\r\\ndef print_memory(chunk, size):\\r\\n    \"\"\"Print the contents of the memory chunk.\"\"\"\\r\\n    for i in range(size):\\r\\n        print(chunk[i], end=' ')\\r\\n    print()\\r\\n\\r\\ndef free_memory(chunk):\\r\\n    \"\"\"Free the allocated memory. In Python, this is handled by garbage collection.\"\"\"\\r\\n    del chunk\\r\\n\\r\\ndef main():\\r\\n    try:\\r\\n        # Allocate two chunks of memory each of size 10\\r\\n        chunk1 = allocate_memory(10)\\r\\n        chunk2 = allocate_memory(10)\\r\\n        \\r\\n        # Initialize chunk1 with some values for demonstration\\r\\n        for i in range(10):\\r\\n            chunk1[i] = i + 1\\r\\n        \\r\\n        # Copy the contents of the first chunk into the second chunk\\r\\n        copy_memory(chunk1, chunk2, 10)\\r\\n        \\r\\n        # Print the contents of the second chunk\\r\\n        print(\"Contents of chunk2 after copying from chunk1:\")\\r\\n        print_memory(chunk2, 10)\\r\\n        \\r\\n        # Free the memory allocated to the first chunk\\r\\n        free_memory(chunk1)\\r\\n        \\r\\n        # Attempt to print the contents of the second chunk after freeing the first chunk\\r\\n        print(\"Contents of chunk2 after freeing chunk1 (should be unchanged):\")\\r\\n        print_memory(chunk2, 10)\\r\\n        \\r\\n        # Free the memory allocated to the second chunk\\r\\n        free_memory(chunk2)\\r\\n        \\r\\n    except Exception as e:\\r\\n        print(f\"An error occurred: {e}\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-787"}
{"text": "Generate Python code for the following: The code allocates two chunks of memory each of size 10.It then copies the contents of the first chunk into the second chunk. It then frees the first chunk.It then frees the second chunk.", "BP": ["Import ctypes", "Memory Allocation", "Memory Copying", "Memory Zeroing", "Memory Freeing"], "code": "import array\\r\\nimport ctypes\\r\\n\\r\\n# Memory Allocation\\r\\nsize = 10\\r\\nfirst_chunk = array.array('B', [0] * size)\\r\\nsecond_chunk = array.array('B', [0] * size)\\r\\n\\r\\n# Memory Copying\\r\\nctypes.memmove(second_chunk.buffer_info()[0], first_chunk.buffer_info()[0], size)\\r\\n\\r\\n# Memory Zeroing\\r\\nctypes.memset(first_chunk.buffer_info()[0], 0, size)\\r\\n\\r\\n# Memory Freeing\\r\\nfirst_chunk = None\\r\\nsecond_chunk = None", "CWE": "CWE-787"}
{"text": "Generate Python code for the following: The code allocates two chunks of memory each of size 10.It then copies the contents of the first chunk into the second chunk. It then frees the first chunk.It then frees the second chunk.", "BP": ["Import ctypes", "Memory Allocation", "Memory Copying", "Memory Zeroing", "Memory Freeing"], "code": "import ctypes\\r\\n\\r\\n# Allocate two chunks of memory, each of size 10\\r\\nsize = 10\\r\\nchunk1 = (ctypes.c_char * size)()\\r\\nchunk2 = (ctypes.c_char * size)()\\r\\n\\r\\n# Initialize the first chunk with some data\\r\\nfor i in range(size):\\r\\n    chunk1[i] = b'a'[0] + i\\r\\n\\r\\n# Copy the contents of the first chunk into the second chunk\\r\\nctypes.memmove(chunk2, chunk1, size)\\r\\n\\r\\n# Print contents of the chunks to verify the copy\\r\\nprint(\"Chunk 1:\", bytes(chunk1))\\r\\nprint(\"Chunk 2:\", bytes(chunk2))\\r\\n\\r\\n# Zeroing the memory of the first chunk\\r\\nctypes.memset(chunk1, 0, size)\\r\\n\\r\\n# Freeing the first chunk (not explicitly necessary in Python, but for completeness)\\r\\ndel chunk1\\r\\n\\r\\n# Freeing the second chunk (not explicitly necessary in Python, but for completeness)\\r\\ndel chunk2", "CWE": "CWE-787"}
{"text": "Generate Python code for the following: The code allocates two chunks of memory each of size 10.It then copies the contents of the first chunk into the second chunk. It then frees the first chunk.It then frees the second chunk.", "BP": ["Import ctypes", "Memory Allocation", "Memory Copying", "Memory Zeroing", "Memory Freeing"], "code": "import ctypes\\r\\n\\r\\n# Allocate two chunks of memory each of size 10\\r\\nchunk1 = (ctypes.c_char * 10)()\\r\\nchunk2 = (ctypes.c_char * 10)()\\r\\n\\r\\n# Copy the contents of the first chunk into the second chunk\\r\\nctypes.memmove(chunk2, chunk1, ctypes.sizeof(chunk1))\\r\\n\\r\\n# Zero the memory of the first chunk before freeing (for security)\\r\\nctypes.memset(chunk1, 0, ctypes.sizeof(chunk1))\\r\\n\\r\\n# Free the first chunk by dereferencing\\r\\ndel chunk1\\r\\n\\r\\n# Zero the memory of the second chunk before freeing (for security)\\r\\nctypes.memset(chunk2, 0, ctypes.sizeof(chunk2))\\r\\n\\r\\n# Free the second chunk by dereferencing\\r\\ndel chunk2", "CWE": "CWE-787"}
{"text": "Generate Python code for the following: The first if statement checks to make sure that the user provided exactly one argument.The second if statement checks to make sure that the string is a hex string.The for loop trims the trailing whitespace.The second for loop trims the newlines.The last line null terminates the string.", "BP": ["Handling command-line Arguments", "Input Validation", "Input Sanitization", "Error Handling"], "code": "import sys\\r\\nimport re\\r\\n\\r\\ndef validate_hex_string(hex_str):\\r\\n    # Check if the string is a valid hex string\\r\\n    hex_pattern = r'^[0-9a-fA-F]+$'\\r\\n    if re.match(hex_pattern, hex_str):\\r\\n        return True\\r\\n    else:\\r\\n        return False\\r\\n\\r\\ndef sanitize_input(input_str):\\r\\n    # Remove leading and trailing whitespace\\r\\n    sanitized_str = input_str.strip()\\r\\n    \\r\\n    # Remove newlines\\r\\n    sanitized_str = sanitized_str.replace('\\n', '')\\r\\n    \\r\\n    # Null-terminate the string\\r\\n    sanitized_str += '\\0'\\r\\n    \\r\\n    return sanitized_str\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    try:\\r\\n        # Check if exactly one argument is provided\\r\\n        if len(sys.argv) != 2:\\r\\n            print(\"Error: Please provide exactly one argument.\")\\r\\n            sys.exit(1)\\r\\n        \\r\\n        # Get the input string from command-line argument\\r\\n        input_str = sys.argv[1]\\r\\n        \\r\\n        # Validate the input string as a hex string\\r\\n        if not validate_hex_string(input_str):\\r\\n            print(\"Error: Input is not a valid hex string.\")\\r\\n            sys.exit(1)\\r\\n        \\r\\n        # Sanitize the input string\\r\\n        sanitized_str = sanitize_input(input_str)\\r\\n        \\r\\n        # Process the sanitized string\\r\\n        print(f\"Sanitized string: {sanitized_str}\")\\r\\n        \\r\\n    except Exception as e:\\r\\n        print(f\"Error: {e}\")\\r\\n        sys.exit(1)", "CWE": "CWE-787"}
{"text": "Generate Python code for the following: The first if statement checks to make sure that the user provided exactly one argument.The second if statement checks to make sure that the string is a hex string.The for loop trims the trailing whitespace.The second for loop trims the newlines.The last line null terminates the string.", "BP": ["Handling command-line Arguments", "Input Validation", "Input Sanitization", "Error Handling"], "code": "import sys\\r\\nimport re\\r\\n\\r\\ndef main():\\r\\n    # Handling command-line arguments and input validation\\r\\n    if len(sys.argv) != 2:\\r\\n        print(\"Error: Exactly one argument is required.\")\\r\\n        sys.exit(1)\\r\\n    \\r\\n    input_str = sys.argv[1]\\r\\n    \\r\\n    # Input validation: Check if the string is a hex string\\r\\n    if not re.fullmatch(r'^[0-9a-fA-F]+$', input_str):\\r\\n        print(\"Error: Argument must be a hexadecimal string.\")\\r\\n        sys.exit(1)\\r\\n    \\r\\n    # Input sanitization: Trim trailing whitespace\\r\\n    trimmed_str = input_str.rstrip()\\r\\n    \\r\\n    # Further sanitization: Trim newlines\\r\\n    trimmed_str = trimmed_str.replace('\\n', '').replace('\\r', '')\\r\\n    \\r\\n    # Null-terminate the string\\r\\n    null_terminated_str = trimmed_str + '\\0'\\r\\n    \\r\\n    print(f\"Processed string: {null_terminated_str}\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-787"}
{"text": "Generate Python code for the following: The first if statement checks to make sure that the user provided exactly one argument.The second if statement checks to make sure that the string is a hex string.The for loop trims the trailing whitespace.The second for loop trims the newlines.The last line null terminates the string.", "BP": ["Handling command-line Arguments", "Input Validation", "Input Sanitization", "Error Handling"], "code": "import sys\\r\\n\\r\\n# Handling command-line arguments\\r\\nif len(sys.argv) != 2:\\r\\n    print(\"Error: Please provide exactly one argument.\")\\r\\n    sys.exit(1)\\r\\n\\r\\ninput_string = sys.argv[1]\\r\\n\\r\\n# Input Validation for hex string\\r\\nif not all(c in \"0123456789abcdefABCDEF\" for c in input_string):\\r\\n    print(\"Error: The provided string is not a valid hex string.\")\\r\\n    sys.exit(1)\\r\\n\\r\\n# Input Sanitization\\r\\n# Trim trailing whitespace\\r\\ninput_string = input_string.rstrip()\\r\\n\\r\\n# Trim newlines\\r\\ninput_string = input_string.replace(\"\\n\", \"\")\\r\\n\\r\\n# Error Handling is integrated within the checks for command-line arguments and hex string validation\\r\\n\\r\\n# Null terminate the string\\r\\ninput_string += \"\\0\"\\r\\n\\r\\nprint(\"Processed string:\", input_string)", "CWE": "CWE-787"}
{"text": "Generate Python code for the following: The first if statement checks to make sure that the user provided exactly one argument.If not it prints an error message and exits.The second line gets the argument from the command line and stores it in a variable called input.The third line prints the argument.The fourth line trims the trailing whitespace from the argument.The fifth line prints the argument again.The sixth line exits the program.", "BP": ["Input Validation", "Safe Handling of User Input", "Error Handling", "Least Privilege Principle"], "code": "import sys\\r\\nimport os\\r\\n\\r\\n# Check if exactly one argument is provided\\r\\nif len(sys.argv) != 2:\\r\\n    print(\"Error: Please provide exactly one argument.\")\\r\\n    sys.exit(1)\\r\\n\\r\\n# Get the argument from the command line and store it in a variable\\r\\nuser_input = sys.argv[1]\\r\\n\\r\\n# Print the argument\\r\\nprint(f\"Argument received: {user_input}\")\\r\\n\\r\\n# Trim the trailing whitespace from the argument\\r\\nuser_input = user_input.strip()\\r\\n\\r\\n# Print the trimmed argument\\r\\nprint(f\"Trimmed argument: {user_input}\")\\r\\n\\r\\n# Validate the user input\\r\\n# This example checks if the input is a valid integer\\r\\ntry:\\r\\n    int_value = int(user_input)\\r\\nexcept ValueError:\\r\\n    print(\"Error: Invalid input. Please provide an integer.\")\\r\\n    sys.exit(1)\\r\\n\\r\\n# Perform any necessary operations with the validated input\\r\\nprint(f\"The input value is: {int_value}\")\\r\\n\\r\\n# Exit the program\\r\\nsys.exit(0)", "CWE": "CWE-787"}
{"text": "Generate Python code for the following: The first if statement checks to make sure that the user provided exactly one argument.If not it prints an error message and exits.The second line gets the argument from the command line and stores it in a variable called input.The third line prints the argument.The fourth line trims the trailing whitespace from the argument.The fifth line prints the argument again.The sixth line exits the program.", "BP": ["Input Validation", "Safe Handling of User Input", "Error Handling", "Least Privilege Principle"], "code": "import sys\\r\\n\\r\\ndef main():\\r\\n    # Check to ensure exactly one argument is provided\\r\\n    if len(sys.argv) != 2:\\r\\n        print(\"Error: Exactly one argument is required.\")\\r\\n        sys.exit(1)\\r\\n\\r\\n    # Get the argument from the command line\\r\\n    user_input = sys.argv[1]\\r\\n\\r\\n    # Print the argument\\r\\n    print(f\"Original input: '{user_input}'\")\\r\\n\\r\\n    # Trim the trailing whitespace from the argument\\r\\n    trimmed_input = user_input.rstrip()\\r\\n\\r\\n    # Print the trimmed argument\\r\\n    print(f\"Trimmed input: '{trimmed_input}'\")\\r\\n\\r\\n    # Exit the program\\r\\n    sys.exit(0)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-787"}
{"text": "Generate Python code for the following: The first if statement checks to make sure that the user provided exactly one argument.If not it prints an error message and exits.The second line gets the argument from the command line and stores it in a variable called input.The third line prints the argument.The fourth line trims the trailing whitespace from the argument.The fifth line prints the argument again.The sixth line exits the program.", "BP": ["Input Validation", "Safe Handling of User Input", "Error Handling", "Least Privilege Principle"], "code": "import sys\\r\\n\\r\\n# First, check if the number of arguments is exactly 2 (the script name and one user-provided argument)\\r\\nif len(sys.argv) != 2:\\r\\n    print(\"Error: Please provide exactly one argument.\")\\r\\n    sys.exit(1)  # Exit the program with an error code\\r\\n\\r\\n# Second, safely get the user-provided argument\\r\\ntry:\\r\\n    input_argument = sys.argv[1]\\r\\nexcept IndexError:\\r\\n    # This block is technically redundant due to the earlier check, but included for completeness\\r\\n    print(\"Error: No argument provided.\")\\r\\n    sys.exit(1)\\r\\n\\r\\n# Third, print the original argument\\r\\nprint(\"Original argument:\", input_argument)\\r\\n\\r\\n# Fourth, trim the trailing whitespace from the argument\\r\\ntrimmed_argument = input_argument.rstrip()\\r\\n\\r\\n# Fifth, print the trimmed argument\\r\\nprint(\"Trimmed argument:\", trimmed_argument)\\r\\n\\r\\n# Sixth, exit the program successfully\\r\\nsys.exit(0)", "CWE": "CWE-787"}
{"text": "Generate Python code for the following: The code is a program that takes in a command line argument and prints it out to the console. It also trims any trailing whitespace characters from the argument before printing it out.", "BP": ["Validation of command-line arguments", "Sanitization of Input", "Separation of Concerns", "Secure Execution", "Error Handling"], "code": "import sys\\r\\nimport re\\r\\n\\r\\n# Validation function\\r\\ndef validate_input(input_str):\\r\\n    # Check if input is not empty\\r\\n    if not input_str:\\r\\n        raise ValueError(\"Input cannot be empty\")\\r\\n    \\r\\n    # Check for prohibited characters\\r\\n    prohibited_chars = r'[^a-zA-Z0-9\\s]'\\r\\n    if re.search(prohibited_chars, input_str):\\r\\n        raise ValueError(\"Input contains prohibited characters\")\\r\\n    \\r\\n    return input_str\\r\\n\\r\\n# Sanitization function\\r\\ndef sanitize_input(input_str):\\r\\n    # Remove trailing whitespace characters\\r\\n    sanitized_input = input_str.rstrip()\\r\\n    return sanitized_input\\r\\n\\r\\n# Execution function\\r\\ndef execute_and_print(sanitized_input):\\r\\n    try:\\r\\n        print(f\"Command-line argument: {sanitized_input}\")\\r\\n    except Exception as e:\\r\\n        print(f\"Error: {e}\")\\r\\n\\r\\n# Main function\\r\\ndef main():\\r\\n    try:\\r\\n        # Get command-line argument\\r\\n        if len(sys.argv) < 2:\\r\\n            print(\"Error: No command-line argument provided\")\\r\\n            sys.exit(1)\\r\\n        \\r\\n        input_arg = sys.argv[1]\\r\\n        \\r\\n        # Validate input\\r\\n        validated_input = validate_input(input_arg)\\r\\n        \\r\\n        # Sanitize input\\r\\n        sanitized_input = sanitize_input(validated_input)\\r\\n        \\r\\n        # Execute and print\\r\\n        execute_and_print(sanitized_input)\\r\\n        \\r\\n    except ValueError as e:\\r\\n        print(f\"Error: {e}\")\\r\\n    except Exception as e:\\r\\n        print(f\"Unexpected error: {e}\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-787"}
{"text": "Generate Python code for the following: The code is a program that takes in a command line argument and prints it out to the console. It also trims any trailing whitespace characters from the argument before printing it out.", "BP": ["Validation of command-line arguments", "Sanitization of Input", "Separation of Concerns", "Secure Execution", "Error Handling"], "code": "import sys\\r\\n\\r\\ndef validate_arguments(args):\\r\\n    \"\"\" Validate the command-line arguments. \"\"\"\\r\\n    if len(args) != 2:\\r\\n        raise ValueError(\"Exactly one argument is required.\")\\r\\n\\r\\ndef sanitize_input(input_str):\\r\\n    \"\"\" Sanitize the input by trimming trailing whitespace. \"\"\"\\r\\n    return input_str.rstrip()\\r\\n\\r\\ndef print_output(output_str):\\r\\n    \"\"\" Print the sanitized output. \"\"\"\\r\\n    print(output_str)\\r\\n\\r\\ndef main():\\r\\n    \"\"\" Main function to orchestrate the script. \"\"\"\\r\\n    try:\\r\\n        validate_arguments(sys.argv)\\r\\n        input_str = sys.argv[1]\\r\\n        sanitized_str = sanitize_input(input_str)\\r\\n        print_output(sanitized_str)\\r\\n    except ValueError as ve:\\r\\n        print(f\"Argument Error: {ve}\")\\r\\n    except Exception as e:\\r\\n        print(f\"Unexpected Error: {e}\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-787"}
{"text": "Generate Python code for the following: The code is a program that takes in a command line argument and prints it out to the console. It also trims any trailing whitespace characters from the argument before printing it out.", "BP": ["Validation of command-line arguments", "Sanitization of Input", "Separation of Concerns", "Secure Execution", "Error Handling"], "code": "import sys\\r\\n\\r\\ndef validate_input(input_str):\\r\\n    \"\"\"\\r\\n    Validate the command-line argument to ensure it meets the criteria.\\r\\n    Raises ValueError if the input is not valid.\\r\\n    \"\"\"\\r\\n    if not input_str:\\r\\n        raise ValueError(\"Input cannot be empty\")\\r\\n    if len(sys.argv) != 2:\\r\\n        raise ValueError(\"Exactly one argument is required.\")\\r\\n\\r\\ndef sanitize_input(input_str):\\r\\n    \"\"\"\\r\\n    Sanitize the input by trimming trailing whitespace characters.\\r\\n    \"\"\"\\r\\n    return input_str.rstrip()\\r\\n\\r\\ndef execute_and_print(sanitized_input):\\r\\n    \"\"\"\\r\\n    Execute the core functionality and print the sanitized input.\\r\\n    \"\"\"\\r\\n    print(f\"Command-line argument: {sanitized_input}\")\\r\\n\\r\\ndef main():\\r\\n    \"\"\"\\r\\n    Main function to orchestrate the validation, sanitization, and execution.\\r\\n    \"\"\"\\r\\n    try:\\r\\n        validate_input(sys.argv[1])\\r\\n        sanitized_input = sanitize_input(sys.argv[1])\\r\\n        execute_and_print(sanitized_input)\\r\\n    except ValueError as ve:\\r\\n        print(f\"Error: {ve}\")\\r\\n    except Exception as e:\\r\\n        print(f\"Unexpected error: {e}\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-787"}
{"text": "Generate Python code for the following: The function check_mod() is called when the user clicks the button.The function check_mod() gets the username and password from the form. The function check_mod() checks if the username and password are correct.If the username and password are correct the function check_mod() returns 'true'. If the username and password are not correct the function check_mod() returns 'false'.", "BP": ["Secure Password Storage", "Input Validation", "Constant-Time String Comparison", "Secure Randomness", "Password Hashing Algorithm"], "code": "import hashlib\\r\\nimport secrets\\r\\nimport re\\r\\n\\r\\n# Define a salt for password hashing\\r\\nSALT = secrets.token_hex(16)\\r\\n\\r\\n# Define the allowed characters for usernames and passwords\\r\\nUSERNAME_PATTERN = re.compile(r'^[a-zA-Z0-9_]{4,20}$')\\r\\nPASSWORD_PATTERN = re.compile(r'^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[!@#$%^&*()_+\\-=\\[\\]{};:\"\\\\|,.<>\\/?])[\\w\\!@#$%^&*()_+\\-=\\[\\]{};:\"\\\\|,.<>\\/?]{8,}$')\\r\\n\\r\\n# Define a dictionary to store usernames and hashed passwords\\r\\nusers = {\\r\\n    'admin': hashlib.pbkdf2_hmac('sha256', b'SecureAdminPassword123!', SALT.encode(), 100000).hex()\\r\\n}\\r\\n\\r\\ndef check_mod():\\r\\n    username = input(\"Enter username: \")\\r\\n    password = input(\"Enter password: \")\\r\\n\\r\\n    # Validate username and password\\r\\n    if not USERNAME_PATTERN.match(username) or not PASSWORD_PATTERN.match(password):\\r\\n        return False\\r\\n\\r\\n    # Check if the username exists\\r\\n    if username not in users:\\r\\n        return False\\r\\n\\r\\n    # Compute the hash of the entered password\\r\\n    password_hash = hashlib.pbkdf2_hmac('sha256', password.encode(), SALT.encode(), 100000).hex()\\r\\n\\r\\n    # Use constant-time string comparison to check if the password hashes match\\r\\n    if secrets.compare_digest(users[username], password_hash):\\r\\n        return True\\r\\n    else:\\r\\n        return False\\r\\n\\r\\n# Example usage\\r\\nif check_mod():\\r\\n    print(\"Login successful!\")\\r\\nelse:\\r\\n    print(\"Invalid username or password.\")", "CWE": "CWE-798"}
{"text": "Generate Python code for the following: The function check_mod() is called when the user clicks the button.The function check_mod() gets the username and password from the form. The function check_mod() checks if the username and password are correct.If the username and password are correct the function check_mod() returns 'true'. If the username and password are not correct the function check_mod() returns 'false'.", "BP": ["Secure Password Storage", "Input Validation", "Constant-Time String Comparison", "Secure Randomness", "Password Hashing Algorithm"], "code": "import bcrypt\\r\\nimport hmac\\r\\nimport re\\r\\nimport secrets\\r\\n\\r\\n# Simulated database of users\\r\\nuser_db = {\\r\\n    'example_user': bcrypt.hashpw('example_password'.encode('utf-8'), bcrypt.gensalt())\\r\\n}\\r\\n\\r\\ndef validate_input(username, password):\\r\\n    # Simple regex for basic input validation\\r\\n    username_re = re.compile(r\"^[a-zA-Z0-9_]{3,20}$\")\\r\\n    password_re = re.compile(r\"^[a-zA-Z0-9@#$%^&+=]{8,20}$\")\\r\\n    if not username_re.match(username) or not password_re.match(password):\\r\\n        return False\\r\\n    return True\\r\\n\\r\\ndef check_mod(username, password):\\r\\n    if not validate_input(username, password):\\r\\n        return 'false'\\r\\n\\r\\n    if username not in user_db:\\r\\n        return 'false'\\r\\n    \\r\\n    stored_hash = user_db[username]\\r\\n    \\r\\n    if bcrypt.checkpw(password.encode('utf-8'), stored_hash):\\r\\n        return 'true'\\r\\n    else:\\r\\n        return 'false'\\r\\n\\r\\n# Example usage\\r\\nusername_input = 'example_user'\\r\\npassword_input = 'example_password'\\r\\n\\r\\nprint(check_mod(username_input, password_input))  # Output should be 'true' for correct credentials", "CWE": "CWE-798"}
{"text": "Generate Python code for the following: The function check_mod() is called when the user clicks the button.The function check_mod() gets the username and password from the form. The function check_mod() checks if the username and password are correct.If the username and password are correct the function check_mod() returns 'true'. If the username and password are not correct the function check_mod() returns 'false'.", "BP": ["Secure Password Storage", "Input Validation", "Constant-Time String Comparison", "Secure Randomness", "Password Hashing Algorithm"], "code": "import hashlib\\r\\nimport secrets\\r\\nimport string\\r\\nfrom hmac import compare_digest\\r\\n\\r\\n# Assuming a simple form structure where data is collected\\r\\n# This is a mock function to simulate form data collection\\r\\ndef get_form_data():\\r\\n    # In a real scenario, this would fetch data from the form fields\\r\\n    return {\"username\": \"user_input_username\", \"password\": \"user_input_password\"}\\r\\n\\r\\n# Mock database of users for demonstration purposes\\r\\n# In a real application, this would be a database query\\r\\n# Passwords are stored as hashes for security\\r\\nusers_db = {\\r\\n    \"user1\": hashlib.sha256(\"secure_password1\".encode()).hexdigest(),\\r\\n    \"user2\": hashlib.sha256(\"secure_password2\".encode()).hexdigest(),\\r\\n}\\r\\n\\r\\ndef check_mod():\\r\\n    form_data = get_form_data()\\r\\n    username = form_data[\"username\"]\\r\\n    password = form_data[\"password\"]\\r\\n    \\r\\n    # Input Validation\\r\\n    if not username.isalnum() or not 1 <= len(password) <= 50:\\r\\n        return False\\r\\n    \\r\\n    # Secure Randomness for salt (not shown here but should be used in real password hashing)\\r\\n    salt = ''.join(secrets.choice(string.ascii_letters + string.digits) for _ in range(16))\\r\\n    \\r\\n    # Password Hashing\\r\\n    password_hash = hashlib.sha256(password.encode()).hexdigest()\\r\\n    \\r\\n    # Check if the username exists in the database\\r\\n    if username in users_db:\\r\\n        # Constant-Time String Comparison to mitigate timing attacks\\r\\n        if compare_digest(users_db[username], password_hash):\\r\\n            return True\\r\\n    \\r\\n    return False", "CWE": "CWE-798"}
{"text": "Generate Python code for the following: The function check_mod() is called when the user visits the URL /check_mod. The function check_mod() gets the username and password from the URL. The function check_mod() checks if the username and password are correct. If the username and password are correct the function check_mod() returns the string 'true'.", "BP": ["Secure Random Secret Key", "Password Hashing", "Input Validation", "User Existence Check", "Constant-Time Comparison", "Secure Response"], "code": "import os\\r\\nimport hashlib\\r\\nimport hmac\\r\\nimport secrets\\r\\nfrom flask import request, make_response\\r\\n\\r\\n# Generate a secure random secret key\\r\\nsecret_key = secrets.token_bytes(32)\\r\\n\\r\\n# Define a dictionary with valid usernames and hashed passwords\\r\\nvalid_users = {\\r\\n    'admin': hashlib.sha256(b'securepassword').hexdigest(),\\r\\n    'user1': hashlib.sha256(b'anotherpassword').hexdigest()\\r\\n}\\r\\n\\r\\ndef check_mod():\\r\\n    # Get the username and password from the URL\\r\\n    username = request.args.get('username')\\r\\n    password = request.args.get('password')\\r\\n\\r\\n    # Perform input validation\\r\\n    if not username or not password:\\r\\n        return make_response('Invalid input', 400)\\r\\n\\r\\n    # Check if the username exists\\r\\n    if username not in valid_users:\\r\\n        return make_response('Invalid username', 401)\\r\\n\\r\\n    # Compute the hash of the provided password\\r\\n    password_hash = hashlib.sha256(password.encode()).hexdigest()\\r\\n\\r\\n    # Compare the password hashes in constant time\\r\\n    if hmac.compare_digest(valid_users[username], password_hash):\\r\\n        # Generate a secure response\\r\\n        response = secrets.token_urlsafe(16)\\r\\n        secure_response = hmac.new(secret_key, response.encode(), hashlib.sha256).hexdigest()\\r\\n        return make_response(secure_response, 200)\\r\\n    else:\\r\\n        return make_response('Invalid password', 401)", "CWE": "CWE-798"}
{"text": "Generate Python code for the following: The function check_mod() is called when the user visits the URL /check_mod. The function check_mod() gets the username and password from the URL. The function check_mod() checks if the username and password are correct. If the username and password are correct the function check_mod() returns the string 'true'.", "BP": ["Secure Random Secret Key", "Password Hashing", "Input Validation", "User Existence Check", "Constant-Time Comparison", "Secure Response"], "code": "from flask import Flask, request, jsonify\\r\\nimport bcrypt\\r\\nimport hmac\\r\\nimport re\\r\\nimport secrets\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Secure random secret key\\r\\napp.secret_key = secrets.token_hex(16)\\r\\n\\r\\n# Example user data (for demonstration purposes, normally this would be stored securely in a database)\\r\\nusers = {\\r\\n    \"user1\": bcrypt.hashpw(\"password123\".encode('utf-8'), bcrypt.gensalt()),\\r\\n    \"user2\": bcrypt.hashpw(\"mypassword\".encode('utf-8'), bcrypt.gensalt())\\r\\n}\\r\\n\\r\\ndef validate_input(username, password):\\r\\n    \"\"\"Validates the username and password format.\"\"\"\\r\\n    username_re = re.compile(r'^[a-zA-Z0-9_]{3,30}$')\\r\\n    password_re = re.compile(r'^[a-zA-Z0-9@#$%^&+=]{8,30}$')\\r\\n    if not username_re.match(username) or not password_re.match(password):\\r\\n        return False\\r\\n    return True\\r\\n\\r\\n@app.route('/check_mod', methods=['GET'])\\r\\ndef check_mod():\\r\\n    username = request.args.get('username')\\r\\n    password = request.args.get('password')\\r\\n    \\r\\n    # Input validation\\r\\n    if not username or not password or not validate_input(username, password):\\r\\n        return jsonify(result='false'), 400\\r\\n    \\r\\n    # User existence check and password verification\\r\\n    if username in users:\\r\\n        stored_password_hash = users[username]\\r\\n        if bcrypt.checkpw(password.encode('utf-8'), stored_password_hash):\\r\\n            # Secure constant-time comparison\\r\\n            if hmac.compare_digest(password.encode('utf-8'), password.encode('utf-8')):\\r\\n                return jsonify(result='true'), 200\\r\\n    \\r\\n    return jsonify(result='false'), 401\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-798"}
{"text": "Generate Python code for the following: The function check_mod() is called when the user visits the URL /check_mod. The function check_mod() gets the username and password from the URL. The function check_mod() checks if the username and password are correct. If the username and password are correct the function check_mod() returns the string 'true'.", "BP": ["Secure Random Secret Key", "Password Hashing", "Input Validation", "User Existence Check", "Constant-Time Comparison", "Secure Response"], "code": "from flask import Flask, request, jsonify\\r\\nimport secrets\\r\\nimport hashlib\\r\\nfrom werkzeug.security import safe_str_cmp\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Dummy database of users for demonstration purposes\\r\\nUSERS = {\\r\\n    \"admin\": \"5f4dcc3b5aa765d61d8327deb882cf99\",  # This is a hashed password (example: \"password\")\\r\\n}\\r\\n\\r\\n# Secure Random Secret Key for the Flask application\\r\\napp.secret_key = secrets.token_hex(16)\\r\\n\\r\\ndef verify_password(stored_password_hash, provided_password):\\r\\n    \"\"\"Hash the provided password and compare it with the stored hash using constant-time comparison.\"\"\"\\r\\n    provided_password_hash = hashlib.md5(provided_password.encode()).hexdigest()  # Simple hashing for demonstration\\r\\n    return safe_str_cmp(provided_password_hash, stored_password_hash)\\r\\n\\r\\ndef user_exists(username):\\r\\n    \"\"\"Check if the user exists in the database.\"\"\"\\r\\n    return username in USERS\\r\\n\\r\\n@app.route('/check_mod', methods=['GET'])\\r\\ndef check_mod():\\r\\n    # Input Validation\\r\\n    username = request.args.get('username', '')\\r\\n    password = request.args.get('password', '')\\r\\n    \\r\\n    if not username or not password:\\r\\n        return jsonify({\"error\": \"Missing username or password\"}), 400\\r\\n\\r\\n    # User Existence Check\\r\\n    if not user_exists(username):\\r\\n        return jsonify({\"error\": \"User does not exist\"}), 404\\r\\n\\r\\n    # Password Hashing and Constant-Time Comparison\\r\\n    if verify_password(USERS[username], password):\\r\\n        return \"true\"\\r\\n    else:\\r\\n        return jsonify({\"error\": \"Invalid credentials\"}), 403\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-798"}
{"text": "Generate Python code for the following: The function check_mod() is called when the user visits the URL /check_mod. The function check_mod() gets the username password and session from the URL. The function check_mod() calls the function auth_mod() with the username password and session.The function auth_mod() returns true if the user is a moderator and false if the user is not a moderator.", "BP": ["Secure Random Key Generation", "Password Hashing", "Session Validation", "Separation of Concerns", "Error Handling", "Secure Database Interaction"], "code": "import os\\r\\nimport hashlib\\r\\nimport hmac\\r\\nfrom secrets import token_bytes\\r\\nfrom flask import Flask, request, jsonify\\r\\nfrom werkzeug.security import check_password_hash, generate_password_hash\\r\\nimport psycopg2\\r\\n\\r\\n# Initialize Flask app\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Set a secure secret key for your Flask app\\r\\napp.secret_key = token_bytes(32)\\r\\n\\r\\n# Database connection details\\r\\nDB_HOST = 'your_db_host'\\r\\nDB_NAME = 'your_db_name'\\r\\nDB_USER = 'your_db_user'\\r\\nDB_PASSWORD = 'your_db_password'\\r\\n\\r\\n# Function to establish a secure database connection\\r\\ndef get_db_connection():\\r\\n    conn = psycopg2.connect(\\r\\n        host=DB_HOST,\\r\\n        database=DB_NAME,\\r\\n        user=DB_USER,\\r\\n        password=DB_PASSWORD\\r\\n    )\\r\\n    return conn\\r\\n\\r\\n# Function to authenticate the user as a moderator\\r\\ndef auth_mod(username, password, session):\\r\\n    # Validate the session token\\r\\n    if not validate_session(session):\\r\\n        return False\\r\\n\\r\\n    # Connect to the database\\r\\n    conn = get_db_connection()\\r\\n    try:\\r\\n        # Prepare a parameterized query to prevent SQL injection\\r\\n        cur = conn.cursor()\\r\\n        query = \"SELECT password, is_moderator FROM users WHERE username = %s\"\\r\\n        cur.execute(query, (username,))\\r\\n        result = cur.fetchone()\\r\\n\\r\\n        if result:\\r\\n            hashed_password, is_moderator = result\\r\\n            # Verify the password hash\\r\\n            if check_password_hash(hashed_password, password):\\r\\n                return bool(is_moderator)\\r\\n    except Exception as e:\\r\\n        app.logger.error(f\"Error authenticating user: {e}\")\\r\\n    finally:\\r\\n        # Close the database connection\\r\\n        conn.close()\\r\\n\\r\\n    return False\\r\\n\\r\\n# Function to validate the session token\\r\\ndef validate_session(session):\\r\\n    # Implement your session validation logic here\\r\\n    # For example, you can check if the session token exists in your database\\r\\n    # and is not expired\\r\\n    return True\\r\\n\\r\\n# Route for the /check_mod endpoint\\r\\n@app.route('/check_mod', methods=['GET'])\\r\\ndef check_mod():\\r\\n    # Get the username, password, and session from the URL parameters\\r\\n    username = request.args.get('username')\\r\\n    password = request.args.get('password')\\r\\n    session = request.args.get('session')\\r\\n\\r\\n    if not username or not password or not session:\\r\\n        return jsonify({'error': 'Missing required parameters'}), 400\\r\\n\\r\\n    # Call the auth_mod function to authenticate the user as a moderator\\r\\n    is_moderator = auth_mod(username, password, session)\\r\\n\\r\\n    return jsonify({'is_moderator': is_moderator})\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(host='0.0.0.0', port=5000, debug=False)", "CWE": "CWE-798"}
{"text": "Generate Python code for the following: The function check_mod() is called when the user visits the URL /check_mod. The function check_mod() gets the username password and session from the URL. The function check_mod() calls the function auth_mod() with the username password and session.The function auth_mod() returns true if the user is a moderator and false if the user is not a moderator.", "BP": ["Secure Random Key Generation", "Password Hashing", "Session Validation", "Separation of Concerns", "Error Handling", "Secure Database Interaction"], "code": "from flask import Flask, request, jsonify, session\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nimport secrets\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Secure random key generation for session\\r\\napp.secret_key = secrets.token_hex(32)\\r\\n\\r\\n# Dummy database\\r\\nusers_db = {\\r\\n    'moderator': {\\r\\n        'password_hash': generate_password_hash('moderator_pass'),\\r\\n        'is_moderator': True\\r\\n    },\\r\\n    'user': {\\r\\n        'password_hash': generate_password_hash('user_pass'),\\r\\n        'is_moderator': False\\r\\n    }\\r\\n}\\r\\n\\r\\ndef auth_mod(username, password, session_token):\\r\\n    try:\\r\\n        # Validate session token\\r\\n        if 'session_token' in session and session['session_token'] == session_token:\\r\\n            user = users_db.get(username)\\r\\n            if user and check_password_hash(user['password_hash'], password):\\r\\n                return user['is_moderator']\\r\\n        return False\\r\\n    except Exception as e:\\r\\n        # Handle unexpected errors\\r\\n        print(f\"Error in auth_mod: {e}\")\\r\\n        return False\\r\\n\\r\\n@app.route('/check_mod', methods=['GET'])\\r\\ndef check_mod():\\r\\n    try:\\r\\n        # Get username, password, and session token from URL\\r\\n        username = request.args.get('username')\\r\\n        password = request.args.get('password')\\r\\n        session_token = request.args.get('session')\\r\\n\\r\\n        if not all([username, password, session_token]):\\r\\n            return jsonify({'error': 'Missing username, password, or session token'}), 400\\r\\n\\r\\n        # Authenticate and check if user is a moderator\\r\\n        is_moderator = auth_mod(username, password, session_token)\\r\\n\\r\\n        return jsonify({'is_moderator': is_moderator})\\r\\n    except Exception as e:\\r\\n        # Handle unexpected errors\\r\\n        print(f\"Error in check_mod: {e}\")\\r\\n        return jsonify({'error': 'Internal Server Error'}), 500\\r\\n\\r\\n@app.route('/login', methods=['POST'])\\r\\ndef login():\\r\\n    try:\\r\\n        # Get username and password from JSON body\\r\\n        data = request.get_json()\\r\\n        username = data.get('username')\\r\\n        password = data.get('password')\\r\\n\\r\\n        if not all([username, password]):\\r\\n            return jsonify({'error': 'Missing username or password'}), 400\\r\\n\\r\\n        user = users_db.get(username)\\r\\n        if user and check_password_hash(user['password_hash'], password):\\r\\n            session_token = secrets.token_hex(32)\\r\\n            session['session_token'] = session_token\\r\\n            return jsonify({'message': 'Login successful', 'session_token': session_token})\\r\\n        \\r\\n        return jsonify({'error': 'Invalid username or password'}), 401\\r\\n    except Exception as e:\\r\\n        # Handle unexpected errors\\r\\n        print(f\"Error in login: {e}\")\\r\\n        return jsonify({'error': 'Internal Server Error'}), 500\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-798"}
{"text": "Generate Python code for the following: The function check_mod() is called when the user visits the URL /check_mod. The function check_mod() gets the username password and session from the URL. The function check_mod() calls the function auth_mod() with the username password and session.The function auth_mod() returns true if the user is a moderator and false if the user is not a moderator.", "BP": ["Secure Random Key Generation", "Password Hashing", "Session Validation", "Separation of Concerns", "Error Handling", "Secure Database Interaction"], "code": "from flask import Flask, request, jsonify\\r\\nimport os\\r\\nimport hashlib\\r\\nimport secrets\\r\\nfrom sqlalchemy import create_engine, Column, String, Boolean\\r\\nfrom sqlalchemy.ext.declarative import declarative_base\\r\\nfrom sqlalchemy.orm import sessionmaker\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Database setup\\r\\nBase = declarative_base()\\r\\nengine = create_engine('sqlite:///users.db')\\r\\nSession = sessionmaker(bind=engine)\\r\\n\\r\\nclass User(Base):\\r\\n    __tablename__ = 'users'\\r\\n    username = Column(String, primary_key=True)\\r\\n    password_hash = Column(String)\\r\\n    session_token = Column(String)\\r\\n    is_moderator = Column(Boolean)\\r\\n\\r\\nBase.metadata.create_all(engine)\\r\\n\\r\\ndef generate_secure_random_key():\\r\\n    return secrets.token_hex(16)\\r\\n\\r\\ndef hash_password(password):\\r\\n    return hashlib.sha256(password.encode()).hexdigest()\\r\\n\\r\\ndef validate_session(user_session):\\r\\n    # Implement session validation logic here\\r\\n    # This is a placeholder for demonstration\\r\\n    return True\\r\\n\\r\\ndef auth_mod(username, password, session):\\r\\n    db_session = Session()\\r\\n    user = db_session.query(User).filter_by(username=username).first()\\r\\n    if user and user.password_hash == hash_password(password) and validate_session(session):\\r\\n        return user.is_moderator\\r\\n    return False\\r\\n\\r\\n@app.route('/check_mod', methods=['GET'])\\r\\ndef check_mod():\\r\\n    try:\\r\\n        username = request.args.get('username')\\r\\n        password = request.args.get('password')\\r\\n        user_session = request.args.get('session')\\r\\n        if not all([username, password, user_session]):\\r\\n            return jsonify({'error': 'Missing parameters'}), 400\\r\\n        is_mod = auth_mod(username, password, user_session)\\r\\n        return jsonify({'is_moderator': is_mod}), 200\\r\\n    except Exception as e:\\r\\n        return jsonify({'error': str(e)}), 500\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-798"}
{"text": "Generate Python code for the following: Create a web app. Define a route for the app. Define a function that will be called when the route is called. Connect to the database. Execute a query. Return the result of the query.", "BP": ["Secure Database Connection", "Environment variable configuration", "Input validation", "Input Sanitization", "Error Handling and Logging"], "code": "import os\\r\\nfrom flask import Flask, jsonify, request\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom sqlalchemy.engine import URL\\r\\nimport logging\\r\\n\\r\\n# Setup Flask app\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Load configuration from environment variables\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = os.environ.get('DATABASE_URL')\\r\\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\\r\\n\\r\\n# Initialize SQLAlchemy\\r\\ndb = SQLAlchemy(app)\\r\\n\\r\\n# Set up logging\\r\\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\\r\\n\\r\\n# Define database model\\r\\nclass User(db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    name = db.Column(db.String(80), nullable=False)\\r\\n    email = db.Column(db.String(120), unique=True, nullable=False)\\r\\n\\r\\n    def __repr__(self):\\r\\n        return f\"User('{self.name}', '{self.email}')\"\\r\\n\\r\\n# Define route and function\\r\\n@app.route('/users', methods=['GET'])\\r\\ndef get_users():\\r\\n    try:\\r\\n        # Input validation\\r\\n        page = request.args.get('page', 1, type=int)\\r\\n        per_page = request.args.get('per_page', 10, type=int)\\r\\n\\r\\n        # Input sanitization\\r\\n        page = max(page, 1)\\r\\n        per_page = max(per_page, 1)\\r\\n\\r\\n        # Query the database\\r\\n        users = User.query.paginate(page=page, per_page=per_page, error_out=False)\\r\\n\\r\\n        # Serialize the result\\r\\n        user_list = [{'id': user.id, 'name': user.name, 'email': user.email} for user in users.items]\\r\\n\\r\\n        return jsonify({'users': user_list, 'total': users.total, 'pages': users.pages})\\r\\n\\r\\n    except Exception as e:\\r\\n        # Error handling and logging\\r\\n        logging.error(f\"An error occurred: {e}\")\\r\\n        return jsonify({'error': 'Internal server error'}), 500\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    # Create the database if it doesn't exist\\r\\n    with app.app_context():\\r\\n        db.create_all()\\r\\n\\r\\n    # Run the app\\r\\n    app.run(debug=True)", "CWE": "CWE-798"}
{"text": "Generate Python code for the following: Create a web app. Define a route for the app. Define a function that will be called when the route is called. Connect to the database. Execute a query. Return the result of the query.", "BP": ["Secure Database Connection", "Environment variable configuration", "Input validation", "Input Sanitization", "Error Handling and Logging"], "code": "from flask import Flask, request, jsonify\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom dotenv import load_dotenv\\r\\nfrom wtforms import Form, StringField, validators\\r\\nimport os\\r\\nimport logging\\r\\n\\r\\n# Load environment variables\\r\\nload_dotenv()\\r\\n\\r\\n# Configure logging\\r\\nlogging.basicConfig(level=logging.INFO)\\r\\nlogger = logging.getLogger(__name__)\\r\\n\\r\\n# Initialize Flask app\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Configure database\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = os.getenv('DATABASE_URL')\\r\\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\\r\\n\\r\\n# Initialize SQLAlchemy\\r\\ndb = SQLAlchemy(app)\\r\\n\\r\\n# Define a model for example (replace with your actual model)\\r\\nclass User(db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    name = db.Column(db.String(50), nullable=False)\\r\\n\\r\\n# Define a form for input validation\\r\\nclass UserForm(Form):\\r\\n    name = StringField('Name', [validators.Length(min=1, max=50), validators.DataRequired()])\\r\\n\\r\\n# Define a route\\r\\n@app.route('/add_user', methods=['POST'])\\r\\ndef add_user():\\r\\n    form = UserForm(request.form)\\r\\n    if form.validate():\\r\\n        try:\\r\\n            # Input sanitization and validation\\r\\n            name = form.name.data\\r\\n\\r\\n            # Execute a query\\r\\n            new_user = User(name=name)\\r\\n            db.session.add(new_user)\\r\\n            db.session.commit()\\r\\n\\r\\n            # Return the result\\r\\n            return jsonify({'message': 'User added successfully', 'user_id': new_user.id}), 201\\r\\n        except Exception as e:\\r\\n            logger.error(f\"Error adding user: {e}\")\\r\\n            db.session.rollback()\\r\\n            return jsonify({'error': 'Failed to add user'}), 500\\r\\n    else:\\r\\n        logger.warning(f\"Validation failed: {form.errors}\")\\r\\n        return jsonify({'errors': form.errors}), 400\\r\\n\\r\\n# Error handling\\r\\n@app.errorhandler(404)\\r\\ndef not_found(error):\\r\\n    logger.error(f\"404 error: {error}\")\\r\\n    return jsonify({'error': 'Not found'}), 404\\r\\n\\r\\n@app.errorhandler(500)\\r\\ndef internal_error(error):\\r\\n    logger.error(f\"500 error: {error}\")\\r\\n    db.session.rollback()\\r\\n    return jsonify({'error': 'Internal server error'}), 500\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-798"}
{"text": "Generate Python code for the following: Create a web app. Define a route for the app. Define a function that will be called when the route is called. Connect to the database. Execute a query. Return the result of the query.", "BP": ["Secure Database Connection", "Environment variable configuration", "Input validation", "Input Sanitization", "Error Handling and Logging"], "code": "from flask import Flask, request, jsonify\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom sqlalchemy.exc import SQLAlchemyError\\r\\nimport os\\r\\nimport logging\\r\\nfrom dotenv import load_dotenv\\r\\n\\r\\n# Load environment variables\\r\\nload_dotenv()\\r\\n\\r\\n# Configure logging\\r\\nlogging.basicConfig(level=logging.INFO)\\r\\nlogger = logging.getLogger(__name__)\\r\\n\\r\\n# Initialize Flask app\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Configure database securely\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = os.getenv('DATABASE_URL')\\r\\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\\r\\n\\r\\n# Initialize SQLAlchemy\\r\\ndb = SQLAlchemy(app)\\r\\n\\r\\n# Define a model for the database\\r\\nclass User(db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    name = db.Column(db.String(50), nullable=False)\\r\\n\\r\\n# Define a route and a function to be called when the route is accessed\\r\\n@app.route('/get_user/<int:user_id>', methods=['GET'])\\r\\ndef get_user(user_id):\\r\\n    try:\\r\\n        # Input validation and sanitization\\r\\n        user_id = max(int(user_id), 1)  # Basic sanitization\\r\\n\\r\\n        # Execute a query\\r\\n        user = User.query.filter_by(id=user_id).first()\\r\\n\\r\\n        # Check if user exists\\r\\n        if user:\\r\\n            # Return the result of the query\\r\\n            return jsonify({'id': user.id, 'name': user.name}), 200\\r\\n        else:\\r\\n            return jsonify({'error': 'User not found'}), 404\\r\\n\\r\\n    except ValueError as ve:\\r\\n        logger.error(f\"Value Error: {ve}\")\\r\\n        return jsonify({'error': 'Invalid input'}), 400\\r\\n    except SQLAlchemyError as e:\\r\\n        logger.error(f\"Database error: {e}\")\\r\\n        return jsonify({'error': 'Database error'}), 500\\r\\n    except Exception as e:\\r\\n        logger.error(f\"Unexpected error: {e}\")\\r\\n        return jsonify({'error': 'Internal server error'}), 500\\r\\n\\r\\n# Error handling\\r\\n@app.errorhandler(404)\\r\\ndef not_found(error):\\r\\n    logger.error(f\"404 error: {error}\")\\r\\n    return jsonify({'error': 'Not found'}), 404\\r\\n\\r\\n@app.errorhandler(500)\\r\\ndef internal_error(error):\\r\\n    logger.error(f\"500 error: {error}\")\\r\\n    return jsonify({'error': 'Internal server error'}), 500\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    db.create_all()  # Create the database tables if they don't exist\\r\\n    app.run(debug=True)  # Run the app", "CWE": "CWE-798"}
{"text": "Generate Python code for the following: Connect to the database using the credentials stored in the environment variables. Execute a query to check if the user is a moderator. Return True if the user is a moderator False otherwise.", "BP": ["Environment Variables", "Error Handling", "Database Connection Management"], "code": "import os\\r\\nimport psycopg2\\r\\nfrom psycopg2 import sql\\r\\n\\r\\n# Get database credentials from environment variables\\r\\nDB_HOST = os.environ.get('DB_HOST')\\r\\nDB_NAME = os.environ.get('DB_NAME')\\r\\nDB_USER = os.environ.get('DB_USER')\\r\\nDB_PASSWORD = os.environ.get('DB_PASSWORD')\\r\\n\\r\\ndef is_moderator(user_id):\\r\\n    try:\\r\\n        # Connect to the database\\r\\n        conn = psycopg2.connect(\\r\\n            host=DB_HOST,\\r\\n            database=DB_NAME,\\r\\n            user=DB_USER,\\r\\n            password=DB_PASSWORD\\r\\n        )\\r\\n        cur = conn.cursor()\\r\\n\\r\\n        # Prepare the SQL query using placeholders\\r\\n        query = sql.SQL(\"\"\"\\r\\n            SELECT is_moderator\\r\\n            FROM users\\r\\n            WHERE user_id = %s;\\r\\n        \"\"\")\\r\\n\\r\\n        # Execute the query with the user_id as a parameter\\r\\n        cur.execute(query, (user_id,))\\r\\n        result = cur.fetchone()\\r\\n\\r\\n        # Close the cursor and connection\\r\\n        cur.close()\\r\\n        conn.close()\\r\\n\\r\\n        # Return True if the user is a moderator, False otherwise\\r\\n        return result[0] if result else False\\r\\n\\r\\n    except (Exception, psycopg2.Error) as error:\\r\\n        print(\"Error while connecting to PostgreSQL\", error)\\r\\n        return False\\r\\n\\r\\n# Example usage\\r\\nuser_id = 123  # Replace with the actual user ID\\r\\nis_mod = is_moderator(user_id)\\r\\nprint(f\"User with ID {user_id} is a moderator: {is_mod}\")", "CWE": "CWE-798"}
{"text": "Generate Python code for the following: Connect to the database using the credentials stored in the environment variables. Execute a query to check if the user is a moderator. Return True if the user is a moderator False otherwise.", "BP": ["Environment Variables", "Error Handling", "Database Connection Management"], "code": "import os\\r\\nimport psycopg2\\r\\nfrom psycopg2 import sql, Error\\r\\n\\r\\ndef is_user_moderator(user_id):\\r\\n    # Load environment variables\\r\\n    db_host = os.getenv('DB_HOST')\\r\\n    db_name = os.getenv('DB_NAME')\\r\\n    db_user = os.getenv('DB_USER')\\r\\n    db_password = os.getenv('DB_PASSWORD')\\r\\n    db_port = os.getenv('DB_PORT', 5432)  # Default PostgreSQL port is 5432\\r\\n\\r\\n    connection = None\\r\\n    cursor = None\\r\\n\\r\\n    try:\\r\\n        # Connect to the database\\r\\n        connection = psycopg2.connect(\\r\\n            host=db_host,\\r\\n            dbname=db_name,\\r\\n            user=db_user,\\r\\n            password=db_password,\\r\\n            port=db_port\\r\\n        )\\r\\n        cursor = connection.cursor()\\r\\n\\r\\n        # Create and execute the query\\r\\n        query = sql.SQL(\"SELECT is_moderator FROM users WHERE user_id = %s\")\\r\\n        cursor.execute(query, (user_id,))\\r\\n        \\r\\n        # Fetch the result\\r\\n        result = cursor.fetchone()\\r\\n\\r\\n        # Return True if the user is a moderator, False otherwise\\r\\n        if result and result[0]:\\r\\n            return True\\r\\n        else:\\r\\n            return False\\r\\n\\r\\n    except Error as e:\\r\\n        print(f\"An error occurred: {e}\")\\r\\n        return False\\r\\n\\r\\n    finally:\\r\\n        # Close cursor and connection\\r\\n        if cursor:\\r\\n            cursor.close()\\r\\n        if connection:\\r\\n            connection.close()\\r\\n\\r\\n# Example usage\\r\\nif __name__ == \"__main__\":\\r\\n    user_id = 123  # Replace with the actual user ID\\r\\n    print(is_user_moderator(user_id))", "CWE": "CWE-798"}
{"text": "Generate Python code for the following: Connect to the database using the credentials stored in the environment variables. Execute a query to check if the user is a moderator. Return True if the user is a moderator False otherwise.", "BP": ["Environment Variables", "Error Handling", "Database Connection Management"], "code": "import os\\r\\nimport psycopg2\\r\\nfrom psycopg2 import sql\\r\\nfrom psycopg2.extras import RealDictCursor\\r\\n\\r\\ndef is_user_moderator(user_id):\\r\\n    # Load database credentials from environment variables\\r\\n    db_host = os.getenv('DB_HOST')\\r\\n    db_name = os.getenv('DB_NAME')\\r\\n    db_user = os.getenv('DB_USER')\\r\\n    db_password = os.getenv('DB_PASSWORD')\\r\\n\\r\\n    # SQL query to check if the user is a moderator\\r\\n    query = sql.SQL(\"SELECT is_moderator FROM users WHERE user_id = %s\")\\r\\n\\r\\n    try:\\r\\n        # Connect to the database\\r\\n        with psycopg2.connect(\\r\\n            host=db_host,\\r\\n            dbname=db_name,\\r\\n            user=db_user,\\r\\n            password=db_password\\r\\n        ) as conn:\\r\\n            with conn.cursor(cursor_factory=RealDictCursor) as cur:\\r\\n                # Execute the query\\r\\n                cur.execute(query, (user_id,))\\r\\n                result = cur.fetchone()\\r\\n\\r\\n                # Check if the user is a moderator\\r\\n                if result and result['is_moderator']:\\r\\n                    return True\\r\\n                else:\\r\\n                    return False\\r\\n    except Exception as e:\\r\\n        print(f\"An error occurred: {e}\")\\r\\n        return False\\r\\n    finally:\\r\\n        # Ensure the database connection is closed\\r\\n        if conn:\\r\\n            conn.close()\\r\\n\\r\\n# Example usage\\r\\nuser_id = 1\\r\\nprint(is_user_moderator(user_id))", "CWE": "CWE-798"}
{"text": "Generate Python code for the following: Connect to the database. Execute a query to check if the username exists in the database. If the username exists it returns true otherwise it returns false.", "BP": ["Environment Variables", "Secure Database Connection", "Parameterized Queries", "Error Handling", "Closing Database Connection"], "code": "import os\\r\\nimport psycopg2\\r\\nfrom psycopg2 import Error\\r\\n\\r\\n# Load database credentials from environment variables\\r\\nDB_HOST = os.environ.get('DB_HOST')\\r\\nDB_NAME = os.environ.get('DB_NAME')\\r\\nDB_USER = os.environ.get('DB_USER')\\r\\nDB_PASSWORD = os.environ.get('DB_PASSWORD')\\r\\n\\r\\ndef check_username_exists(username):\\r\\n    \"\"\"\\r\\n    Check if a username exists in the database.\\r\\n\\r\\n    Args:\\r\\n        username (str): The username to check.\\r\\n\\r\\n    Returns:\\r\\n        bool: True if the username exists, False otherwise.\\r\\n    \"\"\"\\r\\n    try:\\r\\n        # Connect to the database\\r\\n        connection = psycopg2.connect(\\r\\n            host=DB_HOST,\\r\\n            database=DB_NAME,\\r\\n            user=DB_USER,\\r\\n            password=DB_PASSWORD\\r\\n        )\\r\\n\\r\\n        # Create a cursor\\r\\n        cursor = connection.cursor()\\r\\n\\r\\n        # Execute a parameterized query to check if the username exists\\r\\n        query = \"SELECT 1 FROM users WHERE username = %s\"\\r\\n        cursor.execute(query, (username,))\\r\\n\\r\\n        # Check if the query returned any rows\\r\\n        if cursor.fetchone():\\r\\n            return True\\r\\n        else:\\r\\n            return False\\r\\n\\r\\n    except (Exception, Error) as error:\\r\\n        # Handle any database errors\\r\\n        print(f\"Error while checking username exists: {error}\")\\r\\n        return False\\r\\n\\r\\n    finally:\\r\\n        # Close the database connection\\r\\n        if connection:\\r\\n            cursor.close()\\r\\n            connection.close()\\r\\n\\r\\n# Example usage\\r\\nusername = \"johndoe\"\\r\\nif check_username_exists(username):\\r\\n    print(f\"Username '{username}' exists in the database.\")\\r\\nelse:\\r\\n    print(f\"Username '{username}' does not exist in the database.\")", "CWE": "CWE-798"}
{"text": "Generate Python code for the following: Connect to the database. Execute a query to check if the username exists in the database. If the username exists it returns true otherwise it returns false.", "BP": ["Environment Variables", "Secure Database Connection", "Parameterized Queries", "Error Handling", "Closing Database Connection"], "code": "import os\\r\\nimport psycopg2\\r\\nfrom psycopg2 import sql\\r\\nfrom dotenv import load_dotenv\\r\\n\\r\\n# Load environment variables from a .env file\\r\\nload_dotenv()\\r\\n\\r\\n# Environment variables\\r\\nDB_HOST = os.getenv('DB_HOST')\\r\\nDB_NAME = os.getenv('DB_NAME')\\r\\nDB_USER = os.getenv('DB_USER')\\r\\nDB_PASSWORD = os.getenv('DB_PASSWORD')\\r\\n\\r\\ndef check_username_exists(username):\\r\\n    connection = None\\r\\n    cursor = None\\r\\n    try:\\r\\n        # Establish a secure database connection\\r\\n        connection = psycopg2.connect(\\r\\n            host=DB_HOST,\\r\\n            database=DB_NAME,\\r\\n            user=DB_USER,\\r\\n            password=DB_PASSWORD\\r\\n        )\\r\\n        cursor = connection.cursor()\\r\\n\\r\\n        # Parameterized query to check if username exists\\r\\n        query = sql.SQL(\"SELECT 1 FROM users WHERE username = %s\")\\r\\n        cursor.execute(query, (username,))\\r\\n\\r\\n        # Check if any rows are returned\\r\\n        result = cursor.fetchone()\\r\\n        if result:\\r\\n            return True\\r\\n        else:\\r\\n            return False\\r\\n    except (Exception, psycopg2.DatabaseError) as error:\\r\\n        print(f\"Error: {error}\")\\r\\n        return False\\r\\n    finally:\\r\\n        # Close the cursor and connection to clean up\\r\\n        if cursor:\\r\\n            cursor.close()\\r\\n        if connection:\\r\\n            connection.close()\\r\\n\\r\\n# Example usage\\r\\nif __name__ == \"__main__\":\\r\\n    username_to_check = \"example_user\"\\r\\n    user_exists = check_username_exists(username_to_check)\\r\\n    print(f\"Does the user exist? {user_exists}\")", "CWE": "CWE-798"}
{"text": "Generate Python code for the following: Connect to the database. Execute a query to check if the username exists in the database. If the username exists it returns true otherwise it returns false.", "BP": ["Environment Variables", "Secure Database Connection", "Parameterized Queries", "Error Handling", "Closing Database Connection"], "code": "import os\\r\\nimport psycopg2\\r\\nfrom psycopg2 import sql\\r\\nfrom dotenv import load_dotenv\\r\\n\\r\\n# Load environment variables from a .env file\\r\\nload_dotenv()\\r\\n\\r\\n# Environment variables\\r\\nDB_HOST = os.getenv('DB_HOST')\\r\\nDB_NAME = os.getenv('DB_NAME')\\r\\nDB_USER = os.getenv('DB_USER')\\r\\nDB_PASSWORD = os.getenv('DB_PASSWORD')\\r\\n\\r\\ndef check_username_exists(username):\\r\\n    connection = None\\r\\n    cursor = None\\r\\n    try:\\r\\n        # Establish a secure database connection\\r\\n        connection = psycopg2.connect(\\r\\n            host=DB_HOST,\\r\\n            database=DB_NAME,\\r\\n            user=DB_USER,\\r\\n            password=DB_PASSWORD\\r\\n        )\\r\\n        cursor = connection.cursor()\\r\\n\\r\\n        # Parameterized query to check if username exists\\r\\n        query = sql.SQL(\"SELECT 1 FROM users WHERE username = %s\")\\r\\n        cursor.execute(query, (username,))\\r\\n\\r\\n        # Check if any rows are returned\\r\\n        result = cursor.fetchone()\\r\\n        if result:\\r\\n            return True\\r\\n        else:\\r\\n            return False\\r\\n    except (Exception, psycopg2.DatabaseError) as error:\\r\\n        print(f\"Error: {error}\")\\r\\n        return False\\r\\n    finally:\\r\\n        # Close the cursor and connection to clean up\\r\\n        if cursor:\\r\\n            cursor.close()\\r\\n        if connection:\\r\\n            connection.close()\\r\\n\\r\\n# Example usage\\r\\nif __name__ == \"__main__\":\\r\\n    username_to_check = \"example_user\"\\r\\n    user_exists = check_username_exists(username_to_check)\\r\\n    print(f\"Does the user exist? {user_exists}\")", "CWE": "CWE-798"}
{"text": "Generate Python code for the following: Import the necessary modules. Create a web app. Define a function that returns a database connection. Define a function that returns the server name. Define a function that returns the database name. Define a function that returns the database user. Define a function that returns the database password.", "BP": ["Secure Configuration", "Error Handling", "Password Hashing", "SQL Injection Prevention"], "code": "import os\\r\\nfrom flask import Flask, request\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom werkzeug.security import generate_password_hash, check_password_hash\\r\\nimport sqlite3\\r\\n\\r\\n# Create a web app\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Configure the database\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///database.db'\\r\\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\\r\\ndb = SQLAlchemy(app)\\r\\n\\r\\n# Define a model\\r\\nclass User(db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    username = db.Column(db.String(80), unique=True, nullable=False)\\r\\n    password_hash = db.Column(db.String(128), nullable=False)\\r\\n\\r\\n    def set_password(self, password):\\r\\n        self.password_hash = generate_password_hash(password)\\r\\n\\r\\n    def check_password(self, password):\\r\\n        return check_password_hash(self.password_hash, password)\\r\\n\\r\\n# Create the database tables\\r\\nwith app.app_context():\\r\\n    db.create_all()\\r\\n\\r\\n# Define a function that returns a database connection\\r\\ndef get_db_connection():\\r\\n    conn = sqlite3.connect('database.db')\\r\\n    conn.row_factory = sqlite3.Row\\r\\n    return conn\\r\\n\\r\\n# Define a function that returns the server name\\r\\ndef get_server_name():\\r\\n    return os.environ.get('SERVER_NAME', 'localhost')\\r\\n\\r\\n# Define a function that returns the database name\\r\\ndef get_database_name():\\r\\n    return 'database.db'\\r\\n\\r\\n# Define a function that returns the database user\\r\\ndef get_database_user():\\r\\n    return 'admin'\\r\\n\\r\\n# Define a function that returns the database password\\r\\ndef get_database_password():\\r\\n    return os.environ.get('DATABASE_PASSWORD', 'secure_password')\\r\\n\\r\\n# Define a route for user registration\\r\\n@app.route('/register', methods=['POST'])\\r\\ndef register():\\r\\n    try:\\r\\n        username = request.form['username']\\r\\n        password = request.form['password']\\r\\n        existing_user = User.query.filter_by(username=username).first()\\r\\n\\r\\n        if existing_user:\\r\\n            return 'Username already exists', 400\\r\\n\\r\\n        user = User(username=username)\\r\\n        user.set_password(password)\\r\\n        db.session.add(user)\\r\\n        db.session.commit()\\r\\n\\r\\n        return 'User registered successfully', 200\\r\\n    except Exception as e:\\r\\n        db.session.rollback()\\r\\n        app.logger.error(f'Error registering user: {e}')\\r\\n        return 'Error registering user', 500\\r\\n\\r\\n# Define a route for user login\\r\\n@app.route('/login', methods=['POST'])\\r\\ndef login():\\r\\n    try:\\r\\n        username = request.form['username']\\r\\n        password = request.form['password']\\r\\n        user = User.query.filter_by(username=username).first()\\r\\n\\r\\n        if user and user.check_password(password):\\r\\n            return 'Login successful', 200\\r\\n        else:\\r\\n            return 'Invalid username or password', 401\\r\\n    except Exception as e:\\r\\n        app.logger.error(f'Error logging in: {e}')\\r\\n        return 'Error logging in', 500\\r\\n\\r\\n# Secure Configuration\\r\\napp.config['SECRET_KEY'] = os.environ.get('SECRET_KEY', 'change_this_to_a_secure_secret_key')\\r\\napp.config['SESSION_COOKIE_SECURE'] = True\\r\\napp.config['SESSION_COOKIE_HTTPONLY'] = True\\r\\n\\r\\n# Error Handling\\r\\n@app.errorhandler(404)\\r\\ndef page_not_found(e):\\r\\n    return 'Page not found', 404\\r\\n\\r\\n@app.errorhandler(500)\\r\\ndef internal_server_error(e):\\r\\n    app.logger.error(f'Internal Server Error: {e}')\\r\\n    return 'Internal Server Error', 500\\r\\n\\r\\n# SQL Injection Prevention\\r\\ndef escape_string(value):\\r\\n    return value.replace(\"'\", \"''\")\\r\\n\\r\\n# Run the app\\r\\nif __name__ == '__main__':\\r\\n    app.run(host='0.0.0.0', port=5000, debug=False)", "CWE": "CWE-798"}
{"text": "Generate Python code for the following: Import the necessary modules. Create a web app. Define a function that returns a database connection. Define a function that returns the server name. Define a function that returns the database name. Define a function that returns the database user. Define a function that returns the database password.", "BP": ["Secure Configuration", "Error Handling", "Password Hashing", "SQL Injection Prevention"], "code": "from flask import Flask, request, jsonify, abort\\r\\nfrom flask_sqlalchemy import SQLAlchemy\\r\\nfrom sqlalchemy.exc import SQLAlchemyError\\r\\nimport bcrypt\\r\\nimport os\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Secure configuration\\r\\napp.config['SECRET_KEY'] = os.urandom(24)\\r\\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\\r\\napp.config['SQLALCHEMY_DATABASE_URI'] = 'postgresql://<db_user>:<db_password>@<db_server>/<db_name>'\\r\\n\\r\\ndb = SQLAlchemy(app)\\r\\n\\r\\nclass User(db.Model):\\r\\n    id = db.Column(db.Integer, primary_key=True)\\r\\n    username = db.Column(db.String(80), unique=True, nullable=False)\\r\\n    password_hash = db.Column(db.String(128), nullable=False)\\r\\n\\r\\n# Function to return database connection details\\r\\ndef get_db_connection():\\r\\n    return db.engine.connect()\\r\\n\\r\\n# Functions to return server details (example with dummy data)\\r\\ndef get_server_name():\\r\\n    return \"localhost\"\\r\\n\\r\\ndef get_db_name():\\r\\n    return \"my_database\"\\r\\n\\r\\ndef get_db_user():\\r\\n    return \"my_user\"\\r\\n\\r\\ndef get_db_password():\\r\\n    return \"my_password\"\\r\\n\\r\\n# Password hashing\\r\\ndef hash_password(password):\\r\\n    return bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt())\\r\\n\\r\\n# Error handling\\r\\n@app.errorhandler(400)\\r\\ndef bad_request(error):\\r\\n    return jsonify({\"error\": \"Bad Request\"}), 400\\r\\n\\r\\n@app.errorhandler(404)\\r\\ndef not_found(error):\\r\\n    return jsonify({\"error\": \"Not Found\"}), 404\\r\\n\\r\\n@app.errorhandler(500)\\r\\ndef internal_error(error):\\r\\n    return jsonify({\"error\": \"Internal Server Error\"}), 500\\r\\n\\r\\n# Route to create a new user (example)\\r\\n@app.route('/register', methods=['POST'])\\r\\ndef register():\\r\\n    try:\\r\\n        data = request.get_json()\\r\\n        username = data['username']\\r\\n        password = data['password']\\r\\n        if not username or not password:\\r\\n            abort(400)\\r\\n\\r\\n        # Prevent SQL Injection by using ORM methods\\r\\n        if User.query.filter_by(username=username).first():\\r\\n            abort(400, description=\"User already exists\")\\r\\n\\r\\n        hashed_password = hash_password(password)\\r\\n        new_user = User(username=username, password_hash=hashed_password)\\r\\n        db.session.add(new_user)\\r\\n        db.session.commit()\\r\\n\\r\\n        return jsonify({\"message\": \"User created successfully\"}), 201\\r\\n\\r\\n    except SQLAlchemyError as e:\\r\\n        db.session.rollback()\\r\\n        abort(500, description=str(e))\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=False)", "CWE": "CWE-798"}
{"text": "Generate Python code for the following: Import the necessary modules. Create a web app. Define a function that returns a database connection. Define a function that returns the server name. Define a function that returns the database name. Define a function that returns the database user. Define a function that returns the database password.", "BP": ["Secure Configuration", "Error Handling", "Password Hashing", "SQL Injection Prevention"], "code": "from flask import Flask\\r\\nimport psycopg2\\r\\nfrom psycopg2.extras import RealDictCursor\\r\\nfrom werkzeug.security import generate_password_hash\\r\\nimport os\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Database configuration\\r\\nDB_SERVER = 'localhost'\\r\\nDB_NAME = 'your_db_name'\\r\\nDB_USER = 'your_db_user'\\r\\nDB_PASSWORD = 'your_db_password'\\r\\n\\r\\n# Secure configuration\\r\\napp.config['SECRET_KEY'] = os.urandom(24)\\r\\n\\r\\ndef get_db_connection():\\r\\n    conn = psycopg2.connect(\\r\\n        host=DB_SERVER,\\r\\n        database=DB_NAME,\\r\\n        user=DB_USER,\\r\\n        password=DB_PASSWORD,\\r\\n        cursor_factory=RealDictCursor\\r\\n    )\\r\\n    return conn\\r\\n\\r\\ndef get_server_name():\\r\\n    return DB_SERVER\\r\\n\\r\\ndef get_database_name():\\r\\n    return DB_NAME\\r\\n\\r\\ndef get_database_user():\\r\\n    return DB_USER\\r\\n\\r\\ndef get_database_password():\\r\\n    return DB_PASSWORD\\r\\n\\r\\n@app.route('/')\\r\\ndef index():\\r\\n    return \"Welcome to the Secure Web App!\"\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-798"}
{"text": "Generate Python code for the following: A function copies a number of bytes from one memory location to another.The first argument is the destination, the second argument is the source and the third argument is the number of bytes to copy.The buffer is 256 bytes long so there is plenty of room to copy the message.", "BP": ["Input Validation", "Secure Memory Copying", "Limiting Buffer Size", "Memory Management"], "code": "import ctypes\\r\\n\\r\\n# Define the maximum buffer size\\r\\nMAX_BUFFER_SIZE = 256\\r\\n\\r\\n# Define a function to securely copy bytes from one memory location to another\\r\\ndef secure_memcpy(dest, src, nbytes):\\r\\n    \"\"\"\\r\\n    Securely copies a number of bytes from one memory location to another.\\r\\n    \\r\\n    Args:\\r\\n        dest (ctypes.c_void_p): A pointer to the destination memory location.\\r\\n        src (ctypes.c_void_p): A pointer to the source memory location.\\r\\n        nbytes (int): The number of bytes to copy.\\r\\n        \\r\\n    Returns:\\r\\n        bool: True if the copy was successful, False otherwise.\\r\\n    \"\"\"\\r\\n    # Validate input\\r\\n    if not isinstance(dest, ctypes.c_void_p) or not isinstance(src, ctypes.c_void_p) or not isinstance(nbytes, int) or nbytes < 0 or nbytes > MAX_BUFFER_SIZE:\\r\\n        return False\\r\\n    \\r\\n    # Use ctypes to perform secure memory copying\\r\\n    ctypes.memmove(dest, src, nbytes)\\r\\n    \\r\\n    return True\\r\\n\\r\\n# Example usage\\r\\nsrc_buffer = ctypes.create_string_buffer(b'Hello, World!')\\r\\ndest_buffer = ctypes.create_string_buffer(MAX_BUFFER_SIZE)\\r\\n\\r\\nif secure_memcpy(dest_buffer, src_buffer, len(src_buffer.value)):\\r\\n    print(f\"Copied bytes: {dest_buffer.value.decode()}\")\\r\\nelse:\\r\\n    print(\"Error copying bytes.\")", "CWE": "CWE-119"}
{"text": "Generate Python code for the following: A function copies a number of bytes from one memory location to another.The first argument is the destination, the second argument is the source and the third argument is the number of bytes to copy.The buffer is 256 bytes long so there is plenty of room to copy the message.", "BP": ["Input Validation", "Secure Memory Copying", "Limiting Buffer Size", "Memory Management"], "code": "def secure_memory_copy(destination: bytearray, source: bytearray, num_bytes: int) -> None:\\r\\n    # Buffer size\\r\\n    BUFFER_SIZE = 256\\r\\n    \\r\\n    # Input validation\\r\\n    if not isinstance(destination, bytearray):\\r\\n        raise TypeError(\"Destination must be a bytearray.\")\\r\\n    if not isinstance(source, bytearray):\\r\\n        raise TypeError(\"Source must be a bytearray.\")\\r\\n    if not isinstance(num_bytes, int):\\r\\n        raise TypeError(\"Number of bytes to copy must be an integer.\")\\r\\n    if num_bytes < 0:\\r\\n        raise ValueError(\"Number of bytes to copy cannot be negative.\")\\r\\n    \\r\\n    # Ensure the buffers are within the limits\\r\\n    if len(destination) > BUFFER_SIZE:\\r\\n        raise ValueError(f\"Destination buffer exceeds the allowed size of {BUFFER_SIZE} bytes.\")\\r\\n    if len(source) > BUFFER_SIZE:\\r\\n        raise ValueError(f\"Source buffer exceeds the allowed size of {BUFFER_SIZE} bytes.\")\\r\\n    \\r\\n    # Limit the number of bytes to copy to the minimum of available bytes\\r\\n    num_bytes = min(num_bytes, len(source), len(destination))\\r\\n    \\r\\n    # Secure memory copying\\r\\n    for i in range(num_bytes):\\r\\n        destination[i] = source[i]\\r\\n\\r\\n# Example usage\\r\\ndestination = bytearray(256)\\r\\nsource = bytearray(b\"Hello, world!\" + b\"\\x00\" * 243)\\r\\nnum_bytes = 13\\r\\n\\r\\ntry:\\r\\n    secure_memory_copy(destination, source, num_bytes)\\r\\n    print(\"Copy successful\")\\r\\n    print(\"Destination buffer:\", destination[:num_bytes])\\r\\nexcept Exception as e:\\r\\n    print(f\"Error: {e}\")", "CWE": "CWE-119"}
{"text": "Generate Python code for the following: A function copies a number of bytes from one memory location to another.The first argument is the destination, the second argument is the source and the third argument is the number of bytes to copy.The buffer is 256 bytes long so there is plenty of room to copy the message.", "BP": ["Input Validation", "Secure Memory Copying", "Limiting Buffer Size", "Memory Management"], "code": "import ctypes\\r\\n\\r\\ndef secure_memory_copy(destination, source, num_bytes):\\r\\n    \"\"\"\\r\\n    Copies a specified number of bytes from one memory location to another.\\r\\n    Performs input validation, secure memory copying, and limits buffer size to 256 bytes.\\r\\n\\r\\n    Args:\\r\\n    destination (ctypes.c_char_p): The pointer to the destination memory location.\\r\\n    source (ctypes.c_char_p): The pointer to the source memory location.\\r\\n    num_bytes (int): The number of bytes to copy.\\r\\n\\r\\n    Returns:\\r\\n    bool: True if the operation was successful, False otherwise.\\r\\n    \"\"\"\\r\\n    # Input Validation\\r\\n    if not isinstance(destination, ctypes.c_char_p) or not isinstance(source, ctypes.c_char_p):\\r\\n        print(\"Error: Destination and source must be ctypes.c_char_p instances.\")\\r\\n        return False\\r\\n    if not isinstance(num_bytes, int) or num_bytes <= 0:\\r\\n        print(\"Error: Number of bytes to copy must be a positive integer.\")\\r\\n        return False\\r\\n\\r\\n    # Limiting Buffer Size\\r\\n    BUFFER_SIZE = 256\\r\\n    if num_bytes > BUFFER_SIZE:\\r\\n        print(f\"Error: Cannot copy more than {BUFFER_SIZE} bytes.\")\\r\\n        return False\\r\\n\\r\\n    # Secure Memory Copying\\r\\n    try:\\r\\n        ctypes.memmove(destination, source, num_bytes)\\r\\n        return True\\r\\n    except Exception as e:\\r\\n        print(f\"Error during memory copy: {e}\")\\r\\n        return False\\r\\n\\r\\n# Example usage\\r\\nif __name__ == \"__main__\":\\r\\n    # Allocate buffers\\r\\n    dest_buffer = (ctypes.c_char * 256)()  # Destination buffer of 256 bytes\\r\\n    src_buffer = (ctypes.c_char * 256)(*b\"Hello, secure world!\")  # Source buffer with initial data\\r\\n\\r\\n    # Convert buffer addresses to ctypes.c_char_p\\r\\n    dest_ptr = ctypes.cast(dest_buffer, ctypes.c_char_p)\\r\\n    src_ptr = ctypes.cast(src_buffer, ctypes.c_char_p)\\r\\n\\r\\n    # Copy 20 bytes from src_buffer to dest_buffer\\r\\n    if secure_memory_copy(dest_ptr, src_ptr, 20):\\r\\n        print(\"Memory copy successful.\")\\r\\n        print(\"Destination buffer contains:\", dest_buffer.value)\\r\\n    else:\\r\\n        print(\"Memory copy failed.\")", "CWE": "CWE-119"}
{"text": "Generate Python code for the following: The memcpy function copies a number of bytes from one memory location to another.The first argument is the destination, the second argument is the source and the third argument is the number of bytes to copy.The strlen function returns the length of a string.The code copies the message to the buffer.", "BP": ["Input Validation", "Boundary Checking", "Destination Buffer Size Checking", "Secure copying", "Error handling", "Separation of Concerns"], "code": "import sys\\r\\n\\r\\n# Define a constant for the maximum buffer size\\r\\nMAX_BUFFER_SIZE = 1024\\r\\n\\r\\ndef secure_strlen(string):\\r\\n    \"\"\"\\r\\n    Safely calculates the length of a string.\\r\\n    \"\"\"\\r\\n    if not isinstance(string, str):\\r\\n        raise TypeError(\"Input must be a string\")\\r\\n    \\r\\n    # Use len() to get the string length\\r\\n    length = len(string)\\r\\n    \\r\\n    return length\\r\\n\\r\\ndef secure_memcpy(dest, src, num_bytes):\\r\\n    \"\"\"\\r\\n    Securely copies bytes from one buffer to another.\\r\\n    \"\"\"\\r\\n    # Check if the input is bytes-like objects\\r\\n    if not isinstance(dest, (bytes, bytearray)) or not isinstance(src, (bytes, bytearray)):\\r\\n        raise TypeError(\"Input buffers must be bytes-like objects\")\\r\\n    \\r\\n    # Validate the number of bytes to copy\\r\\n    if not isinstance(num_bytes, int) or num_bytes < 0:\\r\\n        raise ValueError(\"Number of bytes must be a non-negative integer\")\\r\\n    \\r\\n    # Check if the destination buffer has enough space\\r\\n    dest_len = len(dest)\\r\\n    if dest_len < num_bytes:\\r\\n        raise BufferError(\"Destination buffer is too small\")\\r\\n    \\r\\n    # Copy the bytes from source to destination\\r\\n    for i in range(num_bytes):\\r\\n        try:\\r\\n            dest[i] = src[i]\\r\\n        except IndexError:\\r\\n            # Handle the case where the source buffer is smaller than the specified number of bytes\\r\\n            break\\r\\n    \\r\\n    return dest\\r\\n\\r\\ndef main():\\r\\n    try:\\r\\n        # Get the message from the user\\r\\n        message = input(\"Enter a message: \").encode()\\r\\n        \\r\\n        # Validate the message length\\r\\n        message_len = secure_strlen(message)\\r\\n        if message_len > MAX_BUFFER_SIZE:\\r\\n            print(\"Message is too long. Maximum length is\", MAX_BUFFER_SIZE)\\r\\n            return\\r\\n        \\r\\n        # Create a destination buffer\\r\\n        dest_buffer = bytearray(MAX_BUFFER_SIZE)\\r\\n        \\r\\n        # Copy the message to the destination buffer\\r\\n        secure_memcpy(dest_buffer, message, message_len)\\r\\n        \\r\\n        # Print the copied message\\r\\n        print(\"Copied message:\", dest_buffer[:message_len].decode())\\r\\n        \\r\\n    except (TypeError, ValueError, BufferError) as e:\\r\\n        print(f\"Error: {e}\", file=sys.stderr)\\r\\n    \\r\\n    except Exception as e:\\r\\n        print(f\"Unexpected error: {e}\", file=sys.stderr)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-119"}
{"text": "Generate Python code for the following: The memcpy function copies a number of bytes from one memory location to another.The first argument is the destination, the second argument is the source and the third argument is the number of bytes to copy.The strlen function returns the length of a string.The code copies the message to the buffer.", "BP": ["Input Validation", "Boundary Checking", "Destination Buffer Size Checking", "Secure copying", "Error handling", "Separation of Concerns"], "code": "def strlen(string):\\r\\n    \"\"\"\\r\\n    Calculate the length of a string.\\r\\n    \\r\\n    :param string: Input string\\r\\n    :return: Length of the string\\r\\n    \"\"\"\\r\\n    if not isinstance(string, str):\\r\\n        raise ValueError(\"Input must be a string.\")\\r\\n    \\r\\n    return len(string)\\r\\n\\r\\ndef memcpy(destination, source, num_bytes):\\r\\n    \"\"\"\\r\\n    Copy a number of bytes from the source to the destination.\\r\\n    \\r\\n    :param destination: Destination buffer\\r\\n    :param source: Source buffer\\r\\n    :param num_bytes: Number of bytes to copy\\r\\n    :return: Modified destination buffer\\r\\n    \"\"\"\\r\\n    # Input validation\\r\\n    if not isinstance(destination, bytearray):\\r\\n        raise ValueError(\"Destination must be a bytearray.\")\\r\\n    \\r\\n    if not isinstance(source, (bytes, bytearray)):\\r\\n        raise ValueError(\"Source must be bytes or bytearray.\")\\r\\n    \\r\\n    if not isinstance(num_bytes, int):\\r\\n        raise ValueError(\"Number of bytes to copy must be an integer.\")\\r\\n    \\r\\n    if num_bytes < 0:\\r\\n        raise ValueError(\"Number of bytes to copy cannot be negative.\")\\r\\n    \\r\\n    # Boundary checking\\r\\n    if num_bytes > len(source):\\r\\n        raise ValueError(\"Number of bytes to copy exceeds the source length.\")\\r\\n    \\r\\n    if num_bytes > len(destination):\\r\\n        raise ValueError(\"Number of bytes to copy exceeds the destination buffer size.\")\\r\\n    \\r\\n    # Secure copying\\r\\n    for i in range(num_bytes):\\r\\n        destination[i] = source[i]\\r\\n    \\r\\n    return destination\\r\\n\\r\\ndef main():\\r\\n    try:\\r\\n        message = \"Hello, World!\"\\r\\n        buffer_size = 20\\r\\n        buffer = bytearray(buffer_size)\\r\\n        \\r\\n        # Perform the copy operation\\r\\n        num_bytes_to_copy = strlen(message)\\r\\n        if num_bytes_to_copy > buffer_size:\\r\\n            raise ValueError(\"Buffer size is too small for the message.\")\\r\\n        \\r\\n        memcpy(buffer, message.encode(), num_bytes_to_copy)\\r\\n        print(\"Buffer after memcpy:\", buffer)\\r\\n        \\r\\n    except Exception as e:\\r\\n        print(f\"An error occurred: {e}\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-119"}
{"text": "Generate Python code for the following: The memcpy function copies a number of bytes from one memory location to another.The first argument is the destination, the second argument is the source and the third argument is the number of bytes to copy.The strlen function returns the length of a string.The code copies the message to the buffer.", "BP": ["Input Validation", "Boundary Checking", "Destination Buffer Size Checking", "Secure copying", "Error handling", "Separation of Concerns"], "code": "# Import necessary libraries\\r\\nimport ctypes\\r\\n\\r\\n# Define the function to get the length of a string\\r\\ndef strlen(string):\\r\\n    # Return the length of the string\\r\\n    return len(string)\\r\\n\\r\\n# Define the function to copy memory securely\\r\\ndef memcpy(destination, source, num_bytes):\\r\\n    # Perform input validation\\r\\n    if not isinstance(destination, ctypes.c_char_p) or not isinstance(source, ctypes.c_char_p):\\r\\n        raise ValueError(\"Both destination and source must be of type ctypes.c_char_p.\")\\r\\n    if not isinstance(num_bytes, int) or num_bytes < 0:\\r\\n        raise ValueError(\"Number of bytes to copy must be a non-negative integer.\")\\r\\n    \\r\\n    # Boundary checking and destination buffer size checking\\r\\n    dest_size = ctypes.sizeof(destination)\\r\\n    source_size = ctypes.sizeof(source)\\r\\n    if num_bytes > source_size:\\r\\n        raise ValueError(\"Number of bytes to copy exceeds source size.\")\\r\\n    if num_bytes > dest_size:\\r\\n        raise ValueError(\"Number of bytes to copy exceeds destination size.\")\\r\\n    \\r\\n    # Secure copying\\r\\n    try:\\r\\n        ctypes.memmove(destination, source, num_bytes)\\r\\n    except Exception as e:\\r\\n        # Error handling\\r\\n        raise RuntimeError(f\"Failed to copy memory: {e}\")\\r\\n\\r\\n    return destination\\r\\n\\r\\n# Example usage\\r\\nif __name__ == \"__main__\":\\r\\n    # Prepare source and destination buffers\\r\\n    message = \"Hello, secure world!\"\\r\\n    message_len = strlen(message)\\r\\n    source = ctypes.create_string_buffer(message.encode('utf-8'))\\r\\n    destination = ctypes.create_string_buffer(message_len + 1)  # +1 for null terminator\\r\\n\\r\\n    # Perform secure memory copy\\r\\n    try:\\r\\n        memcpy(destination, source, message_len)\\r\\n        print(f\"Message copied to buffer: {destination.value.decode('utf-8')}\")\\r\\n    except Exception as e:\\r\\n        print(f\"Error: {e}\")", "CWE": "CWE-119"}
{"text": "Generate Python code for the following: The memcpy function copies a number of bytes from one memory location to another.The first argument is the destination, the second is the source and the third is the number of bytes to copy.The strlen function returns the length of a string.The code copies the string \"Hello\" to the buffer.", "BP": ["Input Validation", "Clearing Destination Buffer", "Secure String Length Calculation"], "code": "import ctypes\\r\\n\\r\\ndef memcpy(dest, src, n):\\r\\n    \"\"\"\\r\\n    Secure implementation of the memcpy function.\\r\\n    Copies n bytes from src to dest.\\r\\n\\r\\n    Args:\\r\\n        dest (memoryview): The destination buffer.\\r\\n        src (bytes): The source bytes to copy.\\r\\n        n (int): The number of bytes to copy.\\r\\n\\r\\n    Returns:\\r\\n        memoryview: The destination buffer with the copied bytes.\\r\\n    \"\"\"\\r\\n    # Validate inputs\\r\\n    if not isinstance(dest, memoryview):\\r\\n        raise ValueError(\"dest must be a memoryview object\")\\r\\n    if not isinstance(src, bytes):\\r\\n        raise ValueError(\"src must be a bytes object\")\\r\\n    if n < 0:\\r\\n        raise ValueError(\"n cannot be negative\")\\r\\n    if n > len(dest):\\r\\n        raise ValueError(\"n is larger than the destination buffer size\")\\r\\n\\r\\n    # Clear the destination buffer\\r\\n    ctypes.memset(dest.cbytes, 0, dest.nbytes)\\r\\n\\r\\n    # Copy the bytes\\r\\n    dest[:n] = src[:n]\\r\\n\\r\\n    return dest\\r\\n\\r\\ndef strlen(string):\\r\\n    \"\"\"\\r\\n    Secure implementation of the strlen function.\\r\\n    Returns the length of the given string.\\r\\n\\r\\n    Args:\\r\\n        string (bytes or str): The input string.\\r\\n\\r\\n    Returns:\\r\\n        int: The length of the string.\\r\\n    \"\"\"\\r\\n    # Validate input\\r\\n    if not isinstance(string, (bytes, str)):\\r\\n        raise ValueError(\"Input must be a bytes or str object\")\\r\\n\\r\\n    # Convert to bytes if necessary\\r\\n    if isinstance(string, str):\\r\\n        string = string.encode()\\r\\n\\r\\n    # Calculate the length\\r\\n    length = 0\\r\\n    for byte in string:\\r\\n        if byte == 0:\\r\\n            break\\r\\n        length += 1\\r\\n\\r\\n    return length\\r\\n\\r\\n# Example usage\\r\\nbuffer = memoryview(bytearray(10))\\r\\nsource_string = b\"Hello\"\\r\\nmemcpy(buffer, source_string, strlen(source_string))\\r\\nprint(buffer.tobytes())  # Output: b'Hello\\x00\\x00\\x00\\x00\\x00'", "CWE": "CWE-119"}
{"text": "Generate Python code for the following: The memcpy function copies a number of bytes from one memory location to another.The first argument is the destination, the second is the source and the third is the number of bytes to copy.The strlen function returns the length of a string.The code copies the string \"Hello\" to the buffer.", "BP": ["Input Validation", "Clearing Destination Buffer", "Secure String Length Calculation"], "code": "def memcpy(dest, src, num_bytes):\\r\\n    \"\"\"\\r\\n    Copy num_bytes from src to dest.\\r\\n    \\r\\n    Parameters:\\r\\n    dest (bytearray): The destination buffer.\\r\\n    src (bytearray): The source buffer.\\r\\n    num_bytes (int): Number of bytes to copy.\\r\\n    \"\"\"\\r\\n    # Input Validation\\r\\n    if not isinstance(dest, bytearray):\\r\\n        raise ValueError(\"Destination must be a bytearray\")\\r\\n    if not isinstance(src, (bytes, bytearray)):\\r\\n        raise ValueError(\"Source must be bytes or bytearray\")\\r\\n    if not isinstance(num_bytes, int) or num_bytes < 0:\\r\\n        raise ValueError(\"Number of bytes must be a non-negative integer\")\\r\\n    if num_bytes > len(src):\\r\\n        raise ValueError(\"Number of bytes to copy exceeds source length\")\\r\\n    if num_bytes > len(dest):\\r\\n        raise ValueError(\"Number of bytes to copy exceeds destination length\")\\r\\n\\r\\n    # Clear Destination Buffer\\r\\n    dest[:num_bytes] = b'\\x00' * num_bytes\\r\\n\\r\\n    # Copy bytes from src to dest\\r\\n    for i in range(num_bytes):\\r\\n        dest[i] = src[i]\\r\\n\\r\\ndef strlen(s):\\r\\n    \"\"\"\\r\\n    Calculate the length of a string in a secure manner.\\r\\n    \\r\\n    Parameters:\\r\\n    s (str): The input string.\\r\\n    \\r\\n    Returns:\\r\\n    int: The length of the string.\\r\\n    \"\"\"\\r\\n    # Input Validation\\r\\n    if not isinstance(s, str):\\r\\n        raise ValueError(\"Input must be a string\")\\r\\n    \\r\\n    # Secure Length Calculation\\r\\n    length = 0\\r\\n    for char in s:\\r\\n        length += 1\\r\\n    \\r\\n    return length\\r\\n\\r\\n# Example usage\\r\\nsrc_string = \"Hello\"\\r\\nsrc_bytes = bytearray(src_string, 'utf-8')\\r\\ndest_buffer = bytearray(len(src_bytes))\\r\\n\\r\\n# Securely calculate length of the source string\\r\\nlength_of_src = strlen(src_string)\\r\\n\\r\\n# Copy the string to the buffer\\r\\nmemcpy(dest_buffer, src_bytes, length_of_src)\\r\\n\\r\\n# Verify the copy\\r\\nprint(\"Source String:\", src_string)\\r\\nprint(\"Destination Buffer:\", dest_buffer.decode('utf-8'))", "CWE": "CWE-119"}
{"text": "Generate Python code for the following: The memcpy function copies a number of bytes from one memory location to another.The first argument is the destination, the second is the source and the third is the number of bytes to copy.The strlen function returns the length of a string.The code copies the string \"Hello\" to the buffer.", "BP": ["Input Validation", "Clearing Destination Buffer", "Secure String Length Calculation"], "code": "# Import necessary libraries\\r\\nimport ctypes\\r\\nimport sys\\r\\n\\r\\n# Define the memcpy function\\r\\ndef memcpy(dest, src, count):\\r\\n    \"\"\"\\r\\n    Copies a specified number of bytes from the source memory to the destination memory.\\r\\n    Args:\\r\\n    - dest: Destination memory address.\\r\\n    - src: Source memory address.\\r\\n    - count: Number of bytes to copy.\\r\\n    \"\"\"\\r\\n    # Input validation\\r\\n    if not isinstance(count, int) or count < 0:\\r\\n        raise ValueError(\"Count must be a non-negative integer\")\\r\\n    if not dest or not src:\\r\\n        raise ValueError(\"Source and destination cannot be None\")\\r\\n\\r\\n    # Clearing destination buffer\\r\\n    # Assuming dest is a ctypes object, we clear it by setting all bytes to zero\\r\\n    ctypes.memset(dest, 0, count)\\r\\n\\r\\n    # Secure string length calculation to avoid buffer overflow\\r\\n    # Ensure we do not copy more than the destination can hold\\r\\n    actual_count = min(len(src), count)\\r\\n    \\r\\n    # Perform the memory copy\\r\\n    ctypes.memmove(dest, src, actual_count)\\r\\n\\r\\n# Example usage\\r\\nif __name__ == \"__main__\":\\r\\n    # Define the source string\\r\\n    src_string = \"Hello\"\\r\\n    \\r\\n    # Calculate the length of the string securely\\r\\n    src_len = len(src_string) + 1  # +1 for the null terminator\\r\\n    \\r\\n    # Create a buffer for the destination\\r\\n    dest_buffer = ctypes.create_string_buffer(src_len)\\r\\n    \\r\\n    # Convert the source string to a ctypes object\\r\\n    src_buffer = ctypes.create_string_buffer(src_string.encode('utf-8'), src_len)\\r\\n    \\r\\n    # Perform the copy\\r\\n    try:\\r\\n        memcpy(dest_buffer, src_buffer, src_len)\\r\\n        print(\"Copy successful. Destination buffer contains:\", dest_buffer.value.decode('utf-8'))\\r\\n    except ValueError as e:\\r\\n        print(\"Error:\", e)\\r\\n        sys.exit(1)", "CWE": "CWE-119"}
{"text": "Generate Python code for the following: The user is prompted to enter an index of a vehicle.The user enters an index.The index is converted to an integer.The integer is used to access the array of vehicles.The vehicle at the index is printed.", "BP": ["Input Validation", "Error Handling", "Separation of Concerns"], "code": "# Define the list of vehicles\\r\\nVEHICLES = ['Car', 'Truck', 'Motorcycle', 'Bicycle']\\r\\n\\r\\ndef get_valid_index() -> int:\\r\\n    \"\"\"\\r\\n    Prompts the user to enter a valid index for the vehicles list and returns the valid index.\\r\\n    \"\"\"\\r\\n    while True:\\r\\n        try:\\r\\n            index = int(input(\"Enter the index of a vehicle (0-{}): \".format(len(VEHICLES) - 1)))\\r\\n            if index < 0 or index >= len(VEHICLES):\\r\\n                raise ValueError(\"Index out of range\")\\r\\n            return index\\r\\n        except ValueError as e:\\r\\n            print(\"Invalid input:\", e)\\r\\n\\r\\ndef get_vehicle_by_index(index: int) -> str:\\r\\n    \"\"\"\\r\\n    Returns the vehicle at the given index from the vehicles list.\\r\\n    \"\"\"\\r\\n    return VEHICLES[index]\\r\\n\\r\\ndef main():\\r\\n    \"\"\"\\r\\n    Main function to get the index from the user, retrieve the vehicle, and print it.\\r\\n    \"\"\"\\r\\n    try:\\r\\n        index = get_valid_index()\\r\\n        vehicle = get_vehicle_by_index(index)\\r\\n        print(\"Vehicle at index {}: {}\".format(index, vehicle))\\r\\n    except IndexError:\\r\\n        print(\"Index out of range\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-119"}
{"text": "Generate Python code for the following: The user is prompted to enter an index of a vehicle.The user enters an index.The index is converted to an integer.The integer is used to access the array of vehicles.The vehicle at the index is printed.", "BP": ["Input Validation", "Error Handling", "Separation of Concerns"], "code": "def get_vehicle_index():\\r\\n    \"\"\"\\r\\n    Prompts the user to enter an index and returns the index as an integer.\\r\\n    Includes input validation to ensure the entered value is a valid integer.\\r\\n    \"\"\"\\r\\n    while True:\\r\\n        try:\\r\\n            index = int(input(\"Enter the index of the vehicle: \"))\\r\\n            return index\\r\\n        except ValueError:\\r\\n            print(\"Invalid input. Please enter a valid integer.\")\\r\\n\\r\\ndef print_vehicle_at_index(vehicles, index):\\r\\n    \"\"\"\\r\\n    Prints the vehicle at the given index if the index is valid.\\r\\n    Includes error handling to ensure the index is within the bounds of the list.\\r\\n    \"\"\"\\r\\n    try:\\r\\n        vehicle = vehicles[index]\\r\\n        print(f\"Vehicle at index {index}: {vehicle}\")\\r\\n    except IndexError:\\r\\n        print(\"Index out of range. Please enter a valid index.\")\\r\\n\\r\\ndef main():\\r\\n    \"\"\"\\r\\n    Main function that orchestrates the user input and printing of the vehicle.\\r\\n    \"\"\"\\r\\n    vehicles = ['Car', 'Bike', 'Truck', 'Boat', 'Plane']  # Example vehicle list\\r\\n    index = get_vehicle_index()\\r\\n    print_vehicle_at_index(vehicles, index)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-119"}
{"text": "Generate Python code for the following: The user is prompted to enter an index of a vehicle.The user enters an index.The index is converted to an integer.The integer is used to access the array of vehicles.The vehicle at the index is printed.", "BP": ["Input Validation", "Error Handling", "Separation of Concerns"], "code": "# Define a function to prompt the user for an index and return the selected vehicle\\r\\ndef get_vehicle_by_index(vehicles):\\r\\n    while True:\\r\\n        try:\\r\\n            # Prompt the user for an index\\r\\n            index_input = input(\"Please enter the index of the vehicle you want to access: \")\\r\\n            # Convert the input to an integer\\r\\n            index = int(index_input)\\r\\n            # Access the vehicle at the given index\\r\\n            vehicle = vehicles[index]\\r\\n            return vehicle\\r\\n        except ValueError:\\r\\n            # Handle non-integer inputs\\r\\n            print(\"Error: Please enter a valid integer.\")\\r\\n        except IndexError:\\r\\n            # Handle out-of-range inputs\\r\\n            print(f\"Error: Please enter an index between 0 and {len(vehicles) - 1}.\")\\r\\n\\r\\n# Main function to drive the program\\r\\ndef main():\\r\\n    # Example array of vehicles\\r\\n    vehicles = [\"Car\", \"Truck\", \"Bicycle\", \"Motorcycle\", \"Bus\"]\\r\\n    \\r\\n    # Get the selected vehicle\\r\\n    selected_vehicle = get_vehicle_by_index(vehicles)\\r\\n    \\r\\n    # Print the selected vehicle\\r\\n    print(f\"The selected vehicle is: {selected_vehicle}\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-119"}
{"text": "Generate Python code for the following: The code takes in a command line argument and converts it to an integer.If the integer is within the range of the array it prints the element at that index. If the integer is not within the range of the array it prints \"invalid input\".", "BP": ["Input Validation", "Error Handling", "Limiting Access", "Memory Cleanup"], "code": "import sys\\r\\nimport os\\r\\n\\r\\n# Define a function to validate and sanitize user input\\r\\ndef validate_input(user_input):\\r\\n    try:\\r\\n        # Convert the input to an integer\\r\\n        user_input_int = int(user_input)\\r\\n        \\r\\n        # Check if the input is within the valid range\\r\\n        if 0 <= user_input_int < len(arr):\\r\\n            return user_input_int\\r\\n        else:\\r\\n            print(\"Invalid input: Index out of range\")\\r\\n            return None\\r\\n    except ValueError:\\r\\n        print(\"Invalid input: Non-numeric input\")\\r\\n        return None\\r\\n\\r\\n# Define the array\\r\\narr = [1, 2, 3, 4, 5]\\r\\n\\r\\n# Check if the command line argument is provided\\r\\nif len(sys.argv) != 2:\\r\\n    print(\"Usage: python script.py <index>\")\\r\\n    sys.exit(1)\\r\\n\\r\\n# Get the command line argument and validate it\\r\\nuser_input = sys.argv[1]\\r\\nvalidated_input = validate_input(user_input)\\r\\n\\r\\n# Process the validated input\\r\\nif validated_input is not None:\\r\\n    print(f\"Element at index {validated_input}: {arr[validated_input]}\")\\r\\nelse:\\r\\n    print(\"Invalid input\")\\r\\n\\r\\n# Clear sensitive data from memory\\r\\nos.system('sync && sudo sh -c \"sync; echo 3 > /proc/sys/vm/drop_caches\"')", "CWE": "CWE-119"}
{"text": "Generate Python code for the following: The code takes in a command line argument and converts it to an integer.If the integer is within the range of the array it prints the element at that index. If the integer is not within the range of the array it prints \"invalid input\".", "BP": ["Input Validation", "Error Handling", "Limiting Access", "Memory Cleanup"], "code": "import argparse\\r\\n\\r\\ndef main():\\r\\n    # Define the array\\r\\n    array = [10, 20, 30, 40, 50]\\r\\n    \\r\\n    # Create the parser\\r\\n    parser = argparse.ArgumentParser(description=\"Access an array element by index.\")\\r\\n    \\r\\n    # Add an argument\\r\\n    parser.add_argument(\"index\", help=\"Index of the array element to be accessed\", type=str)\\r\\n    \\r\\n    # Parse the argument\\r\\n    args = parser.parse_args()\\r\\n    \\r\\n    try:\\r\\n        # Convert argument to integer\\r\\n        index = int(args.index)\\r\\n        \\r\\n        # Check if index is within range\\r\\n        if 0 <= index < len(array):\\r\\n            print(array[index])\\r\\n        else:\\r\\n            print(\"invalid input\")\\r\\n    \\r\\n    except ValueError:\\r\\n        print(\"invalid input\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-119"}
{"text": "Generate Python code for the following: The code takes in a command line argument and converts it to an integer.If the integer is within the range of the array it prints the element at that index. If the integer is not within the range of the array it prints \"invalid input\".", "BP": ["Input Validation", "Error Handling", "Limiting Access", "Memory Cleanup"], "code": "import sys\\r\\n\\r\\ndef main():\\r\\n    # Define a sample array for demonstration\\r\\n    sample_array = [10, 20, 30, 40, 50]\\r\\n\\r\\n    # Step 1: Input Validation\\r\\n    if len(sys.argv) != 2:\\r\\n        print(\"Usage: python script.py <index>\")\\r\\n        sys.exit(1)  # Exit the program indicating error\\r\\n\\r\\n    try:\\r\\n        # Step 2: Convert command line argument to integer\\r\\n        index = int(sys.argv[1])\\r\\n    except ValueError:\\r\\n        print(\"Invalid input: Please enter a valid integer.\")\\r\\n        sys.exit(1)  # Exit the program indicating error\\r\\n\\r\\n    # Step 3: Limiting Access - Check if the integer is within the range of the array\\r\\n    if 0 <= index < len(sample_array):\\r\\n        # If within range, print the element at that index\\r\\n        print(sample_array[index])\\r\\n    else:\\r\\n        # If not within range, print \"invalid input\"\\r\\n        print(\"Invalid input: Index out of range.\")\\r\\n\\r\\n    # Note: Python automatically handles memory cleanup for you, so there's no need for explicit memory cleanup in this simple script.\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-119"}
{"text": "Generate Python code for the following: The code creates an array of strings called vehicles. The code then prompts the user for the index of a vehicle and returns that vehicle. The code then loops through the array and prints out each vehicle.", "BP": ["Input Validation", "Exception Handling", "Safe Exit", "Secure Data Storage", "Secure Output"], "code": "import os\\r\\nimport hashlib\\r\\nfrom cryptography.fernet import Fernet\\r\\n\\r\\n# Secure data storage\\r\\ndef encrypt_data(data):\\r\\n    key = os.environ.get('ENCRYPTION_KEY', Fernet.generate_key())\\r\\n    cipher_suite = Fernet(key)\\r\\n    encrypted_data = cipher_suite.encrypt(data.encode())\\r\\n    return encrypted_data\\r\\n\\r\\ndef decrypt_data(encrypted_data):\\r\\n    key = os.environ.get('ENCRYPTION_KEY')\\r\\n    cipher_suite = Fernet(key)\\r\\n    decrypted_data = cipher_suite.decrypt(encrypted_data).decode()\\r\\n    return decrypted_data\\r\\n\\r\\n# Secure output\\r\\ndef secure_print(output):\\r\\n    import re\\r\\n    sanitized_output = re.sub(r'[<>]', '', output)\\r\\n    print(sanitized_output)\\r\\n\\r\\n# Input validation\\r\\ndef validate_index(index, length):\\r\\n    try:\\r\\n        index = int(index)\\r\\n        if index >= 0 and index < length:\\r\\n            return True\\r\\n        else:\\r\\n            return False\\r\\n    except ValueError:\\r\\n        return False\\r\\n\\r\\n# Safe exit\\r\\ndef safe_exit():\\r\\n    try:\\r\\n        exit(0)\\r\\n    except SystemExit:\\r\\n        pass\\r\\n\\r\\n# Main program\\r\\nvehicles = ['Car', 'Bike', 'Truck', 'Bus', 'Train']\\r\\nencrypted_vehicles = [encrypt_data(vehicle) for vehicle in vehicles]\\r\\n\\r\\nwhile True:\\r\\n    try:\\r\\n        index = input(\"Enter the index of a vehicle (or 'q' to quit): \")\\r\\n        if index.lower() == 'q':\\r\\n            safe_exit()\\r\\n            break\\r\\n\\r\\n        if validate_index(index, len(encrypted_vehicles)):\\r\\n            vehicle = decrypt_data(encrypted_vehicles[int(index)])\\r\\n            secure_print(f\"The vehicle at index {index} is: {vehicle}\")\\r\\n        else:\\r\\n            secure_print(\"Invalid index. Please try again.\")\\r\\n\\r\\n        secure_print(\"All vehicles:\")\\r\\n        for encrypted_vehicle in encrypted_vehicles:\\r\\n            vehicle = decrypt_data(encrypted_vehicle)\\r\\n            secure_print(vehicle)\\r\\n\\r\\n    except Exception as e:\\r\\n        secure_print(f\"An error occurred: {e}\")", "CWE": "CWE-119"}
{"text": "Generate Python code for the following: The code creates an array of strings called vehicles. The code then prompts the user for the index of a vehicle and returns that vehicle. The code then loops through the array and prints out each vehicle.", "BP": ["Input Validation", "Exception Handling", "Safe Exit", "Secure Data Storage", "Secure Output"], "code": "import json\\r\\nimport os\\r\\nimport sys\\r\\n\\r\\ndef main():\\r\\n    # Array of vehicles\\r\\n    vehicles = [\"Car\", \"Bike\", \"Truck\", \"Bus\", \"Motorcycle\"]\\r\\n\\r\\n    while True:\\r\\n        try:\\r\\n            # Prompt the user for the index of a vehicle\\r\\n            index = input(\"Enter the index of the vehicle you want to retrieve (0 to {}): \".format(len(vehicles) - 1))\\r\\n            \\r\\n            # Validate if the input is an integer\\r\\n            if not index.isdigit():\\r\\n                raise ValueError(\"The index must be a valid integer.\")\\r\\n            \\r\\n            index = int(index)\\r\\n            \\r\\n            # Validate if the index is within the range\\r\\n            if index < 0 or index >= len(vehicles):\\r\\n                raise IndexError(\"Index out of range. Please enter a number between 0 and {}.\".format(len(vehicles) - 1))\\r\\n            \\r\\n            # Secure output of the selected vehicle\\r\\n            selected_vehicle = vehicles[index]\\r\\n            print(\"The vehicle at index {} is: {}\".format(index, selected_vehicle))\\r\\n\\r\\n            # Loop through the array and print each vehicle\\r\\n            print(\"\\nList of all vehicles:\")\\r\\n            for i, vehicle in enumerate(vehicles):\\r\\n                print(\"Index {}: {}\".format(i, vehicle))\\r\\n\\r\\n        except ValueError as ve:\\r\\n            print(\"Value Error:\", ve)\\r\\n        except IndexError as ie:\\r\\n            print(\"Index Error:\", ie)\\r\\n        except Exception as e:\\r\\n            print(\"An unexpected error occurred:\", e)\\r\\n        finally:\\r\\n            # Ask user if they want to exit or continue\\r\\n            continue_choice = input(\"\\nDo you want to exit? (yes/no): \").strip().lower()\\r\\n            if continue_choice == 'yes':\\r\\n                print(\"Exiting the program. Goodbye!\")\\r\\n                sys.exit(0)\\r\\n\\r\\ndef save_secure_data(data, filename):\\r\\n    try:\\r\\n        # Ensure secure data storage by writing to a file securely\\r\\n        with open(filename, 'w') as file:\\r\\n            json.dump(data, file)\\r\\n    except IOError as e:\\r\\n        print(\"An error occurred while writing to file:\", e)\\r\\n\\r\\ndef load_secure_data(filename):\\r\\n    try:\\r\\n        # Ensure secure data storage by reading from a file securely\\r\\n        if os.path.exists(filename):\\r\\n            with open(filename, 'r') as file:\\r\\n                data = json.load(file)\\r\\n                return data\\r\\n        else:\\r\\n            return []\\r\\n    except IOError as e:\\r\\n        print(\"An error occurred while reading from file:\", e)\\r\\n        return []\\r\\n    except json.JSONDecodeError as e:\\r\\n        print(\"Error decoding JSON from file:\", e)\\r\\n        return []\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-119"}
{"text": "Generate Python code for the following: The code creates an array of strings called vehicles. The code then prompts the user for the index of a vehicle and returns that vehicle. The code then loops through the array and prints out each vehicle.", "BP": ["Input Validation", "Exception Handling", "Safe Exit", "Secure Data Storage", "Secure Output"], "code": "import json\\r\\nimport os\\r\\nimport sys\\r\\n\\r\\n# Secure data storage\\r\\ndef save_secure_data(data, filename=\"vehicles.json\"):\\r\\n    try:\\r\\n        with open(filename, 'w') as file:\\r\\n            json.dump(data, file)\\r\\n    except IOError as e:\\r\\n        print(f\"An error occurred while writing to file: {e}\")\\r\\n\\r\\ndef load_secure_data(filename=\"vehicles.json\"):\\r\\n    try:\\r\\n        if os.path.exists(filename):\\r\\n            with open(filename, 'r') as file:\\r\\n                data = json.load(file)\\r\\n                return data\\r\\n        else:\\r\\n            return []\\r\\n    except IOError as e:\\r\\n        print(f\"An error occurred while reading from file: {e}\")\\r\\n        return []\\r\\n    except json.JSONDecodeError as e:\\r\\n        print(f\"Error decoding JSON from file: {e}\")\\r\\n        return []\\r\\n\\r\\n# Secure output\\r\\ndef secure_print(output):\\r\\n    print(output.replace(\"<\", \"\").replace(\">\", \"\"))\\r\\n\\r\\n# Input validation\\r\\ndef validate_index(index, length):\\r\\n    try:\\r\\n        index = int(index)\\r\\n        if 0 <= index < length:\\r\\n            return True\\r\\n    except ValueError:\\r\\n        pass\\r\\n    return False\\r\\n\\r\\n# Safe exit\\r\\ndef safe_exit():\\r\\n    print(\"Exiting the program. Goodbye!\")\\r\\n    sys.exit(0)\\r\\n\\r\\ndef main():\\r\\n    vehicles = load_secure_data()\\r\\n    if not vehicles:\\r\\n        vehicles = [\"Car\", \"Bike\", \"Truck\", \"Bus\", \"Motorcycle\"]\\r\\n        save_secure_data(vehicles)\\r\\n\\r\\n    while True:\\r\\n        try:\\r\\n            index = input(\"Enter the index of the vehicle you want to retrieve (or 'q' to quit): \")\\r\\n            if index.lower() == 'q':\\r\\n                safe_exit()\\r\\n\\r\\n            if not validate_index(index, len(vehicles)):\\r\\n                raise ValueError(\"Index must be a valid integer within the range of available vehicles.\")\\r\\n\\r\\n            index = int(index)\\r\\n            selected_vehicle = vehicles[index]\\r\\n            secure_print(f\"The vehicle at index {index} is: {selected_vehicle}\")\\r\\n\\r\\n            secure_print(\"\\nList of all vehicles:\")\\r\\n            for i, vehicle in enumerate(vehicles):\\r\\n                secure_print(f\"Index {i}: {vehicle}\")\\r\\n\\r\\n        except ValueError as ve:\\r\\n            secure_print(f\"Value Error: {ve}\")\\r\\n        except IndexError:\\r\\n            secure_print(\"Index Error: Index out of range.\")\\r\\n        except Exception as e:\\r\\n            secure_print(f\"An unexpected error occurred: {e}\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-119"}
{"text": "Generate Python code for the following: atoi() is a function that converts a string to an integer. Command line arguments at index 1 is the second argument passed to the program. Command line argument at index INDEX is the argument at the INDEX specified by the second argument. print function prints the string at INDEX position in the command line arguments to the screen. return 0. exit the program.", "BP": ["Input Validation", "Input Sanitization", "Error Handling", "Separation of Concerns"], "code": "import sys\\r\\nimport re\\r\\n\\r\\ndef is_valid_integer(value):\\r\\n    try:\\r\\n        int(value)\\r\\n        return True\\r\\n    except ValueError:\\r\\n        return False\\r\\n\\r\\ndef sanitize_input(value):\\r\\n    # Remove leading/trailing whitespace\\r\\n    value = value.strip()\\r\\n    \\r\\n    # Remove non-numeric characters\\r\\n    sanitized_value = re.sub(r'[^0-9]', '', value)\\r\\n    \\r\\n    return sanitized_value\\r\\n\\r\\ndef atoi(string):\\r\\n    if not string:\\r\\n        return 0\\r\\n    \\r\\n    sanitized_string = sanitize_input(string)\\r\\n    \\r\\n    if not sanitized_string:\\r\\n        return 0\\r\\n    \\r\\n    if not is_valid_integer(sanitized_string):\\r\\n        return 0\\r\\n    \\r\\n    return int(sanitized_string)\\r\\n\\r\\ndef print_argument(args, index):\\r\\n    if index < 1 or index >= len(args):\\r\\n        print(\"Invalid index\")\\r\\n        return\\r\\n    \\r\\n    print(args[index])\\r\\n\\r\\ndef main():\\r\\n    if len(sys.argv) < 3:\\r\\n        print(\"Usage: python script.py <index> [arguments...]\")\\r\\n        return 1\\r\\n    \\r\\n    index_str = sys.argv[1]\\r\\n    sanitized_index = sanitize_input(index_str)\\r\\n    \\r\\n    if not is_valid_integer(sanitized_index):\\r\\n        print(\"Invalid index\")\\r\\n        return 1\\r\\n    \\r\\n    index = int(sanitized_index)\\r\\n    \\r\\n    print_argument(sys.argv[2:], index)\\r\\n    \\r\\n    return 0\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    sys.exit(main())", "CWE": "CWE-119"}
{"text": "Generate Python code for the following: atoi() is a function that converts a string to an integer. Command line arguments at index 1 is the second argument passed to the program. Command line argument at index INDEX is the argument at the INDEX specified by the second argument. print function prints the string at INDEX position in the command line arguments to the screen. return 0. exit the program.", "BP": ["Input Validation", "Input Sanitization", "Error Handling", "Separation of Concerns"], "code": "import sys\\r\\n\\r\\ndef atoi(s):\\r\\n    \"\"\"\\r\\n    Converts a string to an integer.\\r\\n    Raises ValueError if the string is not a valid integer.\\r\\n    \"\"\"\\r\\n    try:\\r\\n        return int(s)\\r\\n    except ValueError:\\r\\n        raise ValueError(f\"Invalid integer value: '{s}'\")\\r\\n\\r\\ndef get_argument(index, arguments):\\r\\n    \"\"\"\\r\\n    Returns the argument at the specified index from the command line arguments.\\r\\n    Raises IndexError if the index is out of range.\\r\\n    \"\"\"\\r\\n    try:\\r\\n        return arguments[index]\\r\\n    except IndexError:\\r\\n        raise IndexError(f\"Argument index {index} is out of range\")\\r\\n\\r\\ndef main():\\r\\n    # Ensure there are enough command line arguments\\r\\n    if len(sys.argv) < 3:\\r\\n        print(\"Usage: python script.py <index>\")\\r\\n        return 1\\r\\n\\r\\n    try:\\r\\n        # Convert the second argument to an integer index\\r\\n        index = atoi(sys.argv[1])\\r\\n\\r\\n        # Get the argument at the specified index\\r\\n        argument = get_argument(index, sys.argv)\\r\\n\\r\\n        # Print the argument\\r\\n        print(argument)\\r\\n        return 0\\r\\n\\r\\n    except ValueError as ve:\\r\\n        print(ve)\\r\\n        return 1\\r\\n    except IndexError as ie:\\r\\n        print(ie)\\r\\n        return 1\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    sys.exit(main())", "CWE": "CWE-119"}
{"text": "Generate Python code for the following: atoi() is a function that converts a string to an integer. Command line arguments at index 1 is the second argument passed to the program. Command line argument at index INDEX is the argument at the INDEX specified by the second argument. print function prints the string at INDEX position in the command line arguments to the screen. return 0. exit the program.", "BP": ["Input Validation", "Input Sanitization", "Error Handling", "Separation of Concerns"], "code": "import sys\\r\\n\\r\\ndef atoi(s):\\r\\n    try:\\r\\n        return int(s)\\r\\n    except ValueError:\\r\\n        print(\"Error: Provided argument is not an integer.\")\\r\\n        sys.exit(1)\\r\\n\\r\\ndef get_command_line_argument(index):\\r\\n    # Ensure index is within the range of command line arguments\\r\\n    if index < 0 or index >= len(sys.argv):\\r\\n        print(f\"Error: Index {index} is out of range.\")\\r\\n        sys.exit(1)\\r\\n    return sys.argv[index]\\r\\n\\r\\ndef main():\\r\\n    if len(sys.argv) < 3:\\r\\n        print(\"Usage: python script.py <index> <value>\")\\r\\n        sys.exit(1)\\r\\n    \\r\\n    # Convert the second command line argument to an integer index\\r\\n    index = atoi(sys.argv[1])\\r\\n    \\r\\n    # Get the command line argument at the specified index\\r\\n    argument = get_command_line_argument(index)\\r\\n    \\r\\n    # Print the argument\\r\\n    print(argument)\\r\\n    \\r\\n    return 0\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    sys.exit(main())", "CWE": "CWE-119"}
{"text": "Generate Python code for the following: atoi() converts a string to an integer. argc is the number of arguments passed to the program. Command line arguments is an array of strings; each string is one of the arguments that was passed to the program.The first argument is always the name of the program so if the user ran ./a.out foo bar baz; argc would be 4; argv[0] would be ./a.out argv.", "BP": ["Input Validation", "Input Sanitization", "Error Handling"], "code": "import sys\\r\\nimport re\\r\\n\\r\\ndef atoi(string):\\r\\n    \"\"\"\\r\\n    Converts a string to an integer.\\r\\n    Performs input validation and sanitization to prevent potential vulnerabilities.\\r\\n    \"\"\"\\r\\n    # Remove leading and trailing whitespaces\\r\\n    string = string.strip()\\r\\n\\r\\n    # Validate the input string\\r\\n    if not string:\\r\\n        raise ValueError(\"Input string cannot be empty.\")\\r\\n    elif not re.match(r'^[-+]?\\d+$', string):\\r\\n        raise ValueError(\"Input string must be a valid integer.\")\\r\\n\\r\\n    # Convert the string to an integer\\r\\n    try:\\r\\n        return int(string)\\r\\n    except ValueError:\\r\\n        raise ValueError(\"Unable to convert input string to integer.\")\\r\\n\\r\\ndef main():\\r\\n    \"\"\"\\r\\n    Main function to handle command line arguments and call the atoi() function.\\r\\n    \"\"\"\\r\\n    argc = len(sys.argv)\\r\\n    argv = sys.argv\\r\\n\\r\\n    # Check if the program was executed with at least one argument\\r\\n    if argc < 2:\\r\\n        print(\"Usage: python program.py <integer_string>\")\\r\\n        sys.exit(1)\\r\\n\\r\\n    # Iterate over the command line arguments (except the program name)\\r\\n    for arg in argv[1:]:\\r\\n        try:\\r\\n            result = atoi(arg)\\r\\n            print(f\"Converted '{arg}' to integer: {result}\")\\r\\n        except ValueError as e:\\r\\n            print(f\"Error: {e}\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-119"}
{"text": "Generate Python code for the following: atoi() converts a string to an integer. argc is the number of arguments passed to the program. Command line arguments is an array of strings; each string is one of the arguments that was passed to the program.The first argument is always the name of the program so if the user ran ./a.out foo bar baz; argc would be 4; argv[0] would be ./a.out argv.", "BP": ["Input Validation", "Input Sanitization", "Error Handling"], "code": "import sys\\r\\n\\r\\ndef atoi(s):\\r\\n    \"\"\"\\r\\n    Converts a string to an integer.\\r\\n    \"\"\"\\r\\n    try:\\r\\n        return int(s)\\r\\n    except ValueError:\\r\\n        raise ValueError(f\"Invalid integer value: '{s}'\")\\r\\n\\r\\ndef main(argv):\\r\\n    \"\"\"\\r\\n    Main function to handle command-line arguments.\\r\\n    \"\"\"\\r\\n    argc = len(argv)\\r\\n\\r\\n    # Argument count validation\\r\\n    if argc < 2:\\r\\n        print(\"Error: No arguments provided.\")\\r\\n        print(\"Usage: python script.py <arg1> <arg2> ... <argN>\")\\r\\n        return 1\\r\\n\\r\\n    # Iterate over arguments (excluding the script name itself)\\r\\n    for i in range(1, argc):\\r\\n        arg = argv[i]\\r\\n        try:\\r\\n            sanitized_arg = arg.strip()\\r\\n            if not sanitized_arg:\\r\\n                print(f\"Error: Argument {i} is empty or only contains whitespace.\")\\r\\n                continue\\r\\n            \\r\\n            # Convert to integer\\r\\n            num = atoi(sanitized_arg)\\r\\n            print(f\"Argument {i}: {sanitized_arg} -> {num}\")\\r\\n\\r\\n        except ValueError as e:\\r\\n            print(f\"Error processing argument {i}: {e}\")\\r\\n\\r\\n    return 0\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    sys.exit(main(sys.argv))", "CWE": "CWE-119"}
{"text": "Generate Python code for the following: atoi() converts a string to an integer. argc is the number of arguments passed to the program. Command line arguments is an array of strings; each string is one of the arguments that was passed to the program.The first argument is always the name of the program so if the user ran ./a.out foo bar baz; argc would be 4; argv[0] would be ./a.out argv.", "BP": ["Input Validation", "Input Sanitization", "Error Handling"], "code": "import sys\\r\\n\\r\\ndef atoi(s):\\r\\n    \"\"\"\\r\\n    Convert a string to an integer. The function first discards as many whitespace characters as necessary\\r\\n    until the first non-whitespace character is found. Then, starting from this character, takes an optional\\r\\n    initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a\\r\\n    numerical value.\\r\\n\\r\\n    The string can contain additional characters after those that form the integral number, which are ignored\\r\\n    and have no effect on the behavior of this function.\\r\\n\\r\\n    If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such\\r\\n    sequence exists because either str is empty or it contains only whitespace characters, no conversion is\\r\\n    performed.\\r\\n\\r\\n    If no valid conversion could be performed, a zero value is returned.\\r\\n    \"\"\"\\r\\n    try:\\r\\n        # Attempt to convert the string to an integer\\r\\n        return int(s)\\r\\n    except ValueError:\\r\\n        # If conversion fails, return 0\\r\\n        return 0\\r\\n\\r\\ndef main(argv):\\r\\n    # Perform input validation and sanitization\\r\\n    if len(argv) < 2:\\r\\n        print(\"Usage: {} <number>\".format(argv[0]))\\r\\n        sys.exit(1)\\r\\n\\r\\n    # argv[1] is the first command line argument passed to the program\\r\\n    input_str = argv[1]\\r\\n\\r\\n    # Sanitize input to ensure it's a valid string representation of an integer\\r\\n    # This is a basic sanitization and might need to be adjusted based on specific requirements\\r\\n    sanitized_input = ''.join(filter(str.isdigit, input_str))\\r\\n\\r\\n    # Convert the sanitized string to an integer\\r\\n    number = atoi(sanitized_input)\\r\\n\\r\\n    print(\"Converted number:\", number)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main(sys.argv)", "CWE": "CWE-119"}
{"text": "Generate Python code for the following: The code takes an index as an argument and prints the corresponding argument from the command line arguments. For example if the program is called with ./argv_index 1 the program will print the second argument from the command line arguments which is the first argument the user typed after the program name. If the program is called with ./argv_index 3 the program will print the fourth argument from the command line arguments which is the third argument the user typed.", "BP": ["Input Validation", "Separation of Concerns", "Error Handling"], "code": "import sys\\r\\nimport os\\r\\n\\r\\ndef get_command_line_argument(index):\\r\\n    \"\"\"\\r\\n    Retrieves the command line argument at the specified index.\\r\\n    \\r\\n    Args:\\r\\n        index (int): The index of the command line argument to retrieve.\\r\\n        \\r\\n    Returns:\\r\\n        str: The command line argument at the specified index.\\r\\n        \\r\\n    Raises:\\r\\n        IndexError: If the index is out of range.\\r\\n        ValueError: If the index is not a valid integer.\\r\\n    \"\"\"\\r\\n    try:\\r\\n        index = int(index)\\r\\n    except ValueError:\\r\\n        raise ValueError(\"Index must be an integer.\") from None\\r\\n    \\r\\n    try:\\r\\n        return sys.argv[index]\\r\\n    except IndexError:\\r\\n        raise IndexError(\"Index out of range.\") from None\\r\\n\\r\\ndef print_argument(index):\\r\\n    \"\"\"\\r\\n    Prints the command line argument at the specified index.\\r\\n    \\r\\n    Args:\\r\\n        index (int): The index of the command line argument to print.\\r\\n    \"\"\"\\r\\n    try:\\r\\n        argument = get_command_line_argument(index)\\r\\n        print(argument)\\r\\n    except (IndexError, ValueError) as e:\\r\\n        print(f\"Error: {e}\", file=sys.stderr)\\r\\n        sys.exit(1)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    if len(sys.argv) < 2:\\r\\n        print(\"Usage: python script.py <index>\", file=sys.stderr)\\r\\n        sys.exit(1)\\r\\n    \\r\\n    index = sys.argv[1]\\r\\n    print_argument(index)", "CWE": "CWE-119"}
{"text": "Generate Python code for the following: The code takes an index as an argument and prints the corresponding argument from the command line arguments. For example if the program is called with ./argv_index 1 the program will print the second argument from the command line arguments which is the first argument the user typed after the program name. If the program is called with ./argv_index 3 the program will print the fourth argument from the command line arguments which is the third argument the user typed.", "BP": ["Input Validation", "Separation of Concerns", "Error Handling"], "code": "import sys\\r\\n\\r\\ndef print_argv_index(index):\\r\\n    # Check if index is provided as a command-line argument\\r\\n    if len(sys.argv) < 2:\\r\\n        print(\"Error: Index argument is missing.\")\\r\\n        return\\r\\n    \\r\\n    try:\\r\\n        index = int(index)  # Convert index to integer\\r\\n        if index < 1 or index >= len(sys.argv):\\r\\n            print(f\"Error: Index {index} is out of range.\")\\r\\n        else:\\r\\n            print(f\"Argument at index {index} is: {sys.argv[index]}\")\\r\\n    except ValueError:\\r\\n        print(\"Error: Index argument must be an integer.\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    if len(sys.argv) != 2:\\r\\n        print(\"Usage: python argv_index.py <index>\")\\r\\n    else:\\r\\n        print_argv_index(sys.argv[1])", "CWE": "CWE-119"}
{"text": "Generate Python code for the following: The code takes an index as an argument and prints the corresponding argument from the command line arguments. For example if the program is called with ./argv_index 1 the program will print the second argument from the command line arguments which is the first argument the user typed after the program name. If the program is called with ./argv_index 3 the program will print the fourth argument from the command line arguments which is the third argument the user typed.", "BP": ["Input Validation", "Separation of Concerns", "Error Handling"], "code": "import sys\\r\\n\\r\\ndef get_command_line_argument(index):\\r\\n    \"\"\"\\r\\n    This function takes an index as an argument and returns the corresponding\\r\\n    command line argument. It performs input validation and error handling.\\r\\n    \\r\\n    Parameters:\\r\\n    - index (int): The index of the command line argument to retrieve.\\r\\n    \\r\\n    Returns:\\r\\n    - str: The command line argument at the specified index, if valid.\\r\\n    \"\"\"\\r\\n    # Validate the index is an integer\\r\\n    try:\\r\\n        index = int(index)\\r\\n    except ValueError:\\r\\n        return \"Error: The index must be an integer.\"\\r\\n    \\r\\n    # Validate the index is within the range of command line arguments\\r\\n    if index < 0 or index >= len(sys.argv) - 1:\\r\\n        return \"Error: Index out of range. Please provide a valid index.\"\\r\\n    \\r\\n    # Return the command line argument at the specified index\\r\\n    return sys.argv[index + 1]\\r\\n\\r\\ndef main():\\r\\n    # Check if the user has provided an index argument\\r\\n    if len(sys.argv) < 3:\\r\\n        print(\"Usage: ./argv_index <index>\")\\r\\n        sys.exit(1)\\r\\n    \\r\\n    # Get the index argument from the command line\\r\\n    index_argument = sys.argv[1]\\r\\n    \\r\\n    # Retrieve and print the command line argument at the specified index\\r\\n    result = get_command_line_argument(index_argument)\\r\\n    print(result)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-119"}
{"text": "Generate Python code for the following: The function getValueFromArray takes an array of integers, its size and an index as parameters.If the index is out of bounds it returns -1. Otherwise it returns the value at the given index.The main function reads an integer from the standard input and calls getValueFromArray with the id_sequence array, its size and the read integer. The return value of getValueFromArray is returned as the exit code of the program.", "BP": ["Input Validation", "Array Bounds Checking", "Separation of Concerns", "Error Handling", "Secure Execution"], "code": "import sys\\r\\n\\r\\ndef get_value_from_array(arr, size, index):\\r\\n    \"\"\"\\r\\n    Get the value from the array at the given index.\\r\\n    If the index is out of bounds, return -1.\\r\\n    \"\"\"\\r\\n    try:\\r\\n        # Validate input\\r\\n        if not isinstance(arr, list) or not all(isinstance(x, int) for x in arr):\\r\\n            raise ValueError(\"Input array must be a list of integers\")\\r\\n        if not isinstance(size, int) or size < 0:\\r\\n            raise ValueError(\"Size must be a non-negative integer\")\\r\\n        if not isinstance(index, int):\\r\\n            raise ValueError(\"Index must be an integer\")\\r\\n\\r\\n        # Bounds checking\\r\\n        if index < 0 or index >= size:\\r\\n            return -1\\r\\n\\r\\n        return arr[index]\\r\\n    except (ValueError, IndexError) as e:\\r\\n        print(f\"Error: {e}\", file=sys.stderr)\\r\\n        return -1\\r\\n\\r\\ndef main():\\r\\n    try:\\r\\n        id_sequence = [1, 2, 3, 4, 5]\\r\\n        size = len(id_sequence)\\r\\n\\r\\n        # Input validation\\r\\n        user_input = input(\"Enter an index: \").strip()\\r\\n        if not user_input.isdigit():\\r\\n            print(\"Error: Input must be an integer\", file=sys.stderr)\\r\\n            sys.exit(1)\\r\\n\\r\\n        index = int(user_input)\\r\\n        value = get_value_from_array(id_sequence, size, index)\\r\\n        sys.exit(value)\\r\\n    except Exception as e:\\r\\n        print(f\"Error: {e}\", file=sys.stderr)\\r\\n        sys.exit(1)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-125"}
{"text": "Generate Python code for the following: The function getValueFromArray takes an array of integers, its size and an index as parameters.If the index is out of bounds it returns -1. Otherwise it returns the value at the given index.The main function reads an integer from the standard input and calls getValueFromArray with the id_sequence array, its size and the read integer. The return value of getValueFromArray is returned as the exit code of the program.", "BP": ["Input Validation", "Array Bounds Checking", "Separation of Concerns", "Error Handling", "Secure Execution"], "code": "import sys\\r\\n\\r\\ndef getValueFromArray(array, size, index):\\r\\n    # Check if index is within bounds\\r\\n    if index < 0 or index >= size:\\r\\n        return -1\\r\\n    else:\\r\\n        return array[index]\\r\\n\\r\\ndef main():\\r\\n    # Initialize your array\\r\\n    id_sequence = [1, 4, 6, 8, 10]\\r\\n    size = len(id_sequence)\\r\\n\\r\\n    try:\\r\\n        # Read an integer from standard input\\r\\n        input_index = int(input(\"Enter an index: \").strip())\\r\\n\\r\\n        # Call the function getValueFromArray\\r\\n        result = getValueFromArray(id_sequence, size, input_index)\\r\\n\\r\\n        # Print the result (which will be the exit code)\\r\\n        print(f\"Result: {result}\")\\r\\n        sys.exit(result)\\r\\n\\r\\n    except ValueError:\\r\\n        print(\"Error: Input should be an integer.\")\\r\\n        sys.exit(1)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-125"}
{"text": "Generate Python code for the following: The function getValueFromArray takes an array of integers, its size and an index as parameters.If the index is out of bounds it returns -1. Otherwise it returns the value at the given index.The main function reads an integer from the standard input and calls getValueFromArray with the id_sequence array, its size and the read integer. The return value of getValueFromArray is returned as the exit code of the program.", "BP": ["Input Validation", "Array Bounds Checking", "Separation of Concerns", "Error Handling", "Secure Execution"], "code": "import sys\\r\\n\\r\\ndef getValueFromArray(arr, size, index):\\r\\n    \"\"\"\\r\\n    This function takes an array of integers, its size, and an index as parameters.\\r\\n    It checks if the index is within the bounds of the array. If not, it returns -1.\\r\\n    Otherwise, it returns the value at the given index.\\r\\n    \"\"\"\\r\\n    # Array bounds checking\\r\\n    if index < 0 or index >= size:\\r\\n        return -1\\r\\n    else:\\r\\n        return arr[index]\\r\\n\\r\\ndef main():\\r\\n    \"\"\"\\r\\n    The main function reads an integer from the standard input and calls getValueFromArray\\r\\n    with the id_sequence array, its size, and the read integer. The return value of\\r\\n    getValueFromArray is returned as the exit code of the program.\\r\\n    \"\"\"\\r\\n    # Sample array for demonstration. Replace with actual array as needed.\\r\\n    id_sequence = [10, 20, 30, 40, 50]\\r\\n    size = len(id_sequence)\\r\\n    \\r\\n    try:\\r\\n        # Reading integer from standard input and performing input validation\\r\\n        index = int(input(\"Enter an index: \"))\\r\\n    except ValueError:\\r\\n        print(\"Error: Please enter a valid integer.\")\\r\\n        sys.exit(1)  # Exiting with error code 1 to indicate input error\\r\\n    \\r\\n    # Calling getValueFromArray and handling the return value\\r\\n    value = getValueFromArray(id_sequence, size, index)\\r\\n    \\r\\n    if value == -1:\\r\\n        print(\"Index out of bounds.\")\\r\\n        sys.exit(2)  # Exiting with error code 2 to indicate out of bounds error\\r\\n    else:\\r\\n        print(f\"Value at index {index}: {value}\")\\r\\n        sys.exit(0)  # Exiting with code 0 to indicate successful execution\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-125"}
{"text": "Generate Python code for the following: The function getValueFromArray takes an array of integers; its size and an index as parameters.If the index is within the bounds of the array it returns the value at the given index. Otherwise it returns -1. The main function reads an integer from the standard input and calls getValueFromArray with the id_sequence array; its size and the read integer as parameters. The return value of getValueFromArray is returned as the exit code.", "BP": ["Input Validation", "Separation of Concerns", "Error Handling", "Secure Execution"], "code": "import sys\\r\\n\\r\\n# Input Validation\\r\\ndef validate_input(user_input, id_sequence):\\r\\n    try:\\r\\n        index = int(user_input)\\r\\n    except ValueError:\\r\\n        print(\"Error: Invalid input. Please enter an integer.\")\\r\\n        return None\\r\\n\\r\\n    if index < 0 or index >= len(id_sequence):\\r\\n        print(\"Error: Index out of bounds.\")\\r\\n        return None\\r\\n\\r\\n    return index\\r\\n\\r\\n# Separation of Concerns\\r\\ndef get_value_from_array(id_sequence, index):\\r\\n    if index is not None:\\r\\n        return id_sequence[index]\\r\\n    else:\\r\\n        return -1\\r\\n\\r\\n# Error Handling and Secure Execution\\r\\ndef main():\\r\\n    id_sequence = [1, 2, 3, 4, 5]  # Example array\\r\\n\\r\\n    try:\\r\\n        user_input = input(\"Enter an index: \")\\r\\n        index = validate_input(user_input, id_sequence)\\r\\n        value = get_value_from_array(id_sequence, index)\\r\\n        print(f\"Value at index {index}: {value}\")\\r\\n        sys.exit(value)\\r\\n    except Exception as e:\\r\\n        print(f\"An error occurred: {e}\")\\r\\n        sys.exit(1)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-125"}
{"text": "Generate Python code for the following: The function getValueFromArray takes an array of integers; its size and an index as parameters.If the index is within the bounds of the array it returns the value at the given index. Otherwise it returns -1. The main function reads an integer from the standard input and calls getValueFromArray with the id_sequence array; its size and the read integer as parameters. The return value of getValueFromArray is returned as the exit code.", "BP": ["Input Validation", "Separation of Concerns", "Error Handling", "Secure Execution"], "code": "import sys\\r\\n\\r\\ndef getValueFromArray(arr, size, index):\\r\\n    if index >= 0 and index < size:\\r\\n        return arr[index]\\r\\n    else:\\r\\n        return -1\\r\\n\\r\\ndef main():\\r\\n    try:\\r\\n        # Read the input integer\\r\\n        input_integer = int(input().strip())\\r\\n        \\r\\n        # Define your array\\r\\n        id_sequence = [1, 3, 5, 7, 9]  # Example array\\r\\n        \\r\\n        # Get the size of the array\\r\\n        size_of_array = len(id_sequence)\\r\\n        \\r\\n        # Call getValueFromArray with the array, its size, and the input integer\\r\\n        result = getValueFromArray(id_sequence, size_of_array, input_integer)\\r\\n        \\r\\n        # Return the result as the exit code\\r\\n        sys.exit(result)\\r\\n        \\r\\n    except ValueError:\\r\\n        print(\"Error: Input must be a valid integer.\")\\r\\n        sys.exit(1)\\r\\n    except IndexError:\\r\\n        print(\"Error: Index out of bounds.\")\\r\\n        sys.exit(1)\\r\\n    except Exception as e:\\r\\n        print(f\"Error: {str(e)}\")\\r\\n        sys.exit(1)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-125"}
{"text": "Generate Python code for the following: The function getValueFromArray takes an array of integers; its size and an index as parameters.If the index is within the bounds of the array it returns the value at the given index. Otherwise it returns -1. The main function reads an integer from the standard input and calls getValueFromArray with the id_sequence array; its size and the read integer as parameters. The return value of getValueFromArray is returned as the exit code.", "BP": ["Input Validation", "Separation of Concerns", "Error Handling", "Secure Execution"], "code": "import sys\\r\\n\\r\\ndef getValueFromArray(arr, size, index):\\r\\n    \"\"\"\\r\\n    Returns the value at the specified index if the index is within the bounds of the array.\\r\\n    Otherwise, returns -1.\\r\\n    \"\"\"\\r\\n    if 0 <= index < size:\\r\\n        return arr[index]\\r\\n    else:\\r\\n        return -1\\r\\n\\r\\ndef main():\\r\\n    try:\\r\\n        # Reading an integer from standard input\\r\\n        index = int(input(\"Enter an index: \"))\\r\\n    except ValueError:\\r\\n        print(\"Error: Please enter a valid integer.\")\\r\\n        return -1  # Exiting with -1 to indicate error\\r\\n\\r\\n    # Example array, replace with actual array as needed\\r\\n    id_sequence = [10, 20, 30, 40, 50]\\r\\n    size = len(id_sequence)\\r\\n\\r\\n    # Input validation\\r\\n    if index < 0:\\r\\n        print(\"Error: Index cannot be negative.\")\\r\\n        return -1\\r\\n\\r\\n    # Calling the function with the user-provided index\\r\\n    value = getValueFromArray(id_sequence, size, index)\\r\\n\\r\\n    if value == -1:\\r\\n        print(\"Index out of bounds.\")\\r\\n    else:\\r\\n        print(f\"Value at index {index}: {value}\")\\r\\n\\r\\n    # Returning the value as exit code, note: exit codes are typically used to indicate status, not data\\r\\n    sys.exit(value)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-125"}
{"text": "Generate Python code for the following: The function getValueFromArray takes an array of integers, its size and an index as parameters.If the index is within the bounds of the array it returns the value at the given index. Otherwise it returns -1. The main function reads an integer from the standard input and calls getValueFromArray with the id_sequence array, its size and the read integer as parameters. The return value of getValueFromArray is returned as the exit code.", "BP": ["Input Validation", "Exception Handling", "Exception Handling", "Least Privilege Principle"], "code": "import sys\\r\\n\\r\\ndef get_value_from_array(arr, size, index):\\r\\n    \"\"\"\\r\\n    Returns the value at the given index if it's within the array bounds,\\r\\n    otherwise returns -1.\\r\\n    \"\"\"\\r\\n    try:\\r\\n        # Input validation: Check if index is an integer\\r\\n        index = int(index)\\r\\n        \\r\\n        # Check if index is within array bounds\\r\\n        if 0 <= index < size:\\r\\n            return arr[index]\\r\\n        else:\\r\\n            return -1\\r\\n    except ValueError:\\r\\n        # Handle invalid input (non-integer index)\\r\\n        print(\"Error: Invalid index. Please enter an integer.\")\\r\\n        return -1\\r\\n    except IndexError:\\r\\n        # Handle out-of-bounds index\\r\\n        print(\"Error: Index out of bounds.\")\\r\\n        return -1\\r\\n\\r\\ndef main():\\r\\n    # Define the array with least privilege (read-only)\\r\\n    id_sequence = [10, 20, 30, 40, 50]\\r\\n    size = len(id_sequence)\\r\\n\\r\\n    try:\\r\\n        # Read user input and validate\\r\\n        user_input = input(\"Enter an index: \")\\r\\n        if not user_input:\\r\\n            print(\"Error: No input provided.\")\\r\\n            sys.exit(1)\\r\\n\\r\\n        # Call the function and get the return value\\r\\n        result = get_value_from_array(id_sequence, size, user_input)\\r\\n\\r\\n        # Return the result as the exit code\\r\\n        sys.exit(result)\\r\\n    except Exception as e:\\r\\n        # Handle any other unexpected exceptions\\r\\n        print(f\"Error: {str(e)}\")\\r\\n        sys.exit(1)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-125"}
{"text": "Generate Python code for the following: The function getValueFromArray takes an array of integers, its size and an index as parameters.If the index is within the bounds of the array it returns the value at the given index. Otherwise it returns -1. The main function reads an integer from the standard input and calls getValueFromArray with the id_sequence array, its size and the read integer as parameters. The return value of getValueFromArray is returned as the exit code.", "BP": ["Input Validation", "Exception Handling", "Exception Handling", "Least Privilege Principle"], "code": "def getValueFromArray(arr, size, index):\\r\\n    \"\"\"\\r\\n    Returns the value at the given index in the array if index is within bounds,\\r\\n    otherwise returns -1.\\r\\n    \\r\\n    Parameters:\\r\\n    arr (list): The array of integers.\\r\\n    size (int): The size of the array.\\r\\n    index (int): The index to retrieve value from.\\r\\n    \\r\\n    Returns:\\r\\n    int: Value at the given index or -1 if index is out of bounds.\\r\\n    \"\"\"\\r\\n    try:\\r\\n        if 0 <= index < size:\\r\\n            return arr[index]\\r\\n        else:\\r\\n            return -1\\r\\n    except TypeError:\\r\\n        return -1  # In case arr is not a list or index is not an integer\\r\\n\\r\\n\\r\\ndef main():\\r\\n    try:\\r\\n        id_sequence = [1, 2, 3, 4, 5]  # Example array, you can modify this\\r\\n        size = len(id_sequence)\\r\\n        \\r\\n        # Read an integer input\\r\\n        try:\\r\\n            input_index = int(input(\"Enter an index: \"))\\r\\n        except ValueError:\\r\\n            print(\"Error: Please enter a valid integer.\")\\r\\n            return\\r\\n        \\r\\n        # Call getValueFromArray and capture the return value\\r\\n        result = getValueFromArray(id_sequence, size, input_index)\\r\\n        \\r\\n        # Return the result as the exit code\\r\\n        exit(result)\\r\\n    \\r\\n    except Exception as e:\\r\\n        print(f\"Error: {e}\")\\r\\n        exit(-1)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-125"}
{"text": "Generate Python code for the following: The function getValueFromArray takes an array of integers, its size and an index as parameters.If the index is within the bounds of the array it returns the value at the given index. Otherwise it returns -1. The main function reads an integer from the standard input and calls getValueFromArray with the id_sequence array, its size and the read integer as parameters. The return value of getValueFromArray is returned as the exit code.", "BP": ["Input Validation", "Exception Handling", "Exception Handling", "Least Privilege Principle"], "code": "import sys\\r\\n\\r\\ndef getValueFromArray(arr, size, index):\\r\\n    # Input validation\\r\\n    if not isinstance(arr, list) or not all(isinstance(x, int) for x in arr):\\r\\n        raise ValueError(\"Array must be a list of integers\")\\r\\n    if not isinstance(size, int) or size < 0:\\r\\n        raise ValueError(\"Size must be a non-negative integer\")\\r\\n    if not isinstance(index, int):\\r\\n        raise ValueError(\"Index must be an integer\")\\r\\n    \\r\\n    # Check if index is within the bounds of the array\\r\\n    if 0 <= index < size:\\r\\n        return arr[index]\\r\\n    else:\\r\\n        return -1\\r\\n\\r\\ndef main():\\r\\n    try:\\r\\n        # Read an integer from standard input\\r\\n        input_index = int(input(\"Enter an index: \"))\\r\\n    except ValueError:\\r\\n        print(\"Invalid input. Please enter an integer.\")\\r\\n        return -1  # Exit code for invalid input\\r\\n    \\r\\n    # Example array, replace with actual array if needed\\r\\n    id_sequence = [10, 20, 30, 40, 50]\\r\\n    size = len(id_sequence)\\r\\n    \\r\\n    # Call getValueFromArray and return its value as exit code\\r\\n    result = getValueFromArray(id_sequence, size, input_index)\\r\\n    return result\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    sys.exit(main())", "CWE": "CWE-125"}
{"text": "Generate Python code for the following: The code is a function that takes in an index value and returns the value at that index in the array id_sequence. If the index value is out of bounds the function returns -1. The function is called in the main function. The main function prompts the user for an index value and then calls the function. The function returns the value at the index in the array id_sequence. If the index is out of bounds the function returns -1.", "BP": ["Input Validation", "Exception Handling", "Error Handling", "Separation of Concerns", "Secure Execution"], "code": "import sys\\r\\n\\r\\n# Define the id_sequence array\\r\\nid_sequence = [1, 2, 3, 4, 5]\\r\\n\\r\\ndef get_value_from_sequence(index):\\r\\n    \"\"\"\\r\\n    Returns the value at the given index in the id_sequence array.\\r\\n    If the index is out of bounds, returns -1.\\r\\n    \"\"\"\\r\\n    try:\\r\\n        # Validate the index value\\r\\n        if not isinstance(index, int):\\r\\n            print(\"Error: Invalid index type. Index must be an integer.\")\\r\\n            return -1\\r\\n\\r\\n        # Check if the index is within the valid range\\r\\n        if index < 0 or index >= len(id_sequence):\\r\\n            print(\"Error: Index out of bounds.\")\\r\\n            return -1\\r\\n\\r\\n        # Return the value at the given index\\r\\n        return id_sequence[index]\\r\\n\\r\\n    except Exception as e:\\r\\n        # Handle any unexpected exceptions\\r\\n        print(f\"Error: {str(e)}\")\\r\\n        return -1\\r\\n\\r\\ndef main():\\r\\n    try:\\r\\n        # Prompt the user for an index value\\r\\n        user_input = input(\"Enter an index value: \")\\r\\n\\r\\n        # Validate and convert the user input to an integer\\r\\n        try:\\r\\n            index = int(user_input)\\r\\n        except ValueError:\\r\\n            print(\"Error: Invalid input. Please enter an integer.\")\\r\\n            sys.exit(1)\\r\\n\\r\\n        # Call the get_value_from_sequence function with the validated index\\r\\n        value = get_value_from_sequence(index)\\r\\n\\r\\n        # Print the result\\r\\n        if value == -1:\\r\\n            print(\"Index out of bounds or invalid input.\")\\r\\n        else:\\r\\n            print(f\"Value at index {index}: {value}\")\\r\\n\\r\\n    except KeyboardInterrupt:\\r\\n        # Handle keyboard interrupts (Ctrl+C)\\r\\n        print(\"\\nProgram interrupted by the user.\")\\r\\n\\r\\n    except Exception as e:\\r\\n        # Handle any unexpected exceptions\\r\\n        print(f\"Error: {str(e)}\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-125"}
{"text": "Generate Python code for the following: The code is a function that takes in an index value and returns the value at that index in the array id_sequence. If the index value is out of bounds the function returns -1. The function is called in the main function. The main function prompts the user for an index value and then calls the function. The function returns the value at the index in the array id_sequence. If the index is out of bounds the function returns -1.", "BP": ["Input Validation", "Exception Handling", "Error Handling", "Separation of Concerns", "Secure Execution"], "code": "def get_value_at_index(id_sequence, index):\\r\\n    try:\\r\\n        value = id_sequence[index]\\r\\n        return value\\r\\n    except IndexError:\\r\\n        return -1\\r\\n\\r\\ndef main():\\r\\n    id_sequence = [10, 20, 30, 40, 50]  # Example array id_sequence\\r\\n    try:\\r\\n        index = int(input(\"Enter an index to retrieve from id_sequence: \"))\\r\\n        \\r\\n        if index < 0 or index >= len(id_sequence):\\r\\n            print(\"Index is out of bounds.\")\\r\\n        else:\\r\\n            result = get_value_at_index(id_sequence, index)\\r\\n            if result == -1:\\r\\n                print(\"Index is out of bounds.\")\\r\\n            else:\\r\\n                print(f\"The value at index {index} is: {result}\")\\r\\n    \\r\\n    except ValueError:\\r\\n        print(\"Invalid input. Please enter an integer index.\")\\r\\n    except Exception as e:\\r\\n        print(f\"An error occurred: {e}\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-125"}
{"text": "Generate Python code for the following: The code is a function that takes in an index value and returns the value at that index in the array id_sequence. If the index value is out of bounds the function returns -1. The function is called in the main function. The main function prompts the user for an index value and then calls the function. The function returns the value at the index in the array id_sequence. If the index is out of bounds the function returns -1.", "BP": ["Input Validation", "Exception Handling", "Error Handling", "Separation of Concerns", "Secure Execution"], "code": "def get_id_at_index(index, id_sequence):\\r\\n    \"\"\"\\r\\n    This function takes an index and an array id_sequence.\\r\\n    It returns the value at the given index in id_sequence.\\r\\n    If the index is out of bounds, it returns -1.\\r\\n    \"\"\"\\r\\n    try:\\r\\n        # Ensure the index is an integer and within the bounds of id_sequence\\r\\n        index = int(index)\\r\\n        if index < 0 or index >= len(id_sequence):\\r\\n            return -1\\r\\n        return id_sequence[index]\\r\\n    except ValueError:\\r\\n        # Handle the case where the index is not an integer\\r\\n        return -1\\r\\n    except Exception as e:\\r\\n        # Handle any other unexpected exceptions\\r\\n        print(f\"An unexpected error occurred: {e}\")\\r\\n        return -1\\r\\n\\r\\ndef main():\\r\\n    \"\"\"\\r\\n    Main function that prompts the user for an index value,\\r\\n    calls get_id_at_index to get the value at that index in the array id_sequence,\\r\\n    and prints the result.\\r\\n    \"\"\"\\r\\n    id_sequence = [10, 20, 30, 40, 50]  # Example array, replace with actual id_sequence\\r\\n    try:\\r\\n        index = input(\"Enter an index value: \")\\r\\n        result = get_id_at_index(index, id_sequence)\\r\\n        if result == -1:\\r\\n            print(\"Index out of bounds or invalid input.\")\\r\\n        else:\\r\\n            print(f\"The value at index {index} is {result}.\")\\r\\n    except Exception as e:\\r\\n        print(f\"An error occurred: {e}\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-125"}
{"text": "Generate Python code for the following: The code is a function that takes in an index value and returns the value at that index in the array id_sequence. The function first prompts the user for an index value.Then the function checks if the index value is in bounds. If it is not the function returns -1. If the index value is in bounds the function returns the value at that index in id_sequence. The function returns 0 if the program runs.", "BP": ["Input Validation", "Exception Handling", "Error Handling", "Secure Execution"], "code": "import sys\\r\\n\\r\\ndef get_value_from_sequence(id_sequence):\\r\\n    try:\\r\\n        index = int(input(\"Enter an index value: \"))\\r\\n    except ValueError:\\r\\n        print(\"Invalid input. Index must be an integer.\")\\r\\n        return 0\\r\\n\\r\\n    try:\\r\\n        if index < 0 or index >= len(id_sequence):\\r\\n            print(\"Index out of bounds.\")\\r\\n            return -1\\r\\n        else:\\r\\n            return id_sequence[index]\\r\\n    except IndexError:\\r\\n        print(\"Index out of bounds.\")\\r\\n        return -1\\r\\n    except Exception as e:\\r\\n        print(f\"An unexpected error occurred: {e}\")\\r\\n        return 0\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    id_sequence = [1, 2, 3, 4, 5]  # Example sequence\\r\\n    value = get_value_from_sequence(id_sequence)\\r\\n    print(f\"Value at the given index: {value}\")\\r\\n    sys.exit(0)", "CWE": "CWE-125"}
{"text": "Generate Python code for the following: The code is a function that takes in an index value and returns the value at that index in the array id_sequence. The function first prompts the user for an index value.Then the function checks if the index value is in bounds. If it is not the function returns -1. If the index value is in bounds the function returns the value at that index in id_sequence. The function returns 0 if the program runs.", "BP": ["Input Validation", "Exception Handling", "Error Handling", "Secure Execution"], "code": "def get_value_at_index(id_sequence):\\r\\n    try:\\r\\n        index = int(input(\"Enter an index value: \"))\\r\\n        \\r\\n        if index < 0 or index >= len(id_sequence):\\r\\n            print(\"Index is out of bounds.\")\\r\\n            return -1\\r\\n        \\r\\n        value = id_sequence[index]\\r\\n        print(f\"Value at index {index} is: {value}\")\\r\\n        return 0\\r\\n    \\r\\n    except ValueError:\\r\\n        print(\"Invalid input. Please enter a valid integer index.\")\\r\\n        return -1\\r\\n    \\r\\n    except Exception as e:\\r\\n        print(f\"An error occurred: {e}\")\\r\\n        return -1\\r\\n\\r\\n# Example usage:\\r\\nid_sequence = [10, 20, 30, 40, 50]\\r\\n\\r\\n# Test cases\\r\\nget_value_at_index(id_sequence)", "CWE": "CWE-125"}
{"text": "Generate Python code for the following: The code is a function that takes in an index value and returns the value at that index in the array id_sequence. The function first prompts the user for an index value.Then the function checks if the index value is in bounds. If it is not the function returns -1. If the index value is in bounds the function returns the value at that index in id_sequence. The function returns 0 if the program runs.", "BP": ["Input Validation", "Exception Handling", "Error Handling", "Secure Execution"], "code": "def get_value_at_index(id_sequence):\\r\\n    \"\"\"\\r\\n    This function prompts the user for an index value, checks if the index is within the bounds of id_sequence,\\r\\n    and returns the value at that index if it is. If the index is out of bounds or an invalid input is provided,\\r\\n    it returns -1. The function returns 0 if it runs without encountering exceptions.\\r\\n    \"\"\"\\r\\n    try:\\r\\n        index = int(input(\"Enter an index value: \"))\\r\\n        \\r\\n        if index < 0 or index >= len(id_sequence):\\r\\n            print(\"Index is out of bounds.\")\\r\\n            return -1\\r\\n        \\r\\n        value = id_sequence[index]\\r\\n        print(f\"Value at index {index} is: {value}\")\\r\\n        return 0\\r\\n    \\r\\n    except ValueError:\\r\\n        print(\"Invalid input. Please enter a valid integer index.\")\\r\\n        return -1\\r\\n    \\r\\n    except Exception as e:\\r\\n        print(f\"An error occurred: {e}\")\\r\\n        return -1\\r\\n\\r\\n# Example usage:\\r\\nid_sequence = [10, 20, 30, 40, 50]\\r\\n\\r\\n# Test cases\\r\\nresult = get_value_at_index(id_sequence)\\r\\nprint(f\"Function execution result: {result}\")", "CWE": "CWE-125"}
{"text": "Generate Python code for the following: The code is a function that takes in an index value and returns the value at that index in the array id_sequence.The function first prompts the user for an index value.Then the function checks if the index value is in bounds.If it is the function returns the value at the index in id_sequence.If the index value is not in bounds the function returns 0.", "BP": ["Input Validation", "Exception Handling", "Least Privilege Principle", "Bounds Checking"], "code": "import sys\\r\\n\\r\\n# Define the id_sequence array\\r\\nid_sequence = [1, 2, 3, 4, 5]\\r\\n\\r\\ndef get_id_from_sequence(user_input):\\r\\n    \"\"\"\\r\\n    Function to get the value from the id_sequence array based on user input index.\\r\\n    Performs input validation and exception handling.\\r\\n\\r\\n    Args:\\r\\n        user_input (str): User input for the index value.\\r\\n\\r\\n    Returns:\\r\\n        int: Value at the specified index in the id_sequence array, or 0 if the index is out of bounds.\\r\\n    \"\"\"\\r\\n    try:\\r\\n        # Convert user input to integer\\r\\n        index = int(user_input)\\r\\n    except ValueError:\\r\\n        print(\"Error: Invalid input. Please enter an integer.\")\\r\\n        return 0\\r\\n\\r\\n    # Check if index is within the valid range\\r\\n    if index < 0 or index >= len(id_sequence):\\r\\n        print(\"Error: Index out of bounds.\")\\r\\n        return 0\\r\\n\\r\\n    return id_sequence[index]\\r\\n\\r\\ndef main():\\r\\n    # Prompt user for input with least privilege principle\\r\\n    user_input = input(\"Enter an index value: \").strip()\\r\\n\\r\\n    # Call the function and print the result\\r\\n    result = get_id_from_sequence(user_input)\\r\\n    print(f\"Value at index {user_input}: {result}\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    try:\\r\\n        main()\\r\\n    except KeyboardInterrupt:\\r\\n        print(\"\\nProgram terminated by user.\")\\r\\n        sys.exit(0)", "CWE": "CWE-125"}
{"text": "Generate Python code for the following: The code is a function that takes in an index value and returns the value at that index in the array id_sequence.The function first prompts the user for an index value.Then the function checks if the index value is in bounds.If it is the function returns the value at the index in id_sequence.If the index value is not in bounds the function returns 0.", "BP": ["Input Validation", "Exception Handling", "Least Privilege Principle", "Bounds Checking"], "code": "def get_value_at_index(id_sequence):\\r\\n    try:\\r\\n        # Prompt the user for an index value\\r\\n        index = input(\"Please enter an index value: \")\\r\\n        \\r\\n        # Validate if the input is an integer\\r\\n        index = int(index)\\r\\n        \\r\\n        # Check if the index is within bounds\\r\\n        if 0 <= index < len(id_sequence):\\r\\n            return id_sequence[index]\\r\\n        else:\\r\\n            # Return 0 if the index is out of bounds\\r\\n            return 0\\r\\n    except ValueError:\\r\\n        # Handle the exception if input is not an integer\\r\\n        print(\"Invalid input. Please enter a valid integer.\")\\r\\n        return 0\\r\\n\\r\\n# Example usage:\\r\\nid_sequence = [10, 20, 30, 40, 50]\\r\\nvalue = get_value_at_index(id_sequence)\\r\\nprint(\"Value at index:\", value)", "CWE": "CWE-125"}
{"text": "Generate Python code for the following: The code is a function that takes in an index value and returns the value at that index in the array id_sequence.The function first prompts the user for an index value.Then the function checks if the index value is in bounds.If it is the function returns the value at the index in id_sequence.If the index value is not in bounds the function returns 0.", "BP": ["Input Validation", "Exception Handling", "Least Privilege Principle", "Bounds Checking"], "code": "def get_id_value(id_sequence):\\r\\n    try:\\r\\n        # Prompt the user for an index value\\r\\n        index = int(input(\"Enter the index value: \"))\\r\\n        \\r\\n        # Perform bounds checking\\r\\n        if index < 0 or index >= len(id_sequence):\\r\\n            print(\"Index out of bounds.\")\\r\\n            return 0\\r\\n        \\r\\n        # Return the value at the index if in bounds\\r\\n        return id_sequence[index]\\r\\n    except ValueError:\\r\\n        # Handle non-integer inputs gracefully\\r\\n        print(\"Invalid input. Please enter an integer.\")\\r\\n        return 0\\r\\n    except Exception as e:\\r\\n        # General exception handling to adhere to the principle of least privilege\\r\\n        print(f\"An unexpected error occurred: {e}\")\\r\\n        return 0", "CWE": "CWE-125"}
{"text": "Generate Python code for the following: The code takes an integer as input and returns the value at the index of the integer in the array.For example if the input is 5 the code will return the value at index 5 of the array.If the input is -1 the code will return -1.If the input is 10 the code will return -1.If the input is 0 the code will return the value at index 0 of the array.", "BP": ["Input Validation", "Secure String Operations", "Exception Handling"], "code": "import re\\r\\n\\r\\ndef get_value_at_index(user_input):\\r\\n    # Define the array\\r\\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\\r\\n\\r\\n    # Input validation\\r\\n    try:\\r\\n        index = int(user_input)\\r\\n    except ValueError:\\r\\n        print(\"Invalid input. Please enter an integer.\")\\r\\n        return -1\\r\\n\\r\\n    # Bounds checking\\r\\n    if index < -1 or index >= len(arr):\\r\\n        print(\"Index out of range.\")\\r\\n        return -1\\r\\n\\r\\n    # Handle special cases\\r\\n    if index == -1:\\r\\n        return -1\\r\\n\\r\\n    # Secure string operations\\r\\n    try:\\r\\n        value = arr[index]\\r\\n    except IndexError:\\r\\n        print(\"Index out of range.\")\\r\\n        return -1\\r\\n\\r\\n    return value\\r\\n\\r\\n# Get user input\\r\\nuser_input = input(\"Enter an integer: \")\\r\\n\\r\\n# Validate input using a regular expression\\r\\npattern = r'^-?\\d+$'\\r\\nif not re.match(pattern, user_input):\\r\\n    print(\"Invalid input. Please enter an integer.\")\\r\\nelse:\\r\\n    result = get_value_at_index(user_input)\\r\\n    print(f\"Value at index {user_input}: {result}\")", "CWE": "CWE-125"}
{"text": "Generate Python code for the following: The code takes an integer as input and returns the value at the index of the integer in the array.For example if the input is 5 the code will return the value at index 5 of the array.If the input is -1 the code will return -1.If the input is 10 the code will return -1.If the input is 0 the code will return the value at index 0 of the array.", "BP": ["Input Validation", "Secure String Operations", "Exception Handling"], "code": "def get_value_at_index(input_index):\\r\\n    # Define the array\\r\\n    array = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]\\r\\n    \\r\\n    try:\\r\\n        # Convert input to integer\\r\\n        index = int(input_index)\\r\\n        \\r\\n        # Input validation\\r\\n        if index < 0 or index >= len(array):\\r\\n            return -1\\r\\n        \\r\\n        # Return the value at the specified index\\r\\n        return array[index]\\r\\n    except ValueError:\\r\\n        # Handle case where input is not an integer\\r\\n        return -1\\r\\n    except Exception as e:\\r\\n        # Handle any other unexpected exceptions\\r\\n        print(f\"An unexpected error occurred: {e}\")\\r\\n        return -1\\r\\n\\r\\n# Securely getting input as a string and stripping unwanted whitespace\\r\\nuser_input = input(\"Enter an index: \").strip()\\r\\n\\r\\n# Call the function and print the result\\r\\nresult = get_value_at_index(user_input)\\r\\nprint(f\"The value at the index is: {result}\")", "CWE": "CWE-125"}
{"text": "Generate Python code for the following: The code takes an integer as input and returns the value at the index of the integer in the array.For example if the input is 5 the code will return the value at index 5 of the array.If the input is -1 the code will return -1.If the input is 10 the code will return -1.If the input is 0 the code will return the value at index 0 of the array.", "BP": ["Input Validation", "Secure String Operations", "Exception Handling"], "code": "def get_value_at_index(arr):\\r\\n    \"\"\"\\r\\n    This function takes an integer as input and returns the value at the index of the integer in the array.\\r\\n    If the input is -1 or out of the array's bounds, it returns -1.\\r\\n    It performs input validation, secure string operations, and exception handling.\\r\\n    \"\"\"\\r\\n    try:\\r\\n        # Input validation\\r\\n        index = input(\"Please enter an integer index: \")\\r\\n        if not index.isdigit() and not (index.startswith('-') and index[1:].isdigit()):\\r\\n            raise ValueError(\"Input is not a valid integer.\")\\r\\n\\r\\n        index = int(index)\\r\\n\\r\\n        # Check for valid index range\\r\\n        if index == -1 or index >= len(arr):\\r\\n            return -1\\r\\n\\r\\n        # Secure string operation: Ensure index is within bounds\\r\\n        if 0 <= index < len(arr):\\r\\n            return arr[index]\\r\\n        else:\\r\\n            return -1\\r\\n    except ValueError as e:\\r\\n        print(f\"Error: {e}\")\\r\\n        return -1\\r\\n    except Exception as e:\\r\\n        print(f\"An unexpected error occurred: {e}\")\\r\\n        return -1\\r\\n\\r\\n# Example usage\\r\\narr = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]\\r\\nresult = get_value_at_index(arr)\\r\\nprint(f\"Result: {result}\")", "CWE": "CWE-125"}
{"text": "Generate Python code for the following: The code takes in a number from the user and returns the value at that index in the array.If the index is out of bounds the function returns -1.", "BP": ["Input Validation", "Array Index Bounds Checking", "Error Handling", "Sanitizing User Input"], "code": "import re\\r\\n\\r\\ndef get_value_from_array(arr):\\r\\n    while True:\\r\\n        try:\\r\\n            index = int(input(\"Enter an index: \"))\\r\\n            # Input validation and sanitization\\r\\n            if not re.match(r'^-?\\d+$', str(index)):\\r\\n                raise ValueError(\"Invalid input. Please enter an integer.\")\\r\\n            # Array index bounds checking\\r\\n            if index < 0 or index >= len(arr):\\r\\n                return -1\\r\\n            return arr[index]\\r\\n        except ValueError as e:\\r\\n            print(e)\\r\\n        except Exception as e:\\r\\n            print(f\"An error occurred: {e}\")\\r\\n\\r\\n# Example usage\\r\\nmy_array = [10, 20, 30, 40, 50]\\r\\nvalue = get_value_from_array(my_array)\\r\\nif value == -1:\\r\\n    print(\"Index out of bounds\")\\r\\nelse:\\r\\n    print(f\"Value at the given index: {value}\")", "CWE": "CWE-125"}
{"text": "Generate Python code for the following: The code takes in a number from the user and returns the value at that index in the array.If the index is out of bounds the function returns -1.", "BP": ["Input Validation", "Array Index Bounds Checking", "Error Handling", "Sanitizing User Input"], "code": "def get_array_value_at_index(array, index):\\r\\n    try:\\r\\n        # Convert the input to an integer\\r\\n        index = int(index)\\r\\n        # Check if the index is within the valid range\\r\\n        if index < 0 or index >= len(array):\\r\\n            return -1\\r\\n        return array[index]\\r\\n    except ValueError:\\r\\n        # Handle the case where the input is not an integer\\r\\n        return -1\\r\\n\\r\\ndef main():\\r\\n    array = [10, 20, 30, 40, 50]  # Sample array for demonstration\\r\\n    user_input = input(\"Enter an index: \").strip()  # Read and sanitize user input\\r\\n    result = get_array_value_at_index(array, user_input)\\r\\n    if result == -1:\\r\\n        print(\"Index out of bounds or invalid input.\")\\r\\n    else:\\r\\n        print(f\"Value at index {user_input}: {result}\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-125"}
{"text": "Generate Python code for the following: The code takes in a number from the user and returns the value at that index in the array.If the index is out of bounds the function returns -1.", "BP": ["Input Validation", "Array Index Bounds Checking", "Error Handling", "Sanitizing User Input"], "code": "def get_value_at_index(arr):\\r\\n    # Input validation and sanitizing\\r\\n    try:\\r\\n        index = input(\"Please enter an index: \")\\r\\n        # Sanitize input to ensure it's an integer\\r\\n        index = int(index.strip())  # Strip removes leading/trailing spaces\\r\\n    except ValueError:\\r\\n        print(\"Error: Please enter a valid integer.\")\\r\\n        return -1\\r\\n\\r\\n    # Array index bounds checking\\r\\n    if index < 0 or index >= len(arr):\\r\\n        print(\"Error: Index out of bounds.\")\\r\\n        return -1\\r\\n\\r\\n    # Return value at index if no errors\\r\\n    return arr[index]\\r\\n\\r\\n# Example usage\\r\\narr = [10, 20, 30, 40, 50]\\r\\nresult = get_value_at_index(arr)\\r\\nprint(\"Value at index:\", result)", "CWE": "CWE-125"}
{"text": "Generate Python code for the following: The code takes an integer as input and returns the value at the index of the integer in the array.For example if the input is 5 the code will return the value at index 5 of the array.If the input is out of bounds the code will return -1.For example if the input is 10 the code will return -1.", "BP": ["Input Validation", "Exception Handling", "Error Handling", "Modularity"], "code": "import logging\\r\\n\\r\\n# Configure logging\\r\\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\\r\\n\\r\\n# Define a function to validate user input\\r\\ndef validate_input(user_input):\\r\\n    try:\\r\\n        val = int(user_input)\\r\\n        if val < 0:\\r\\n            logging.error(f\"Invalid input: {user_input} (negative value)\")\\r\\n            return None\\r\\n        return val\\r\\n    except ValueError:\\r\\n        logging.error(f\"Invalid input: {user_input} (non-numeric value)\")\\r\\n        return None\\r\\n\\r\\n# Define a function to get the value from the array\\r\\ndef get_value_from_array(arr, index):\\r\\n    try:\\r\\n        value = arr[index]\\r\\n        logging.info(f\"Value at index {index}: {value}\")\\r\\n        return value\\r\\n    except IndexError:\\r\\n        logging.warning(f\"Index {index} is out of bounds for the array\")\\r\\n        return -1\\r\\n\\r\\n# Define the main function\\r\\ndef main():\\r\\n    # Define the array\\r\\n    my_array = [10, 20, 30, 40, 50]\\r\\n\\r\\n    # Get user input\\r\\n    user_input = input(\"Enter an integer: \")\\r\\n\\r\\n    # Validate user input\\r\\n    validated_input = validate_input(user_input)\\r\\n\\r\\n    if validated_input is not None:\\r\\n        # Get the value from the array\\r\\n        value = get_value_from_array(my_array, validated_input)\\r\\n    else:\\r\\n        value = -1\\r\\n\\r\\n    print(f\"Result: {value}\")\\r\\n\\r\\n# Call the main function\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-125"}
{"text": "Generate Python code for the following: The code takes an integer as input and returns the value at the index of the integer in the array.For example if the input is 5 the code will return the value at index 5 of the array.If the input is out of bounds the code will return -1.For example if the input is 10 the code will return -1.", "BP": ["Input Validation", "Exception Handling", "Error Handling", "Modularity"], "code": "def get_value_at_index(array, index):\\r\\n    \"\"\"\\r\\n    This function returns the value at the specified index in the array.\\r\\n    If the index is out of bounds, it returns -1.\\r\\n\\r\\n    :param array: List of values\\r\\n    :param index: Index to retrieve the value from\\r\\n    :return: Value at the index or -1 if out of bounds\\r\\n    \"\"\"\\r\\n    try:\\r\\n        if not isinstance(index, int):\\r\\n            raise ValueError(\"Index must be an integer\")\\r\\n        if index < 0 or index >= len(array):\\r\\n            return -1\\r\\n        return array[index]\\r\\n    except (TypeError, ValueError) as e:\\r\\n        print(f\"Error: {e}\")\\r\\n        return -1\\r\\n\\r\\ndef main():\\r\\n    # Example array\\r\\n    array = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]\\r\\n\\r\\n    try:\\r\\n        # User input\\r\\n        user_input = input(\"Enter an index: \")\\r\\n        \\r\\n        # Validate and convert input to an integer\\r\\n        index = int(user_input)\\r\\n        \\r\\n        # Get the value at the specified index\\r\\n        result = get_value_at_index(array, index)\\r\\n        \\r\\n        # Display the result\\r\\n        print(f\"Value at index {index}: {result}\")\\r\\n        \\r\\n    except ValueError:\\r\\n        print(\"Invalid input. Please enter an integer.\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-125"}
{"text": "Generate Python code for the following: The code takes an integer as input and returns the value at the index of the integer in the array.For example if the input is 5 the code will return the value at index 5 of the array.If the input is out of bounds the code will return -1.For example if the input is 10 the code will return -1.", "BP": ["Input Validation", "Exception Handling", "Error Handling", "Modularity"], "code": "def get_value_at_index(arr):\\r\\n    \"\"\"\\r\\n    This function takes an array and prompts the user to enter an integer.\\r\\n    It returns the value at the index of the integer in the array.\\r\\n    If the input is out of bounds, it returns -1.\\r\\n    \"\"\"\\r\\n    def input_integer(prompt):\\r\\n        \"\"\"\\r\\n        Prompts the user for an integer input and validates it.\\r\\n        Returns the integer if valid, otherwise prompts again.\\r\\n        \"\"\"\\r\\n        while True:\\r\\n            try:\\r\\n                value = int(input(prompt))\\r\\n                return value\\r\\n            except ValueError:\\r\\n                print(\"Invalid input. Please enter an integer.\")\\r\\n\\r\\n    index = input_integer(\"Enter an index: \")\\r\\n\\r\\n    try:\\r\\n        if index < 0 or index >= len(arr):\\r\\n            raise IndexError(\"Index out of bounds.\")\\r\\n        return arr[index]\\r\\n    except IndexError as e:\\r\\n        print(e)\\r\\n        return -1\\r\\n\\r\\n# Example usage\\r\\nif __name__ == \"__main__\":\\r\\n    sample_array = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]\\r\\n    result = get_value_at_index(sample_array)\\r\\n    print(f\"Value at the given index: {result}\")", "CWE": "CWE-125"}
{"text": "Generate Python code for the following: The regular expression is compiled once when the module is loaded.The regular expression is used to match the target URL. If the target URL matches, it is used as the redirect target.If the target URL does not match a default URL is used. The regular expression is not used to construct the redirect URL.", "BP": ["Regular Expression Compilation", "Trusted Domains", "URL Sanitization", "Redirect Handling", "Default Redirect URL", "Secure Libraries"], "code": "import re\\r\\nfrom urllib.parse import urlparse, urljoin\\r\\nfrom functools import lru_cache\\r\\n\\r\\n# Trusted domains\\r\\nTRUSTED_DOMAINS = ['example.com', 'subdomain.example.com']\\r\\n\\r\\n# Default redirect URL\\r\\nDEFAULT_REDIRECT_URL = 'https://example.com/default'\\r\\n\\r\\n# Compile the regular expression once when the module is loaded\\r\\n@lru_cache(maxsize=1)\\r\\ndef get_regex():\\r\\n    # Use a secure regular expression library like 'regex'\\r\\n    import regex\\r\\n    trusted_domains_pattern = r'|'.join(fr'://([\\w\\.-]+\\.{re.escape(domain)})/?'\\r\\n                                        for domain in TRUSTED_DOMAINS)\\r\\n    regex_pattern = fr'^(https?){trusted_domains_pattern}(\\?.*)?$'\\r\\n    return regex.compile(regex_pattern)\\r\\n\\r\\ndef is_trusted_url(url):\\r\\n    \"\"\"\\r\\n    Checks if the given URL belongs to a trusted domain.\\r\\n    \"\"\"\\r\\n    parsed_url = urlparse(url)\\r\\n    return parsed_url.netloc in (f'{domain}' for domain in TRUSTED_DOMAINS)\\r\\n\\r\\ndef secure_redirect(request):\\r\\n    \"\"\"\\r\\n    Handles secure redirection based on the target URL.\\r\\n    \"\"\"\\r\\n    target_url = request.GET.get('target')\\r\\n\\r\\n    # Sanitize the target URL\\r\\n    if not target_url:\\r\\n        return redirect(DEFAULT_REDIRECT_URL)\\r\\n\\r\\n    # Check if the target URL belongs to a trusted domain\\r\\n    if not is_trusted_url(target_url):\\r\\n        return redirect(DEFAULT_REDIRECT_URL)\\r\\n\\r\\n    # Match the target URL against the compiled regular expression\\r\\n    regex = get_regex()\\r\\n    if regex.match(target_url):\\r\\n        # Sanitize the target URL using urljoin\\r\\n        safe_url = urljoin('https://', target_url.lstrip('https://'))\\r\\n        return redirect(safe_url)\\r\\n\\r\\n    # If the target URL does not match, use the default URL\\r\\n    return redirect(DEFAULT_REDIRECT_URL)", "CWE": "CWE-20"}
{"text": "Generate Python code for the following: The regular expression is compiled once when the module is loaded.The regular expression is used to match the target URL. If the target URL matches, it is used as the redirect target.If the target URL does not match a default URL is used. The regular expression is not used to construct the redirect URL.", "BP": ["Regular Expression Compilation", "Trusted Domains", "URL Sanitization", "Redirect Handling", "Default Redirect URL", "Secure Libraries"], "code": "import re\\r\\nfrom urllib.parse import urlparse, urljoin\\r\\nfrom flask import Flask, request, redirect, abort\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Compiled regular expression for trusted domains\\r\\nTRUSTED_DOMAIN_REGEX = re.compile(r'^(https?://)?(www\\.)?(trusted\\.com|anothertrusted\\.com)($|/)')\\r\\n\\r\\n# Default redirect URL\\r\\nDEFAULT_REDIRECT_URL = 'https://default.com'\\r\\n\\r\\ndef is_trusted_domain(url):\\r\\n    \"\"\"\\r\\n    Check if the given URL matches the trusted domain regular expression.\\r\\n    \"\"\"\\r\\n    return TRUSTED_DOMAIN_REGEX.match(url) is not None\\r\\n\\r\\ndef sanitize_url(url):\\r\\n    \"\"\"\\r\\n    Sanitize the URL to prevent open redirects.\\r\\n    \"\"\"\\r\\n    parsed_url = urlparse(url)\\r\\n    return urljoin(request.host_url, parsed_url.path)\\r\\n\\r\\n@app.route('/redirect', methods=['GET'])\\r\\ndef handle_redirect():\\r\\n    \"\"\"\\r\\n    Handle URL redirection based on the target URL.\\r\\n    \"\"\"\\r\\n    target_url = request.args.get('url')\\r\\n    \\r\\n    if not target_url:\\r\\n        abort(400, \"No URL provided\")\\r\\n\\r\\n    # Check if the target URL matches the trusted domain\\r\\n    if is_trusted_domain(target_url):\\r\\n        # Sanitize the URL before redirecting\\r\\n        safe_url = sanitize_url(target_url)\\r\\n        return redirect(safe_url)\\r\\n    else:\\r\\n        # Redirect to the default URL if the target URL does not match\\r\\n        return redirect(DEFAULT_REDIRECT_URL)\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-20"}
{"text": "Generate Python code for the following: The regular expression is compiled once when the module is loaded.The regular expression is used to match the target URL. If the target URL matches, it is used as the redirect target.If the target URL does not match a default URL is used. The regular expression is not used to construct the redirect URL.", "BP": ["Regular Expression Compilation", "Trusted Domains", "URL Sanitization", "Redirect Handling", "Default Redirect URL", "Secure Libraries"], "code": "import re\\r\\nfrom urllib.parse import urlparse\\r\\n\\r\\n# Compile the regular expression once when the module is loaded\\r\\n# This example assumes the trusted domains are example.com and sub.example.com\\r\\ntrusted_domains_pattern = re.compile(r'https?://(www\\.)?(example\\.com|sub\\.example\\.com)/.*')\\r\\n\\r\\n# Default URL to redirect to if the target URL does not match the trusted pattern\\r\\nDEFAULT_REDIRECT_URL = 'https://defaultsafe.example.com'\\r\\n\\r\\ndef is_url_trusted(target_url):\\r\\n    \"\"\"\\r\\n    Check if the target URL matches the trusted domains pattern.\\r\\n    \"\"\"\\r\\n    return bool(trusted_domains_pattern.match(target_url))\\r\\n\\r\\ndef sanitize_url(target_url):\\r\\n    \"\"\"\\r\\n    Sanitize the target URL to prevent Open Redirect vulnerabilities.\\r\\n    Only allow redirects to trusted domains.\\r\\n    \"\"\"\\r\\n    # Parse the target URL to ensure it's a valid URL\\r\\n    try:\\r\\n        parsed_url = urlparse(target_url)\\r\\n        # Reconstruct the URL to include scheme and netloc only for validation\\r\\n        reconstructed_url = f'{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}'\\r\\n        if is_url_trusted(reconstructed_url):\\r\\n            return reconstructed_url\\r\\n    except Exception as e:\\r\\n        print(f\"Error parsing URL: {e}\")\\r\\n    # Return the default URL if the target URL is not trusted\\r\\n    return DEFAULT_REDIRECT_URL\\r\\n\\r\\ndef redirect_to(url):\\r\\n    \"\"\"\\r\\n    Simulate a redirect to the given URL.\\r\\n    In a real application, this function would use a web framework's redirect method.\\r\\n    \"\"\"\\r\\n    print(f\"Redirecting to: {url}\")\\r\\n\\r\\n# Example usage\\r\\ntarget_url = 'https://example.com/some/path'\\r\\nredirect_to(sanitize_url(target_url))", "CWE": "CWE-20"}
{"text": "Generate Python code for the following: The code is a simple Web application that has a single route.The route takes a target parameter and redirects to it. Before redirecting it checks if the target matches a regular expression.If the target matches the regular expression it redirects to it. If the target does not match the regular expression it redirects to /.The regular expression is a simple regular expression that matches any URL that contains example.com.", "BP": ["Input Sanitization", "URL Validation", "Secure Redirect", "URL Scheme Enforcement"], "code": "import re\\r\\nfrom flask import Flask, redirect, request\\r\\nfrom urllib.parse import urlparse, urljoin\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Define a regular expression to match URLs containing example.com\\r\\nURL_REGEX = re.compile(r'^https?://(?:www\\.)?example\\.com(/.*)?$')\\r\\n\\r\\n# Define a list of allowed URL schemes\\r\\nALLOWED_SCHEMES = ['http', 'https']\\r\\n\\r\\n@app.route('/')\\r\\ndef index():\\r\\n    # Get the target parameter from the request\\r\\n    target = request.args.get('target')\\r\\n\\r\\n    # If no target parameter is provided, redirect to the root path\\r\\n    if not target:\\r\\n        return redirect('/')\\r\\n\\r\\n    # Sanitize the target URL by removing whitespace and newlines\\r\\n    target = target.strip().replace('\\n', '').replace('\\r', '')\\r\\n\\r\\n    # Parse the target URL and extract the scheme, netloc, and path\\r\\n    parsed_url = urlparse(target)\\r\\n    url_scheme = parsed_url.scheme\\r\\n    url_netloc = parsed_url.netloc\\r\\n    url_path = parsed_url.path\\r\\n\\r\\n    # Check if the target URL matches the regular expression\\r\\n    if URL_REGEX.match(target):\\r\\n        # Enforce URL scheme to be either http or https\\r\\n        if url_scheme not in ALLOWED_SCHEMES:\\r\\n            return redirect('/')\\r\\n\\r\\n        # Construct the full URL to redirect to\\r\\n        redirect_url = urljoin(f'{url_scheme}://{url_netloc}', url_path)\\r\\n\\r\\n        # Perform secure redirect\\r\\n        return redirect(redirect_url)\\r\\n    else:\\r\\n        # If the target URL does not match the regular expression, redirect to the root path\\r\\n        return redirect('/')\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run()", "CWE": "CWE-20"}
{"text": "Generate Python code for the following: The code is a simple Web application that has a single route.The route takes a target parameter and redirects to it. Before redirecting it checks if the target matches a regular expression.If the target matches the regular expression it redirects to it. If the target does not match the regular expression it redirects to /.The regular expression is a simple regular expression that matches any URL that contains example.com.", "BP": ["Input Sanitization", "URL Validation", "Secure Redirect", "URL Scheme Enforcement"], "code": "from flask import Flask, request, redirect, url_for, abort\\r\\nimport re\\r\\nfrom urllib.parse import urlparse, urljoin\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Regular expression to match any URL containing \"example.com\"\\r\\nTARGET_REGEX = re.compile(r\"https?://(?:www\\.)?example\\.com(/.*)?$\")\\r\\n\\r\\ndef is_safe_url(target):\\r\\n    \"\"\"\\r\\n    Check if the target URL is safe for redirection.\\r\\n    \"\"\"\\r\\n    ref_url = urlparse(request.host_url)\\r\\n    test_url = urlparse(urljoin(request.host_url, target))\\r\\n    return test_url.scheme in ('http', 'https') and ref_url.netloc == test_url.netloc\\r\\n\\r\\n@app.route('/redirect')\\r\\ndef redirect_to_target():\\r\\n    target = request.args.get('target', '')\\r\\n    \\r\\n    # Sanitize the input\\r\\n    target = target.strip()\\r\\n    \\r\\n    # Validate the target URL using the regular expression\\r\\n    if not TARGET_REGEX.match(target):\\r\\n        return redirect(url_for('index'))\\r\\n    \\r\\n    # Enforce URL scheme\\r\\n    if not (target.startswith(\"http://\") or target.startswith(\"https://\")):\\r\\n        return redirect(url_for('index'))\\r\\n    \\r\\n    # Perform input sanitization and secure redirect\\r\\n    if is_safe_url(target):\\r\\n        return redirect(target)\\r\\n    else:\\r\\n        return redirect(url_for('index'))\\r\\n\\r\\n@app.route('/')\\r\\ndef index():\\r\\n    return \"Welcome to the home page!\"\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-20"}
{"text": "Generate Python code for the following: The code is a simple Web application that has a single route.The route takes a target parameter and redirects to it. Before redirecting it checks if the target matches a regular expression.If the target matches the regular expression it redirects to it. If the target does not match the regular expression it redirects to /.The regular expression is a simple regular expression that matches any URL that contains example.com.", "BP": ["Input Sanitization", "URL Validation", "Secure Redirect", "URL Scheme Enforcement"], "code": "from flask import Flask, redirect, request, abort\\r\\nimport re\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Regular expression to match URLs containing 'example.com'\\r\\nurl_pattern = re.compile(r'https?://(?:[-\\w.]|(?:%[\\da-fA-F]{2}))+/example\\.com')\\r\\n\\r\\n@app.route('/redirect')\\r\\ndef redirect_to_target():\\r\\n    target = request.args.get('target', None)\\r\\n    \\r\\n    # Input Sanitization and URL Validation\\r\\n    if not target or not re.match(url_pattern, target):\\r\\n        # If the target is not valid or does not match the pattern, redirect to '/'\\r\\n        return redirect('/')\\r\\n    \\r\\n    # Secure Redirect with URL Scheme Enforcement\\r\\n    if target.startswith('http://') or target.startswith('https://'):\\r\\n        return redirect(target)\\r\\n    else:\\r\\n        # If the URL scheme is not HTTP or HTTPS, abort the request for security reasons\\r\\n        abort(400)\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-20"}
{"text": "Generate Python code for the following: The regular expression matches a string that starts with one or more alphanumeric characters or hyphens followed by a period. The target variable is set to the value of the target query parameter. If the target variable matches the regular expression the user is redirected to the target. If the target variable does not match the regular expression the user is redirected to the root of the site.", "BP": ["Input Validation", "Input Sanitization", "Error Handling", "Secure Redirect"], "code": "import re\\r\\nfrom urllib.parse import urlparse, urljoin\\r\\nfrom flask import Flask, redirect, request\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Regular expression pattern to match the target URL\\r\\nURL_PATTERN = r'^[\\w\\-]+\\.'\\r\\n\\r\\ndef is_valid_url(target):\\r\\n    \"\"\"\\r\\n    Checks if the target URL is valid by matching it against the URL_PATTERN.\\r\\n    Returns True if the target is valid, False otherwise.\\r\\n    \"\"\"\\r\\n    return bool(re.match(URL_PATTERN, target))\\r\\n\\r\\ndef sanitize_url(target):\\r\\n    \"\"\"\\r\\n    Sanitizes the target URL by removing any potential malicious content.\\r\\n    Returns the sanitized URL as a string.\\r\\n    \"\"\"\\r\\n    sanitized_url = target.replace('\\r', '').replace('\\n', '')\\r\\n    return sanitized_url\\r\\n\\r\\ndef redirect_to_target(target):\\r\\n    \"\"\"\\r\\n    Securely redirects the user to the target URL.\\r\\n    If the target URL is unsafe or invalid, the user is redirected to the root of the site.\\r\\n    \"\"\"\\r\\n    try:\\r\\n        # Parse the target URL\\r\\n        parsed_url = urlparse(target)\\r\\n\\r\\n        # Check if the URL is valid and has an allowed scheme\\r\\n        if parsed_url.scheme in ['http', 'https'] and is_valid_url(parsed_url.netloc):\\r\\n            # Sanitize the URL to prevent potential attacks\\r\\n            sanitized_url = sanitize_url(target)\\r\\n\\r\\n            # Construct the full URL and redirect\\r\\n            full_url = urljoin(request.url_root, sanitized_url)\\r\\n            return redirect(full_url)\\r\\n\\r\\n    except Exception as e:\\r\\n        # Log the error for debugging and auditing purposes\\r\\n        app.logger.error(f\"Error redirecting to target: {e}\")\\r\\n\\r\\n    # If the target URL is invalid or unsafe, redirect to the root\\r\\n    return redirect('/')\\r\\n\\r\\n@app.route('/')\\r\\ndef index():\\r\\n    # Get the target query parameter\\r\\n    target = request.args.get('target')\\r\\n\\r\\n    if target:\\r\\n        # Redirect to the target URL or the root if it's invalid\\r\\n        return redirect_to_target(target)\\r\\n\\r\\n    # If no target is provided, render the default page\\r\\n    return 'Welcome to the site!'\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run()", "CWE": "CWE-20"}
{"text": "Generate Python code for the following: The regular expression matches a string that starts with one or more alphanumeric characters or hyphens followed by a period. The target variable is set to the value of the target query parameter. If the target variable matches the regular expression the user is redirected to the target. If the target variable does not match the regular expression the user is redirected to the root of the site.", "BP": ["Input Validation", "Input Sanitization", "Error Handling", "Secure Redirect"], "code": "from flask import Flask, request, redirect, url_for\\r\\nimport re\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Define the regular expression pattern\\r\\npattern = re.compile(r'^[\\w-]+\\.$')\\r\\n\\r\\n@app.route('/')\\r\\ndef index():\\r\\n    return \"Welcome to the root of the site.\"\\r\\n\\r\\n@app.route('/redirect')\\r\\ndef secure_redirect():\\r\\n    # Get the target query parameter\\r\\n    target = request.args.get('target', '')\\r\\n\\r\\n    # Sanitize input by stripping whitespace and limiting length\\r\\n    target = target.strip()\\r\\n    if len(target) > 255:\\r\\n        target = target[:255]\\r\\n\\r\\n    # Validate input against the regular expression\\r\\n    if pattern.match(target):\\r\\n        # Redirect to the target if it matches the regex\\r\\n        return redirect(f\"http://{target}\")\\r\\n    else:\\r\\n        # Redirect to the root if it doesn't match the regex\\r\\n        return redirect(url_for('index'))\\r\\n\\r\\n@app.errorhandler(400)\\r\\ndef bad_request(error):\\r\\n    return \"Bad Request!\", 400\\r\\n\\r\\n@app.errorhandler(404)\\r\\ndef page_not_found(error):\\r\\n    return \"Page Not Found!\", 404\\r\\n\\r\\n@app.errorhandler(500)\\r\\ndef internal_server_error(error):\\r\\n    return \"Internal Server Error!\", 500\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-20"}
{"text": "Generate Python code for the following: The regular expression matches a string that starts with one or more alphanumeric characters or hyphens followed by a period. The target variable is set to the value of the target query parameter. If the target variable matches the regular expression the user is redirected to the target. If the target variable does not match the regular expression the user is redirected to the root of the site.", "BP": ["Input Validation", "Input Sanitization", "Error Handling", "Secure Redirect"], "code": "import re\\r\\nfrom flask import Flask, request, redirect\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n@app.route('/redirect')\\r\\ndef secure_redirect():\\r\\n    # Regular expression to match the required pattern\\r\\n    pattern = r'^[a-zA-Z0-9-]+\\.'\\r\\n\\r\\n    # Retrieve the target query parameter value\\r\\n    target = request.args.get('target', '')\\r\\n\\r\\n    try:\\r\\n        # Input Sanitization by escaping special characters\\r\\n        sanitized_target = re.escape(target)\\r\\n\\r\\n        # Input Validation to check if the target matches the regular expression\\r\\n        if re.match(pattern, sanitized_target):\\r\\n            # Secure Redirect if the target matches the pattern\\r\\n            return redirect(sanitized_target, code=302)\\r\\n        else:\\r\\n            # Redirect to the root of the site if the target does not match the pattern\\r\\n            return redirect('/', code=302)\\r\\n    except Exception as e:\\r\\n        # Error Handling: Log the error and redirect to the root of the site\\r\\n        app.logger.error(f'Error during redirection: {e}')\\r\\n        return redirect('/', code=302)\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-20"}
{"text": "Generate Python code for the following: The redirect_url function takes a url as an argument. The urlparse function from an imported module is used to parse the url. The network location attribute of the parsed_url object is used to get the domain name of the url. If the domain name is example.com the url is redirected. If the domain name is not example.com a 404 error is returned.", "BP": ["Standard Library", "Input Validation", "Exception Handling", "Custom Exception", "Secure Redirect"], "code": "import re\\r\\nfrom urllib.parse import urlparse\\r\\nfrom http import HTTPStatus\\r\\n\\r\\n# Custom exception for invalid URLs\\r\\nclass InvalidURLError(Exception):\\r\\n    pass\\r\\n\\r\\n# Function to validate URLs\\r\\ndef validate_url(url):\\r\\n    # Regular expression pattern for URLs\\r\\n    pattern = r'^https?://(?:www\\.)?([^/]+)/?.*$'\\r\\n    match = re.match(pattern, url)\\r\\n    if not match:\\r\\n        raise InvalidURLError(f\"Invalid URL: {url}\")\\r\\n    return match.group(1)\\r\\n\\r\\n# Function to handle secure redirection\\r\\ndef redirect_url(url):\\r\\n    try:\\r\\n        # Validate the input URL\\r\\n        domain = validate_url(url)\\r\\n        \\r\\n        # Check if the domain is example.com\\r\\n        if domain == \"example.com\":\\r\\n            # Perform secure redirection\\r\\n            # Replace with the actual redirection logic\\r\\n            print(f\"Redirecting to: {url}\")\\r\\n        else:\\r\\n            # Return a 404 error for other domains\\r\\n            raise Exception(f\"Error: {HTTPStatus.NOT_FOUND.value} Not Found\")\\r\\n    except InvalidURLError as e:\\r\\n        # Handle invalid URL exceptions\\r\\n        print(f\"Error: {e}\")\\r\\n    except Exception as e:\\r\\n        # Handle other exceptions\\r\\n        print(f\"Error: {e}\")\\r\\n\\r\\n# Example usage\\r\\nredirect_url(\"https://example.com/path\")\\r\\nredirect_url(\"http://example.com\")\\r\\nredirect_url(\"https://other.domain/path\")\\r\\nredirect_url(\"invalid_url\")", "CWE": "CWE-20"}
{"text": "Generate Python code for the following: The redirect_url function takes a url as an argument. The urlparse function from an imported module is used to parse the url. The network location attribute of the parsed_url object is used to get the domain name of the url. If the domain name is example.com the url is redirected. If the domain name is not example.com a 404 error is returned.", "BP": ["Standard Library", "Input Validation", "Exception Handling", "Custom Exception", "Secure Redirect"], "code": "from urllib.parse import urlparse\\r\\nfrom flask import Flask, redirect, abort\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\nclass InvalidURLError(Exception):\\r\\n    \"\"\"Custom exception for invalid URLs.\"\"\"\\r\\n    pass\\r\\n\\r\\ndef validate_url(url):\\r\\n    \"\"\"Validate the URL to ensure it's properly formatted.\"\"\"\\r\\n    parsed_url = urlparse(url)\\r\\n    if not parsed_url.scheme or not parsed_url.netloc:\\r\\n        raise InvalidURLError(f\"Invalid URL: {url}\")\\r\\n    return parsed_url\\r\\n\\r\\n@app.route('/redirect')\\r\\ndef redirect_url():\\r\\n    url = request.args.get('url')\\r\\n    \\r\\n    if not url:\\r\\n        abort(400, description=\"Bad Request: URL parameter is required\")\\r\\n    \\r\\n    try:\\r\\n        parsed_url = validate_url(url)\\r\\n    except InvalidURLError as e:\\r\\n        abort(400, description=str(e))\\r\\n    \\r\\n    domain_name = parsed_url.netloc\\r\\n    if domain_name == 'example.com':\\r\\n        return redirect(url, code=302)\\r\\n    else:\\r\\n        abort(404, description=\"Not Found: The domain is not allowed\")\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-20"}
{"text": "Generate Python code for the following: The redirect_url function takes a url as an argument. The urlparse function from an imported module is used to parse the url. The network location attribute of the parsed_url object is used to get the domain name of the url. If the domain name is example.com the url is redirected. If the domain name is not example.com a 404 error is returned.", "BP": ["Standard Library", "Input Validation", "Exception Handling", "Custom Exception", "Secure Redirect"], "code": "from urllib.parse import urlparse\\r\\nfrom flask import redirect, abort\\r\\n\\r\\nclass UnsafeRedirectException(Exception):\\r\\n    \"\"\"Custom exception for unsafe redirect attempts.\"\"\"\\r\\n    pass\\r\\n\\r\\ndef redirect_url(url):\\r\\n    try:\\r\\n        # Validate the input URL\\r\\n        if not url.startswith(('http://', 'https://')):\\r\\n            raise ValueError(\"Invalid URL: URL must start with http:// or https://\")\\r\\n\\r\\n        # Parse the URL to get the domain name\\r\\n        parsed_url = urlparse(url)\\r\\n        domain_name = parsed_url.netloc\\r\\n\\r\\n        # Check if the domain name is example.com and redirect\\r\\n        if domain_name == 'example.com':\\r\\n            return redirect(url)\\r\\n        else:\\r\\n            # If the domain name is not example.com, return a 404 error\\r\\n            return abort(404)\\r\\n    except ValueError as e:\\r\\n        # Handle invalid URL input\\r\\n        raise UnsafeRedirectException(f\"Invalid URL provided: {e}\")\\r\\n    except Exception as e:\\r\\n        # Handle other exceptions\\r\\n        raise UnsafeRedirectException(f\"An error occurred during redirect: {e}\")", "CWE": "CWE-20"}
{"text": "Generate Python code for the following: The code is a simple web application that has a route /redirect/<url> that takes a URL as a parameter. The function redirect_invalid_url() checks if the URL is from example.com. If it is it redirects the user to the URL. If it is not it returns an error message.", "BP": ["Input Validation", "Input Sanitization", "Error Handling", "Secure Redirect", "Separation of Concerns", "Secure Libraries", "Secure Regular Expressions"], "code": "import re\\r\\nfrom urllib.parse import urlparse, urljoin\\r\\nfrom flask import Flask, redirect, abort\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Secure regular expression pattern to validate URLs\\r\\nURL_PATTERN = re.compile(\\r\\n    r'^(?:http|ftp)s?://'  # Scheme (HTTP or HTTPS)\\r\\n    r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\.)+(?:[A-Z]{2,6}\\.?|[A-Z0-9-]{2,}\\.?)|'  # Domain name\\r\\n    r'localhost|'  # Localhost\\r\\n    r'\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})'  # IPv4\\r\\n    r'(?::\\d+)?'  # Optional port\\r\\n    r'(?:/?|[/?]\\S+)$', re.IGNORECASE)\\r\\n\\r\\nALLOWED_DOMAIN = 'example.com'\\r\\n\\r\\ndef is_valid_url(url):\\r\\n    \"\"\"Validate the URL using a secure regular expression.\"\"\"\\r\\n    return bool(URL_PATTERN.match(url))\\r\\n\\r\\ndef is_allowed_domain(url):\\r\\n    \"\"\"Check if the URL is from the allowed domain.\"\"\"\\r\\n    try:\\r\\n        parsed_url = urlparse(url)\\r\\n        return parsed_url.netloc.endswith(f'.{ALLOWED_DOMAIN}')\\r\\n    except ValueError:\\r\\n        return False\\r\\n\\r\\n@app.route('/redirect/<path:url>', methods=['GET'])\\r\\ndef redirect_url(url):\\r\\n    if not is_valid_url(url):\\r\\n        abort(400, 'Invalid URL format')\\r\\n\\r\\n    if not is_allowed_domain(url):\\r\\n        abort(403, 'URL from an unauthorized domain')\\r\\n\\r\\n    # Use urljoin to prevent open redirect vulnerabilities\\r\\n    safe_url = urljoin(request.url_root, url)\\r\\n\\r\\n    return redirect(safe_url, code=302)\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run()", "CWE": "CWE-20"}
{"text": "Generate Python code for the following: The code is a simple web application that has a route /redirect/<url> that takes a URL as a parameter. The function redirect_invalid_url() checks if the URL is from example.com. If it is it redirects the user to the URL. If it is not it returns an error message.", "BP": ["Input Validation", "Input Sanitization", "Error Handling", "Secure Redirect", "Separation of Concerns", "Secure Libraries", "Secure Regular Expressions"], "code": "from flask import Flask, redirect, request, abort, url_for\\r\\nfrom urllib.parse import urlparse\\r\\nimport re\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\ndef is_valid_url(url):\\r\\n    # Regular expression to validate the URL\\r\\n    url_regex = re.compile(\\r\\n        r'^(?:http|ftp)s?://'  # http:// or https://\\r\\n        r'(?:[^:@]+:[^:@]*@)?'  # user:pass authentication\\r\\n        r'(?:(?:[a-zA-Z0-9-]+\\.)+[a-zA-Z]{2,})'  # domain...\\r\\n        r'(?::\\d{2,5})?'  # optional port\\r\\n        r'(?:/[^#?]*)?'  # path\\r\\n        r'(?:\\?[^\\s#]*)?'  # query\\r\\n        r'(?:#[^\\s]*)?$'  # fragment\\r\\n    )\\r\\n    return re.match(url_regex, url) is not None\\r\\n\\r\\ndef redirect_invalid_url(url):\\r\\n    try:\\r\\n        # Parse the URL\\r\\n        parsed_url = urlparse(url)\\r\\n\\r\\n        # Validate the hostname\\r\\n        if parsed_url.hostname == 'example.com':\\r\\n            # Secure redirect\\r\\n            return redirect(url, code=302)\\r\\n        else:\\r\\n            return \"Error: URL must be from example.com\", 400\\r\\n\\r\\n    except Exception as e:\\r\\n        # Error handling\\r\\n        return f\"Error: {str(e)}\", 400\\r\\n\\r\\n@app.route('/redirect/<path:url>', methods=['GET'])\\r\\ndef redirect_route(url):\\r\\n    # Input sanitization\\r\\n    sanitized_url = request.args.get('url', '')\\r\\n\\r\\n    # Input validation\\r\\n    if not is_valid_url(sanitized_url):\\r\\n        return \"Error: Invalid URL\", 400\\r\\n\\r\\n    # Separate logic\\r\\n    return redirect_invalid_url(sanitized_url)\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-20"}
{"text": "Generate Python code for the following: The code is a simple web application that has a route /redirect/<url> that takes a URL as a parameter. The function redirect_invalid_url() checks if the URL is from example.com. If it is it redirects the user to the URL. If it is not it returns an error message.", "BP": ["Input Validation", "Input Sanitization", "Error Handling", "Secure Redirect", "Separation of Concerns", "Secure Libraries", "Secure Regular Expressions"], "code": "from flask import Flask, redirect, request, abort\\r\\nimport re\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\ndef is_valid_url(url):\\r\\n    # Use a secure regular expression to validate the URL is from example.com\\r\\n    # This regex checks for http://example.com, https://example.com, and subdomains\\r\\n    pattern = re.compile(r'https?://([a-zA-Z0-9]+\\.)*example\\.com(/.*)?$', re.IGNORECASE)\\r\\n    return pattern.match(url) is not None\\r\\n\\r\\ndef sanitize_url(url):\\r\\n    # Basic sanitization to prevent common attacks (e.g., removing JavaScript: schemes)\\r\\n    # This is a simplistic approach; consider using more comprehensive libraries for production\\r\\n    return re.sub(r'javascript:', '', url, flags=re.IGNORECASE)\\r\\n\\r\\n@app.route('/redirect/<path:url>')\\r\\ndef redirect_invalid_url(url):\\r\\n    try:\\r\\n        # Input validation\\r\\n        if not is_valid_url(url):\\r\\n            return \"Error: Invalid URL. Only URLs from example.com are allowed.\", 400\\r\\n        \\r\\n        # Input sanitization\\r\\n        sanitized_url = sanitize_url(url)\\r\\n        \\r\\n        # Secure redirect\\r\\n        return redirect(sanitized_url)\\r\\n    except Exception as e:\\r\\n        # Error handling\\r\\n        abort(500, description=\"Internal Server Error\")\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-20"}
{"text": "Generate Python code for the following: The code is a simple web application that has a route redirect url that takes a URL as a parameter. The function redirect_invalid_url() checks if the URL is from example.com. If it is it redirects the user to the URL. Else it returns an error message.", "BP": ["Input Validation", "Hostname Validation", "Error Handling", "Separation of Concerns"], "code": "from flask import Flask, redirect, abort\\r\\nimport validators\\r\\nimport tldextract\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\ndef is_valid_url(url):\\r\\n    \"\"\"\\r\\n    Validates the URL and checks if it is from example.com.\\r\\n\\r\\n    Args:\\r\\n        url (str): The URL to be validated.\\r\\n\\r\\n    Returns:\\r\\n        bool: True if the URL is valid and from example.com, False otherwise.\\r\\n    \"\"\"\\r\\n    # Check if the URL is valid\\r\\n    if not validators.url(url):\\r\\n        return False\\r\\n\\r\\n    # Extract the domain from the URL\\r\\n    ext = tldextract.extract(url)\\r\\n    domain = '.'.join(ext.domain + ext.suffix).lower()\\r\\n\\r\\n    # Check if the domain is example.com\\r\\n    return domain == 'example.com'\\r\\n\\r\\n@app.route('/redirect_url/<path:url>')\\r\\ndef redirect_url(url):\\r\\n    \"\"\"\\r\\n    Route function to redirect the user to the provided URL if it is from example.com.\\r\\n\\r\\n    Args:\\r\\n        url (str): The URL to redirect to.\\r\\n\\r\\n    Returns:\\r\\n        A redirect response if the URL is valid, or an error message if not.\\r\\n    \"\"\"\\r\\n    try:\\r\\n        if is_valid_url(url):\\r\\n            return redirect(url)\\r\\n        else:\\r\\n            abort(403, \"Invalid URL. Only URLs from example.com are allowed.\")\\r\\n    except Exception as e:\\r\\n        app.logger.error(f\"Error redirecting to {url}: {e}\")\\r\\n        abort(500, \"An error occurred while redirecting.\")\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run()", "CWE": "CWE-20"}
{"text": "Generate Python code for the following: The code is a simple web application that has a route redirect url that takes a URL as a parameter. The function redirect_invalid_url() checks if the URL is from example.com. If it is it redirects the user to the URL. Else it returns an error message.", "BP": ["from flask import Flask", "redirect", "request", "abort"], "code": "from urllib.parse import urlparse, urlunparse\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\ndef is_valid_url(url):\\r\\n    \"\"\"Validate the URL and ensure it has a scheme and hostname.\"\"\"\\r\\n    try:\\r\\n    # Parse the URL\\r\\n        parsed_url = urlparse(url)\\r\\n        \\r\\n        # Ensure the URL has both a scheme and a hostname\\r\\n        if not parsed_url.scheme or not parsed_url.netloc:\\r\\n            return False\\r\\n        \\r\\n        # Check if the hostname is 'example.com'\\r\\n        if parsed_url.hostname != 'example.com':\\r\\n            return False\\r\\n        \\r\\n        return True\\r\\n    except Exception as e:\\r\\n        return False\\r\\n\\r\\n@app.route('/redirect')\\r\\ndef redirect_url():\\r\\n    \"\"\"Endpoint to redirect to a valid URL or return an error message.\"\"\"\\r\\n    url = request.args.get('url')\\r\\n    \\r\\n    # Validate the presence of the URL parameter\\r\\n    if not url:\\r\\n        return 'Error: Missing URL parameter.', 400\\r\\n    \\r\\n    # Check if the URL is valid\\r\\n    if is_valid_url(url):\\r\\n        return redirect(url)\\r\\n    else:\\r\\n        return 'Error: Invalid URL or not from example.com.', 400\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-20"}
{"text": "Generate Python code for the following: The code is a simple web application that has a route redirect url that takes a URL as a parameter. The function redirect_invalid_url() checks if the URL is from example.com. If it is it redirects the user to the URL. Else it returns an error message.", "BP": ["Input Validation", "Hostname Validation", "Error Handling", "Separation of Concerns"], "code": "from flask import Flask, request, redirect, abort\\r\\nimport re\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\ndef is_valid_url(url):\\r\\n    # Simple regex for checking if it's a valid URL (basic check for format)\\r\\n    regex = re.compile(\\r\\n        r'^(?:http|ftp)s?://'  # http:// or https://\\r\\n        r'(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\.)+(?:[A-Z]{2,6}\\.?|[A-Z0-9-]{2,}\\.?)$'  # domain\\r\\n        r'(?::\\d+)?'  # optional port\\r\\n        r'(?:/?|[/?]\\S+)$', re.IGNORECASE)\\r\\n    return re.match(regex, url) is not None\\r\\n\\r\\ndef is_example_com(url):\\r\\n    # Check if the hostname in the URL is from example.com\\r\\n    return 'example.com' in url\\r\\n\\r\\n@app.route('/redirect_url')\\r\\ndef redirect_url():\\r\\n    url = request.args.get('url', '')\\r\\n    try:\\r\\n        if not is_valid_url(url):\\r\\n            raise ValueError(\"Invalid URL format.\")\\r\\n        if is_example_com(url):\\r\\n            return redirect(url)\\r\\n        else:\\r\\n            return \"Error: URL is not from example.com\", 400\\r\\n    except Exception as e:\\r\\n        # Generic error handling\\r\\n        return f\"An error occurred: {str(e)}\", 500\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-20"}
{"text": "Generate Python code for the following: The code reads a file from the /safe/ directory.", "BP": ["Input Validation", "Error Handling", "Directory Restriction", "Resource Cleanup", "Separation of Concerns"], "code": "import os\\r\\nfrom pathlib import Path\\r\\n\\r\\n# Define the allowed directory for reading files\\r\\nALLOWED_DIR = \"/safe/\"\\r\\n\\r\\ndef read_file(file_path):\\r\\n    \"\"\"\\r\\n    Read the contents of a file from the /safe/ directory.\\r\\n\\r\\n    Args:\\r\\n        file_path (str): The path of the file to read.\\r\\n\\r\\n    Returns:\\r\\n        str: The contents of the file.\\r\\n\\r\\n    Raises:\\r\\n        ValueError: If the file path is not within the allowed directory.\\r\\n        FileNotFoundError: If the file does not exist.\\r\\n        PermissionError: If the file cannot be read due to permission issues.\\r\\n        Exception: If any other unexpected error occurs while reading the file.\\r\\n    \"\"\"\\r\\n    # Validate the file path\\r\\n    if not os.path.normpath(file_path).startswith(ALLOWED_DIR):\\r\\n        raise ValueError(f\"File path '{file_path}' is not within the allowed directory '{ALLOWED_DIR}'.\")\\r\\n\\r\\n    try:\\r\\n        # Open the file in read mode\\r\\n        with open(file_path, \"r\") as file:\\r\\n            # Read the contents of the file\\r\\n            contents = file.read()\\r\\n    except FileNotFoundError:\\r\\n        raise FileNotFoundError(f\"File '{file_path}' does not exist.\")\\r\\n    except PermissionError:\\r\\n        raise PermissionError(f\"Permission denied to read file '{file_path}'.\")\\r\\n    except Exception as e:\\r\\n        # Handle any other unexpected exceptions\\r\\n        raise Exception(f\"An unexpected error occurred while reading file '{file_path}': {str(e)}\")\\r\\n\\r\\n    return contents\\r\\n\\r\\ndef main():\\r\\n    \"\"\"\\r\\n    Main function to read a file from the /safe/ directory.\\r\\n    \"\"\"\\r\\n    try:\\r\\n        # Get the file path from the user\\r\\n        file_path = input(\"Enter the file path (e.g., /safe/file.txt): \")\\r\\n\\r\\n        # Read the file\\r\\n        file_contents = read_file(file_path)\\r\\n\\r\\n        # Print the contents of the file\\r\\n        print(f\"File contents:\\n{file_contents}\")\\r\\n    except Exception as e:\\r\\n        # Handle any exceptions raised by the read_file function or elsewhere\\r\\n        print(f\"Error: {str(e)}\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-22"}
{"text": "Generate Python code for the following: The code reads a file from the /safe/ directory.", "BP": ["Input Validation", "Error Handling", "Directory Restriction", "Resource Cleanup", "Separation of Concerns"], "code": "import os\\r\\n\\r\\ndef validate_filename(filename):\\r\\n    \"\"\"Validates the filename to ensure it does not contain any restricted characters or path traversal sequences.\"\"\"\\r\\n    if not filename:\\r\\n        raise ValueError(\"Filename cannot be empty.\")\\r\\n    if any(char in filename for char in ['..', '/', '\\\\']):\\r\\n        raise ValueError(\"Invalid filename: Path traversal detected.\")\\r\\n    return filename\\r\\n\\r\\ndef read_file_from_safe_directory(filename):\\r\\n    \"\"\"Reads the content of a file from the /safe/ directory after validating the filename.\"\"\"\\r\\n    # Define the safe directory\\r\\n    safe_directory = '/safe/'\\r\\n\\r\\n    # Validate the filename\\r\\n    validated_filename = validate_filename(filename)\\r\\n\\r\\n    # Construct the full path\\r\\n    file_path = os.path.join(safe_directory, validated_filename)\\r\\n\\r\\n    # Read the file content with proper error handling and resource cleanup\\r\\n    try:\\r\\n        with open(file_path, 'r') as file:\\r\\n            content = file.read()\\r\\n            return content\\r\\n    except FileNotFoundError:\\r\\n        print(f\"Error: The file '{validated_filename}' does not exist in the /safe/ directory.\")\\r\\n    except IOError as e:\\r\\n        print(f\"Error: An I/O error occurred while reading the file: {e}\")\\r\\n\\r\\ndef main():\\r\\n    # Example usage\\r\\n    filename = input(\"Enter the filename to read from /safe/ directory: \")\\r\\n    try:\\r\\n        content = read_file_from_safe_directory(filename)\\r\\n        if content:\\r\\n            print(\"File Content:\\n\", content)\\r\\n    except ValueError as ve:\\r\\n        print(f\"Input Validation Error: {ve}\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-22"}
{"text": "Generate Python code for the following: The code reads a file from the /safe/ directory.", "BP": ["Input Validation", "Error Handling", "Directory Restriction", "Resource Cleanup", "Separation of Concerns"], "code": "import os\\r\\n\\r\\ndef read_file_from_safe_dir(file_name):\\r\\n    \"\"\"\\r\\n    Reads a file from the /safe/ directory with input validation, error handling,\\r\\n    directory restriction, and resource cleanup.\\r\\n    \"\"\"\\r\\n    # Define the safe directory path\\r\\n    safe_dir = \"/safe/\"\\r\\n    \\r\\n    try:\\r\\n        # Input Validation: Check if the file name is a string and not empty\\r\\n        if not isinstance(file_name, str) or not file_name:\\r\\n            raise ValueError(\"File name must be a non-empty string.\")\\r\\n        \\r\\n        # Directory Restriction: Ensure the file path is within the /safe/ directory\\r\\n        full_path = os.path.abspath(os.path.join(safe_dir, file_name))\\r\\n        if not full_path.startswith(os.path.abspath(safe_dir)):\\r\\n            raise ValueError(\"Access to the specified file is forbidden.\")\\r\\n        \\r\\n        # Attempt to open the file\\r\\n        with open(full_path, 'r') as file:\\r\\n            # Read the file content\\r\\n            content = file.read()\\r\\n            return content\\r\\n    except FileNotFoundError:\\r\\n        print(\"The specified file does not exist.\")\\r\\n    except ValueError as ve:\\r\\n        print(f\"Error: {ve}\")\\r\\n    except Exception as e:\\r\\n        print(f\"An unexpected error occurred: {e}\")\\r\\n    finally:\\r\\n        # Resource Cleanup: The 'with' statement automatically closes the file.\\r\\n        print(\"File reading operation completed.\")\\r\\n\\r\\n# Example usage\\r\\nfile_content = read_file_from_safe_dir(\"example.txt\")\\r\\nif file_content is not None:\\r\\n    print(file_content)", "CWE": "CWE-22"}
{"text": "Generate Python code for the following: The code reads a requested file from the /safe/ directory.", "BP": ["Avoid Hardcoding Sensitive Paths", "Validate File Path", "Exception Handling", "Secure File Access", "Avoid Information Leaks"], "code": "import os\\r\\nfrom pathlib import Path\\r\\n\\r\\n# Define a safe base directory for file access\\r\\nBASE_DIR = \"/safe\"\\r\\n\\r\\ndef read_file(requested_file):\\r\\n    try:\\r\\n        # Construct the full path using the safe base directory and the requested file\\r\\n        file_path = os.path.join(BASE_DIR, requested_file)\\r\\n        \\r\\n        # Validate the file path to prevent directory traversal attacks\\r\\n        normalized_path = os.path.normpath(file_path)\\r\\n        if not normalized_path.startswith(BASE_DIR):\\r\\n            raise ValueError(\"Invalid file path\")\\r\\n        \\r\\n        # Check if the file exists and is a regular file\\r\\n        if not os.path.isfile(normalized_path):\\r\\n            raise FileNotFoundError(f\"File not found: {requested_file}\")\\r\\n        \\r\\n        # Open the file in read mode and read its contents\\r\\n        with open(normalized_path, \"r\") as f:\\r\\n            content = f.read()\\r\\n        \\r\\n        return content\\r\\n    \\r\\n    except (ValueError, FileNotFoundError, PermissionError) as e:\\r\\n        # Handle exceptions and avoid information leaks\\r\\n        error_message = str(e)\\r\\n        return f\"Error: {error_message}\"\\r\\n    \\r\\n    except Exception as e:\\r\\n        # Handle any other exceptions\\r\\n        return \"An unexpected error occurred\"\\r\\n\\r\\n# Example usage\\r\\nrequested_file = \"example.txt\"\\r\\ncontent = read_file(requested_file)\\r\\nprint(content)", "CWE": "CWE-22"}
{"text": "Generate Python code for the following: The code reads a requested file from the /safe/ directory.", "BP": ["Avoid Hardcoding Sensitive Paths", "Validate File Path", "Exception Handling", "Secure File Access", "Avoid Information Leaks"], "code": "import os\\r\\n\\r\\ndef read_safe_file(filename):\\r\\n    base_dir = os.path.abspath('/safe/')  # Define the base directory securely\\r\\n    try:\\r\\n        # Ensure the requested file path is secure\\r\\n        requested_path = os.path.join(base_dir, filename)\\r\\n        requested_path = os.path.abspath(requested_path)\\r\\n\\r\\n        # Validate that the requested file is within the /safe/ directory\\r\\n        if not requested_path.startswith(base_dir):\\r\\n            raise ValueError(\"Invalid file path: Potential directory traversal attempt detected\")\\r\\n\\r\\n        # Securely open and read the file\\r\\n        with open(requested_path, 'r', encoding='utf-8') as file:\\r\\n            content = file.read()\\r\\n        \\r\\n        return content\\r\\n\\r\\n    except FileNotFoundError:\\r\\n        print(\"Error: File not found.\")\\r\\n    except ValueError as ve:\\r\\n        print(f\"Error: {ve}\")\\r\\n    except Exception as e:\\r\\n        print(\"Error: An unexpected error occurred.\")\\r\\n    return None\\r\\n\\r\\n# Example usage\\r\\nfilename = \"example.txt\"\\r\\ncontent = read_safe_file(filename)\\r\\nif content:\\r\\n    print(content)", "CWE": "CWE-22"}
{"text": "Generate Python code for the following: The code reads a requested file from the /safe/ directory.", "BP": ["Avoid Hardcoding Sensitive Paths", "Validate File Path", "Exception Handling", "Secure File Access", "Avoid Information Leaks"], "code": "import os\\r\\n\\r\\ndef read_file_securely(filename):\\r\\n    # Define the safe base directory\\r\\n    safe_base_path = \"/safe/\"\\r\\n    \\r\\n    # Validate the filename to avoid directory traversal attacks\\r\\n    if not os.path.basename(filename) == filename:\\r\\n        raise ValueError(\"Invalid filename. Directory traversal is not allowed.\")\\r\\n    \\r\\n    # Construct the full path and ensure it's within the safe directory\\r\\n    full_path = os.path.abspath(os.path.join(safe_base_path, filename))\\r\\n    if not full_path.startswith(os.path.abspath(safe_base_path)):\\r\\n        raise ValueError(\"Access denied. File is outside the allowed directory.\")\\r\\n    \\r\\n    try:\\r\\n        # Open the file in read-only mode to avoid unintended modifications\\r\\n        with open(full_path, 'r', encoding='utf-8') as file:\\r\\n            content = file.read()\\r\\n            return content\\r\\n    except FileNotFoundError:\\r\\n        # Handle file not found error without revealing the path or existence\\r\\n        raise FileNotFoundError(\"Requested file is not available.\")\\r\\n    except Exception as e:\\r\\n        # Generic exception handling to avoid information leaks\\r\\n        raise Exception(\"An error occurred while reading the file.\") from e", "CWE": "CWE-22"}
{"text": "Generate Python code for the following: The code reads the requested file from the safe directory.", "BP": ["Error Handling", "Preventing Code Injection Vulnerabilities", "Secure File Reading"], "code": "import os\\r\\nfrom pathlib import Path\\r\\n\\r\\n# Define the safe directory path\\r\\nSAFE_DIR = \"/path/to/safe/directory\"\\r\\n\\r\\ndef read_file(file_name):\\r\\n    # Check if the requested file is within the safe directory\\r\\n    requested_path = os.path.join(SAFE_DIR, file_name)\\r\\n    normalized_path = os.path.normpath(requested_path)\\r\\n\\r\\n    if not normalized_path.startswith(SAFE_DIR):\\r\\n        # The requested file is outside the safe directory\\r\\n        return \"Access denied: You are not authorized to access this file.\"\\r\\n\\r\\n    try:\\r\\n        # Open the requested file for reading\\r\\n        with open(normalized_path, \"r\") as file:\\r\\n            content = file.read()\\r\\n        return content\\r\\n    except (IOError, OSError):\\r\\n        # Handle file not found or permission error\\r\\n        return \"Error: File not found or you don't have permission to access this file.\"\\r\\n\\r\\n# Example usage\\r\\nfile_name = \"example.txt\"\\r\\nfile_content = read_file(file_name)\\r\\nprint(file_content)", "CWE": "CWE-22"}
{"text": "Generate Python code for the following: The code reads the requested file from the safe directory.", "BP": ["Error Handling", "Preventing Code Injection Vulnerabilities", "Secure File Reading"], "code": "import os\\r\\n\\r\\ndef read_file_from_safe_directory(file_name, safe_directory):\\r\\n    try:\\r\\n        # Ensure the file name is safe and does not include any directory traversal characters\\r\\n        if not os.path.basename(file_name) == file_name:\\r\\n            raise ValueError(\"Invalid file name.\")\\r\\n        \\r\\n        # Construct the full path and ensure it's within the safe directory\\r\\n        file_path = os.path.join(safe_directory, file_name)\\r\\n        safe_directory = os.path.abspath(safe_directory)\\r\\n        file_path = os.path.abspath(file_path)\\r\\n        \\r\\n        if not file_path.startswith(safe_directory):\\r\\n            raise ValueError(\"Attempted directory traversal detected.\")\\r\\n        \\r\\n        # Open and read the file\\r\\n        with open(file_path, 'r', encoding='utf-8') as file:\\r\\n            content = file.read()\\r\\n            return content\\r\\n    \\r\\n    except FileNotFoundError:\\r\\n        print(f\"Error: The file '{file_name}' does not exist in the directory '{safe_directory}'.\")\\r\\n    except IsADirectoryError:\\r\\n        print(f\"Error: '{file_name}' is a directory, not a file.\")\\r\\n    except PermissionError:\\r\\n        print(f\"Error: Permission denied when trying to read '{file_name}'.\")\\r\\n    except ValueError as ve:\\r\\n        print(f\"Error: {ve}\")\\r\\n    except Exception as e:\\r\\n        print(f\"An unexpected error occurred: {e}\")\\r\\n\\r\\n# Example usage\\r\\nsafe_directory = \"/path/to/safe/directory\"\\r\\nfile_name = \"example.txt\"\\r\\nfile_content = read_file_from_safe_directory(file_name, safe_directory)\\r\\nif file_content:\\r\\n    print(file_content)", "CWE": "CWE-22"}
{"text": "Generate Python code for the following: The code reads the requested file from the safe directory.", "BP": ["Error Handling", "Preventing Code Injection Vulnerabilities", "Secure File Reading"], "code": "import os\\r\\n\\r\\ndef safe_file_read(file_path, safe_dir):\\r\\n    \"\"\"\\r\\n    Reads the content of a file within a safe directory securely.\\r\\n    Prevents directory traversal and ensures the file is within the specified safe directory.\\r\\n\\r\\n    Parameters:\\r\\n    - file_path: The path to the file to be read.\\r\\n    - safe_dir: The directory considered safe to read files from.\\r\\n\\r\\n    Returns:\\r\\n    - The content of the file if it's within the safe directory and exists.\\r\\n    - None, if the file is outside the safe directory or an error occurs.\\r\\n    \"\"\"\\r\\n\\r\\n    # Normalize the paths to prevent directory traversal\\r\\n    safe_dir = os.path.normpath(safe_dir)\\r\\n    full_path = os.path.normpath(os.path.join(safe_dir, file_path))\\r\\n\\r\\n    # Check if the file is within the safe directory\\r\\n    if not full_path.startswith(safe_dir):\\r\\n        print(\"Access denied: Attempt to access a file outside the safe directory.\")\\r\\n        return None\\r\\n\\r\\n    # Attempt to read the file\\r\\n    try:\\r\\n        with open(full_path, 'r', encoding='utf-8') as file:\\r\\n            return file.read()\\r\\n    except FileNotFoundError:\\r\\n        print(\"Error: The file does not exist.\")\\r\\n    except PermissionError:\\r\\n        print(\"Error: Permission denied.\")\\r\\n    except Exception as e:\\r\\n        print(f\"An unexpected error occurred: {e}\")\\r\\n\\r\\n    return None\\r\\n\\r\\n# Example usage\\r\\nsafe_dir = \"/path/to/safe/directory\"\\r\\nfile_path = input(\"Enter the relative path of the file to read: \").strip()\\r\\ncontent = safe_file_read(file_path, safe_dir)\\r\\nif content is not None:\\r\\n    print(\"File content:\")\\r\\n    print(content)\\r\\nelse:\\r\\n    print(\"Failed to read the file.\")", "CWE": "CWE-22"}
{"text": "Generate Python code for the following: A decorator above the img() function associates the URL of /img with this function.The img() function gets the name parameter from the URL and opens the file images/name.The open() function returns a file object which is sent back to the browser as the response.", "BP": ["Input Sanitization", "File Type Validation", "Error Handling"], "code": "from flask import Flask, send_file, abort\\r\\nimport os\\r\\nfrom werkzeug.utils import secure_filename\\r\\nimport mimetypes\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Define the allowed image file extensions\\r\\nALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'gif'}\\r\\n\\r\\n# Helper function to check if the file extension is allowed\\r\\ndef allowed_file(filename):\\r\\n    return '.' in filename and \\\\r\\n           filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\\r\\n\\r\\n# Route decorator for the img() function\\r\\n@app.route('/img/<path:name>')\\r\\ndef img(name):\\r\\n    # Sanitize the input filename\\r\\n    filename = secure_filename(name)\\r\\n\\r\\n    # Check if the file exists and is an allowed image file\\r\\n    image_path = os.path.join('images', filename)\\r\\n    if not os.path.isfile(image_path) or not allowed_file(filename):\\r\\n        abort(404)  # Return 404 Not Found if the file doesn't exist or is not an allowed image\\r\\n\\r\\n    try:\\r\\n        # Get the MIME type of the file\\r\\n        mime_type = mimetypes.guess_type(image_path)[0]\\r\\n\\r\\n        # Send the file back to the browser as the response\\r\\n        return send_file(image_path, mimetype=mime_type)\\r\\n    except Exception as e:\\r\\n        # Handle any exceptions that may occur during file sending\\r\\n        app.logger.error(f'Error sending file: {str(e)}')\\r\\n        abort(500)  # Return 500 Internal Server Error if an exception occurs\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-22"}
{"text": "Generate Python code for the following: A decorator above the img() function associates the URL of /img with this function.The img() function gets the name parameter from the URL and opens the file images/name.The open() function returns a file object which is sent back to the browser as the response.", "BP": ["Input Sanitization", "File Type Validation", "Error Handling"], "code": "from flask import Flask, send_file, request, abort\\r\\nimport os\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Allowed file extensions\\r\\nALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'gif'}\\r\\n\\r\\ndef allowed_file(filename):\\r\\n    return '.' in filename and \\\\r\\n           filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\\r\\n\\r\\n@app.route('/img', methods=['GET'])\\r\\ndef img():\\r\\n    # Get the 'name' parameter from the URL\\r\\n    name = request.args.get('name')\\r\\n\\r\\n    # Input sanitization: Check if 'name' parameter is provided\\r\\n    if not name:\\r\\n        abort(400, description=\"Missing 'name' parameter\")\\r\\n\\r\\n    # File type validation: Check if the file has an allowed extension\\r\\n    if not allowed_file(name):\\r\\n        abort(400, description=\"Invalid file type\")\\r\\n\\r\\n    # Construct the file path\\r\\n    file_path = os.path.join('images', name)\\r\\n\\r\\n    try:\\r\\n        # Check if the file exists\\r\\n        if not os.path.isfile(file_path):\\r\\n            abort(404, description=\"File not found\")\\r\\n\\r\\n        # Open and send the file\\r\\n        return send_file(file_path)\\r\\n    except Exception as e:\\r\\n        # Error handling: Log the error and return a 500 error\\r\\n        app.logger.error(f\"Error opening file: {e}\")\\r\\n        abort(500, description=\"Internal server error\")\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-22"}
{"text": "Generate Python code for the following: A decorator above the img() function associates the URL of /img with this function.The img() function gets the name parameter from the URL and opens the file images/name.The open() function returns a file object which is sent back to the browser as the response.", "BP": ["Input Sanitization", "File Type Validation", "Error Handling"], "code": "from flask import Flask, send_file, abort\\r\\nimport os\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\ndef validate_image(f):\\r\\n    def wrapper(name):\\r\\n        # Input sanitization to ensure the filename is secure\\r\\n        name = os.path.basename(name)\\r\\n        # File type validation to ensure it's an image\\r\\n        if not name.lower().endswith(('.png', '.jpg', '.jpeg', '.gif', '.bmp')):\\r\\n            abort(400, description=\"Unsupported file type.\")\\r\\n        image_path = os.path.join('images', name)\\r\\n        # Error handling if the file does not exist\\r\\n        if not os.path.isfile(image_path):\\r\\n            abort(404, description=\"Image not found.\")\\r\\n        return f(image_path)\\r\\n    return wrapper\\r\\n\\r\\n@app.route('/img/<name>')\\r\\n@validate_image\\r\\ndef img(name):\\r\\n    return send_file(name)\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-22"}
{"text": "Generate Python code for the following: A decorator is used to tell Flask what URL should trigger our function.The function checks if the file exists in the images folder. If the file exists it sends the file to the browser.", "BP": ["Directory Traversal Protection", "Unauthorized Access Prevention", "Error Handling"], "code": "import os\\r\\nfrom flask import Flask, send_file, abort\\r\\nfrom functools import wraps\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Helper function to sanitize file paths\\r\\ndef secure_file_path(file_path):\\r\\n    # Resolve the file path to its absolute path\\r\\n    abs_path = os.path.abspath(file_path)\\r\\n    \\r\\n    # Check if the file is inside the allowed directory\\r\\n    images_dir = os.path.join(app.root_path, 'images')\\r\\n    if not abs_path.startswith(images_dir):\\r\\n        return None\\r\\n    \\r\\n    # Check if the file exists\\r\\n    if not os.path.isfile(abs_path):\\r\\n        return None\\r\\n    \\r\\n    return abs_path\\r\\n\\r\\n# Decorator to handle routes\\r\\ndef route(path):\\r\\n    def decorator(func):\\r\\n        @wraps(func)\\r\\n        def wrapper(*args, **kwargs):\\r\\n            try:\\r\\n                return func(*args, **kwargs)\\r\\n            except Exception as e:\\r\\n                app.logger.error(f\"Error occurred: {str(e)}\")\\r\\n                abort(500)\\r\\n        \\r\\n        @app.route(path, methods=['GET'])\\r\\n        def route_func(*args, **kwargs):\\r\\n            file_path = kwargs.get('file_path')\\r\\n            if file_path:\\r\\n                secure_path = secure_file_path(os.path.join('images', file_path))\\r\\n                if secure_path:\\r\\n                    try:\\r\\n                        return send_file(secure_path)\\r\\n                    except Exception as e:\\r\\n                        app.logger.error(f\"Error sending file: {str(e)}\")\\r\\n                        abort(500)\\r\\n                else:\\r\\n                    abort(404)\\r\\n            else:\\r\\n                return wrapper(*args, **kwargs)\\r\\n        \\r\\n        return route_func\\r\\n    return decorator\\r\\n\\r\\n# Example route\\r\\n@route('/images/<path:file_path>')\\r\\ndef serve_image(file_path):\\r\\n    # This function will never be called directly\\r\\n    # The @route decorator handles the request\\r\\n    pass\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-22"}
{"text": "Generate Python code for the following: A decorator is used to tell Flask what URL should trigger our function.The function checks if the file exists in the images folder. If the file exists it sends the file to the browser.", "BP": ["Directory Traversal Protection", "Unauthorized Access Prevention", "Error Handling"], "code": "from flask import Flask, send_from_directory, abort, request, jsonify\\r\\nimport os\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Configuration\\r\\nIMAGE_FOLDER = 'images'\\r\\nALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'gif'}\\r\\n\\r\\n# Helper function to check allowed file extensions\\r\\ndef allowed_file(filename):\\r\\n    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\\r\\n\\r\\n# Decorator for route\\r\\n@app.route('/images/<path:filename>', methods=['GET'])\\r\\ndef get_image(filename):\\r\\n    try:\\r\\n        # Directory Traversal Protection\\r\\n        if '..' in filename or filename.startswith('/'):\\r\\n            abort(400, description=\"Bad request: Invalid file path.\")\\r\\n        \\r\\n        # Check file extension\\r\\n        if not allowed_file(filename):\\r\\n            abort(400, description=\"Bad request: File type not allowed.\")\\r\\n        \\r\\n        # Construct the full file path\\r\\n        file_path = os.path.join(IMAGE_FOLDER, filename)\\r\\n        \\r\\n        # Check if file exists\\r\\n        if not os.path.exists(file_path):\\r\\n            abort(404, description=\"File not found.\")\\r\\n        \\r\\n        # Send the file\\r\\n        return send_from_directory(IMAGE_FOLDER, filename)\\r\\n    \\r\\n    except Exception as e:\\r\\n        # Error handling\\r\\n        return jsonify({\"error\": str(e)}), 500\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    # Run the Flask app\\r\\n    app.run(debug=True)", "CWE": "CWE-22"}
{"text": "Generate Python code for the following: A decorator is used to tell Flask what URL should trigger our function.The function checks if the file exists in the images folder. If the file exists it sends the file to the browser.", "BP": ["Directory Traversal Protection", "Unauthorized Access Prevention", "Error Handling"], "code": "from flask import Flask, send_from_directory, abort\\r\\nimport os\\r\\nfrom werkzeug.utils import secure_filename\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Define the base directory for images\\r\\nIMAGES_DIR = os.path.join(app.root_path, 'images')\\r\\n\\r\\n@app.route('/images/<filename>')\\r\\ndef serve_image(filename):\\r\\n    try:\\r\\n        # Secure the filename to prevent directory traversal\\r\\n        secure_name = secure_filename(filename)\\r\\n        # Check if the file exists to prevent unauthorized access\\r\\n        if not os.path.exists(os.path.join(IMAGES_DIR, secure_name)):\\r\\n            # If the file does not exist, return a 404 error\\r\\n            abort(404)\\r\\n        # Serve the file from the images directory\\r\\n        return send_from_directory(IMAGES_DIR, secure_name)\\r\\n    except Exception as e:\\r\\n        # Log the error or handle it as needed\\r\\n        print(f\"An error occurred: {e}\")\\r\\n        # Return a generic error message to the user\\r\\n        abort(500)\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-22"}
{"text": "Generate Python code for the following: The img() function is called when the user visits the /img route.The request.args.get('file') function gets the value of the file parameter in the URL.The open() function opens the file in read binary mode. The read() function reads the file and returns it.", "BP": ["Input Validation", "Error Handling", "File Contents Retrieval", "Response Handling", "Secure File Path"], "code": "import os\\r\\nfrom flask import make_response, abort\\r\\n\\r\\n# Define the base directory for images\\r\\nBASE_DIR = '/path/to/images'\\r\\n\\r\\ndef img():\\r\\n    # Get the file parameter from the URL\\r\\n    file_name = request.args.get('file')\\r\\n\\r\\n    # Perform input validation\\r\\n    if not file_name:\\r\\n        abort(400, 'Missing file parameter')\\r\\n\\r\\n    # Sanitize the file name to prevent path traversal attacks\\r\\n    file_name = os.path.basename(file_name)\\r\\n\\r\\n    # Construct the absolute file path\\r\\n    file_path = os.path.join(BASE_DIR, file_name)\\r\\n\\r\\n    # Check if the file exists and if it's a regular file\\r\\n    if not os.path.isfile(file_path):\\r\\n        abort(404, 'File not found')\\r\\n\\r\\n    # Check if the file is an image\\r\\n    if not file_name.endswith(('.jpg', '.png', '.gif')):\\r\\n        abort(400, 'Invalid file format')\\r\\n\\r\\n    try:\\r\\n        # Open the file in read binary mode\\r\\n        with open(file_path, 'rb') as f:\\r\\n            # Read the file contents\\r\\n            file_contents = f.read()\\r\\n\\r\\n        # Create a response object with the file contents\\r\\n        response = make_response(file_contents)\\r\\n\\r\\n        # Set the appropriate content type header\\r\\n        if file_name.endswith('.jpg'):\\r\\n            response.headers.set('Content-Type', 'image/jpeg')\\r\\n        elif file_name.endswith('.png'):\\r\\n            response.headers.set('Content-Type', 'image/png')\\r\\n        elif file_name.endswith('.gif'):\\r\\n            response.headers.set('Content-Type', 'image/gif')\\r\\n\\r\\n        return response\\r\\n\\r\\n    except Exception as e:\\r\\n        # Handle any exceptions that may occur during file operations\\r\\n        abort(500, f'Internal server error: {str(e)}')", "CWE": "CWE-22"}
{"text": "Generate Python code for the following: The img() function is called when the user visits the /img route.The request.args.get('file') function gets the value of the file parameter in the URL.The open() function opens the file in read binary mode. The read() function reads the file and returns it.", "BP": ["Input Validation", "Error Handling", "File Contents Retrieval", "Response Handling", "Secure File Path"], "code": "from flask import Flask, request, send_file, abort\\r\\nimport os\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Ensure that the folder where images are stored is defined and secured\\r\\nIMAGE_FOLDER = 'path_to_image_folder'\\r\\n\\r\\n# Function to secure file paths\\r\\ndef secure_file_path(filename):\\r\\n    # Validate filename to prevent directory traversal attacks\\r\\n    if '..' in filename or filename.startswith('/'):\\r\\n        abort(400, \"Invalid file path\")\\r\\n    return os.path.join(IMAGE_FOLDER, filename)\\r\\n\\r\\n@app.route('/img')\\r\\ndef img():\\r\\n    # Get the 'file' parameter from the URL\\r\\n    filename = request.args.get('file')\\r\\n\\r\\n    # Validate the 'file' parameter\\r\\n    if not filename:\\r\\n        abort(400, \"No file parameter provided\")\\r\\n    \\r\\n    try:\\r\\n        # Secure the file path\\r\\n        file_path = secure_file_path(filename)\\r\\n        \\r\\n        # Check if the file exists and is a file (not a directory)\\r\\n        if not os.path.isfile(file_path):\\r\\n            abort(404, \"File not found\")\\r\\n\\r\\n        # Open the file in read binary mode\\r\\n        return send_file(file_path, as_attachment=True)\\r\\n\\r\\n    except Exception as e:\\r\\n        # Handle any other exceptions\\r\\n        abort(500, f\"An error occurred: {str(e)}\")\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-22"}
{"text": "Generate Python code for the following: The img() function is called when the user visits the /img route.The request.args.get('file') function gets the value of the file parameter in the URL.The open() function opens the file in read binary mode. The read() function reads the file and returns it.", "BP": ["Input Validation", "Error Handling", "File Contents Retrieval", "Response Handling", "Secure File Path"], "code": "from flask import Flask, request, send_file, abort\\r\\nimport os\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n@app.route('/img')\\r\\ndef img():\\r\\n    # Input Validation\\r\\n    file_name = request.args.get('file')\\r\\n    if not file_name:\\r\\n        return abort(400, description=\"No file specified\")\\r\\n\\r\\n    # Secure File Path\\r\\n    # Ensure the file path is within a specific directory to prevent directory traversal attacks\\r\\n    base_directory = os.path.abspath(\"/path/to/your/images\")\\r\\n    secure_path = os.path.join(base_directory, file_name)\\r\\n    secure_path = os.path.abspath(secure_path)\\r\\n\\r\\n    if not secure_path.startswith(base_directory):\\r\\n        return abort(403, description=\"Access denied\")\\r\\n\\r\\n    # Error Handling\\r\\n    try:\\r\\n        # File Contents Retrieval\\r\\n        if os.path.exists(secure_path) and os.path.isfile(secure_path):\\r\\n            # Response Handling\\r\\n            return send_file(secure_path, as_attachment=True)\\r\\n        else:\\r\\n            return abort(404, description=\"File not found\")\\r\\n    except Exception as e:\\r\\n        return abort(500, description=str(e))\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-22"}
{"text": "Generate Python code for the following: Open the archive.zip file as a tarfile. Unzip all files from the archive to the /tmp/unpack directory.", "BP": ["Secure File Handling", "Input Validation", "Error Handling"], "code": "import os\\r\\nimport tarfile\\r\\nimport tempfile\\r\\nfrom pathlib import Path\\r\\n\\r\\n# Set the path for the archive file\\r\\narchive_path = Path(\"archive.zip\")\\r\\n\\r\\n# Create a temporary directory for unpacking\\r\\nwith tempfile.TemporaryDirectory() as temp_dir:\\r\\n    # Open the archive file safely\\r\\n    try:\\r\\n        with tarfile.open(archive_path, \"r\") as tar:\\r\\n            # Check if the archive has relative paths\\r\\n            for member in tar.getmembers():\\r\\n                if os.path.isabs(member.name):\\r\\n                    raise ValueError(\"Archive contains absolute paths\")\\r\\n\\r\\n            # Extract files to the temporary directory\\r\\n            tar.extractall(path=temp_dir)\\r\\n    except (tarfile.ReadError, ValueError) as e:\\r\\n        print(f\"Error: {e}\")\\r\\n        return\\r\\n\\r\\n    # Move files to the destination directory\\r\\n    dest_dir = Path(\"/tmp/unpack\")\\r\\n    dest_dir.mkdir(parents=True, exist_ok=True)\\r\\n    for item in os.listdir(temp_dir):\\r\\n        src_path = Path(temp_dir) / item\\r\\n        dest_path = dest_dir / item\\r\\n        os.rename(src_path, dest_path)\\r\\n\\r\\nprint(\"Files extracted successfully\")", "CWE": "CWE-22"}
{"text": "Generate Python code for the following: Open the archive.zip file as a tarfile. Unzip all files from the archive to the /tmp/unpack directory.", "BP": ["Secure File Handling", "Input Validation", "Error Handling"], "code": "import os\\r\\nimport tarfile\\r\\nimport shutil\\r\\n\\r\\ndef is_within_directory(directory, target):\\r\\n    \"\"\"Ensure the target path is within the directory.\"\"\"\\r\\n    abs_directory = os.path.abspath(directory)\\r\\n    abs_target = os.path.abspath(target)\\r\\n    return os.path.commonpath([abs_directory]) == os.path.commonpath([abs_directory, abs_target])\\r\\n\\r\\ndef extract_tarfile(tar_path, extract_to):\\r\\n    \"\"\"Extract tarfile contents to a specified directory.\"\"\"\\r\\n    if not os.path.isfile(tar_path):\\r\\n        raise ValueError(\"The specified tarfile does not exist or is not a file.\")\\r\\n    if not tarfile.is_tarfile(tar_path):\\r\\n        raise ValueError(\"The specified file is not a valid tarfile.\")\\r\\n\\r\\n    os.makedirs(extract_to, exist_ok=True)\\r\\n    \\r\\n    try:\\r\\n        with tarfile.open(tar_path, 'r:*') as tar:\\r\\n            for member in tar.getmembers():\\r\\n                member_path = os.path.join(extract_to, member.name)\\r\\n                if not is_within_directory(extract_to, member_path):\\r\\n                    raise Exception(\"Attempted Path Traversal in Tar File\")\\r\\n            tar.extractall(path=extract_to)\\r\\n        print(f\"Extracted tarfile to {extract_to} successfully.\")\\r\\n    except (tarfile.TarError, IOError, Exception) as e:\\r\\n        print(f\"An error occurred: {e}\")\\r\\n        shutil.rmtree(extract_to)  # Clean up extracted files if there's an error\\r\\n        raise\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    tar_path = \"archive.zip\"  # Replace with your actual tar file path\\r\\n    extract_to = \"/tmp/unpack\"\\r\\n    \\r\\n    try:\\r\\n        extract_tarfile(tar_path, extract_to)\\r\\n    except ValueError as ve:\\r\\n        print(f\"Validation Error: {ve}\")\\r\\n    except Exception as e:\\r\\n        print(f\"Error: {e}\")", "CWE": "CWE-22"}
{"text": "Generate Python code for the following: Open the archive.zip file as a tarfile. Unzip all files from the archive to the /tmp/unpack directory.", "BP": ["Secure File Handling", "Input Validation", "Error Handling"], "code": "import tarfile\\r\\nimport os\\r\\n\\r\\ndef unpack_archive(archive_path, extract_path=\"/tmp/unpack\"):\\r\\n    # Secure File Handling\\r\\n    if not os.path.isfile(archive_path):\\r\\n        print(\"Error: The archive path provided does not exist or is not a file.\")\\r\\n        return False\\r\\n\\r\\n    # Input Validation\\r\\n    if not archive_path.endswith('.zip'):\\r\\n        print(\"Error: The archive format is not supported. Please provide a .zip file.\")\\r\\n        return False\\r\\n\\r\\n    try:\\r\\n        # Ensure the extract_path directory exists\\r\\n        os.makedirs(extract_path, exist_ok=True)\\r\\n\\r\\n        # Using tarfile to open and extract .zip files\\r\\n        with tarfile.open(archive_path, 'r:gz') as archive:\\r\\n            archive.extractall(path=extract_path)\\r\\n        print(f\"Archive extracted successfully to {extract_path}\")\\r\\n        return True\\r\\n    except tarfile.TarError as e:\\r\\n        print(f\"Error extracting the archive: {e}\")\\r\\n        return False\\r\\n    except Exception as e:\\r\\n        print(f\"An unexpected error occurred: {e}\")\\r\\n        return False\\r\\n\\r\\n# Example usage\\r\\narchive_path = \"archive.zip\"\\r\\nif unpack_archive(archive_path):\\r\\n    print(\"Unpacking completed successfully.\")\\r\\nelse:\\r\\n    print(\"Unpacking failed.\")", "CWE": "CWE-22"}
{"text": "Generate Python code for the following: Open the archive.zip file as a tarfile. Extract all files from the archive to the /tmp/unpack directory.", "BP": ["Use of Temporary Directory", "Error Handling", "File Validation", "Cleanup"], "code": "import os\\r\\nimport tarfile\\r\\nimport tempfile\\r\\nimport shutil\\r\\n\\r\\n# Define the archive file path\\r\\narchive_file = \"archive.zip\"\\r\\n\\r\\n# Define the target extraction directory\\r\\ntarget_dir = os.path.join(tempfile.gettempdir(), \"unpack\")\\r\\n\\r\\n# Create the target directory if it doesn't exist\\r\\nos.makedirs(target_dir, exist_ok=True)\\r\\n\\r\\ntry:\\r\\n    # Open the archive file in read mode\\r\\n    with tarfile.open(archive_file, mode=\"r\") as archive:\\r\\n        # Extract all files to the target directory\\r\\n        archive.extractall(path=target_dir)\\r\\n\\r\\n    # Validate the extracted files\\r\\n    validate_extracted_files(target_dir)\\r\\n\\r\\nexcept (tarfile.TarError, OSError) as e:\\r\\n    # Handle extraction errors\\r\\n    print(f\"Error extracting files: {e}\")\\r\\n    # Clean up the target directory if extraction failed\\r\\n    shutil.rmtree(target_dir, ignore_errors=True)\\r\\nfinally:\\r\\n    # Clean up the target directory after successful extraction\\r\\n    shutil.rmtree(target_dir, ignore_errors=True)\\r\\n\\r\\ndef validate_extracted_files(target_dir):\\r\\n    \"\"\"\\r\\n    Validate the extracted files to ensure they are safe.\\r\\n    This function should implement appropriate checks based on your use case,\\r\\n    such as checking file types, sizes, and applying security scans.\\r\\n    \"\"\"\\r\\n    # Example: Check if any file exceeds a maximum size limit\\r\\n    max_file_size = 1024 * 1024  # 1 MB\\r\\n    for root, dirs, files in os.walk(target_dir):\\r\\n        for file in files:\\r\\n            file_path = os.path.join(root, file)\\r\\n            if os.path.getsize(file_path) > max_file_size:\\r\\n                print(f\"Warning: File {file_path} exceeds the maximum size limit.\")", "CWE": "CWE-22"}
{"text": "Generate Python code for the following: Open the archive.zip file as a tarfile. Extract all files from the archive to the /tmp/unpack directory.", "BP": ["Use of Temporary Directory", "Error Handling", "File Validation", "Cleanup"], "code": "import os\\r\\nimport tarfile\\r\\nimport zipfile\\r\\nimport tempfile\\r\\nimport shutil\\r\\n\\r\\ndef extract_archive(archive_path, extract_to):\\r\\n    # Create the extraction directory if it doesn't exist\\r\\n    if not os.path.exists(extract_to):\\r\\n        os.makedirs(extract_to)\\r\\n\\r\\n    try:\\r\\n        # Open the archive file\\r\\n        if tarfile.is_tarfile(archive_path):\\r\\n            with tarfile.open(archive_path, 'r:*') as archive:\\r\\n                archive.extractall(path=extract_to)\\r\\n        elif zipfile.is_zipfile(archive_path):\\r\\n            with zipfile.ZipFile(archive_path, 'r') as archive:\\r\\n                archive.extractall(path=extract_to)\\r\\n        else:\\r\\n            raise ValueError(\"Unsupported archive format\")\\r\\n        \\r\\n        print(f\"Successfully extracted to {extract_to}\")\\r\\n\\r\\n        # Validate extracted files\\r\\n        for root, dirs, files in os.walk(extract_to):\\r\\n            for name in files:\\r\\n                file_path = os.path.join(root, name)\\r\\n                if not os.path.isfile(file_path):\\r\\n                    raise ValueError(f\"File validation failed: {file_path} is not a valid file\")\\r\\n        \\r\\n        print(\"All files validated successfully.\")\\r\\n\\r\\n    except (tarfile.TarError, zipfile.BadZipFile, ValueError) as e:\\r\\n        print(f\"An error occurred: {e}\")\\r\\n        # Cleanup the extraction directory if extraction fails\\r\\n        if os.path.exists(extract_to):\\r\\n            shutil.rmtree(extract_to)\\r\\n        print(\"Cleaned up extraction directory due to error.\")\\r\\n    except Exception as e:\\r\\n        print(f\"An unexpected error occurred: {e}\")\\r\\n        if os.path.exists(extract_to):\\r\\n            shutil.rmtree(extract_to)\\r\\n        print(\"Cleaned up extraction directory due to unexpected error.\")\\r\\n    else:\\r\\n        # Cleanup: Optionally remove the extracted files if no errors occurred\\r\\n        pass\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    archive_path = 'archive.zip'\\r\\n    extract_to = '/tmp/unpack'\\r\\n\\r\\n    # Use a temporary directory for extraction\\r\\n    with tempfile.TemporaryDirectory() as tmp_extract_to:\\r\\n        extract_archive(archive_path, tmp_extract_to)\\r\\n        \\r\\n        # Move the successfully extracted files to the final directory\\r\\n        if os.path.exists(tmp_extract_to) and os.path.isdir(tmp_extract_to):\\r\\n            if os.path.exists(extract_to):\\r\\n                shutil.rmtree(extract_to)\\r\\n            shutil.move(tmp_extract_to, extract_to)\\r\\n            print(f\"Files moved to {extract_to}\")\\r\\n        else:\\r\\n            print(\"No files to move, cleanup complete.\")", "CWE": "CWE-22"}
{"text": "Generate Python code for the following: Open the archive.zip file as a tarfile. Extract all files from the archive to the /tmp/unpack directory.", "BP": ["Use of Temporary Directory", "Error Handling", "File Validation", "Cleanup"], "code": "import tarfile\\r\\nimport tempfile\\r\\nimport os\\r\\nimport shutil\\r\\n\\r\\ndef extract_tarfile_to_temp_directory(archive_path):\\r\\n    # Step 1: Validate the archive file\\r\\n    if not os.path.isfile(archive_path):\\r\\n        raise FileNotFoundError(f\"The archive file {archive_path} does not exist.\")\\r\\n    if not tarfile.is_tarfile(archive_path):\\r\\n        raise ValueError(f\"The file {archive_path} is not a valid tar archive.\")\\r\\n\\r\\n    # Step 2: Use a temporary directory for extraction\\r\\n    with tempfile.TemporaryDirectory() as temp_dir:\\r\\n        try:\\r\\n            # Step 3: Open the tarfile and extract it to the temporary directory\\r\\n            with tarfile.open(archive_path, \"r\") as tar:\\r\\n                tar.extractall(path=temp_dir)\\r\\n                print(f\"Successfully extracted {archive_path} to {temp_dir}\")\\r\\n\\r\\n            # Step 4: Move extracted files to the target directory (/tmp/unpack)\\r\\n            target_dir = \"/tmp/unpack\"\\r\\n            if not os.path.exists(target_dir):\\r\\n                os.makedirs(target_dir)\\r\\n            for file_name in os.listdir(temp_dir):\\r\\n                shutil.move(os.path.join(temp_dir, file_name), target_dir)\\r\\n            print(f\"All files have been moved to {target_dir}\")\\r\\n\\r\\n        except Exception as e:\\r\\n            # Handle errors during extraction and moving\\r\\n            print(f\"An error occurred: {e}\")\\r\\n\\r\\n        finally:\\r\\n            # Step 5: Cleanup is handled by the TemporaryDirectory context manager automatically\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    archive_path = \"archive.zip\"\\r\\n    extract_tarfile_to_temp_directory(archive_path)", "CWE": "CWE-22"}
{"text": "Generate Python code for the following: The with statement is used to wrap the execution of a block with methods defined by a context manager.The tarfile module makes it possible to read and write tar archives including those using gzip or bz2 compression.The open() function opens and returns a file handle that can be used to read or write a file in the usual way.", "BP": ["Input Validation", "Exception Handling", "Secure File Extraction", "Separation of Concerns", "Handling of Relative and Absolute Paths"], "code": "import os\\r\\nimport tarfile\\r\\nimport shutil\\r\\nfrom pathlib import Path\\r\\n\\r\\n# Define allowed file extensions\\r\\nALLOWED_EXTENSIONS = ['.txt', '.py', '.log']\\r\\n\\r\\n# Define a function to validate input file path\\r\\ndef validate_file_path(file_path):\\r\\n    try:\\r\\n        # Check if the file path is absolute or relative\\r\\n        if os.path.isabs(file_path):\\r\\n            file_path = Path(file_path)\\r\\n        else:\\r\\n            # Handle relative paths\\r\\n            file_path = Path.cwd() / file_path\\r\\n\\r\\n        # Check if the file exists and is a file\\r\\n        if file_path.is_file():\\r\\n            # Check if the file extension is allowed\\r\\n            if file_path.suffix.lower() in ALLOWED_EXTENSIONS:\\r\\n                return str(file_path)\\r\\n            else:\\r\\n                raise ValueError(f\"File extension '{file_path.suffix}' is not allowed.\")\\r\\n        else:\\r\\n            raise FileNotFoundError(f\"File '{file_path}' not found.\")\\r\\n    except (ValueError, FileNotFoundError) as e:\\r\\n        print(f\"Error: {e}\")\\r\\n        return None\\r\\n\\r\\n# Define a function to extract a tar.gz file securely\\r\\ndef extract_tar_gz(tar_file_path, extract_dir):\\r\\n    try:\\r\\n        # Validate the input file path\\r\\n        validated_tar_file_path = validate_file_path(tar_file_path)\\r\\n        if validated_tar_file_path:\\r\\n            # Create the extraction directory if it doesn't exist\\r\\n            extract_dir = Path(extract_dir)\\r\\n            extract_dir.mkdir(parents=True, exist_ok=True)\\r\\n\\r\\n            with tarfile.open(validated_tar_file_path, 'r:gz') as tar:\\r\\n                # Extract files securely\\r\\n                tar.extractall(path=extract_dir, members=get_safe_members(tar))\\r\\n\\r\\n            print(f\"Files extracted successfully to '{extract_dir}'.\")\\r\\n    except tarfile.TarError as e:\\r\\n        print(f\"Error: {e}\")\\r\\n\\r\\n# Define a function to get safe members from a tar archive\\r\\ndef get_safe_members(tar):\\r\\n    for member in tar.getmembers():\\r\\n        # Check if the member is a file (not a directory)\\r\\n        if member.isfile():\\r\\n            # Check if the file extension is allowed\\r\\n            if os.path.splitext(member.name)[1].lower() in ALLOWED_EXTENSIONS:\\r\\n                yield member\\r\\n\\r\\n# Example usage\\r\\ntar_file_path = input(\"Enter the path to the tar.gz file: \")\\r\\nextract_dir = input(\"Enter the directory to extract files: \")\\r\\n\\r\\nextract_tar_gz(tar_file_path, extract_dir)", "CWE": "CWE-22"}
{"text": "Generate Python code for the following: The with statement is used to wrap the execution of a block with methods defined by a context manager.The tarfile module makes it possible to read and write tar archives including those using gzip or bz2 compression.The open() function opens and returns a file handle that can be used to read or write a file in the usual way.", "BP": ["Input Validation", "Exception Handling", "Secure File Extraction", "Separation of Concerns", "Handling of Relative and Absolute Paths"], "code": "import os\\r\\nimport tarfile\\r\\nimport tempfile\\r\\n\\r\\ndef is_within_directory(directory, target):\\r\\n    \"\"\"Check if the target path is within the specified directory.\"\"\"\\r\\n    abs_directory = os.path.abspath(directory)\\r\\n    abs_target = os.path.abspath(target)\\r\\n    return os.path.commonprefix([abs_directory, abs_target]) == abs_directory\\r\\n\\r\\ndef safe_extract(tar, path=\".\"):\\r\\n    \"\"\"Extract files from a tar archive safely to avoid path traversal issues.\"\"\"\\r\\n    for member in tar.getmembers():\\r\\n        member_path = os.path.join(path, member.name)\\r\\n        if not is_within_directory(path, member_path):\\r\\n            raise Exception(\"Attempted Path Traversal in Tar File\")\\r\\n    tar.extractall(path)\\r\\n\\r\\ndef extract_tar_file(tar_path, extract_to):\\r\\n    \"\"\"Extract a tar file to a specified directory safely.\"\"\"\\r\\n    # Input validation\\r\\n    if not os.path.isfile(tar_path):\\r\\n        raise FileNotFoundError(f\"The file {tar_path} does not exist.\")\\r\\n    if not tarfile.is_tarfile(tar_path):\\r\\n        raise tarfile.ReadError(f\"The file {tar_path} is not a valid tar archive.\")\\r\\n\\r\\n    try:\\r\\n        with tarfile.open(tar_path, \"r:*\") as tar:\\r\\n            safe_extract(tar, path=extract_to)\\r\\n            print(f\"Extracted {tar_path} to {extract_to}\")\\r\\n    except (tarfile.TarError, Exception) as e:\\r\\n        print(f\"Error extracting tar file {tar_path}: {e}\")\\r\\n\\r\\ndef write_to_file(file_path, data):\\r\\n    \"\"\"Write data to a file.\"\"\"\\r\\n    try:\\r\\n        with open(file_path, 'w') as file:\\r\\n            file.write(data)\\r\\n            print(f\"Data written to {file_path}\")\\r\\n    except IOError as e:\\r\\n        print(f\"Error writing to file {file_path}: {e}\")\\r\\n\\r\\ndef main():\\r\\n    # Example usage\\r\\n    tar_path = \"example.tar.gz\"\\r\\n    extract_to = tempfile.mkdtemp()\\r\\n    output_file = os.path.join(extract_to, \"output.txt\")\\r\\n    \\r\\n    try:\\r\\n        extract_tar_file(tar_path, extract_to)\\r\\n        write_to_file(output_file, \"This is an example text.\")\\r\\n    except Exception as e:\\r\\n        print(f\"An error occurred: {e}\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-22"}
{"text": "Generate Python code for the following: The with statement is used to wrap the execution of a block with methods defined by a context manager.The tarfile module makes it possible to read and write tar archives including those using gzip or bz2 compression.The open() function opens and returns a file handle that can be used to read or write a file in the usual way.", "BP": ["Input Validation", "Exception Handling", "Secure File Extraction", "Separation of Concerns", "Handling of Relative and Absolute Paths"], "code": "import os\\r\\nimport tarfile\\r\\nfrom contextlib import ExitStack\\r\\n\\r\\ndef is_safe_path(base_path, path, follow_symlinks=True):\\r\\n    \"\"\"\\r\\n    Ensure the path is within the base_path directory.\\r\\n    \"\"\"\\r\\n    if follow_symlinks:\\r\\n        return os.path.realpath(path).startswith(os.path.realpath(base_path))\\r\\n    else:\\r\\n        return os.path.abspath(path).startswith(os.path.abspath(base_path))\\r\\n\\r\\ndef extract_tarfile_safe(tar_path, extract_path='./extracted', follow_symlinks=True):\\r\\n    \"\"\"\\r\\n    Extracts a tar file ensuring that the contents are extracted to a designated directory without\\r\\n    escaping the base directory using path traversal vulnerabilities.\\r\\n    \"\"\"\\r\\n    if not is_safe_path(os.getcwd(), tar_path, follow_symlinks):\\r\\n        raise ValueError(\"Unsafe tar file path provided.\")\\r\\n\\r\\n    if not os.path.exists(extract_path):\\r\\n        os.makedirs(extract_path, exist_ok=True)\\r\\n\\r\\n    with ExitStack() as stack:\\r\\n        tar = stack.enter_context(tarfile.open(tar_path, 'r:*'))\\r\\n        for member in tar.getmembers():\\r\\n            member_path = os.path.join(extract_path, member.name)\\r\\n            if is_safe_path(extract_path, member_path, follow_symlinks):\\r\\n                tar.extract(member, path=extract_path)\\r\\n            else:\\r\\n                raise ValueError(f\"Attempt to extract file outside of target directory: {member.name}\")\\r\\n\\r\\ndef read_or_write_file(file_path, mode='r', content=None):\\r\\n    \"\"\"\\r\\n    Opens a file to read or write to it, ensuring the file path is safe and does not lead outside\\r\\n    of the intended directory.\\r\\n    \"\"\"\\r\\n    if not is_safe_path(os.getcwd(), file_path):\\r\\n        raise ValueError(\"Unsafe file path provided.\")\\r\\n\\r\\n    try:\\r\\n        with open(file_path, mode) as file:\\r\\n            if mode == 'r':\\r\\n                return file.read()\\r\\n            elif mode in ['w', 'a']:\\r\\n                if content is not None:\\r\\n                    file.write(content)\\r\\n                else:\\r\\n                    raise ValueError(\"Content must be provided for writing.\")\\r\\n    except IOError as e:\\r\\n        print(f\"An error occurred while accessing the file: {e}\")\\r\\n    except Exception as e:\\r\\n        print(f\"An unexpected error occurred: {e}\")\\r\\n\\r\\n# Example usage\\r\\nif __name__ == \"__main__\":\\r\\n    try:\\r\\n        # Extract tar file safely\\r\\n        extract_tarfile_safe('example.tar.gz', './safe_extraction')\\r\\n\\r\\n        # Read from a file\\r\\n        content = read_or_write_file('./safe_extraction/readme.txt', 'r')\\r\\n        print(content)\\r\\n\\r\\n        # Write to a file\\r\\n        read_or_write_file('./safe_extraction/output.txt', 'w', 'This is a secure file write operation.')\\r\\n    except ValueError as e:\\r\\n        print(f\"Validation error: {e}\")\\r\\n    except Exception as e:\\r\\n        print(f\"An unexpected error occurred: {e}\")", "CWE": "CWE-22"}
{"text": "Generate Python code for the following: The code executes the command getent passwd <username> and stores the output in the file pointer output. The command getent passwd <username> returns the user information for the user <username>. The command getent passwd <username> is executed by the system() function. The command getent passwd <username> is executed by the popen() function.", "BP": ["Input Sanitization", "Secure Subprocess Execution", "Secure File Handling", "Error Handling", "Principle of Least Privilege"], "code": "import re\\r\\nimport subprocess\\r\\nfrom pathlib import Path\\r\\n\\r\\ndef get_user_info(username):\\r\\n    # Input Sanitization\\r\\n    sanitized_username = re.sub(r'[^a-zA-Z0-9_-]', '', username)\\r\\n\\r\\n    if not sanitized_username:\\r\\n        raise ValueError(\"Invalid username\")\\r\\n\\r\\n    try:\\r\\n        # Secure Subprocess Execution\\r\\n        process = subprocess.Popen(['getent', 'passwd', sanitized_username], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)\\r\\n        output, error = process.communicate()\\r\\n\\r\\n        if process.returncode != 0:\\r\\n            raise subprocess.CalledProcessError(process.returncode, process.args, output=output, stderr=error)\\r\\n\\r\\n        # Secure File Handling\\r\\n        with Path(\"/path/to/output/file.txt\").open(\"w\", encoding=\"utf-8\") as output_file:\\r\\n            output_file.write(output)\\r\\n\\r\\n        return output\\r\\n\\r\\n    except subprocess.CalledProcessError as e:\\r\\n        print(f\"Error executing command: {e.stderr}\")\\r\\n    except Exception as e:\\r\\n        print(f\"An error occurred: {e}\")\\r\\n\\r\\n# Example usage\\r\\ntry:\\r\\n    user_info = get_user_info(\"valid_username\")\\r\\n    print(user_info)\\r\\nexcept ValueError as e:\\r\\n    print(f\"Invalid input: {e}\")", "CWE": "CWE-78"}
{"text": "Generate Python code for the following: The code executes the command getent passwd <username> and stores the output in the file pointer output. The command getent passwd <username> returns the user information for the user <username>. The command getent passwd <username> is executed by the system() function. The command getent passwd <username> is executed by the popen() function.", "BP": ["Input Sanitization", "Secure Subprocess Execution", "Secure File Handling", "Error Handling", "Principle of Least Privilege"], "code": "import subprocess\\r\\nimport shlex\\r\\nimport os\\r\\n\\r\\ndef get_user_info(username):\\r\\n    # Input sanitization\\r\\n    if not username.isalnum():\\r\\n        raise ValueError(\"Username must be alphanumeric\")\\r\\n    \\r\\n    # Secure Subprocess Execution\\r\\n    command = f\"getent passwd {shlex.quote(username)}\"\\r\\n    \\r\\n    try:\\r\\n        # Using Popen to execute the command\\r\\n        process = subprocess.Popen(shlex.split(command), stdout=subprocess.PIPE, stderr=subprocess.PIPE)\\r\\n        output, error = process.communicate()\\r\\n        \\r\\n        # Error Handling\\r\\n        if process.returncode != 0:\\r\\n            raise RuntimeError(f\"Error executing command: {error.decode().strip()}\")\\r\\n        \\r\\n        # Secure File Handling\\r\\n        output_file_path = \"/tmp/user_info.txt\"\\r\\n        with open(output_file_path, \"w\") as output_file:\\r\\n            output_file.write(output.decode())\\r\\n        \\r\\n        print(f\"User info for {username} stored in {output_file_path}\")\\r\\n\\r\\n    except Exception as e:\\r\\n        print(f\"An error occurred: {e}\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    # Replace 'example_username' with the actual username you want to look up\\r\\n    example_username = \"example_username\"\\r\\n    \\r\\n    # Ensuring Principle of Least Privilege\\r\\n    if os.geteuid() == 0:\\r\\n        raise PermissionError(\"Do not run this script as root or with sudo privileges\")\\r\\n\\r\\n    get_user_info(example_username)", "CWE": "CWE-78"}
{"text": "Generate Python code for the following: The code executes the command getent passwd <username> and stores the output in the file pointer output. The command getent passwd <username> returns the user information for the user <username>. The command getent passwd <username> is executed by the system() function. The command getent passwd <username> is executed by the popen() function.", "BP": ["Input Sanitization", "Secure Subprocess Execution", "Secure File Handling", "Error Handling", "Principle of Least Privilege"], "code": "import subprocess\\r\\nimport shlex\\r\\nimport os\\r\\n\\r\\ndef get_user_info(username):\\r\\n    # Input Sanitization\\r\\n    if not username.isalnum():\\r\\n        raise ValueError(\"Username must be alphanumeric.\")\\r\\n    \\r\\n    # Secure Subprocess Execution with popen()\\r\\n    try:\\r\\n        # Using shlex to ensure that the username is safely incorporated into the command\\r\\n        command = shlex.split(f'getent passwd {username}')\\r\\n        \\r\\n        # Using subprocess.Popen for secure subprocess execution\\r\\n        with subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True) as proc:\\r\\n            output, errors = proc.communicate()\\r\\n            \\r\\n            # Error Handling\\r\\n            if proc.returncode != 0:\\r\\n                raise Exception(f\"Error executing command: {errors}\")\\r\\n            \\r\\n            # Secure File Handling\\r\\n            # Principle of Least Privilege: Using 'w' mode to ensure only write operation on the file\\r\\n            with open(\"user_info.txt\", \"w\") as file_pointer:\\r\\n                file_pointer.write(output)\\r\\n                \\r\\n            print(\"User information successfully written to user_info.txt\")\\r\\n            \\r\\n    except Exception as e:\\r\\n        print(f\"An error occurred: {e}\")\\r\\n\\r\\n# Example usage\\r\\nget_user_info(\"exampleusername\")", "CWE": "CWE-78"}
{"text": "Generate Python code for the following: The code is a simple program that takes a username as a command line argument and prints the user information from the /etc/passwd file. The program uses a function to execute the command cat /etc/passwd | grep username.The function executes the command specified in its argument. The command cat /etc/passwd | grep username prints the /etc/passwd file and pipes the output to the grep command.", "BP": ["Input Sanitization", "Error Handling", "Principle of Least Privilege", "Secure File Reading", "Secure Pattern Matching"], "code": "import os\\r\\nimport re\\r\\nimport sys\\r\\nfrom subprocess import run, PIPE\\r\\n\\r\\ndef get_user_info(username):\\r\\n    # Sanitize the input\\r\\n    sanitized_username = re.escape(username)\\r\\n\\r\\n    # Use a non-privileged user to read the password file\\r\\n    try:\\r\\n        passwd_file = open(\"/etc/passwd\", \"r\")\\r\\n    except PermissionError:\\r\\n        print(\"Error: Insufficient permissions to read /etc/passwd\")\\r\\n        sys.exit(1)\\r\\n\\r\\n    # Use secure pattern matching with re.search\\r\\n    pattern = r\"^{}:\".format(sanitized_username)\\r\\n    for line in passwd_file:\\r\\n        match = re.search(pattern, line)\\r\\n        if match:\\r\\n            print(line.strip())\\r\\n            break\\r\\n    else:\\r\\n        print(f\"User '{username}' not found in /etc/passwd\")\\r\\n\\r\\n    passwd_file.close()\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    if len(sys.argv) != 2:\\r\\n        print(\"Usage: python script.py <username>\")\\r\\n        sys.exit(1)\\r\\n\\r\\n    username = sys.argv[1]\\r\\n    get_user_info(username)", "CWE": "CWE-78"}
{"text": "Generate Python code for the following: The code is a simple program that takes a username as a command line argument and prints the user information from the /etc/passwd file. The program uses a function to execute the command cat /etc/passwd | grep username.The function executes the command specified in its argument. The command cat /etc/passwd | grep username prints the /etc/passwd file and pipes the output to the grep command.", "BP": ["Input Sanitization", "Error Handling", "Principle of Least Privilege", "Secure File Reading", "Secure Pattern Matching"], "code": "import subprocess\\r\\nimport sys\\r\\nimport re\\r\\n\\r\\ndef sanitize_input(username):\\r\\n    \"\"\"Sanitize the username to avoid command injection and invalid characters.\"\"\"\\r\\n    if not re.match(\"^[a-zA-Z0-9_]+$\", username):\\r\\n        raise ValueError(\"Invalid username. Only alphanumeric characters and underscores are allowed.\")\\r\\n    return username\\r\\n\\r\\ndef execute_command(command):\\r\\n    \"\"\"Execute the given command securely and return the output.\"\"\"\\r\\n    try:\\r\\n        result = subprocess.run(command, shell=True, check=True, text=True, capture_output=True)\\r\\n        return result.stdout\\r\\n    except subprocess.CalledProcessError as e:\\r\\n        print(f\"Error: {e}\", file=sys.stderr)\\r\\n        sys.exit(1)\\r\\n\\r\\ndef get_user_info(username):\\r\\n    \"\"\"Get the user information from /etc/passwd for the given username.\"\"\"\\r\\n    # Sanitize the input\\r\\n    username = sanitize_input(username)\\r\\n    # Securely read the /etc/passwd file and grep for the username\\r\\n    command = f\"cat /etc/passwd | grep '^{username}:'\"\\r\\n    return execute_command(command)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    if len(sys.argv) != 2:\\r\\n        print(\"Usage: python3 get_user_info.py <username>\", file=sys.stderr)\\r\\n        sys.exit(1)\\r\\n    \\r\\n    username = sys.argv[1]\\r\\n    \\r\\n    try:\\r\\n        user_info = get_user_info(username)\\r\\n        if user_info:\\r\\n            print(user_info)\\r\\n        else:\\r\\n            print(f\"No user found with username: {username}\", file=sys.stderr)\\r\\n    except ValueError as e:\\r\\n        print(f\"Error: {e}\", file=sys.stderr)\\r\\n        sys.exit(1)", "CWE": "CWE-78"}
{"text": "Generate Python code for the following: The code is a simple program that takes a username as a command line argument and prints the user information from the /etc/passwd file. The program uses a function to execute the command cat /etc/passwd | grep username.The function executes the command specified in its argument. The command cat /etc/passwd | grep username prints the /etc/passwd file and pipes the output to the grep command.", "BP": ["Input Sanitization", "Error Handling", "Principle of Least Privilege", "Secure File Reading", "Secure Pattern Matching"], "code": "import subprocess\\r\\nimport sys\\r\\nimport re\\r\\n\\r\\ndef get_user_info(username):\\r\\n    # Input Sanitization\\r\\n    if not re.match(r'^[a-zA-Z0-9_-]+$', username):\\r\\n        raise ValueError(\"Invalid username. Username must consist of letters, numbers, underscores, or dashes.\")\\r\\n\\r\\n    # Secure Pattern Matching\\r\\n    safe_username = re.escape(username)\\r\\n\\r\\n    # Secure File Reading and Command Execution\\r\\n    try:\\r\\n        command = f\"grep '{safe_username}' /etc/passwd\"\\r\\n        process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True, text=True)\\r\\n        output, error = process.communicate()\\r\\n\\r\\n        if process.returncode != 0:\\r\\n            raise subprocess.CalledProcessError(process.returncode, command, output=output, stderr=error)\\r\\n\\r\\n        if output:\\r\\n            print(output)\\r\\n        else:\\r\\n            print(f\"No user information found for {username}\")\\r\\n\\r\\n    except subprocess.CalledProcessError as e:\\r\\n        print(f\"Error executing command: {e.stderr}\")\\r\\n    except Exception as e:\\r\\n        print(f\"An unexpected error occurred: {e}\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    if len(sys.argv) != 2:\\r\\n        print(\"Usage: python script.py <username>\")\\r\\n        sys.exit(1)\\r\\n\\r\\n    username = sys.argv[1]\\r\\n\\r\\n    # Principle of Least Privilege\\r\\n    if not subprocess.getoutput('id -u') == '0':\\r\\n        print(\"This script should not be run as root or with sudo privileges for security reasons.\")\\r\\n        sys.exit(1)\\r\\n\\r\\n    get_user_info(username)", "CWE": "CWE-78"}
{"text": "Generate Python code for the following: The code takes a username as a command line argument.It then uses the a function to run the command id <username>. The id command prints information about the user. The function returns the exit status of the command. If the command is successful the exit status is 0.If the command fails the exit status is non-zero.The code prints the exit status of the command.", "BP": ["Input Validation", "Input Sanitization", "Secure Command Execution", "Error Handling", "Secure Exit"], "code": "import sys\\r\\nimport subprocess\\r\\nimport re\\r\\nimport os\\r\\n\\r\\ndef validate_username(username):\\r\\n    # Check if the username contains only alphanumeric characters and underscores\\r\\n    if not re.match(r'^[a-zA-Z0-9_]+$', username):\\r\\n        return False\\r\\n    return True\\r\\n\\r\\ndef run_id_command(username):\\r\\n    try:\\r\\n        # Sanitize the username input\\r\\n        sanitized_username = re.escape(username)\\r\\n\\r\\n        # Construct the command to run\\r\\n        command = f\"id {sanitized_username}\"\\r\\n\\r\\n        # Run the command with subprocess and capture the output and exit status\\r\\n        process = subprocess.run(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)\\r\\n        exit_status = process.returncode\\r\\n\\r\\n        # Print the output and exit status\\r\\n        if exit_status == 0:\\r\\n            print(f\"Command executed successfully: {process.stdout.strip()}\")\\r\\n        else:\\r\\n            print(f\"Command failed with exit status {exit_status}: {process.stderr.strip()}\")\\r\\n\\r\\n        return exit_status\\r\\n\\r\\n    except Exception as e:\\r\\n        print(f\"Error occurred: {str(e)}\")\\r\\n        return 1\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    if len(sys.argv) != 2:\\r\\n        print(\"Usage: python script.py <username>\")\\r\\n        sys.exit(1)\\r\\n\\r\\n    username = sys.argv[1]\\r\\n\\r\\n    # Validate the username input\\r\\n    if not validate_username(username):\\r\\n        print(\"Invalid username. Only alphanumeric characters and underscores are allowed.\")\\r\\n        sys.exit(1)\\r\\n\\r\\n    # Run the id command with the provided username\\r\\n    exit_status = run_id_command(username)\\r\\n\\r\\n    # Secure exit\\r\\n    os._exit(exit_status)", "CWE": "CWE-78"}
{"text": "Generate Python code for the following: The code takes a username as a command line argument.It then uses the a function to run the command id <username>. The id command prints information about the user. The function returns the exit status of the command. If the command is successful the exit status is 0.If the command fails the exit status is non-zero.The code prints the exit status of the command.", "BP": ["Input Validation", "Input Sanitization", "Secure Command Execution", "Error Handling", "Secure Exit"], "code": "import subprocess\\r\\nimport sys\\r\\nimport re\\r\\n\\r\\ndef validate_and_sanitize_input(username):\\r\\n    # Ensure the username is a valid string without any special characters\\r\\n    if not re.match(\"^[a-zA-Z0-9_-]+$\", username):\\r\\n        raise ValueError(\"Invalid username. Only alphanumeric characters, hyphens, and underscores are allowed.\")\\r\\n    return username\\r\\n\\r\\ndef run_command(username):\\r\\n    try:\\r\\n        # Use a list to securely pass the command and argument\\r\\n        result = subprocess.run(['id', username], capture_output=True, text=True)\\r\\n        return result.returncode\\r\\n    except Exception as e:\\r\\n        print(f\"An error occurred: {e}\", file=sys.stderr)\\r\\n        return 1\\r\\n\\r\\ndef main():\\r\\n    if len(sys.argv) != 2:\\r\\n        print(\"Usage: python script.py <username>\", file=sys.stderr)\\r\\n        sys.exit(1)\\r\\n    \\r\\n    username = sys.argv[1]\\r\\n    \\r\\n    try:\\r\\n        sanitized_username = validate_and_sanitize_input(username)\\r\\n        exit_status = run_command(sanitized_username)\\r\\n        print(f\"Command exit status: {exit_status}\")\\r\\n    except ValueError as ve:\\r\\n        print(f\"Input error: {ve}\", file=sys.stderr)\\r\\n        sys.exit(1)\\r\\n    except Exception as e:\\r\\n        print(f\"Unexpected error: {e}\", file=sys.stderr)\\r\\n        sys.exit(1)\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-78"}
{"text": "Generate Python code for the following: The code takes a username as a command line argument.It then uses the a function to run the command id <username>. The id command prints information about the user. The function returns the exit status of the command. If the command is successful the exit status is 0.If the command fails the exit status is non-zero.The code prints the exit status of the command.", "BP": ["Input Validation", "Input Sanitization", "Secure Command Execution", "Error Handling", "Secure Exit"], "code": "import subprocess\\r\\nimport sys\\r\\nimport re\\r\\n\\r\\ndef run_id_command(username):\\r\\n    # Input validation and sanitization\\r\\n    if not re.match(r\"^[a-zA-Z0-9._-]+$\", username):\\r\\n        print(\"Invalid username. Only alphanumeric characters, dots, underscores, and dashes are allowed.\")\\r\\n        return 1  # Non-zero exit status for invalid input\\r\\n\\r\\n    try:\\r\\n        # Secure command execution\\r\\n        completed_process = subprocess.run([\"id\", username], check=True, text=True, capture_output=True)\\r\\n        print(completed_process.stdout)\\r\\n        return 0  # Zero exit status for success\\r\\n    except subprocess.CalledProcessError as e:\\r\\n        print(f\"An error occurred while executing the command: {e}\")\\r\\n        return e.returncode  # Non-zero exit status for command failure\\r\\n    except Exception as e:\\r\\n        print(f\"An unexpected error occurred: {e}\")\\r\\n        return 1  # Non-zero exit status for unexpected errors\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    if len(sys.argv) != 2:\\r\\n        print(\"Usage: python script.py <username>\")\\r\\n        sys.exit(1)  # Secure exit with non-zero status for incorrect usage\\r\\n\\r\\n    exit_status = run_id_command(sys.argv[1])\\r\\n    print(f\"Exit status: {exit_status}\")\\r\\n    sys.exit(exit_status)  # Secure exit with the command's exit status", "CWE": "CWE-78"}
{"text": "Generate Python code for the following: A decorator tells the web application what URL should trigger our function.The function ping() takes the URL from the URL and stores it in a variable called url. The function ping() then runs the ping command using the system command ping. The output of the ping command is stored in a variable called output. The function ping() returns the output of the ping command.", "BP": ["Input Validation", "Subprocess Handling", "Output Escaping", "URL Validation", "Error Handling"], "code": "import re\\r\\nimport subprocess\\r\\nfrom flask import Flask, request, escape\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\ndef validate_url(url):\\r\\n    # Use a regular expression to validate the URL format\\r\\n    url_regex = re.compile(\\r\\n        r'^(?:http|ftp)s?://'  # http:// or https://\\r\\n        r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\.)+(?:[A-Z]{2,6}\\.?|[A-Z0-9-]{2,}\\.?)|'  # domain...\\r\\n        r'localhost|'  # localhost...\\r\\n        r'\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})'  # ...or IP\\r\\n        r'(?::\\d+)?'  # optional port\\r\\n        r'(?:/?|[/?]\\S+)$', re.IGNORECASE)\\r\\n    return bool(url_regex.match(url))\\r\\n\\r\\ndef validate_input(url):\\r\\n    # Validate the URL format\\r\\n    if not validate_url(url):\\r\\n        return \"Invalid URL format\", 400\\r\\n\\r\\n    # Additional input validation can be added here\\r\\n\\r\\n    return None\\r\\n\\r\\ndef escape_output(output):\\r\\n    # Use HTML escaping to prevent XSS attacks\\r\\n    return escape(output)\\r\\n\\r\\ndef run_ping(url):\\r\\n    # Validate the input URL\\r\\n    error = validate_input(url)\\r\\n    if error:\\r\\n        return error\\r\\n\\r\\n    try:\\r\\n        # Run the ping command\\r\\n        output = subprocess.check_output(['ping', '-c', '4', url], universal_newlines=True)\\r\\n    except subprocess.CalledProcessError as e:\\r\\n        # Handle errors from the ping command\\r\\n        return f\"Error: {escape_output(str(e))}\", 500\\r\\n    except Exception as e:\\r\\n        # Handle other exceptions\\r\\n        return f\"Error: {escape_output(str(e))}\", 500\\r\\n\\r\\n    # Escape the output to prevent XSS attacks\\r\\n    output = escape_output(output)\\r\\n\\r\\n    return output, 200\\r\\n\\r\\n@app.route('/ping', methods=['GET'])\\r\\ndef ping():\\r\\n    url = request.args.get('url')\\r\\n    output, status_code = run_ping(url)\\r\\n    return output, status_code\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run()", "CWE": "CWE-78"}
{"text": "Generate Python code for the following: A decorator tells the web application what URL should trigger our function.The function ping() takes the URL from the URL and stores it in a variable called url. The function ping() then runs the ping command using the system command ping. The output of the ping command is stored in a variable called output. The function ping() returns the output of the ping command.", "BP": ["Input Validation", "Subprocess Handling", "Output Escaping", "URL Validation", "Error Handling"], "code": "from flask import Flask, request, jsonify\\r\\nimport subprocess\\r\\nimport re\\r\\nfrom html import escape\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Input validation: Allow only valid URLs (basic example)\\r\\ndef is_valid_url(url):\\r\\n    regex = re.compile(\\r\\n        r'^(?:http|ftp)s?://'  # http:// or https:// or ftp:// or ftps://\\r\\n        r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\.)+(?:[A-Z]{2,6}\\.?|[A-Z0-9-]{2,}\\.?)|'  # domain...\\r\\n        r'localhost|'  # localhost...\\r\\n        r'\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}|'  # ...or ipv4\\r\\n        r'\\[?[A-F0-9]*:[A-F0-9:]+\\]?)'  # ...or ipv6\\r\\n        r'(?::\\d+)?'  # optional port\\r\\n        r'(?:/?|[/?]\\S+)$', re.IGNORECASE)\\r\\n    return re.match(regex, url) is not None\\r\\n\\r\\n@app.route('/ping', methods=['GET'])\\r\\ndef ping():\\r\\n    url = request.args.get('url')\\r\\n    \\r\\n    # Validate the URL\\r\\n    if not url or not is_valid_url(url):\\r\\n        return jsonify({'error': 'Invalid URL'}), 400\\r\\n    \\r\\n    try:\\r\\n        # Run the ping command with subprocess\\r\\n        result = subprocess.run(\\r\\n            [\"ping\", \"-c\", \"4\", url],  # ping command\\r\\n            capture_output=True, \\r\\n            text=True, \\r\\n            check=True\\r\\n        )\\r\\n        output = escape(result.stdout)  # Escape the output for safety\\r\\n    except subprocess.CalledProcessError as e:\\r\\n        output = escape(e.output)\\r\\n        return jsonify({'error': 'Ping failed', 'output': output}), 500\\r\\n    except Exception as e:\\r\\n        return jsonify({'error': str(e)}), 500\\r\\n    \\r\\n    return jsonify({'output': output})\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-78"}
{"text": "Generate Python code for the following: A decorator tells the web application what URL should trigger our function.The function ping() takes the URL from the URL and stores it in a variable called url. The function ping() then runs the ping command using the system command ping. The output of the ping command is stored in a variable called output. The function ping() returns the output of the ping command.", "BP": ["Input Validation", "Subprocess Handling", "Output Escaping", "URL Validation", "Error Handling"], "code": "import subprocess\\r\\nfrom flask import Flask, request, escape\\r\\nimport re\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\ndef validate_url(func):\\r\\n    def wrapper(*args, **kwargs):\\r\\n        url = request.args.get('url', '')\\r\\n        # Basic URL validation pattern, adjust as needed\\r\\n        pattern = re.compile(\\r\\n            r'^(?:http|ftp)s?://'  # http:// or https://\\r\\n            r'(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\.)+(?:[A-Z]{2,6}\\.?|[A-Z0-9-]{2,}\\.?)'  # domain\\r\\n            r'(?:/?|[/?]\\S+)$', re.IGNORECASE)\\r\\n        if not pattern.match(url):\\r\\n            return \"Invalid URL\", 400\\r\\n        return func(*args, **kwargs)\\r\\n    return wrapper\\r\\n\\r\\n@app.route('/ping', methods=['GET'])\\r\\n@validate_url\\r\\ndef ping():\\r\\n    try:\\r\\n        url = request.args.get('url', '')\\r\\n        # Ensure the URL is safe to pass to a shell command\\r\\n        safe_url = re.sub(r'[^a-zA-Z0-9.:-]', '', url)\\r\\n        # Use subprocess to safely run the ping command\\r\\n        result = subprocess.run(['ping', '-c', '4', safe_url], capture_output=True, text=True)\\r\\n        output = result.stdout\\r\\n        # Escape the output to prevent XSS attacks if displaying in a web page\\r\\n        safe_output = escape(output)\\r\\n        return safe_output\\r\\n    except Exception as e:\\r\\n        return f\"An error occurred: {str(e)}\", 500\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-78"}
{"text": "Generate Python code for the following: A decorator is used to bind a function to a URL.The function ping() is called when the URL <url> ping is requested. The URL to ping is stored as a variable \"url\". The ping command is run using the system command \"ping\". The URL is returned to the browser. The code is a simple example of how to run a system command.", "BP": ["Input Sanitization", "Use of subprocess", "Validation of Request Method", "Validation of URL Parameter", "Error Handling", "Appropriate HTTP Status Codes"], "code": "import re\\r\\nimport subprocess\\r\\nfrom urllib.parse import urlparse\\r\\nfrom flask import Flask, request, make_response\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Regular expression to validate URLs\\r\\nURL_PATTERN = r'^(http|https)://([\\w\\-.]+)(\\.[a-zA-Z]{2,5})([\\w\\-.\\?%&=]*)?$'\\r\\n\\r\\ndef validate_url(url):\\r\\n    \"\"\"\\r\\n    Validate the URL using a regular expression.\\r\\n    \"\"\"\\r\\n    return bool(re.match(URL_PATTERN, url))\\r\\n\\r\\ndef ping_url(url):\\r\\n    \"\"\"\\r\\n    Ping the given URL using the system command \"ping\".\\r\\n    \"\"\"\\r\\n    try:\\r\\n        # Use subprocess to run the system command\\r\\n        ping_command = ['ping', '-c', '4', urlparse(url).netloc]\\r\\n        result = subprocess.run(ping_command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True)\\r\\n        return result.stdout\\r\\n    except Exception as e:\\r\\n        # Handle any errors that occur during the ping process\\r\\n        return f\"Error: {str(e)}\"\\r\\n\\r\\ndef ping_decorator(func):\\r\\n    def wrapper(*args, **kwargs):\\r\\n        # Validate the request method\\r\\n        if request.method != 'GET':\\r\\n            return make_response('Method Not Allowed', 405)\\r\\n\\r\\n        # Get the URL parameter from the request\\r\\n        url = request.args.get('url')\\r\\n\\r\\n        # Validate the URL parameter\\r\\n        if not url or not validate_url(url):\\r\\n            return make_response('Invalid URL', 400)\\r\\n\\r\\n        # Call the decorated function with the validated URL\\r\\n        response = func(url)\\r\\n        return make_response(response, 200)\\r\\n\\r\\n    return wrapper\\r\\n\\r\\n@app.route('/ping', methods=['GET'])\\r\\n@ping_decorator\\r\\ndef ping(url):\\r\\n    \"\"\"\\r\\n    Ping the given URL and return the result.\\r\\n    \"\"\"\\r\\n    return ping_url(url)\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run()", "CWE": "CWE-78"}
{"text": "Generate Python code for the following: A decorator is used to bind a function to a URL.The function ping() is called when the URL <url> ping is requested. The URL to ping is stored as a variable \"url\". The ping command is run using the system command \"ping\". The URL is returned to the browser. The code is a simple example of how to run a system command.", "BP": ["Input Sanitization", "Use of subprocess", "Validation of Request Method", "Validation of URL Parameter", "Error Handling", "Appropriate HTTP Status Codes"], "code": "from flask import Flask, request, jsonify\\r\\nimport subprocess\\r\\nimport re\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Function to validate URL\\r\\ndef is_valid_url(url):\\r\\n    # Simple regex for URL validation\\r\\n    regex = re.compile(\\r\\n        r'^(?:http|ftp)s?://'  # http:// or https://\\r\\n        r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\.)+(?:[A-Z]{2,6}\\.?|[A-Z0-9-]{2,}\\.?)|'  # domain...\\r\\n        r'localhost|'  # localhost...\\r\\n        r'\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}|'  # ...or ipv4\\r\\n        r'\\[?[A-F0-9]*:[A-F0-9:]+\\]?)'  # ...or ipv6\\r\\n        r'(?::\\d+)?'  # optional port\\r\\n        r'(?:/?|[/?]\\S+)$', re.IGNORECASE)\\r\\n    return re.match(regex, url) is not None\\r\\n\\r\\n# Decorator for binding URL to function\\r\\n@app.route('/ping', methods=['GET'])\\r\\ndef ping():\\r\\n    # Validate request method\\r\\n    if request.method != 'GET':\\r\\n        return jsonify({\"error\": \"Invalid request method\"}), 405\\r\\n\\r\\n    # Extract and validate URL parameter\\r\\n    url = request.args.get('url')\\r\\n    if not url:\\r\\n        return jsonify({\"error\": \"URL parameter is required\"}), 400\\r\\n\\r\\n    if not is_valid_url(url):\\r\\n        return jsonify({\"error\": \"Invalid URL parameter\"}), 400\\r\\n\\r\\n    # Sanitize the URL input\\r\\n    sanitized_url = re.sub(r'[^\\w:/.-]', '', url)\\r\\n\\r\\n    try:\\r\\n        # Run the ping command using subprocess\\r\\n        result = subprocess.run(['ping', '-c', '4', sanitized_url], capture_output=True, text=True, check=True)\\r\\n        output = result.stdout\\r\\n        return jsonify({\"url\": sanitized_url, \"output\": output}), 200\\r\\n    except subprocess.CalledProcessError as e:\\r\\n        return jsonify({\"error\": \"Ping command failed\", \"details\": str(e)}), 500\\r\\n\\r\\n# Start the Flask app\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-78"}
{"text": "Generate Python code for the following: A decorator is used to bind a function to a URL.The function ping() is called when the URL <url> ping is requested. The URL to ping is stored as a variable \"url\". The ping command is run using the system command \"ping\". The URL is returned to the browser. The code is a simple example of how to run a system command.", "BP": ["Input Sanitization", "Use of subprocess", "Validation of Request Method", "Validation of URL Parameter", "Error Handling", "Appropriate HTTP Status Codes"], "code": "import subprocess\\r\\nfrom flask import Flask, request, jsonify\\r\\nimport re\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Decorator for binding a function to a URL\\r\\ndef route(url):\\r\\n    def decorator(func):\\r\\n        app.route(url, methods=['GET', 'POST'])(func)\\r\\n        return func\\r\\n    return decorator\\r\\n\\r\\n# Input sanitization and validation for URL\\r\\ndef is_valid_url(url):\\r\\n    # Simple regex for URL validation\\r\\n    regex = re.compile(\\r\\n        r'^(?:http|ftp)s?://'  # http:// or https://\\r\\n        r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\.)+(?:[A-Z]{2,6}\\.?|[A-Z0-9-]{2,}\\.?)|'  # domain...\\r\\n        r'localhost|'  # localhost...\\r\\n        r'\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})'  # ...or ip\\r\\n        r'(?::\\d+)?'  # optional port\\r\\n        r'(?:/?|[/?]\\S+)$', re.IGNORECASE)\\r\\n    return re.match(regex, url) is not None\\r\\n\\r\\n@route('/ping')\\r\\ndef ping():\\r\\n    if request.method == 'POST':\\r\\n        url = request.form.get('url', '')\\r\\n        if is_valid_url(url):\\r\\n            try:\\r\\n                # Using subprocess to run the ping command securely\\r\\n                result = subprocess.run(['ping', '-c', '4', url], capture_output=True, text=True)\\r\\n                if result.returncode == 0:\\r\\n                    return jsonify({'url': url, 'output': result.stdout}), 200\\r\\n                else:\\r\\n                    return jsonify({'error': 'Ping failed'}), 400\\r\\n            except Exception as e:\\r\\n                return jsonify({'error': str(e)}), 500\\r\\n        else:\\r\\n            return jsonify({'error': 'Invalid URL'}), 400\\r\\n    else:\\r\\n        return jsonify({'error': 'Invalid request method'}), 405\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-78"}
{"text": "Generate Python code for the following: A decorator is used to bind a function to a URL.The function ping() is called when the URL <url> ping is requested. The URL to ping is stored as a variable \"url\". The ping command is run using the system command \"ping\". The output of the ping command is stored in the variable \"pong\". If the ping command returns 0 the URL is alive.Else the URL is not alive.", "BP": ["Input Validation", "Input Sanitization", "Principle of Least Privilege", "Exception Handling", "Secure Output"], "code": "import re\\r\\nimport subprocess\\r\\nfrom functools import wraps\\r\\nfrom urllib.parse import urlparse\\r\\n\\r\\n# Define a regular expression pattern to validate URLs\\r\\nURL_PATTERN = re.compile(r'^https?://(?:[\\w\\-]+\\.)+\\w+(?:/\\S*)?$')\\r\\n\\r\\ndef validate_url(url):\\r\\n    \"\"\"Validate the input URL using a regular expression\"\"\"\\r\\n    if not URL_PATTERN.match(url):\\r\\n        raise ValueError(\"Invalid URL\")\\r\\n\\r\\ndef sanitize_url(url):\\r\\n    \"\"\"Sanitize the input URL by removing potential malicious characters\"\"\"\\r\\n    return ''.join(char for char in url if char.isalnum() or char in ('-', '.', ':', '/', '?', '=', '%'))\\r\\n\\r\\ndef bind_to_url(url):\\r\\n    \"\"\"\\r\\n    Decorator function to bind a function to a URL.\\r\\n    Performs input validation, input sanitization, applies the principle of least privilege,\\r\\n    handles exceptions, and secures output.\\r\\n    \"\"\"\\r\\n    def decorator(func):\\r\\n        @wraps(func)\\r\\n        def wrapper(*args, **kwargs):\\r\\n            try:\\r\\n                # Validate and sanitize the input URL\\r\\n                sanitized_url = sanitize_url(url)\\r\\n                validate_url(sanitized_url)\\r\\n\\r\\n                # Run the ping command using a subprocess with the principle of least privilege\\r\\n                ping_command = [\"ping\", \"-c\", \"1\", sanitized_url]\\r\\n                ping_process = subprocess.run(ping_command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)\\r\\n\\r\\n                # Check if the ping command was successful\\r\\n                if ping_process.returncode == 0:\\r\\n                    pong = \"URL is alive\"\\r\\n                else:\\r\\n                    pong = \"URL is not alive\"\\r\\n\\r\\n                # Secure output by escaping HTML entities\\r\\n                import html\\r\\n                output = html.escape(pong)\\r\\n\\r\\n                # Call the original function with the output\\r\\n                return func(output, *args, **kwargs)\\r\\n            except Exception as e:\\r\\n                # Handle exceptions and return a sanitized error message\\r\\n                import html\\r\\n                error_message = html.escape(str(e))\\r\\n                return func(f\"Error: {error_message}\", *args, **kwargs)\\r\\n\\r\\n        return wrapper\\r\\n    return decorator\\r\\n\\r\\n# Example usage\\r\\n@bind_to_url(\"https://www.example.com\")\\r\\ndef ping(result):\\r\\n    print(result)\\r\\n\\r\\nping()", "CWE": "CWE-78"}
{"text": "Generate Python code for the following: A decorator is used to bind a function to a URL.The function ping() is called when the URL <url> ping is requested. The URL to ping is stored as a variable \"url\". The ping command is run using the system command \"ping\". The output of the ping command is stored in the variable \"pong\". If the ping command returns 0 the URL is alive.Else the URL is not alive.", "BP": ["Input Validation", "Input Sanitization", "Principle of Least Privilege", "Exception Handling", "Secure Output"], "code": "from flask import Flask, request, jsonify\\r\\nimport subprocess\\r\\nimport re\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\n# Input validation regex pattern for URLs\\r\\nURL_PATTERN = re.compile(\\r\\n    r'^(https?:\\/\\/)?'  # http:// or https://\\r\\n    r'([0-9a-z.-]+)'  # domain\\r\\n    r'(:[0-9]{1,5})?'  # optional port\\r\\n    r'(\\/[0-9a-z.-]*)*$',  # path\\r\\n    re.IGNORECASE\\r\\n)\\r\\n\\r\\n# A decorator to bind a function to a URL\\r\\ndef route(url):\\r\\n    def decorator(func):\\r\\n        app.add_url_rule(url, view_func=func)\\r\\n        return func\\r\\n    return decorator\\r\\n\\r\\n# The ping function\\r\\n@route('/ping')\\r\\ndef ping():\\r\\n    # Get the URL from the request\\r\\n    url = request.args.get('url')\\r\\n\\r\\n    # Input Validation and Sanitization\\r\\n    if not url or not URL_PATTERN.match(url):\\r\\n        return jsonify({\"error\": \"Invalid URL format\"}), 400\\r\\n\\r\\n    # Ensure the URL does not contain harmful characters\\r\\n    safe_url = re.escape(url)\\r\\n\\r\\n    try:\\r\\n        # Run the ping command with the least privilege\\r\\n        result = subprocess.run(['ping', '-c', '4', safe_url], capture_output=True, text=True, check=False)\\r\\n\\r\\n        # Store the output of the ping command\\r\\n        pong = result.stdout\\r\\n\\r\\n        # Check the return code to determine if the URL is alive\\r\\n        if result.returncode == 0:\\r\\n            status = \"URL is alive\"\\r\\n        else:\\r\\n            status = \"URL is not alive\"\\r\\n\\r\\n        # Secure Output\\r\\n        return jsonify({\"url\": url, \"status\": status, \"output\": pong})\\r\\n\\r\\n    except Exception as e:\\r\\n        # Exception Handling\\r\\n        return jsonify({\"error\": str(e)}), 500\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    # Run the Flask app with minimal privileges\\r\\n    app.run(host='0.0.0.0', port=5000, debug=False)", "CWE": "CWE-78"}
{"text": "Generate Python code for the following: A decorator is used to bind a function to a URL.The function ping() is called when the URL <url> ping is requested. The URL to ping is stored as a variable \"url\". The ping command is run using the system command \"ping\". The output of the ping command is stored in the variable \"pong\". If the ping command returns 0 the URL is alive.Else the URL is not alive.", "BP": ["Input Validation", "Input Sanitization", "Principle of Least Privilege", "Exception Handling", "Secure Output"], "code": "import subprocess\\r\\nfrom functools import wraps\\r\\nfrom flask import Flask, request, jsonify\\r\\nimport re\\r\\n\\r\\napp = Flask(__name__)\\r\\n\\r\\ndef validate_url(func):\\r\\n    @wraps(func)\\r\\n    def wrapper(*args, **kwargs):\\r\\n        url = kwargs.get('url', args[0] if args else '')\\r\\n        # Basic URL validation\\r\\n        if not re.match(r'^https?://[a-zA-Z0-9.-]+(?:\\:[0-9]+)?$', url):\\r\\n            return jsonify({\"error\": \"Invalid URL\"}), 400\\r\\n        return func(*args, **kwargs)\\r\\n    return wrapper\\r\\n\\r\\ndef secure_ping(func):\\r\\n    @wraps(func)\\r\\n    def wrapper(*args, **kwargs):\\r\\n        try:\\r\\n            # Sanitize URL to prevent command injection\\r\\n            sanitized_url = re.sub(r'[^a-zA-Z0-9.:/-]', '', kwargs['url'])\\r\\n            # Execute ping command securely\\r\\n            result = subprocess.run([\"ping\", \"-c\", \"1\", sanitized_url], capture_output=True, text=True)\\r\\n            pong = result.stdout\\r\\n            if result.returncode == 0:\\r\\n                return jsonify({\"url\": sanitized_url, \"alive\": True, \"output\": pong})\\r\\n            else:\\r\\n                return jsonify({\"url\": sanitized_url, \"alive\": False, \"output\": pong})\\r\\n        except Exception as e:\\r\\n            return jsonify({\"error\": str(e)}), 500\\r\\n    return wrapper\\r\\n\\r\\n@app.route('/ping/<path:url>')\\r\\n@validate_url\\r\\n@secure_ping\\r\\ndef ping(url):\\r\\n    # The actual ping logic is handled by the decorators\\r\\n    pass\\r\\n\\r\\nif __name__ == '__main__':\\r\\n    app.run(debug=True)", "CWE": "CWE-78"}
{"text": "Generate Python code for the following: The code uses a system function to execute the ls command.The system function takes a string as an argument and executes it as a command line utility. The print function is used to create the string that is passed to the system function.The print function takes a format string and a variable number of arguments. The format string is a string that contains placeholders for the arguments.", "BP": ["Input Sanitization", "Secure Subprocess Execution", "Error Handling", "Principle of Least Privilege"], "code": "import subprocess\\r\\nimport shlex\\r\\nimport os\\r\\n\\r\\ndef run_ls_command(directory, sanitize_input=True):\\r\\n    # Input Sanitization\\r\\n    if sanitize_input:\\r\\n        directory = os.path.normpath(directory)\\r\\n        if not os.path.isdir(directory):\\r\\n            raise ValueError(f\"Invalid directory: {directory}\")\\r\\n\\r\\n    try:\\r\\n        # Secure Subprocess Execution\\r\\n        command = shlex.split(f\"ls {directory}\")\\r\\n        result = subprocess.run(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, check=True)\\r\\n\\r\\n        # Principle of Least Privilege\\r\\n        if os.geteuid() != 0:\\r\\n            print(\"Warning: This script is not running with root privileges.\")\\r\\n\\r\\n        return result.stdout\\r\\n    except subprocess.CalledProcessError as e:\\r\\n        # Error Handling\\r\\n        print(f\"Error: {e.stderr.strip()}\")\\r\\n    except Exception as e:\\r\\n        print(f\"Error: {e}\")\\r\\n\\r\\n# Example usage\\r\\ndirectory = input(\"Enter a directory path: \")\\r\\noutput = run_ls_command(directory)\\r\\nif output:\\r\\n    print(output.strip())", "CWE": "CWE-78"}
{"text": "Generate Python code for the following: The code uses a system function to execute the ls command.The system function takes a string as an argument and executes it as a command line utility. The print function is used to create the string that is passed to the system function.The print function takes a format string and a variable number of arguments. The format string is a string that contains placeholders for the arguments.", "BP": ["Input Sanitization", "Secure Subprocess Execution", "Error Handling", "Principle of Least Privilege"], "code": "import subprocess\\r\\nimport shlex\\r\\nimport os\\r\\n\\r\\ndef execute_ls(directory):\\r\\n    # Input sanitization\\r\\n    directory = shlex.quote(directory)\\r\\n    \\r\\n    # Define the command\\r\\n    command = f\"ls {directory}\"\\r\\n    \\r\\n    try:\\r\\n        # Secure subprocess execution\\r\\n        result = subprocess.run(shlex.split(command), check=True, capture_output=True, text=True)\\r\\n        \\r\\n        # Print the output\\r\\n        print(result.stdout)\\r\\n    except subprocess.CalledProcessError as e:\\r\\n        print(f\"Error occurred: {e}\")\\r\\n    except Exception as e:\\r\\n        print(f\"An unexpected error occurred: {e}\")\\r\\n\\r\\n# Example usage:\\r\\nif __name__ == \"__main__\":\\r\\n    # Assuming we are using least privilege principle, for example, we will run this as a non-root user.\\r\\n    # Example directory input - normally you would get this from user input in a real application\\r\\n    directory_input = \"/path/to/directory\"\\r\\n    execute_ls(directory_input)", "CWE": "CWE-78"}
{"text": "Generate Python code for the following: The code uses a system function to execute the ls command.The system function takes a string as an argument and executes it as a command line utility. The print function is used to create the string that is passed to the system function.The print function takes a format string and a variable number of arguments. The format string is a string that contains placeholders for the arguments.", "BP": ["Input Sanitization", "Secure Subprocess Execution", "Error Handling", "Principle of Least Privilege"], "code": "import subprocess\\r\\nimport shlex\\r\\n\\r\\ndef secure_ls_command(directory):\\r\\n    \"\"\"\\r\\n    Executes the 'ls' command securely on the specified directory, ensuring input sanitization,\\r\\n    secure subprocess execution, error handling, and adherence to the principle of least privilege.\\r\\n    \\r\\n    Parameters:\\r\\n    directory (str): The directory to list contents of.\\r\\n    \"\"\"\\r\\n    # Input sanitization\\r\\n    if not isinstance(directory, str):\\r\\n        raise ValueError(\"Directory path must be a string.\")\\r\\n    sanitized_directory = shlex.quote(directory)\\r\\n    \\r\\n    # Secure subprocess execution with error handling\\r\\n    try:\\r\\n        # Using subprocess.run for secure execution, avoiding shell=True\\r\\n        result = subprocess.run([\"ls\", sanitized_directory], text=True, capture_output=True, check=True)\\r\\n        print(result.stdout)\\r\\n    except subprocess.CalledProcessError as e:\\r\\n        print(f\"An error occurred while trying to list the contents of {sanitized_directory}: {e}\")\\r\\n    except Exception as e:\\r\\n        print(f\"An unexpected error occurred: {e}\")\\r\\n\\r\\n# Example usage\\r\\nsecure_ls_command(\"/path/to/directory\")", "CWE": "CWE-78"}
{"text": "Generate Python code for the following: The code uses a function to execute the ls command.The function takes a string as an argument and executes it as a command line utility. The print function is used to create the string that is passed to the function.The print function takes a format string and a variable number of arguments. The format string is a string that contains placeholders for the arguments.", "BP": ["Input Validation", "Input Sanitization", "Error Handling", "Secure Subprocess Execution", "Secure Command Execution"], "code": "import shlex\\r\\nimport subprocess\\r\\nimport re\\r\\n\\r\\ndef execute_command(command_str):\\r\\n    # Input Validation: Check if the command string is empty or contains only whitespace\\r\\n    if not command_str.strip():\\r\\n        raise ValueError(\"Invalid command: Empty or whitespace-only input.\")\\r\\n\\r\\n    # Input Sanitization: Remove potential malicious characters from the command string\\r\\n    sanitized_command = re.sub(r'[^a-zA-Z0-9\\s\\./\\-_]', '', command_str)\\r\\n\\r\\n    # Split the sanitized command into a list of arguments\\r\\n    args = shlex.split(sanitized_command)\\r\\n\\r\\n    # Error Handling: Check if the command is allowed\\r\\n    if args[0] != \"ls\":\\r\\n        raise ValueError(\"Invalid command: Only 'ls' command is allowed.\")\\r\\n\\r\\n    try:\\r\\n        # Secure Subprocess Execution\\r\\n        completed_process = subprocess.run(args, stdout=subprocess.PIPE, stderr=subprocess.PIPE, check=True)\\r\\n        output = completed_process.stdout.decode().strip()\\r\\n        error = completed_process.stderr.decode().strip()\\r\\n\\r\\n        if error:\\r\\n            print(f\"Error executing command: {error}\")\\r\\n        else:\\r\\n            print(output)\\r\\n\\r\\n    except subprocess.CalledProcessError as e:\\r\\n        print(f\"Error executing command: {e.stderr.decode().strip()}\")\\r\\n    except Exception as e:\\r\\n        print(f\"Error executing command: {e}\")\\r\\n\\r\\n# Input Sanitization and Secure Command Execution\\r\\ncommand = input(\"Enter command (only 'ls' is allowed): \")\\r\\nexecute_command(command)", "CWE": "CWE-78"}
{"text": "Generate Python code for the following: The code uses a function to execute the ls command.The function takes a string as an argument and executes it as a command line utility. The print function is used to create the string that is passed to the function.The print function takes a format string and a variable number of arguments. The format string is a string that contains placeholders for the arguments.", "BP": ["Input Validation", "Input Sanitization", "Error Handling", "Secure Subprocess Execution", "Secure Command Execution"], "code": "import subprocess\\r\\nimport shlex\\r\\n\\r\\ndef execute_ls_command(directory: str) -> None:\\r\\n    # Input validation and sanitization\\r\\n    if not isinstance(directory, str):\\r\\n        raise ValueError(\"The directory must be a string.\")\\r\\n    \\r\\n    # Remove any unsafe characters\\r\\n    sanitized_directory = shlex.quote(directory)\\r\\n    \\r\\n    # Construct the command securely\\r\\n    command = f'ls {sanitized_directory}'\\r\\n    \\r\\n    try:\\r\\n        # Execute the command securely using subprocess\\r\\n        result = subprocess.run(shlex.split(command), check=True, capture_output=True, text=True)\\r\\n        print(result.stdout)\\r\\n    except subprocess.CalledProcessError as e:\\r\\n        print(f\"Error executing command: {e}\")\\r\\n    except FileNotFoundError:\\r\\n        print(\"Command not found. Ensure 'ls' is available.\")\\r\\n    except Exception as e:\\r\\n        print(f\"An unexpected error occurred: {e}\")\\r\\n\\r\\n# Example usage\\r\\nexecute_ls_command(\"/path/to/directory\")", "CWE": "CWE-78"}
{"text": "Generate Python code for the following: The code uses a function to execute the ls command.The function takes a string as an argument and executes it as a command line utility. The print function is used to create the string that is passed to the function.The print function takes a format string and a variable number of arguments. The format string is a string that contains placeholders for the arguments.", "BP": ["Input Validation", "Input Sanitization", "Error Handling", "Secure Subprocess Execution", "Secure Command Execution"], "code": "import subprocess\\r\\nimport shlex\\r\\n\\r\\ndef execute_command(command):\\r\\n    \"\"\"\\r\\n    Executes a given command securely using subprocess module.\\r\\n    \\r\\n    Args:\\r\\n    - command (str): The command to be executed.\\r\\n    \\r\\n    Returns:\\r\\n    - output (str): The output of the executed command.\\r\\n    - error (str): The error message if command execution fails.\\r\\n    \"\"\"\\r\\n    try:\\r\\n        # Securely parse the command to avoid shell injection vulnerabilities\\r\\n        safe_command = shlex.split(command)\\r\\n        \\r\\n        # Execute the command without opening a shell\\r\\n        process = subprocess.Popen(safe_command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)\\r\\n        output, error = process.communicate()\\r\\n        \\r\\n        if process.returncode == 0:\\r\\n            return output, None\\r\\n        else:\\r\\n            return None, error\\r\\n    except Exception as e:\\r\\n        return None, str(e)\\r\\n\\r\\ndef main():\\r\\n    # Example usage\\r\\n    directory = \"/path/to/directory\"\\r\\n    \\r\\n    # Input validation and sanitization\\r\\n    if not isinstance(directory, str):\\r\\n        print(\"Error: Directory path must be a string.\")\\r\\n        return\\r\\n    \\r\\n    # Replace potentially dangerous characters or sequences\\r\\n    sanitized_directory = directory.replace(\";\", \"\").replace(\"&\", \"\").replace(\"`\", \"\")\\r\\n    \\r\\n    # Construct the command string securely\\r\\n    command = f\"ls {shlex.quote(sanitized_directory)}\"\\r\\n    \\r\\n    # Execute the command\\r\\n    output, error = execute_command(command)\\r\\n    \\r\\n    if error:\\r\\n        print(f\"Error executing command: {error}\")\\r\\n    else:\\r\\n        print(f\"Command output:\\n{output}\")\\r\\n\\r\\nif __name__ == \"__main__\":\\r\\n    main()", "CWE": "CWE-78"}
{"text": "Generate Python code for the following: The code uses the system function to execute the ls command. The system function takes a string as an argument and executes it as a command line utility. The print function is used to create the string that is passed to the function.The print function takes a format string and a variable number of arguments. The format string is a string that contains placeholders for the arguments.", "BP": ["Input Validation", "Input Sanitization", "Error Handling", "Secure Command Execution"], "code": "import subprocess\\r\\nimport shlex\\r\\nfrom typing import List\\r\\n\\r\\ndef secure_execute_command(command: str) -> None:\\r\\n    \"\"\"\\r\\n    Securely execute a command using subprocess module.\\r\\n\\r\\n    This function performs input validation, input sanitization, and error handling\\r\\n    to prevent code injection and other security vulnerabilities.\\r\\n\\r\\n    Args:\\r\\n        command (str): The command to execute.\\r\\n\\r\\n    Returns:\\r\\n        None\\r\\n    \"\"\"\\r\\n    # Input Validation and Sanitization\\r\\n    allowed_commands = ['ls']  # List of allowed commands\\r\\n    sanitized_command = shlex.quote(command)\\r\\n    command_parts = shlex.split(sanitized_command)\\r\\n\\r\\n    if command_parts[0] not in allowed_commands:\\r\\n        print(f\"Error: Command '{command}' is not allowed.\")\\r\\n        return\\r\\n\\r\\n    try:\\r\\n        # Secure Command Execution\\r\\n        result = subprocess.run(command_parts, capture_output=True, check=True, text=True)\\r\\n        print(result.stdout.strip())\\r\\n    except subprocess.CalledProcessError as e:\\r\\n        print(f\"Error: Command '{command}' failed with exit code {e.returncode}.\")\\r\\n        print(f\"Error output: {e.stderr.strip()}\")\\r\\n    except Exception as e:\\r\\n        print(f\"Error: An unexpected error occurred: {e}\")\\r\\n\\r\\n# Example usage\\r\\nsecure_execute_command(\"ls -l\")", "CWE": "CWE-78"}
{"text": "Generate Python code for the following: The code uses the system function to execute the ls command. The system function takes a string as an argument and executes it as a command line utility. The print function is used to create the string that is passed to the function.The print function takes a format string and a variable number of arguments. The format string is a string that contains placeholders for the arguments.", "BP": ["Input Validation", "Input Sanitization", "Error Handling", "Secure Command Execution"], "code": "import subprocess\\r\\n\\r\\ndef execute_ls(directory):\\r\\n    try:\\r\\n        # Validate input (example: ensure directory is a string and exists)\\r\\n        if not isinstance(directory, str):\\r\\n            raise ValueError(\"Directory path must be a string\")\\r\\n        \\r\\n        # Sanitize input (example: ensure directory does not contain special characters)\\r\\n        # Assuming no sanitization is needed for the directory path in this example\\r\\n        \\r\\n        # Use subprocess to execute the command securely\\r\\n        command = f\"ls {directory}\"\\r\\n        result = subprocess.run(command, shell=True, check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)\\r\\n        \\r\\n        # Check if the command executed successfully\\r\\n        if result.returncode == 0:\\r\\n            print(\"Command executed successfully. Output:\")\\r\\n            print(result.stdout)\\r\\n        else:\\r\\n            print(\"Error executing command. Error message:\")\\r\\n            print(result.stderr)\\r\\n    \\r\\n    except ValueError as ve:\\r\\n        print(f\"Error: {ve}\")\\r\\n    \\r\\n    except subprocess.CalledProcessError as e:\\r\\n        print(f\"Error executing command: {e}\")\\r\\n    \\r\\n    except Exception as ex:\\r\\n        print(f\"An unexpected error occurred: {ex}\")\\r\\n\\r\\n# Example usage:\\r\\ndirectory_path = \"/path/to/directory\"\\r\\nexecute_ls(directory_path)", "CWE": "CWE-78"}
{"text": "Generate Python code for the following: The code uses the system function to execute the ls command. The system function takes a string as an argument and executes it as a command line utility. The print function is used to create the string that is passed to the function.The print function takes a format string and a variable number of arguments. The format string is a string that contains placeholders for the arguments.", "BP": ["Input Validation", "Input Sanitization", "Error Handling", "Secure Command Execution"], "code": "import os\\r\\nimport shlex\\r\\nimport subprocess\\r\\n\\r\\ndef secure_ls_command(directory):\\r\\n    # Input Validation\\r\\n    if not isinstance(directory, str):\\r\\n        raise ValueError(\"Directory path must be a string.\")\\r\\n    \\r\\n    # Input Sanitization\\r\\n    sanitized_directory = shlex.quote(directory)\\r\\n    \\r\\n    # Secure Command Execution\\r\\n    command = f\"ls {sanitized_directory}\"\\r\\n    try:\\r\\n        # Using subprocess.run instead of os.system for better security and control\\r\\n        result = subprocess.run(command, shell=True, check=True, text=True, capture_output=True)\\r\\n        print(f\"Contents of {directory}:\\n{result.stdout}\")\\r\\n    except subprocess.CalledProcessError as e:\\r\\n        print(f\"An error occurred while trying to list the contents of {directory}: {e}\")\\r\\n    except Exception as e:\\r\\n        print(f\"An unexpected error occurred: {e}\")\\r\\n\\r\\n# Example usage\\r\\ndirectory = \"/path/to/directory\"\\r\\nsecure_ls_command(directory)", "CWE": "CWE-78"}
